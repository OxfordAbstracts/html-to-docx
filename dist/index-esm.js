import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports, module) => {
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module.exports = { nextTick };
  } else {
    module.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports, module) => {
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/jszip/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === undefined;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = __require("buffer").Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util = __require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
      var obj = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj;
    };
  }
});

// node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS((exports, module) => {
  module.exports = __require("util").deprecate;
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util.inherits(Writable, Stream);
  function nop() {}
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var debugUtil = __require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {};
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/jszip/node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
  }
});

// node_modules/jszip/lib/support.js
var require_support = __commonJS((exports) => {
  exports.base64 = true;
  exports.array = true;
  exports.string = true;
  exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  exports.nodebuffer = typeof Buffer !== "undefined";
  exports.uint8array = typeof Uint8Array !== "undefined";
  if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
  } else {
    buffer = new ArrayBuffer(0);
    try {
      exports.blob = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e) {
      try {
        Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        builder = new Builder;
        builder.append(buffer);
        exports.blob = builder.getBlob("application/zip").size === 0;
      } catch (e2) {
        exports.blob = false;
      }
    }
  }
  var buffer;
  var Builder;
  var builder;
  try {
    exports.nodestream = !!require_readable().Readable;
  } catch (e) {
    exports.nodestream = false;
  }
});

// node_modules/jszip/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var utils = require_utils();
  var support = require_support();
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;
    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
      remainingBytes = len - i;
      if (!isArray) {
        chr1 = input.charCodeAt(i++);
        chr2 = i < len ? input.charCodeAt(i++) : 0;
        chr3 = i < len ? input.charCodeAt(i++) : 0;
      } else {
        chr1 = input[i++];
        chr2 = i < len ? input[i++] : 0;
        chr3 = i < len ? input[i++] : 0;
      }
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
      enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
      output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }
    return output.join("");
  };
  exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;
    var dataUrlPrefix = "data:";
    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
      throw new Error("Invalid base64 input, it looks like a data url.");
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (totalLength % 1 !== 0) {
      throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
      output = new Uint8Array(totalLength | 0);
    } else {
      output = new Array(totalLength | 0);
    }
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output[resultIndex++] = chr1;
      if (enc3 !== 64) {
        output[resultIndex++] = chr2;
      }
      if (enc4 !== 64) {
        output[resultIndex++] = chr3;
      }
    }
    return output;
  };
});

// node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS((exports, module) => {
  module.exports = {
    isNode: typeof Buffer !== "undefined",
    newBufferFrom: function(data, encoding) {
      if (Buffer.from && Buffer.from !== Uint8Array.from) {
        return Buffer.from(data, encoding);
      } else {
        if (typeof data === "number") {
          throw new Error('The "data" argument must not be a number');
        }
        return new Buffer(data, encoding);
      }
    },
    allocBuffer: function(size) {
      if (Buffer.alloc) {
        return Buffer.alloc(size);
      } else {
        var buf = new Buffer(size);
        buf.fill(0);
        return buf;
      }
    },
    isBuffer: function(b) {
      return Buffer.isBuffer(b);
    },
    isStream: function(obj) {
      return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
  };
});

// node_modules/immediate/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var Mutation = global.MutationObserver || global.WebKitMutationObserver;
  var scheduleDrain;
  if (false) {} else {
    scheduleDrain = function() {
      process.nextTick(nextTick);
    };
  }
  var called;
  var observer;
  var element;
  var channel;
  var draining;
  var queue = [];
  function nextTick() {
    draining = true;
    var i, oldQueue;
    var len = queue.length;
    while (len) {
      oldQueue = queue;
      queue = [];
      i = -1;
      while (++i < len) {
        oldQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  module.exports = immediate;
  function immediate(task) {
    if (queue.push(task) === 1 && !draining) {
      scheduleDrain();
    }
  }
});

// node_modules/lie/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var immediate = require_lib();
  function INTERNAL() {}
  var handlers = {};
  var REJECTED = ["REJECTED"];
  var FULFILLED = ["FULFILLED"];
  var PENDING = ["PENDING"];
  if (true) {
    UNHANDLED = ["UNHANDLED"];
  }
  var UNHANDLED;
  module.exports = Promise2;
  function Promise2(resolver) {
    if (typeof resolver !== "function") {
      throw new TypeError("resolver must be a function");
    }
    this.state = PENDING;
    this.queue = [];
    this.outcome = undefined;
    if (true) {
      this.handled = UNHANDLED;
    }
    if (resolver !== INTERNAL) {
      safelyResolveThenable(this, resolver);
    }
  }
  Promise2.prototype.finally = function(callback) {
    if (typeof callback !== "function") {
      return this;
    }
    var p = this.constructor;
    return this.then(resolve2, reject2);
    function resolve2(value) {
      function yes() {
        return value;
      }
      return p.resolve(callback()).then(yes);
    }
    function reject2(reason) {
      function no() {
        throw reason;
      }
      return p.resolve(callback()).then(no);
    }
  };
  Promise2.prototype.catch = function(onRejected) {
    return this.then(null, onRejected);
  };
  Promise2.prototype.then = function(onFulfilled, onRejected) {
    if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
      return this;
    }
    var promise = new this.constructor(INTERNAL);
    if (true) {
      if (this.handled === UNHANDLED) {
        this.handled = null;
      }
    }
    if (this.state !== PENDING) {
      var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
      unwrap(promise, resolver, this.outcome);
    } else {
      this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
    }
    return promise;
  };
  function QueueItem(promise, onFulfilled, onRejected) {
    this.promise = promise;
    if (typeof onFulfilled === "function") {
      this.onFulfilled = onFulfilled;
      this.callFulfilled = this.otherCallFulfilled;
    }
    if (typeof onRejected === "function") {
      this.onRejected = onRejected;
      this.callRejected = this.otherCallRejected;
    }
  }
  QueueItem.prototype.callFulfilled = function(value) {
    handlers.resolve(this.promise, value);
  };
  QueueItem.prototype.otherCallFulfilled = function(value) {
    unwrap(this.promise, this.onFulfilled, value);
  };
  QueueItem.prototype.callRejected = function(value) {
    handlers.reject(this.promise, value);
  };
  QueueItem.prototype.otherCallRejected = function(value) {
    unwrap(this.promise, this.onRejected, value);
  };
  function unwrap(promise, func, value) {
    immediate(function() {
      var returnValue;
      try {
        returnValue = func(value);
      } catch (e) {
        return handlers.reject(promise, e);
      }
      if (returnValue === promise) {
        handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
      } else {
        handlers.resolve(promise, returnValue);
      }
    });
  }
  handlers.resolve = function(self2, value) {
    var result = tryCatch(getThen, value);
    if (result.status === "error") {
      return handlers.reject(self2, result.value);
    }
    var thenable = result.value;
    if (thenable) {
      safelyResolveThenable(self2, thenable);
    } else {
      self2.state = FULFILLED;
      self2.outcome = value;
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callFulfilled(value);
      }
    }
    return self2;
  };
  handlers.reject = function(self2, error) {
    self2.state = REJECTED;
    self2.outcome = error;
    if (true) {
      if (self2.handled === UNHANDLED) {
        immediate(function() {
          if (self2.handled === UNHANDLED) {
            process.emit("unhandledRejection", error, self2);
          }
        });
      }
    }
    var i = -1;
    var len = self2.queue.length;
    while (++i < len) {
      self2.queue[i].callRejected(error);
    }
    return self2;
  };
  function getThen(obj) {
    var then = obj && obj.then;
    if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
      return function appyThen() {
        then.apply(obj, arguments);
      };
    }
  }
  function safelyResolveThenable(self2, thenable) {
    var called = false;
    function onError(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.reject(self2, value);
    }
    function onSuccess(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.resolve(self2, value);
    }
    function tryToUnwrap() {
      thenable(onSuccess, onError);
    }
    var result = tryCatch(tryToUnwrap);
    if (result.status === "error") {
      onError(result.value);
    }
  }
  function tryCatch(func, value) {
    var out = {};
    try {
      out.value = func(value);
      out.status = "success";
    } catch (e) {
      out.status = "error";
      out.value = e;
    }
    return out;
  }
  Promise2.resolve = resolve;
  function resolve(value) {
    if (value instanceof this) {
      return value;
    }
    return handlers.resolve(new this(INTERNAL), value);
  }
  Promise2.reject = reject;
  function reject(reason) {
    var promise = new this(INTERNAL);
    return handlers.reject(promise, reason);
  }
  Promise2.all = all;
  function all(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var values = new Array(len);
    var resolved = 0;
    var i = -1;
    var promise = new this(INTERNAL);
    while (++i < len) {
      allResolver(iterable[i], i);
    }
    return promise;
    function allResolver(value, i2) {
      self2.resolve(value).then(resolveFromAll, function(error) {
        if (!called) {
          called = true;
          handlers.reject(promise, error);
        }
      });
      function resolveFromAll(outValue) {
        values[i2] = outValue;
        if (++resolved === len && !called) {
          called = true;
          handlers.resolve(promise, values);
        }
      }
    }
  }
  Promise2.race = race;
  function race(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var i = -1;
    var promise = new this(INTERNAL);
    while (++i < len) {
      resolver(iterable[i]);
    }
    return promise;
    function resolver(value) {
      self2.resolve(value).then(function(response) {
        if (!called) {
          called = true;
          handlers.resolve(promise, response);
        }
      }, function(error) {
        if (!called) {
          called = true;
          handlers.reject(promise, error);
        }
      });
    }
  }
});

// node_modules/jszip/lib/external.js
var require_external = __commonJS((exports, module) => {
  var ES6Promise = null;
  if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
  } else {
    ES6Promise = require_lib2();
  }
  module.exports = {
    Promise: ES6Promise
  };
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  (function(global2, undefined2) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel;
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
});

// node_modules/jszip/lib/utils.js
var require_utils = __commonJS((exports) => {
  var support = require_support();
  var base64 = require_base64();
  var nodejsUtils = require_nodejsUtils();
  var external = require_external();
  require_setImmediate();
  function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
  }
  exports.newBlob = function(part, type) {
    exports.checkSupport("blob");
    try {
      return new Blob([part], {
        type
      });
    } catch (e) {
      try {
        var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        var builder = new Builder;
        builder.append(part);
        return builder.getBlob(type);
      } catch (e2) {
        throw new Error("Bug : can't construct the Blob.");
      }
    }
  };
  function identity(input) {
    return input;
  }
  function stringToArrayLike(str, array) {
    for (var i = 0;i < str.length; ++i) {
      array[i] = str.charCodeAt(i) & 255;
    }
    return array;
  }
  var arrayToStringHelper = {
    stringifyByChunk: function(array, type, chunk) {
      var result = [], k = 0, len = array.length;
      if (len <= chunk) {
        return String.fromCharCode.apply(null, array);
      }
      while (k < len) {
        if (type === "array" || type === "nodebuffer") {
          result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
        } else {
          result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
        }
        k += chunk;
      }
      return result.join("");
    },
    stringifyByChar: function(array) {
      var resultStr = "";
      for (var i = 0;i < array.length; i++) {
        resultStr += String.fromCharCode(array[i]);
      }
      return resultStr;
    },
    applyCanBeUsed: {
      uint8array: function() {
        try {
          return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (e) {
          return false;
        }
      }(),
      nodebuffer: function() {
        try {
          return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
        } catch (e) {
          return false;
        }
      }()
    }
  };
  function arrayLikeToString(array) {
    var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;
    if (type === "uint8array") {
      canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
      canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }
    if (canUseApply) {
      while (chunk > 1) {
        try {
          return arrayToStringHelper.stringifyByChunk(array, type, chunk);
        } catch (e) {
          chunk = Math.floor(chunk / 2);
        }
      }
    }
    return arrayToStringHelper.stringifyByChar(array);
  }
  exports.applyFromCharCode = arrayLikeToString;
  function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0;i < arrayFrom.length; i++) {
      arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
  }
  var transform = {};
  transform["string"] = {
    string: identity,
    array: function(input) {
      return stringToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return transform["string"]["uint8array"](input).buffer;
    },
    uint8array: function(input) {
      return stringToArrayLike(input, new Uint8Array(input.length));
    },
    nodebuffer: function(input) {
      return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
  };
  transform["array"] = {
    string: arrayLikeToString,
    array: identity,
    arraybuffer: function(input) {
      return new Uint8Array(input).buffer;
    },
    uint8array: function(input) {
      return new Uint8Array(input);
    },
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(input);
    }
  };
  transform["arraybuffer"] = {
    string: function(input) {
      return arrayLikeToString(new Uint8Array(input));
    },
    array: function(input) {
      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    arraybuffer: identity,
    uint8array: function(input) {
      return new Uint8Array(input);
    },
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
  };
  transform["uint8array"] = {
    string: arrayLikeToString,
    array: function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return input.buffer;
    },
    uint8array: identity,
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(input);
    }
  };
  transform["nodebuffer"] = {
    string: arrayLikeToString,
    array: function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    uint8array: function(input) {
      return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    nodebuffer: identity
  };
  exports.transformTo = function(outputType, input) {
    if (!input) {
      input = "";
    }
    if (!outputType) {
      return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
  };
  exports.resolve = function(path) {
    var parts = path.split("/");
    var result = [];
    for (var index = 0;index < parts.length; index++) {
      var part = parts[index];
      if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
        continue;
      } else if (part === "..") {
        result.pop();
      } else {
        result.push(part);
      }
    }
    return result.join("/");
  };
  exports.getTypeOf = function(input) {
    if (typeof input === "string") {
      return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
      return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
      return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
      return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
      return "arraybuffer";
    }
  };
  exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
      throw new Error(type + " is not supported by this platform");
    }
  };
  exports.MAX_VALUE_16BITS = 65535;
  exports.MAX_VALUE_32BITS = -1;
  exports.pretty = function(str) {
    var res = "", code, i;
    for (i = 0;i < (str || "").length; i++) {
      code = str.charCodeAt(i);
      res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
  };
  exports.delay = function(callback, args, self2) {
    setImmediate(function() {
      callback.apply(self2 || null, args || []);
    });
  };
  exports.inherits = function(ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj;
  };
  exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0;i < arguments.length; i++) {
      for (attr in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
          result[attr] = arguments[i][attr];
        }
      }
    }
    return result;
  };
  exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
    var promise = external.Promise.resolve(inputData).then(function(data) {
      var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
      if (isBlob && typeof FileReader !== "undefined") {
        return new external.Promise(function(resolve, reject) {
          var reader = new FileReader;
          reader.onload = function(e) {
            resolve(e.target.result);
          };
          reader.onerror = function(e) {
            reject(e.target.error);
          };
          reader.readAsArrayBuffer(data);
        });
      } else {
        return data;
      }
    });
    return promise.then(function(data) {
      var dataType = exports.getTypeOf(data);
      if (!dataType) {
        return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
      }
      if (dataType === "arraybuffer") {
        data = exports.transformTo("uint8array", data);
      } else if (dataType === "string") {
        if (isBase64) {
          data = base64.decode(data);
        } else if (isBinary) {
          if (isOptimizedBinaryString !== true) {
            data = string2binary(data);
          }
        }
      }
      return data;
    });
  };
});

// node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS((exports, module) => {
  function GenericWorker(name) {
    this.name = name || "default";
    this.streamInfo = {};
    this.generatedError = null;
    this.extraStreamInfo = {};
    this.isPaused = true;
    this.isFinished = false;
    this.isLocked = false;
    this._listeners = {
      data: [],
      end: [],
      error: []
    };
    this.previous = null;
  }
  GenericWorker.prototype = {
    push: function(chunk) {
      this.emit("data", chunk);
    },
    end: function() {
      if (this.isFinished) {
        return false;
      }
      this.flush();
      try {
        this.emit("end");
        this.cleanUp();
        this.isFinished = true;
      } catch (e) {
        this.emit("error", e);
      }
      return true;
    },
    error: function(e) {
      if (this.isFinished) {
        return false;
      }
      if (this.isPaused) {
        this.generatedError = e;
      } else {
        this.isFinished = true;
        this.emit("error", e);
        if (this.previous) {
          this.previous.error(e);
        }
        this.cleanUp();
      }
      return true;
    },
    on: function(name, listener) {
      this._listeners[name].push(listener);
      return this;
    },
    cleanUp: function() {
      this.streamInfo = this.generatedError = this.extraStreamInfo = null;
      this._listeners = [];
    },
    emit: function(name, arg) {
      if (this._listeners[name]) {
        for (var i = 0;i < this._listeners[name].length; i++) {
          this._listeners[name][i].call(this, arg);
        }
      }
    },
    pipe: function(next) {
      return next.registerPrevious(this);
    },
    registerPrevious: function(previous) {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.streamInfo = previous.streamInfo;
      this.mergeStreamInfo();
      this.previous = previous;
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.end();
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    },
    pause: function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = true;
      if (this.previous) {
        this.previous.pause();
      }
      return true;
    },
    resume: function() {
      if (!this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = false;
      var withError = false;
      if (this.generatedError) {
        this.error(this.generatedError);
        withError = true;
      }
      if (this.previous) {
        this.previous.resume();
      }
      return !withError;
    },
    flush: function() {},
    processChunk: function(chunk) {
      this.push(chunk);
    },
    withStreamInfo: function(key, value) {
      this.extraStreamInfo[key] = value;
      this.mergeStreamInfo();
      return this;
    },
    mergeStreamInfo: function() {
      for (var key in this.extraStreamInfo) {
        if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
          continue;
        }
        this.streamInfo[key] = this.extraStreamInfo[key];
      }
    },
    lock: function() {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.isLocked = true;
      if (this.previous) {
        this.previous.lock();
      }
    },
    toString: function() {
      var me = "Worker " + this.name;
      if (this.previous) {
        return this.previous + " -> " + me;
      } else {
        return me;
      }
    }
  };
  module.exports = GenericWorker;
});

// node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS((exports) => {
  var utils = require_utils();
  var support = require_support();
  var nodejsUtils = require_nodejsUtils();
  var GenericWorker = require_GenericWorker();
  var _utf8len = new Array(256);
  for (i = 0;i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
  }
  var i;
  _utf8len[254] = _utf8len[254] = 1;
  var string2buf = function(str) {
    var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    if (support.uint8array) {
      buf = new Uint8Array(buf_len);
    } else {
      buf = new Array(buf_len);
    }
    for (i2 = 0, m_pos = 0;i2 < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i2++] = c;
      } else if (c < 2048) {
        buf[i2++] = 192 | c >>> 6;
        buf[i2++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i2++] = 224 | c >>> 12;
        buf[i2++] = 128 | c >>> 6 & 63;
        buf[i2++] = 128 | c & 63;
      } else {
        buf[i2++] = 240 | c >>> 18;
        buf[i2++] = 128 | c >>> 12 & 63;
        buf[i2++] = 128 | c >>> 6 & 63;
        buf[i2++] = 128 | c & 63;
      }
    }
    return buf;
  };
  var utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
  var buf2string = function(buf) {
    var i2, out, c, c_len;
    var len = buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i2 = 0;i2 < len; ) {
      c = buf[i2++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len) {
        c = c << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    if (utf16buf.length !== out) {
      if (utf16buf.subarray) {
        utf16buf = utf16buf.subarray(0, out);
      } else {
        utf16buf.length = out;
      }
    }
    return utils.applyFromCharCode(utf16buf);
  };
  exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
      return nodejsUtils.newBufferFrom(str, "utf-8");
    }
    return string2buf(str);
  };
  exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
      return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }
    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
    return buf2string(buf);
  };
  function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  utils.inherits(Utf8DecodeWorker, GenericWorker);
  Utf8DecodeWorker.prototype.processChunk = function(chunk) {
    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: exports.utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker.prototype.flush = function() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: exports.utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  exports.Utf8DecodeWorker = Utf8DecodeWorker;
  function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
  }
  utils.inherits(Utf8EncodeWorker, GenericWorker);
  Utf8EncodeWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: exports.utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  exports.Utf8EncodeWorker = Utf8EncodeWorker;
});

// node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS((exports, module) => {
  var GenericWorker = require_GenericWorker();
  var utils = require_utils();
  function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  utils.inherits(ConvertWorker, GenericWorker);
  ConvertWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: utils.transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  module.exports = ConvertWorker;
});

// node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS((exports, module) => {
  var Readable = require_readable().Readable;
  var utils = require_utils();
  utils.inherits(NodejsStreamOutputAdapter, Readable);
  function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;
    var self2 = this;
    helper.on("data", function(data, meta) {
      if (!self2.push(data)) {
        self2._helper.pause();
      }
      if (updateCb) {
        updateCb(meta);
      }
    }).on("error", function(e) {
      self2.emit("error", e);
    }).on("end", function() {
      self2.push(null);
    });
  }
  NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
  };
  module.exports = NodejsStreamOutputAdapter;
});

// node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS((exports, module) => {
  var utils = require_utils();
  var ConvertWorker = require_ConvertWorker();
  var GenericWorker = require_GenericWorker();
  var base64 = require_base64();
  var support = require_support();
  var external = require_external();
  var NodejsStreamOutputAdapter = null;
  if (support.nodestream) {
    try {
      NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
    } catch (e) {}
  }
  function transformZipOutput(type, content, mimeType) {
    switch (type) {
      case "blob":
        return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
      case "base64":
        return base64.encode(content);
      default:
        return utils.transformTo(type, content);
    }
  }
  function concat(type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for (i = 0;i < dataArray.length; i++) {
      totalLength += dataArray[i].length;
    }
    switch (type) {
      case "string":
        return dataArray.join("");
      case "array":
        return Array.prototype.concat.apply([], dataArray);
      case "uint8array":
        res = new Uint8Array(totalLength);
        for (i = 0;i < dataArray.length; i++) {
          res.set(dataArray[i], index);
          index += dataArray[i].length;
        }
        return res;
      case "nodebuffer":
        return Buffer.concat(dataArray);
      default:
        throw new Error("concat : unsupported type '" + type + "'");
    }
  }
  function accumulate(helper, updateCallback) {
    return new external.Promise(function(resolve, reject) {
      var dataArray = [];
      var { _internalType: chunkType, _outputType: resultType, _mimeType: mimeType } = helper;
      helper.on("data", function(data, meta) {
        dataArray.push(data);
        if (updateCallback) {
          updateCallback(meta);
        }
      }).on("error", function(err) {
        dataArray = [];
        reject(err);
      }).on("end", function() {
        try {
          var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
          resolve(result);
        } catch (e) {
          reject(e);
        }
        dataArray = [];
      }).resume();
    });
  }
  function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
      case "blob":
      case "arraybuffer":
        internalType = "uint8array";
        break;
      case "base64":
        internalType = "string";
        break;
    }
    try {
      this._internalType = internalType;
      this._outputType = outputType;
      this._mimeType = mimeType;
      utils.checkSupport(internalType);
      this._worker = worker.pipe(new ConvertWorker(internalType));
      worker.lock();
    } catch (e) {
      this._worker = new GenericWorker("error");
      this._worker.error(e);
    }
  }
  StreamHelper.prototype = {
    accumulate: function(updateCb) {
      return accumulate(this, updateCb);
    },
    on: function(evt, fn) {
      var self2 = this;
      if (evt === "data") {
        this._worker.on(evt, function(chunk) {
          fn.call(self2, chunk.data, chunk.meta);
        });
      } else {
        this._worker.on(evt, function() {
          utils.delay(fn, arguments, self2);
        });
      }
      return this;
    },
    resume: function() {
      utils.delay(this._worker.resume, [], this._worker);
      return this;
    },
    pause: function() {
      this._worker.pause();
      return this;
    },
    toNodejsStream: function(updateCb) {
      utils.checkSupport("nodestream");
      if (this._outputType !== "nodebuffer") {
        throw new Error(this._outputType + " is not supported by this method");
      }
      return new NodejsStreamOutputAdapter(this, {
        objectMode: this._outputType !== "nodebuffer"
      }, updateCb);
    }
  };
  module.exports = StreamHelper;
});

// node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS((exports) => {
  exports.base64 = false;
  exports.binary = false;
  exports.dir = false;
  exports.createFolders = true;
  exports.date = null;
  exports.compression = null;
  exports.compressionOptions = null;
  exports.comment = null;
  exports.unixPermissions = null;
  exports.dosPermissions = null;
});

// node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var DEFAULT_BLOCK_SIZE = 16 * 1024;
  function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self2 = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self2.dataIsReady = true;
      self2.data = data;
      self2.max = data && data.length || 0;
      self2.type = utils.getTypeOf(data);
      if (!self2.isPaused) {
        self2._tickAndRepeat();
      }
    }, function(e) {
      self2.error(e);
    });
  }
  utils.inherits(DataWorker, GenericWorker);
  DataWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      utils.delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker.prototype._tick = function() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
        case "nodebuffer":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  module.exports = DataWorker;
});

// node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  var utils = require_utils();
  function makeTable() {
    var c, table = [];
    for (var n = 0;n < 256; n++) {
      c = n;
      for (var k = 0;k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i = pos;i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i = pos;i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
    }
    return crc ^ -1;
  }
  module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
      return 0;
    }
    var isArray = utils.getTypeOf(input) !== "string";
    if (isArray) {
      return crc32(crc | 0, input, input.length, 0);
    } else {
      return crc32str(crc | 0, input, input.length, 0);
    }
  };
});

// node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS((exports, module) => {
  var GenericWorker = require_GenericWorker();
  var crc32 = require_crc32();
  var utils = require_utils();
  function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  utils.inherits(Crc32Probe, GenericWorker);
  Crc32Probe.prototype.processChunk = function(chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  module.exports = Crc32Probe;
});

// node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  utils.inherits(DataLengthProbe, GenericWorker);
  DataLengthProbe.prototype.processChunk = function(chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
  };
  module.exports = DataLengthProbe;
});

// node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS((exports, module) => {
  var external = require_external();
  var DataWorker = require_DataWorker();
  var Crc32Probe = require_Crc32Probe();
  var DataLengthProbe = require_DataLengthProbe();
  function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
  }
  CompressedObject.prototype = {
    getContentWorker: function() {
      var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
      var that = this;
      worker.on("end", function() {
        if (this.streamInfo["data_length"] !== that.uncompressedSize) {
          throw new Error("Bug : uncompressed data size mismatch");
        }
      });
      return worker;
    },
    getCompressedWorker: function() {
      return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
  };
  CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
  };
  module.exports = CompressedObject;
});

// node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS((exports, module) => {
  var StreamHelper = require_StreamHelper();
  var DataWorker = require_DataWorker();
  var utf8 = require_utf8();
  var CompressedObject = require_compressedObject();
  var GenericWorker = require_GenericWorker();
  var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;
    this._data = data;
    this._dataBinary = options.binary;
    this.options = {
      compression: options.compression,
      compressionOptions: options.compressionOptions
    };
  };
  ZipObject.prototype = {
    internalStream: function(type) {
      var result = null, outputType = "string";
      try {
        if (!type) {
          throw new Error("No output type specified.");
        }
        outputType = type.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
          outputType = "string";
        }
        result = this._decompressWorker();
        var isUnicodeString = !this._dataBinary;
        if (isUnicodeString && !askUnicodeString) {
          result = result.pipe(new utf8.Utf8EncodeWorker);
        }
        if (!isUnicodeString && askUnicodeString) {
          result = result.pipe(new utf8.Utf8DecodeWorker);
        }
      } catch (e) {
        result = new GenericWorker("error");
        result.error(e);
      }
      return new StreamHelper(result, outputType, "");
    },
    async: function(type, onUpdate) {
      return this.internalStream(type).accumulate(onUpdate);
    },
    nodeStream: function(type, onUpdate) {
      return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },
    _compressWorker: function(compression, compressionOptions) {
      if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
        return this._data.getCompressedWorker();
      } else {
        var result = this._decompressWorker();
        if (!this._dataBinary) {
          result = result.pipe(new utf8.Utf8EncodeWorker);
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
      }
    },
    _decompressWorker: function() {
      if (this._data instanceof CompressedObject) {
        return this._data.getContentWorker();
      } else if (this._data instanceof GenericWorker) {
        return this._data;
      } else {
        return new DataWorker(this._data);
      }
    }
  };
  var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
  var removedFn = function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  };
  for (i = 0;i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
  }
  var i;
  module.exports = ZipObject;
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS((exports) => {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0;i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      var i, l, len, pos, chunk, result;
      len = 0;
      for (i = 0, l = chunks.length;i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length;i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i = 0;i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS((exports) => {
  var utils = require_common();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  function send_code(s, c, tree) {
    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0;bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1;h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length;bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1;bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0;n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0;code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0;n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0;code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0;n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (;code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n = 0;n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0;bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0;n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s) {
    var n;
    for (n = 0;n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0;n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0;n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  function smaller(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  function compress_block(s, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0;n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1;n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0;rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0;n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32;n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
  }
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  function _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  exports._tr_init = _tr_init;
  exports._tr_stored_block = _tr_stored_block;
  exports._tr_flush_block = _tr_flush_block;
  exports._tr_tally = _tr_tally;
  exports._tr_align = _tr_align;
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS((exports, module) => {
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  module.exports = adler32;
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS((exports, module) => {
  function makeTable() {
    var c, table = [];
    for (var n = 0;n < 256; n++) {
      c = n;
      for (var k = 0;k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i = pos;i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  module.exports = crc32;
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS((exports, module) => {
  module.exports = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS((exports) => {
  var utils = require_common();
  var trees = require_trees();
  var adler32 = require_adler32();
  var crc32 = require_crc322();
  var msg = require_messages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  function flush_block_only(s, last) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (;; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;
    for (;; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s, flush) {
    var bflush;
    for (;; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees._tr_init(s);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState;
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils.Buf8(s.w_size * 2);
    s.head = new utils.Buf16(s.hash_size);
    s.prev = new utils.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils.Buf8(s.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }
  exports.deflateInit = deflateInit;
  exports.deflateInit2 = deflateInit2;
  exports.deflateReset = deflateReset;
  exports.deflateResetKeep = deflateResetKeep;
  exports.deflateSetHeader = deflateSetHeader;
  exports.deflate = deflate;
  exports.deflateEnd = deflateEnd;
  exports.deflateSetDictionary = deflateSetDictionary;
  exports.deflateInfo = "pako deflate (from Nodeca project)";
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS((exports) => {
  var utils = require_common();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils.Buf8(256);
  for (q = 0;q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  var q;
  _utf8len[254] = _utf8len[254] = 1;
  exports.string2buf = function(str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new utils.Buf8(buf_len);
    for (i = 0, m_pos = 0;i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i = 0;i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  exports.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  exports.binstring2buf = function(str) {
    var buf = new utils.Buf8(str.length);
    for (var i = 0, len = buf.length;i < len; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  };
  exports.buf2string = function(buf, max) {
    var i, out, c, c_len;
    var len = max || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i = 0;i < len; ) {
      c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  exports.utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS((exports, module) => {
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module.exports = ZStream;
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS((exports) => {
  var zlib_deflate = require_deflate();
  var utils = require_common();
  var strings = require_strings();
  var msg = require_messages();
  var ZStream = require_zstream();
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate))
      return new Deflate(options);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS((exports, module) => {
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (;; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (;; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS((exports, module) => {
  var utils = require_common();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0;len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0;sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS;max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1;min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1;len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1;len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0;sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (;; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS((exports) => {
  var utils = require_common();
  var adler32 = require_adler32();
  var crc32 = require_crc322();
  var inflate_fast = require_inffast();
  var inflate_table = require_inftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState;
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix;
  var distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (;; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  exports.inflateReset = inflateReset;
  exports.inflateReset2 = inflateReset2;
  exports.inflateResetKeep = inflateResetKeep;
  exports.inflateInit = inflateInit;
  exports.inflateInit2 = inflateInit2;
  exports.inflate = inflate;
  exports.inflateEnd = inflateEnd;
  exports.inflateGetHeader = inflateGetHeader;
  exports.inflateSetDictionary = inflateSetDictionary;
  exports.inflateInfo = "pako inflate (from Nodeca project)";
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS((exports, module) => {
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  module.exports = GZheader;
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS((exports) => {
  var zlib_inflate = require_inflate();
  var utils = require_common();
  var strings = require_strings();
  var c = require_constants();
  var msg = require_messages();
  var ZStream = require_zstream();
  var GZheader = require_gzheader();
  var toString = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate))
      return new Inflate(options);
    this.options = utils.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader;
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.binstring2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
      if (status === c.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c.Z_BUF_ERROR && allowBufError === true) {
        status = c.Z_OK;
        allowBufError = false;
      }
      if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
    if (status === c.Z_STREAM_END) {
      _mode = c.Z_FINISH;
    }
    if (_mode === c.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c.Z_OK;
    }
    if (_mode === c.Z_SYNC_FLUSH) {
      this.onEnd(c.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  }
  exports.Inflate = Inflate;
  exports.inflate = inflate;
  exports.inflateRaw = inflateRaw;
  exports.ungzip = inflate;
});

// node_modules/pako/index.js
var require_pako = __commonJS((exports, module) => {
  var assign = require_common().assign;
  var deflate = require_deflate2();
  var inflate = require_inflate2();
  var constants = require_constants();
  var pako = {};
  assign(pako, deflate, inflate, constants);
  module.exports = pako;
});

// node_modules/jszip/lib/flate.js
var require_flate = __commonJS((exports) => {
  var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var pako = require_pako();
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
  exports.magic = "\b\x00";
  function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  utils.inherits(FlateWorker, GenericWorker);
  FlateWorker.prototype.processChunk = function(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
  };
  FlateWorker.prototype.flush = function() {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker.prototype._createPako = function() {
    this._pako = new pako[this._pakoAction]({
      raw: true,
      level: this._pakoOptions.level || -1
    });
    var self2 = this;
    this._pako.onData = function(data) {
      self2.push({
        data,
        meta: self2.meta
      });
    };
  };
  exports.compressWorker = function(compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
  };
  exports.uncompressWorker = function() {
    return new FlateWorker("Inflate", {});
  };
});

// node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS((exports) => {
  var GenericWorker = require_GenericWorker();
  exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function() {
      return new GenericWorker("STORE compression");
    },
    uncompressWorker: function() {
      return new GenericWorker("STORE decompression");
    }
  };
  exports.DEFLATE = require_flate();
});

// node_modules/jszip/lib/signature.js
var require_signature = __commonJS((exports) => {
  exports.LOCAL_FILE_HEADER = "PK\x03\x04";
  exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
  exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
  exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
  exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
  exports.DATA_DESCRIPTOR = "PK\x07\b";
});

// node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var utf8 = require_utf8();
  var crc32 = require_crc32();
  var signature = require_signature();
  var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0;i < bytes; i++) {
      hex += String.fromCharCode(dec & 255);
      dec = dec >>> 8;
    }
    return hex;
  };
  var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
    var result = unixPermissions;
    if (!unixPermissions) {
      result = isDir ? 16893 : 33204;
    }
    return (result & 65535) << 16;
  };
  var generateDosExternalFileAttr = function(dosPermissions) {
    return (dosPermissions || 0) & 63;
  };
  var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
    var dataInfo = {
      crc32: 0,
      compressedSize: 0,
      uncompressedSize: 0
    };
    if (!streamedContent || streamingEnded) {
      dataInfo.crc32 = streamInfo["crc32"];
      dataInfo.compressedSize = streamInfo["compressedSize"];
      dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
    }
    var bitflag = 0;
    if (streamedContent) {
      bitflag |= 8;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
      bitflag |= 2048;
    }
    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
      extFileAttr |= 16;
    }
    if (platform === "UNIX") {
      versionMadeBy = 798;
      extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
      versionMadeBy = 20;
      extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }
    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;
    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();
    if (useUTF8ForFileName) {
      unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
      extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
    }
    if (useUTF8ForComment) {
      unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;
      extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
    }
    var header = "";
    header += `
\x00`;
    header += decToHex(bitflag, 2);
    header += compression.magic;
    header += decToHex(dosTime, 2);
    header += decToHex(dosDate, 2);
    header += decToHex(dataInfo.crc32, 4);
    header += decToHex(dataInfo.compressedSize, 4);
    header += decToHex(dataInfo.uncompressedSize, 4);
    header += decToHex(encodedFileName.length, 2);
    header += decToHex(extraFields.length, 2);
    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
    var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\x00\x00" + "\x00\x00" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
    return {
      fileRecord,
      dirRecord
    };
  };
  var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));
    dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
    return dirEnd;
  };
  var generateDataDescriptors = function(streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo["crc32"], 4) + decToHex(streamInfo["compressedSize"], 4) + decToHex(streamInfo["uncompressedSize"], 4);
    return descriptor;
  };
  function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment;
    this.zipPlatform = platform;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  utils.inherits(ZipFileWorker, GenericWorker);
  ZipFileWorker.prototype.push = function(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker.prototype.openedSource = function(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker.prototype.closedSource = function(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker.prototype.flush = function() {
    var localDirLength = this.bytesWritten;
    for (var i = 0;i < this.dirRecords.length; i++) {
      this.push({
        data: this.dirRecords[i],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker.prototype.prepareNextSource = function() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker.prototype.registerPrevious = function(previous) {
    this._sources.push(previous);
    var self2 = this;
    previous.on("data", function(chunk) {
      self2.processChunk(chunk);
    });
    previous.on("end", function() {
      self2.closedSource(self2.previous.streamInfo);
      if (self2._sources.length) {
        self2.prepareNextSource();
      } else {
        self2.end();
      }
    });
    previous.on("error", function(e) {
      self2.error(e);
    });
    return this;
  };
  ZipFileWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker.prototype.error = function(e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
      return false;
    }
    for (var i = 0;i < sources.length; i++) {
      try {
        sources[i].error(e);
      } catch (e2) {}
    }
    return true;
  };
  ZipFileWorker.prototype.lock = function() {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0;i < sources.length; i++) {
      sources[i].lock();
    }
  };
  module.exports = ZipFileWorker;
});

// node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS((exports) => {
  var compressions = require_compressions();
  var ZipFileWorker = require_ZipFileWorker();
  var getCompression = function(fileCompression, zipCompression) {
    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
      throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
  };
  exports.generateWorker = function(zip, options, comment) {
    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {
      zip.forEach(function(relativePath, file) {
        entriesCount++;
        var compression = getCompression(file.options.compression, options.compression);
        var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
        var { dir, date } = file;
        file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
          name: relativePath,
          dir,
          date,
          comment: file.comment || "",
          unixPermissions: file.unixPermissions,
          dosPermissions: file.dosPermissions
        }).pipe(zipFileWorker);
      });
      zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
      zipFileWorker.error(e);
    }
    return zipFileWorker;
  };
});

// node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
  }
  utils.inherits(NodejsStreamInputAdapter, GenericWorker);
  NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
    var self2 = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function(chunk) {
      self2.push({
        data: chunk,
        meta: {
          percent: 0
        }
      });
    }).on("error", function(e) {
      if (self2.isPaused) {
        this.generatedError = e;
      } else {
        self2.error(e);
      }
    }).on("end", function() {
      if (self2.isPaused) {
        self2._upstreamEnded = true;
      } else {
        self2.end();
      }
    });
  };
  NodejsStreamInputAdapter.prototype.pause = function() {
    if (!GenericWorker.prototype.pause.call(this)) {
      return false;
    }
    this._stream.pause();
    return true;
  };
  NodejsStreamInputAdapter.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (this._upstreamEnded) {
      this.end();
    } else {
      this._stream.resume();
    }
    return true;
  };
  module.exports = NodejsStreamInputAdapter;
});

// node_modules/jszip/lib/object.js
var require_object = __commonJS((exports, module) => {
  var utf8 = require_utf8();
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var StreamHelper = require_StreamHelper();
  var defaults = require_defaults();
  var CompressedObject = require_compressedObject();
  var ZipObject = require_zipObject();
  var generate = require_generate();
  var nodejsUtils = require_nodejsUtils();
  var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
  var fileAdd = function(name, data, originalOptions) {
    var dataType = utils.getTypeOf(data), parent;
    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date;
    if (o.compression !== null) {
      o.compression = o.compression.toUpperCase();
    }
    if (typeof o.unixPermissions === "string") {
      o.unixPermissions = parseInt(o.unixPermissions, 8);
    }
    if (o.unixPermissions && o.unixPermissions & 16384) {
      o.dir = true;
    }
    if (o.dosPermissions && o.dosPermissions & 16) {
      o.dir = true;
    }
    if (o.dir) {
      name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
      folderAdd.call(this, parent, true);
    }
    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
      o.binary = !isUnicodeString;
    }
    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
      o.base64 = false;
      o.binary = true;
      data = "";
      o.compression = "STORE";
      dataType = "string";
    }
    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
      zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
      zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }
    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
  };
  var parentFolder = function(path) {
    if (path.slice(-1) === "/") {
      path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf("/");
    return lastSlash > 0 ? path.substring(0, lastSlash) : "";
  };
  var forceTrailingSlash = function(path) {
    if (path.slice(-1) !== "/") {
      path += "/";
    }
    return path;
  };
  var folderAdd = function(name, createFolders) {
    createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
    name = forceTrailingSlash(name);
    if (!this.files[name]) {
      fileAdd.call(this, name, null, {
        dir: true,
        createFolders
      });
    }
    return this.files[name];
  };
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  var out = {
    load: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    forEach: function(cb) {
      var filename, relativePath, file;
      for (filename in this.files) {
        file = this.files[filename];
        relativePath = filename.slice(this.root.length, filename.length);
        if (relativePath && filename.slice(0, this.root.length) === this.root) {
          cb(relativePath, file);
        }
      }
    },
    filter: function(search) {
      var result = [];
      this.forEach(function(relativePath, entry) {
        if (search(relativePath, entry)) {
          result.push(entry);
        }
      });
      return result;
    },
    file: function(name, data, o) {
      if (arguments.length === 1) {
        if (isRegExp(name)) {
          var regexp = name;
          return this.filter(function(relativePath, file) {
            return !file.dir && regexp.test(relativePath);
          });
        } else {
          var obj = this.files[this.root + name];
          if (obj && !obj.dir) {
            return obj;
          } else {
            return null;
          }
        }
      } else {
        name = this.root + name;
        fileAdd.call(this, name, data, o);
      }
      return this;
    },
    folder: function(arg) {
      if (!arg) {
        return this;
      }
      if (isRegExp(arg)) {
        return this.filter(function(relativePath, file) {
          return file.dir && arg.test(relativePath);
        });
      }
      var name = this.root + arg;
      var newFolder = folderAdd.call(this, name);
      var ret = this.clone();
      ret.root = newFolder.name;
      return ret;
    },
    remove: function(name) {
      name = this.root + name;
      var file = this.files[name];
      if (!file) {
        if (name.slice(-1) !== "/") {
          name += "/";
        }
        file = this.files[name];
      }
      if (file && !file.dir) {
        delete this.files[name];
      } else {
        var kids = this.filter(function(relativePath, file2) {
          return file2.name.slice(0, name.length) === name;
        });
        for (var i = 0;i < kids.length; i++) {
          delete this.files[kids[i].name];
        }
      }
      return this;
    },
    generate: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
        opts = utils.extend(options || {}, {
          streamFiles: false,
          compression: "STORE",
          compressionOptions: null,
          type: "",
          platform: "DOS",
          comment: null,
          mimeType: "application/zip",
          encodeFileName: utf8.utf8encode
        });
        opts.type = opts.type.toLowerCase();
        opts.compression = opts.compression.toUpperCase();
        if (opts.type === "binarystring") {
          opts.type = "string";
        }
        if (!opts.type) {
          throw new Error("No output type specified.");
        }
        utils.checkSupport(opts.type);
        if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
          opts.platform = "UNIX";
        }
        if (opts.platform === "win32") {
          opts.platform = "DOS";
        }
        var comment = opts.comment || this.comment || "";
        worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    generateAsync: function(options, onUpdate) {
      return this.generateInternalStream(options).accumulate(onUpdate);
    },
    generateNodeStream: function(options, onUpdate) {
      options = options || {};
      if (!options.type) {
        options.type = "nodebuffer";
      }
      return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
  };
  module.exports = out;
});

// node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS((exports, module) => {
  var utils = require_utils();
  function DataReader(data) {
    this.data = data;
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
  }
  DataReader.prototype = {
    checkOffset: function(offset) {
      this.checkIndex(this.index + offset);
    },
    checkIndex: function(newIndex) {
      if (this.length < this.zero + newIndex || newIndex < 0) {
        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
      }
    },
    setIndex: function(newIndex) {
      this.checkIndex(newIndex);
      this.index = newIndex;
    },
    skip: function(n) {
      this.setIndex(this.index + n);
    },
    byteAt: function() {},
    readInt: function(size) {
      var result = 0, i;
      this.checkOffset(size);
      for (i = this.index + size - 1;i >= this.index; i--) {
        result = (result << 8) + this.byteAt(i);
      }
      this.index += size;
      return result;
    },
    readString: function(size) {
      return utils.transformTo("string", this.readData(size));
    },
    readData: function() {},
    lastIndexOfSignature: function() {},
    readAndCheckSignature: function() {},
    readDate: function() {
      var dostime = this.readInt(4);
      return new Date(Date.UTC((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1));
    }
  };
  module.exports = DataReader;
});

// node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS((exports, module) => {
  var DataReader = require_DataReader();
  var utils = require_utils();
  function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i = 0;i < this.data.length; i++) {
      data[i] = data[i] & 255;
    }
  }
  utils.inherits(ArrayReader, DataReader);
  ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
  };
  ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4;i >= 0; --i) {
      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
        return i - this.zero;
      }
    }
    return -1;
  };
  ArrayReader.prototype.readAndCheckSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = ArrayReader;
});

// node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS((exports, module) => {
  var DataReader = require_DataReader();
  var utils = require_utils();
  function StringReader(data) {
    DataReader.call(this, data);
  }
  utils.inherits(StringReader, DataReader);
  StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
  };
  StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader.prototype.readAndCheckSignature = function(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = StringReader;
});

// node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS((exports, module) => {
  var ArrayReader = require_ArrayReader();
  var utils = require_utils();
  function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
  }
  utils.inherits(Uint8ArrayReader, ArrayReader);
  Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = Uint8ArrayReader;
});

// node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS((exports, module) => {
  var Uint8ArrayReader = require_Uint8ArrayReader();
  var utils = require_utils();
  function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
  }
  utils.inherits(NodeBufferReader, Uint8ArrayReader);
  NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = NodeBufferReader;
});

// node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS((exports, module) => {
  var utils = require_utils();
  var support = require_support();
  var ArrayReader = require_ArrayReader();
  var StringReader = require_StringReader();
  var NodeBufferReader = require_NodeBufferReader();
  var Uint8ArrayReader = require_Uint8ArrayReader();
  module.exports = function(data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
      return new StringReader(data);
    }
    if (type === "nodebuffer") {
      return new NodeBufferReader(data);
    }
    if (support.uint8array) {
      return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
  };
});

// node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS((exports, module) => {
  var readerFor = require_readerFor();
  var utils = require_utils();
  var CompressedObject = require_compressedObject();
  var crc32fn = require_crc32();
  var utf8 = require_utf8();
  var compressions = require_compressions();
  var support = require_support();
  var MADE_BY_DOS = 0;
  var MADE_BY_UNIX = 3;
  var findCompression = function(compressionMethod) {
    for (var method in compressions) {
      if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
        continue;
      }
      if (compressions[method].magic === compressionMethod) {
        return compressions[method];
      }
    }
    return null;
  };
  function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
  }
  ZipEntry.prototype = {
    isEncrypted: function() {
      return (this.bitFlag & 1) === 1;
    },
    useUTF8: function() {
      return (this.bitFlag & 2048) === 2048;
    },
    readLocalPart: function(reader) {
      var compression, localExtraFieldsLength;
      reader.skip(22);
      this.fileNameLength = reader.readInt(2);
      localExtraFieldsLength = reader.readInt(2);
      this.fileName = reader.readData(this.fileNameLength);
      reader.skip(localExtraFieldsLength);
      if (this.compressedSize === -1 || this.uncompressedSize === -1) {
        throw new Error("Bug or corrupted zip : didn't get enough information from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
      }
      compression = findCompression(this.compressionMethod);
      if (compression === null) {
        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
      }
      this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },
    readCentralPart: function(reader) {
      this.versionMadeBy = reader.readInt(2);
      reader.skip(2);
      this.bitFlag = reader.readInt(2);
      this.compressionMethod = reader.readString(2);
      this.date = reader.readDate();
      this.crc32 = reader.readInt(4);
      this.compressedSize = reader.readInt(4);
      this.uncompressedSize = reader.readInt(4);
      var fileNameLength = reader.readInt(2);
      this.extraFieldsLength = reader.readInt(2);
      this.fileCommentLength = reader.readInt(2);
      this.diskNumberStart = reader.readInt(2);
      this.internalFileAttributes = reader.readInt(2);
      this.externalFileAttributes = reader.readInt(4);
      this.localHeaderOffset = reader.readInt(4);
      if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
      }
      reader.skip(fileNameLength);
      this.readExtraFields(reader);
      this.parseZIP64ExtraField(reader);
      this.fileComment = reader.readData(this.fileCommentLength);
    },
    processAttributes: function() {
      this.unixPermissions = null;
      this.dosPermissions = null;
      var madeBy = this.versionMadeBy >> 8;
      this.dir = this.externalFileAttributes & 16 ? true : false;
      if (madeBy === MADE_BY_DOS) {
        this.dosPermissions = this.externalFileAttributes & 63;
      }
      if (madeBy === MADE_BY_UNIX) {
        this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
      }
      if (!this.dir && this.fileNameStr.slice(-1) === "/") {
        this.dir = true;
      }
    },
    parseZIP64ExtraField: function() {
      if (!this.extraFields[1]) {
        return;
      }
      var extraReader = readerFor(this.extraFields[1].value);
      if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
        this.uncompressedSize = extraReader.readInt(8);
      }
      if (this.compressedSize === utils.MAX_VALUE_32BITS) {
        this.compressedSize = extraReader.readInt(8);
      }
      if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
        this.localHeaderOffset = extraReader.readInt(8);
      }
      if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
        this.diskNumberStart = extraReader.readInt(4);
      }
    },
    readExtraFields: function(reader) {
      var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
      if (!this.extraFields) {
        this.extraFields = {};
      }
      while (reader.index + 4 < end) {
        extraFieldId = reader.readInt(2);
        extraFieldLength = reader.readInt(2);
        extraFieldValue = reader.readData(extraFieldLength);
        this.extraFields[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
      reader.setIndex(end);
    },
    handleUTF8: function() {
      var decodeParamType = support.uint8array ? "uint8array" : "array";
      if (this.useUTF8()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
      } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
          this.fileNameStr = upath;
        } else {
          var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
          this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }
        var ucomment = this.findExtraFieldUnicodeComment();
        if (ucomment !== null) {
          this.fileCommentStr = ucomment;
        } else {
          var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
          this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
        }
      }
    },
    findExtraFieldUnicodePath: function() {
      var upathField = this.extraFields[28789];
      if (upathField) {
        var extraReader = readerFor(upathField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
          return null;
        }
        return utf8.utf8decode(extraReader.readData(upathField.length - 5));
      }
      return null;
    },
    findExtraFieldUnicodeComment: function() {
      var ucommentField = this.extraFields[25461];
      if (ucommentField) {
        var extraReader = readerFor(ucommentField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
          return null;
        }
        return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
      }
      return null;
    }
  };
  module.exports = ZipEntry;
});

// node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS((exports, module) => {
  var readerFor = require_readerFor();
  var utils = require_utils();
  var sig = require_signature();
  var ZipEntry = require_zipEntry();
  var support = require_support();
  function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
  }
  ZipEntries.prototype = {
    checkSignature: function(expectedSignature) {
      if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
      }
    },
    isSignature: function(askedIndex, expectedSignature) {
      var currentIndex = this.reader.index;
      this.reader.setIndex(askedIndex);
      var signature = this.reader.readString(4);
      var result = signature === expectedSignature;
      this.reader.setIndex(currentIndex);
      return result;
    },
    readBlockEndOfCentral: function() {
      this.diskNumber = this.reader.readInt(2);
      this.diskWithCentralDirStart = this.reader.readInt(2);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
      this.centralDirRecords = this.reader.readInt(2);
      this.centralDirSize = this.reader.readInt(4);
      this.centralDirOffset = this.reader.readInt(4);
      this.zipCommentLength = this.reader.readInt(2);
      var zipComment = this.reader.readData(this.zipCommentLength);
      var decodeParamType = support.uint8array ? "uint8array" : "array";
      var decodeContent = utils.transformTo(decodeParamType, zipComment);
      this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    readBlockZip64EndOfCentral: function() {
      this.zip64EndOfCentralSize = this.reader.readInt(8);
      this.reader.skip(4);
      this.diskNumber = this.reader.readInt(4);
      this.diskWithCentralDirStart = this.reader.readInt(4);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
      this.centralDirRecords = this.reader.readInt(8);
      this.centralDirSize = this.reader.readInt(8);
      this.centralDirOffset = this.reader.readInt(8);
      this.zip64ExtensibleData = {};
      var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
      while (index < extraDataSize) {
        extraFieldId = this.reader.readInt(2);
        extraFieldLength = this.reader.readInt(4);
        extraFieldValue = this.reader.readData(extraFieldLength);
        this.zip64ExtensibleData[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
    },
    readBlockZip64EndOfCentralLocator: function() {
      this.diskWithZip64CentralDirStart = this.reader.readInt(4);
      this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
      this.disksCount = this.reader.readInt(4);
      if (this.disksCount > 1) {
        throw new Error("Multi-volumes zip are not supported");
      }
    },
    readLocalFiles: function() {
      var i, file;
      for (i = 0;i < this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.processAttributes();
      }
    },
    readCentralDir: function() {
      var file;
      this.reader.setIndex(this.centralDirOffset);
      while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
        file = new ZipEntry({
          zip64: this.zip64
        }, this.loadOptions);
        file.readCentralPart(this.reader);
        this.files.push(file);
      }
      if (this.centralDirRecords !== this.files.length) {
        if (this.centralDirRecords !== 0 && this.files.length === 0) {
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        } else {}
      }
    },
    readEndOfCentral: function() {
      var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
      if (offset < 0) {
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
        if (isGarbage) {
          throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        } else {
          throw new Error("Corrupted zip: can't find end of central directory");
        }
      }
      this.reader.setIndex(offset);
      var endOfCentralDirOffset = offset;
      this.checkSignature(sig.CENTRAL_DIRECTORY_END);
      this.readBlockEndOfCentral();
      if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
        this.zip64 = true;
        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        if (offset < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
        }
        this.reader.setIndex(offset);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        this.readBlockZip64EndOfCentralLocator();
        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
          this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          if (this.relativeOffsetEndOfZip64CentralDir < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          }
        }
        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        this.readBlockZip64EndOfCentral();
      }
      var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
      if (this.zip64) {
        expectedEndOfCentralDirOffset += 20;
        expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
      }
      var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
      if (extraBytes > 0) {
        if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {} else {
          this.reader.zero = extraBytes;
        }
      } else if (extraBytes < 0) {
        throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
      }
    },
    prepareReader: function(data) {
      this.reader = readerFor(data);
    },
    load: function(data) {
      this.prepareReader(data);
      this.readEndOfCentral();
      this.readCentralDir();
      this.readLocalFiles();
    }
  };
  module.exports = ZipEntries;
});

// node_modules/jszip/lib/load.js
var require_load = __commonJS((exports, module) => {
  var utils = require_utils();
  var external = require_external();
  var utf8 = require_utf8();
  var ZipEntries = require_zipEntries();
  var Crc32Probe = require_Crc32Probe();
  var nodejsUtils = require_nodejsUtils();
  function checkEntryCRC32(zipEntry) {
    return new external.Promise(function(resolve, reject) {
      var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe);
      worker.on("error", function(e) {
        reject(e);
      }).on("end", function() {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
          reject(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
          resolve();
        }
      }).resume();
    });
  }
  module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
      base64: false,
      checkCRC32: false,
      optimizedBinaryString: false,
      createFolders: false,
      decodeFileName: utf8.utf8decode
    });
    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }
    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
      var zipEntries = new ZipEntries(options);
      zipEntries.load(data2);
      return zipEntries;
    }).then(function checkCRC32(zipEntries) {
      var promises = [external.Promise.resolve(zipEntries)];
      var files = zipEntries.files;
      if (options.checkCRC32) {
        for (var i = 0;i < files.length; i++) {
          promises.push(checkEntryCRC32(files[i]));
        }
      }
      return external.Promise.all(promises);
    }).then(function addFiles(results) {
      var zipEntries = results.shift();
      var files = zipEntries.files;
      for (var i = 0;i < files.length; i++) {
        var input = files[i];
        var unsafeName = input.fileNameStr;
        var safeName = utils.resolve(input.fileNameStr);
        zip.file(safeName, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
        if (!input.dir) {
          zip.file(safeName).unsafeOriginalName = unsafeName;
        }
      }
      if (zipEntries.zipComment.length) {
        zip.comment = zipEntries.zipComment;
      }
      return zip;
    });
  };
});

// node_modules/jszip/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  function JSZip() {
    if (!(this instanceof JSZip)) {
      return new JSZip;
    }
    if (arguments.length) {
      throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }
    this.files = Object.create(null);
    this.comment = null;
    this.root = "";
    this.clone = function() {
      var newObj = new JSZip;
      for (var i in this) {
        if (typeof this[i] !== "function") {
          newObj[i] = this[i];
        }
      }
      return newObj;
    };
  }
  JSZip.prototype = require_object();
  JSZip.prototype.loadAsync = require_load();
  JSZip.support = require_support();
  JSZip.defaults = require_defaults();
  JSZip.version = "3.10.1";
  JSZip.loadAsync = function(content, options) {
    return new JSZip().loadAsync(content, options);
  };
  JSZip.external = require_external();
  module.exports = JSZip;
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS((exports, module) => {
  /*! https://mths.be/punycode v1.4.1 by @mathias */
  (function(root) {
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = typeof module == "object" && module && !module.nodeType && module;
    var freeGlobal = typeof global == "object" && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root = freeGlobal;
    }
    var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length = string.length, value, extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map(array, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (;delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode2(input) {
      var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j = 0;j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
        for (oldi = i, w = 1, k = base;; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return ucs2encode(output);
    }
    function encode(input) {
      var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n = initialN;
      delta = 0;
      bias = initialBias;
      for (j = 0;j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m = maxInt, j = 0;j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (j = 0;j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            for (q = delta, k = base;; k += base) {
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    }
    punycode = {
      version: "1.4.1",
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
      },
      decode: decode2,
      encode,
      toASCII,
      toUnicode
    };
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      define("punycode", function() {
        return punycode;
      });
    } else if (freeExports && freeModule) {
      if (exports == freeExports) {
        freeModule.exports = punycode;
      } else {
        for (key in punycode) {
          punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
        }
      }
    } else {
      root.punycode = punycode;
    }
  })(exports);
});

// node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
  module.exports = Object;
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
  module.exports = Math.abs;
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
  module.exports = Math.floor;
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
  module.exports = Math.max;
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
  module.exports = Math.min;
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
  module.exports = Math.pow;
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports, module) => {
  module.exports = Math.round;
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports, module) => {
  module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports, module) => {
  var $isNaN = require_isNaN();
  module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports, module) => {
  var $Object = require_es_object_atoms();
  module.exports = $Object.getPrototypeOf || null;
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
  module.exports = Function.prototype.call;
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
  module.exports = Function.prototype.apply;
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module.exports = $reflectApply || bind.call($call, $apply);
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $TypeError = require_type();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports, module) => {
  var reflectGetProto = require_Reflect_getPrototypeOf();
  var originalGetProto = require_Object_getPrototypeOf();
  var getDunderProto = require_get();
  module.exports = reflectGetProto ? function getProto(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto(O) {
    return getDunderProto(O);
  } : null;
});

// node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var round = require_round();
  var sign = require_sign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = require_get_proto();
  var $ObjectGPO = require_Object_getPrototypeOf();
  var $ReflectGPO = require_Reflect_getPrototypeOf();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow,
    "%Math.round%": round,
    "%Math.sign%": sign,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBindBasic = require_call_bind_apply_helpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic([intrinsic]);
    }
    return intrinsic;
  };
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports, module) => {
  var hasSymbols = require_shams();
  module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
  };
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS((exports, module) => {
  var callBound = require_call_bound();
  var hasToStringTag = require_shams2()();
  var hasOwn = require_hasown();
  var gOPD = require_gopd();
  var fn;
  if (hasToStringTag) {
    $exec = callBound("RegExp.prototype.exec");
    isRegexMarker = {};
    throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn = function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    };
  } else {
    $toString = callBound("Object.prototype.toString");
    regexClass = "[object RegExp]";
    fn = function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  var $exec;
  var isRegexMarker;
  var throwRegexMarker;
  var badStringifier;
  var $toString;
  var regexClass;
  module.exports = fn;
});

// node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS((exports, module) => {
  var callBound = require_call_bound();
  var isRegex = require_is_regex();
  var $exec = callBound("RegExp.prototype.exec");
  var $TypeError = require_type();
  module.exports = function regexTester(regex) {
    if (!isRegex(regex)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s) {
      return $exec(regex, s) !== null;
    };
  };
});

// node_modules/ent/reversed.json
var require_reversed = __commonJS((exports, module) => {
  module.exports = {
    "9": "Tab;",
    "10": "NewLine;",
    "33": "excl;",
    "34": "quot;",
    "35": "num;",
    "36": "dollar;",
    "37": "percnt;",
    "38": "amp;",
    "39": "apos;",
    "40": "lpar;",
    "41": "rpar;",
    "42": "midast;",
    "43": "plus;",
    "44": "comma;",
    "46": "period;",
    "47": "sol;",
    "58": "colon;",
    "59": "semi;",
    "60": "lt;",
    "61": "equals;",
    "62": "gt;",
    "63": "quest;",
    "64": "commat;",
    "91": "lsqb;",
    "92": "bsol;",
    "93": "rsqb;",
    "94": "Hat;",
    "95": "UnderBar;",
    "96": "grave;",
    "123": "lcub;",
    "124": "VerticalLine;",
    "125": "rcub;",
    "160": "NonBreakingSpace;",
    "161": "iexcl;",
    "162": "cent;",
    "163": "pound;",
    "164": "curren;",
    "165": "yen;",
    "166": "brvbar;",
    "167": "sect;",
    "168": "uml;",
    "169": "copy;",
    "170": "ordf;",
    "171": "laquo;",
    "172": "not;",
    "173": "shy;",
    "174": "reg;",
    "175": "strns;",
    "176": "deg;",
    "177": "pm;",
    "178": "sup2;",
    "179": "sup3;",
    "180": "DiacriticalAcute;",
    "181": "micro;",
    "182": "para;",
    "183": "middot;",
    "184": "Cedilla;",
    "185": "sup1;",
    "186": "ordm;",
    "187": "raquo;",
    "188": "frac14;",
    "189": "half;",
    "190": "frac34;",
    "191": "iquest;",
    "192": "Agrave;",
    "193": "Aacute;",
    "194": "Acirc;",
    "195": "Atilde;",
    "196": "Auml;",
    "197": "Aring;",
    "198": "AElig;",
    "199": "Ccedil;",
    "200": "Egrave;",
    "201": "Eacute;",
    "202": "Ecirc;",
    "203": "Euml;",
    "204": "Igrave;",
    "205": "Iacute;",
    "206": "Icirc;",
    "207": "Iuml;",
    "208": "ETH;",
    "209": "Ntilde;",
    "210": "Ograve;",
    "211": "Oacute;",
    "212": "Ocirc;",
    "213": "Otilde;",
    "214": "Ouml;",
    "215": "times;",
    "216": "Oslash;",
    "217": "Ugrave;",
    "218": "Uacute;",
    "219": "Ucirc;",
    "220": "Uuml;",
    "221": "Yacute;",
    "222": "THORN;",
    "223": "szlig;",
    "224": "agrave;",
    "225": "aacute;",
    "226": "acirc;",
    "227": "atilde;",
    "228": "auml;",
    "229": "aring;",
    "230": "aelig;",
    "231": "ccedil;",
    "232": "egrave;",
    "233": "eacute;",
    "234": "ecirc;",
    "235": "euml;",
    "236": "igrave;",
    "237": "iacute;",
    "238": "icirc;",
    "239": "iuml;",
    "240": "eth;",
    "241": "ntilde;",
    "242": "ograve;",
    "243": "oacute;",
    "244": "ocirc;",
    "245": "otilde;",
    "246": "ouml;",
    "247": "divide;",
    "248": "oslash;",
    "249": "ugrave;",
    "250": "uacute;",
    "251": "ucirc;",
    "252": "uuml;",
    "253": "yacute;",
    "254": "thorn;",
    "255": "yuml;",
    "256": "Amacr;",
    "257": "amacr;",
    "258": "Abreve;",
    "259": "abreve;",
    "260": "Aogon;",
    "261": "aogon;",
    "262": "Cacute;",
    "263": "cacute;",
    "264": "Ccirc;",
    "265": "ccirc;",
    "266": "Cdot;",
    "267": "cdot;",
    "268": "Ccaron;",
    "269": "ccaron;",
    "270": "Dcaron;",
    "271": "dcaron;",
    "272": "Dstrok;",
    "273": "dstrok;",
    "274": "Emacr;",
    "275": "emacr;",
    "278": "Edot;",
    "279": "edot;",
    "280": "Eogon;",
    "281": "eogon;",
    "282": "Ecaron;",
    "283": "ecaron;",
    "284": "Gcirc;",
    "285": "gcirc;",
    "286": "Gbreve;",
    "287": "gbreve;",
    "288": "Gdot;",
    "289": "gdot;",
    "290": "Gcedil;",
    "292": "Hcirc;",
    "293": "hcirc;",
    "294": "Hstrok;",
    "295": "hstrok;",
    "296": "Itilde;",
    "297": "itilde;",
    "298": "Imacr;",
    "299": "imacr;",
    "302": "Iogon;",
    "303": "iogon;",
    "304": "Idot;",
    "305": "inodot;",
    "306": "IJlig;",
    "307": "ijlig;",
    "308": "Jcirc;",
    "309": "jcirc;",
    "310": "Kcedil;",
    "311": "kcedil;",
    "312": "kgreen;",
    "313": "Lacute;",
    "314": "lacute;",
    "315": "Lcedil;",
    "316": "lcedil;",
    "317": "Lcaron;",
    "318": "lcaron;",
    "319": "Lmidot;",
    "320": "lmidot;",
    "321": "Lstrok;",
    "322": "lstrok;",
    "323": "Nacute;",
    "324": "nacute;",
    "325": "Ncedil;",
    "326": "ncedil;",
    "327": "Ncaron;",
    "328": "ncaron;",
    "329": "napos;",
    "330": "ENG;",
    "331": "eng;",
    "332": "Omacr;",
    "333": "omacr;",
    "336": "Odblac;",
    "337": "odblac;",
    "338": "OElig;",
    "339": "oelig;",
    "340": "Racute;",
    "341": "racute;",
    "342": "Rcedil;",
    "343": "rcedil;",
    "344": "Rcaron;",
    "345": "rcaron;",
    "346": "Sacute;",
    "347": "sacute;",
    "348": "Scirc;",
    "349": "scirc;",
    "350": "Scedil;",
    "351": "scedil;",
    "352": "Scaron;",
    "353": "scaron;",
    "354": "Tcedil;",
    "355": "tcedil;",
    "356": "Tcaron;",
    "357": "tcaron;",
    "358": "Tstrok;",
    "359": "tstrok;",
    "360": "Utilde;",
    "361": "utilde;",
    "362": "Umacr;",
    "363": "umacr;",
    "364": "Ubreve;",
    "365": "ubreve;",
    "366": "Uring;",
    "367": "uring;",
    "368": "Udblac;",
    "369": "udblac;",
    "370": "Uogon;",
    "371": "uogon;",
    "372": "Wcirc;",
    "373": "wcirc;",
    "374": "Ycirc;",
    "375": "ycirc;",
    "376": "Yuml;",
    "377": "Zacute;",
    "378": "zacute;",
    "379": "Zdot;",
    "380": "zdot;",
    "381": "Zcaron;",
    "382": "zcaron;",
    "402": "fnof;",
    "437": "imped;",
    "501": "gacute;",
    "567": "jmath;",
    "710": "circ;",
    "711": "Hacek;",
    "728": "breve;",
    "729": "dot;",
    "730": "ring;",
    "731": "ogon;",
    "732": "tilde;",
    "733": "DiacriticalDoubleAcute;",
    "785": "DownBreve;",
    "913": "Alpha;",
    "914": "Beta;",
    "915": "Gamma;",
    "916": "Delta;",
    "917": "Epsilon;",
    "918": "Zeta;",
    "919": "Eta;",
    "920": "Theta;",
    "921": "Iota;",
    "922": "Kappa;",
    "923": "Lambda;",
    "924": "Mu;",
    "925": "Nu;",
    "926": "Xi;",
    "927": "Omicron;",
    "928": "Pi;",
    "929": "Rho;",
    "931": "Sigma;",
    "932": "Tau;",
    "933": "Upsilon;",
    "934": "Phi;",
    "935": "Chi;",
    "936": "Psi;",
    "937": "Omega;",
    "945": "alpha;",
    "946": "beta;",
    "947": "gamma;",
    "948": "delta;",
    "949": "epsilon;",
    "950": "zeta;",
    "951": "eta;",
    "952": "theta;",
    "953": "iota;",
    "954": "kappa;",
    "955": "lambda;",
    "956": "mu;",
    "957": "nu;",
    "958": "xi;",
    "959": "omicron;",
    "960": "pi;",
    "961": "rho;",
    "962": "varsigma;",
    "963": "sigma;",
    "964": "tau;",
    "965": "upsilon;",
    "966": "phi;",
    "967": "chi;",
    "968": "psi;",
    "969": "omega;",
    "977": "vartheta;",
    "978": "upsih;",
    "981": "varphi;",
    "982": "varpi;",
    "988": "Gammad;",
    "989": "gammad;",
    "1008": "varkappa;",
    "1009": "varrho;",
    "1013": "varepsilon;",
    "1014": "bepsi;",
    "1025": "IOcy;",
    "1026": "DJcy;",
    "1027": "GJcy;",
    "1028": "Jukcy;",
    "1029": "DScy;",
    "1030": "Iukcy;",
    "1031": "YIcy;",
    "1032": "Jsercy;",
    "1033": "LJcy;",
    "1034": "NJcy;",
    "1035": "TSHcy;",
    "1036": "KJcy;",
    "1038": "Ubrcy;",
    "1039": "DZcy;",
    "1040": "Acy;",
    "1041": "Bcy;",
    "1042": "Vcy;",
    "1043": "Gcy;",
    "1044": "Dcy;",
    "1045": "IEcy;",
    "1046": "ZHcy;",
    "1047": "Zcy;",
    "1048": "Icy;",
    "1049": "Jcy;",
    "1050": "Kcy;",
    "1051": "Lcy;",
    "1052": "Mcy;",
    "1053": "Ncy;",
    "1054": "Ocy;",
    "1055": "Pcy;",
    "1056": "Rcy;",
    "1057": "Scy;",
    "1058": "Tcy;",
    "1059": "Ucy;",
    "1060": "Fcy;",
    "1061": "KHcy;",
    "1062": "TScy;",
    "1063": "CHcy;",
    "1064": "SHcy;",
    "1065": "SHCHcy;",
    "1066": "HARDcy;",
    "1067": "Ycy;",
    "1068": "SOFTcy;",
    "1069": "Ecy;",
    "1070": "YUcy;",
    "1071": "YAcy;",
    "1072": "acy;",
    "1073": "bcy;",
    "1074": "vcy;",
    "1075": "gcy;",
    "1076": "dcy;",
    "1077": "iecy;",
    "1078": "zhcy;",
    "1079": "zcy;",
    "1080": "icy;",
    "1081": "jcy;",
    "1082": "kcy;",
    "1083": "lcy;",
    "1084": "mcy;",
    "1085": "ncy;",
    "1086": "ocy;",
    "1087": "pcy;",
    "1088": "rcy;",
    "1089": "scy;",
    "1090": "tcy;",
    "1091": "ucy;",
    "1092": "fcy;",
    "1093": "khcy;",
    "1094": "tscy;",
    "1095": "chcy;",
    "1096": "shcy;",
    "1097": "shchcy;",
    "1098": "hardcy;",
    "1099": "ycy;",
    "1100": "softcy;",
    "1101": "ecy;",
    "1102": "yucy;",
    "1103": "yacy;",
    "1105": "iocy;",
    "1106": "djcy;",
    "1107": "gjcy;",
    "1108": "jukcy;",
    "1109": "dscy;",
    "1110": "iukcy;",
    "1111": "yicy;",
    "1112": "jsercy;",
    "1113": "ljcy;",
    "1114": "njcy;",
    "1115": "tshcy;",
    "1116": "kjcy;",
    "1118": "ubrcy;",
    "1119": "dzcy;",
    "8194": "ensp;",
    "8195": "emsp;",
    "8196": "emsp13;",
    "8197": "emsp14;",
    "8199": "numsp;",
    "8200": "puncsp;",
    "8201": "ThinSpace;",
    "8202": "VeryThinSpace;",
    "8203": "ZeroWidthSpace;",
    "8204": "zwnj;",
    "8205": "zwj;",
    "8206": "lrm;",
    "8207": "rlm;",
    "8208": "hyphen;",
    "8211": "ndash;",
    "8212": "mdash;",
    "8213": "horbar;",
    "8214": "Vert;",
    "8216": "OpenCurlyQuote;",
    "8217": "rsquor;",
    "8218": "sbquo;",
    "8220": "OpenCurlyDoubleQuote;",
    "8221": "rdquor;",
    "8222": "ldquor;",
    "8224": "dagger;",
    "8225": "ddagger;",
    "8226": "bullet;",
    "8229": "nldr;",
    "8230": "mldr;",
    "8240": "permil;",
    "8241": "pertenk;",
    "8242": "prime;",
    "8243": "Prime;",
    "8244": "tprime;",
    "8245": "bprime;",
    "8249": "lsaquo;",
    "8250": "rsaquo;",
    "8254": "OverBar;",
    "8257": "caret;",
    "8259": "hybull;",
    "8260": "frasl;",
    "8271": "bsemi;",
    "8279": "qprime;",
    "8287": "MediumSpace;",
    "8288": "NoBreak;",
    "8289": "ApplyFunction;",
    "8290": "it;",
    "8291": "InvisibleComma;",
    "8364": "euro;",
    "8411": "TripleDot;",
    "8412": "DotDot;",
    "8450": "Copf;",
    "8453": "incare;",
    "8458": "gscr;",
    "8459": "Hscr;",
    "8460": "Poincareplane;",
    "8461": "quaternions;",
    "8462": "planckh;",
    "8463": "plankv;",
    "8464": "Iscr;",
    "8465": "imagpart;",
    "8466": "Lscr;",
    "8467": "ell;",
    "8469": "Nopf;",
    "8470": "numero;",
    "8471": "copysr;",
    "8472": "wp;",
    "8473": "primes;",
    "8474": "rationals;",
    "8475": "Rscr;",
    "8476": "Rfr;",
    "8477": "Ropf;",
    "8478": "rx;",
    "8482": "trade;",
    "8484": "Zopf;",
    "8487": "mho;",
    "8488": "Zfr;",
    "8489": "iiota;",
    "8492": "Bscr;",
    "8493": "Cfr;",
    "8495": "escr;",
    "8496": "expectation;",
    "8497": "Fscr;",
    "8499": "phmmat;",
    "8500": "oscr;",
    "8501": "aleph;",
    "8502": "beth;",
    "8503": "gimel;",
    "8504": "daleth;",
    "8517": "DD;",
    "8518": "DifferentialD;",
    "8519": "exponentiale;",
    "8520": "ImaginaryI;",
    "8531": "frac13;",
    "8532": "frac23;",
    "8533": "frac15;",
    "8534": "frac25;",
    "8535": "frac35;",
    "8536": "frac45;",
    "8537": "frac16;",
    "8538": "frac56;",
    "8539": "frac18;",
    "8540": "frac38;",
    "8541": "frac58;",
    "8542": "frac78;",
    "8592": "slarr;",
    "8593": "uparrow;",
    "8594": "srarr;",
    "8595": "ShortDownArrow;",
    "8596": "leftrightarrow;",
    "8597": "varr;",
    "8598": "UpperLeftArrow;",
    "8599": "UpperRightArrow;",
    "8600": "searrow;",
    "8601": "swarrow;",
    "8602": "nleftarrow;",
    "8603": "nrightarrow;",
    "8605": "rightsquigarrow;",
    "8606": "twoheadleftarrow;",
    "8607": "Uarr;",
    "8608": "twoheadrightarrow;",
    "8609": "Darr;",
    "8610": "leftarrowtail;",
    "8611": "rightarrowtail;",
    "8612": "mapstoleft;",
    "8613": "UpTeeArrow;",
    "8614": "RightTeeArrow;",
    "8615": "mapstodown;",
    "8617": "larrhk;",
    "8618": "rarrhk;",
    "8619": "looparrowleft;",
    "8620": "rarrlp;",
    "8621": "leftrightsquigarrow;",
    "8622": "nleftrightarrow;",
    "8624": "lsh;",
    "8625": "rsh;",
    "8626": "ldsh;",
    "8627": "rdsh;",
    "8629": "crarr;",
    "8630": "curvearrowleft;",
    "8631": "curvearrowright;",
    "8634": "olarr;",
    "8635": "orarr;",
    "8636": "lharu;",
    "8637": "lhard;",
    "8638": "upharpoonright;",
    "8639": "upharpoonleft;",
    "8640": "RightVector;",
    "8641": "rightharpoondown;",
    "8642": "RightDownVector;",
    "8643": "LeftDownVector;",
    "8644": "rlarr;",
    "8645": "UpArrowDownArrow;",
    "8646": "lrarr;",
    "8647": "llarr;",
    "8648": "uuarr;",
    "8649": "rrarr;",
    "8650": "downdownarrows;",
    "8651": "ReverseEquilibrium;",
    "8652": "rlhar;",
    "8653": "nLeftarrow;",
    "8654": "nLeftrightarrow;",
    "8655": "nRightarrow;",
    "8656": "Leftarrow;",
    "8657": "Uparrow;",
    "8658": "Rightarrow;",
    "8659": "Downarrow;",
    "8660": "Leftrightarrow;",
    "8661": "vArr;",
    "8662": "nwArr;",
    "8663": "neArr;",
    "8664": "seArr;",
    "8665": "swArr;",
    "8666": "Lleftarrow;",
    "8667": "Rrightarrow;",
    "8669": "zigrarr;",
    "8676": "LeftArrowBar;",
    "8677": "RightArrowBar;",
    "8693": "duarr;",
    "8701": "loarr;",
    "8702": "roarr;",
    "8703": "hoarr;",
    "8704": "forall;",
    "8705": "complement;",
    "8706": "PartialD;",
    "8707": "Exists;",
    "8708": "NotExists;",
    "8709": "varnothing;",
    "8711": "nabla;",
    "8712": "isinv;",
    "8713": "notinva;",
    "8715": "SuchThat;",
    "8716": "NotReverseElement;",
    "8719": "Product;",
    "8720": "Coproduct;",
    "8721": "sum;",
    "8722": "minus;",
    "8723": "mp;",
    "8724": "plusdo;",
    "8726": "ssetmn;",
    "8727": "lowast;",
    "8728": "SmallCircle;",
    "8730": "Sqrt;",
    "8733": "vprop;",
    "8734": "infin;",
    "8735": "angrt;",
    "8736": "angle;",
    "8737": "measuredangle;",
    "8738": "angsph;",
    "8739": "VerticalBar;",
    "8740": "nsmid;",
    "8741": "spar;",
    "8742": "nspar;",
    "8743": "wedge;",
    "8744": "vee;",
    "8745": "cap;",
    "8746": "cup;",
    "8747": "Integral;",
    "8748": "Int;",
    "8749": "tint;",
    "8750": "oint;",
    "8751": "DoubleContourIntegral;",
    "8752": "Cconint;",
    "8753": "cwint;",
    "8754": "cwconint;",
    "8755": "CounterClockwiseContourIntegral;",
    "8756": "therefore;",
    "8757": "because;",
    "8758": "ratio;",
    "8759": "Proportion;",
    "8760": "minusd;",
    "8762": "mDDot;",
    "8763": "homtht;",
    "8764": "Tilde;",
    "8765": "bsim;",
    "8766": "mstpos;",
    "8767": "acd;",
    "8768": "wreath;",
    "8769": "nsim;",
    "8770": "esim;",
    "8771": "TildeEqual;",
    "8772": "nsimeq;",
    "8773": "TildeFullEqual;",
    "8774": "simne;",
    "8775": "NotTildeFullEqual;",
    "8776": "TildeTilde;",
    "8777": "NotTildeTilde;",
    "8778": "approxeq;",
    "8779": "apid;",
    "8780": "bcong;",
    "8781": "CupCap;",
    "8782": "HumpDownHump;",
    "8783": "HumpEqual;",
    "8784": "esdot;",
    "8785": "eDot;",
    "8786": "fallingdotseq;",
    "8787": "risingdotseq;",
    "8788": "coloneq;",
    "8789": "eqcolon;",
    "8790": "eqcirc;",
    "8791": "cire;",
    "8793": "wedgeq;",
    "8794": "veeeq;",
    "8796": "trie;",
    "8799": "questeq;",
    "8800": "NotEqual;",
    "8801": "equiv;",
    "8802": "NotCongruent;",
    "8804": "leq;",
    "8805": "GreaterEqual;",
    "8806": "LessFullEqual;",
    "8807": "GreaterFullEqual;",
    "8808": "lneqq;",
    "8809": "gneqq;",
    "8810": "NestedLessLess;",
    "8811": "NestedGreaterGreater;",
    "8812": "twixt;",
    "8813": "NotCupCap;",
    "8814": "NotLess;",
    "8815": "NotGreater;",
    "8816": "NotLessEqual;",
    "8817": "NotGreaterEqual;",
    "8818": "lsim;",
    "8819": "gtrsim;",
    "8820": "NotLessTilde;",
    "8821": "NotGreaterTilde;",
    "8822": "lg;",
    "8823": "gtrless;",
    "8824": "ntlg;",
    "8825": "ntgl;",
    "8826": "Precedes;",
    "8827": "Succeeds;",
    "8828": "PrecedesSlantEqual;",
    "8829": "SucceedsSlantEqual;",
    "8830": "prsim;",
    "8831": "succsim;",
    "8832": "nprec;",
    "8833": "nsucc;",
    "8834": "subset;",
    "8835": "supset;",
    "8836": "nsub;",
    "8837": "nsup;",
    "8838": "SubsetEqual;",
    "8839": "supseteq;",
    "8840": "nsubseteq;",
    "8841": "nsupseteq;",
    "8842": "subsetneq;",
    "8843": "supsetneq;",
    "8845": "cupdot;",
    "8846": "uplus;",
    "8847": "SquareSubset;",
    "8848": "SquareSuperset;",
    "8849": "SquareSubsetEqual;",
    "8850": "SquareSupersetEqual;",
    "8851": "SquareIntersection;",
    "8852": "SquareUnion;",
    "8853": "oplus;",
    "8854": "ominus;",
    "8855": "otimes;",
    "8856": "osol;",
    "8857": "odot;",
    "8858": "ocir;",
    "8859": "oast;",
    "8861": "odash;",
    "8862": "plusb;",
    "8863": "minusb;",
    "8864": "timesb;",
    "8865": "sdotb;",
    "8866": "vdash;",
    "8867": "LeftTee;",
    "8868": "top;",
    "8869": "UpTee;",
    "8871": "models;",
    "8872": "vDash;",
    "8873": "Vdash;",
    "8874": "Vvdash;",
    "8875": "VDash;",
    "8876": "nvdash;",
    "8877": "nvDash;",
    "8878": "nVdash;",
    "8879": "nVDash;",
    "8880": "prurel;",
    "8882": "vltri;",
    "8883": "vrtri;",
    "8884": "trianglelefteq;",
    "8885": "trianglerighteq;",
    "8886": "origof;",
    "8887": "imof;",
    "8888": "mumap;",
    "8889": "hercon;",
    "8890": "intercal;",
    "8891": "veebar;",
    "8893": "barvee;",
    "8894": "angrtvb;",
    "8895": "lrtri;",
    "8896": "xwedge;",
    "8897": "xvee;",
    "8898": "xcap;",
    "8899": "xcup;",
    "8900": "diamond;",
    "8901": "sdot;",
    "8902": "Star;",
    "8903": "divonx;",
    "8904": "bowtie;",
    "8905": "ltimes;",
    "8906": "rtimes;",
    "8907": "lthree;",
    "8908": "rthree;",
    "8909": "bsime;",
    "8910": "cuvee;",
    "8911": "cuwed;",
    "8912": "Subset;",
    "8913": "Supset;",
    "8914": "Cap;",
    "8915": "Cup;",
    "8916": "pitchfork;",
    "8917": "epar;",
    "8918": "ltdot;",
    "8919": "gtrdot;",
    "8920": "Ll;",
    "8921": "ggg;",
    "8922": "LessEqualGreater;",
    "8923": "gtreqless;",
    "8926": "curlyeqprec;",
    "8927": "curlyeqsucc;",
    "8928": "nprcue;",
    "8929": "nsccue;",
    "8930": "nsqsube;",
    "8931": "nsqsupe;",
    "8934": "lnsim;",
    "8935": "gnsim;",
    "8936": "prnsim;",
    "8937": "succnsim;",
    "8938": "ntriangleleft;",
    "8939": "ntriangleright;",
    "8940": "ntrianglelefteq;",
    "8941": "ntrianglerighteq;",
    "8942": "vellip;",
    "8943": "ctdot;",
    "8944": "utdot;",
    "8945": "dtdot;",
    "8946": "disin;",
    "8947": "isinsv;",
    "8948": "isins;",
    "8949": "isindot;",
    "8950": "notinvc;",
    "8951": "notinvb;",
    "8953": "isinE;",
    "8954": "nisd;",
    "8955": "xnis;",
    "8956": "nis;",
    "8957": "notnivc;",
    "8958": "notnivb;",
    "8965": "barwedge;",
    "8966": "doublebarwedge;",
    "8968": "LeftCeiling;",
    "8969": "RightCeiling;",
    "8970": "lfloor;",
    "8971": "RightFloor;",
    "8972": "drcrop;",
    "8973": "dlcrop;",
    "8974": "urcrop;",
    "8975": "ulcrop;",
    "8976": "bnot;",
    "8978": "profline;",
    "8979": "profsurf;",
    "8981": "telrec;",
    "8982": "target;",
    "8988": "ulcorner;",
    "8989": "urcorner;",
    "8990": "llcorner;",
    "8991": "lrcorner;",
    "8994": "sfrown;",
    "8995": "ssmile;",
    "9005": "cylcty;",
    "9006": "profalar;",
    "9014": "topbot;",
    "9021": "ovbar;",
    "9023": "solbar;",
    "9084": "angzarr;",
    "9136": "lmoustache;",
    "9137": "rmoustache;",
    "9140": "tbrk;",
    "9141": "UnderBracket;",
    "9142": "bbrktbrk;",
    "9180": "OverParenthesis;",
    "9181": "UnderParenthesis;",
    "9182": "OverBrace;",
    "9183": "UnderBrace;",
    "9186": "trpezium;",
    "9191": "elinters;",
    "9251": "blank;",
    "9416": "oS;",
    "9472": "HorizontalLine;",
    "9474": "boxv;",
    "9484": "boxdr;",
    "9488": "boxdl;",
    "9492": "boxur;",
    "9496": "boxul;",
    "9500": "boxvr;",
    "9508": "boxvl;",
    "9516": "boxhd;",
    "9524": "boxhu;",
    "9532": "boxvh;",
    "9552": "boxH;",
    "9553": "boxV;",
    "9554": "boxdR;",
    "9555": "boxDr;",
    "9556": "boxDR;",
    "9557": "boxdL;",
    "9558": "boxDl;",
    "9559": "boxDL;",
    "9560": "boxuR;",
    "9561": "boxUr;",
    "9562": "boxUR;",
    "9563": "boxuL;",
    "9564": "boxUl;",
    "9565": "boxUL;",
    "9566": "boxvR;",
    "9567": "boxVr;",
    "9568": "boxVR;",
    "9569": "boxvL;",
    "9570": "boxVl;",
    "9571": "boxVL;",
    "9572": "boxHd;",
    "9573": "boxhD;",
    "9574": "boxHD;",
    "9575": "boxHu;",
    "9576": "boxhU;",
    "9577": "boxHU;",
    "9578": "boxvH;",
    "9579": "boxVh;",
    "9580": "boxVH;",
    "9600": "uhblk;",
    "9604": "lhblk;",
    "9608": "block;",
    "9617": "blk14;",
    "9618": "blk12;",
    "9619": "blk34;",
    "9633": "square;",
    "9642": "squf;",
    "9643": "EmptyVerySmallSquare;",
    "9645": "rect;",
    "9646": "marker;",
    "9649": "fltns;",
    "9651": "xutri;",
    "9652": "utrif;",
    "9653": "utri;",
    "9656": "rtrif;",
    "9657": "triangleright;",
    "9661": "xdtri;",
    "9662": "dtrif;",
    "9663": "triangledown;",
    "9666": "ltrif;",
    "9667": "triangleleft;",
    "9674": "lozenge;",
    "9675": "cir;",
    "9708": "tridot;",
    "9711": "xcirc;",
    "9720": "ultri;",
    "9721": "urtri;",
    "9722": "lltri;",
    "9723": "EmptySmallSquare;",
    "9724": "FilledSmallSquare;",
    "9733": "starf;",
    "9734": "star;",
    "9742": "phone;",
    "9792": "female;",
    "9794": "male;",
    "9824": "spadesuit;",
    "9827": "clubsuit;",
    "9829": "heartsuit;",
    "9830": "diams;",
    "9834": "sung;",
    "9837": "flat;",
    "9838": "natural;",
    "9839": "sharp;",
    "10003": "checkmark;",
    "10007": "cross;",
    "10016": "maltese;",
    "10038": "sext;",
    "10072": "VerticalSeparator;",
    "10098": "lbbrk;",
    "10099": "rbbrk;",
    "10184": "bsolhsub;",
    "10185": "suphsol;",
    "10214": "lobrk;",
    "10215": "robrk;",
    "10216": "LeftAngleBracket;",
    "10217": "RightAngleBracket;",
    "10218": "Lang;",
    "10219": "Rang;",
    "10220": "loang;",
    "10221": "roang;",
    "10229": "xlarr;",
    "10230": "xrarr;",
    "10231": "xharr;",
    "10232": "xlArr;",
    "10233": "xrArr;",
    "10234": "xhArr;",
    "10236": "xmap;",
    "10239": "dzigrarr;",
    "10498": "nvlArr;",
    "10499": "nvrArr;",
    "10500": "nvHarr;",
    "10501": "Map;",
    "10508": "lbarr;",
    "10509": "rbarr;",
    "10510": "lBarr;",
    "10511": "rBarr;",
    "10512": "RBarr;",
    "10513": "DDotrahd;",
    "10514": "UpArrowBar;",
    "10515": "DownArrowBar;",
    "10518": "Rarrtl;",
    "10521": "latail;",
    "10522": "ratail;",
    "10523": "lAtail;",
    "10524": "rAtail;",
    "10525": "larrfs;",
    "10526": "rarrfs;",
    "10527": "larrbfs;",
    "10528": "rarrbfs;",
    "10531": "nwarhk;",
    "10532": "nearhk;",
    "10533": "searhk;",
    "10534": "swarhk;",
    "10535": "nwnear;",
    "10536": "toea;",
    "10537": "tosa;",
    "10538": "swnwar;",
    "10547": "rarrc;",
    "10549": "cudarrr;",
    "10550": "ldca;",
    "10551": "rdca;",
    "10552": "cudarrl;",
    "10553": "larrpl;",
    "10556": "curarrm;",
    "10557": "cularrp;",
    "10565": "rarrpl;",
    "10568": "harrcir;",
    "10569": "Uarrocir;",
    "10570": "lurdshar;",
    "10571": "ldrushar;",
    "10574": "LeftRightVector;",
    "10575": "RightUpDownVector;",
    "10576": "DownLeftRightVector;",
    "10577": "LeftUpDownVector;",
    "10578": "LeftVectorBar;",
    "10579": "RightVectorBar;",
    "10580": "RightUpVectorBar;",
    "10581": "RightDownVectorBar;",
    "10582": "DownLeftVectorBar;",
    "10583": "DownRightVectorBar;",
    "10584": "LeftUpVectorBar;",
    "10585": "LeftDownVectorBar;",
    "10586": "LeftTeeVector;",
    "10587": "RightTeeVector;",
    "10588": "RightUpTeeVector;",
    "10589": "RightDownTeeVector;",
    "10590": "DownLeftTeeVector;",
    "10591": "DownRightTeeVector;",
    "10592": "LeftUpTeeVector;",
    "10593": "LeftDownTeeVector;",
    "10594": "lHar;",
    "10595": "uHar;",
    "10596": "rHar;",
    "10597": "dHar;",
    "10598": "luruhar;",
    "10599": "ldrdhar;",
    "10600": "ruluhar;",
    "10601": "rdldhar;",
    "10602": "lharul;",
    "10603": "llhard;",
    "10604": "rharul;",
    "10605": "lrhard;",
    "10606": "UpEquilibrium;",
    "10607": "ReverseUpEquilibrium;",
    "10608": "RoundImplies;",
    "10609": "erarr;",
    "10610": "simrarr;",
    "10611": "larrsim;",
    "10612": "rarrsim;",
    "10613": "rarrap;",
    "10614": "ltlarr;",
    "10616": "gtrarr;",
    "10617": "subrarr;",
    "10619": "suplarr;",
    "10620": "lfisht;",
    "10621": "rfisht;",
    "10622": "ufisht;",
    "10623": "dfisht;",
    "10629": "lopar;",
    "10630": "ropar;",
    "10635": "lbrke;",
    "10636": "rbrke;",
    "10637": "lbrkslu;",
    "10638": "rbrksld;",
    "10639": "lbrksld;",
    "10640": "rbrkslu;",
    "10641": "langd;",
    "10642": "rangd;",
    "10643": "lparlt;",
    "10644": "rpargt;",
    "10645": "gtlPar;",
    "10646": "ltrPar;",
    "10650": "vzigzag;",
    "10652": "vangrt;",
    "10653": "angrtvbd;",
    "10660": "ange;",
    "10661": "range;",
    "10662": "dwangle;",
    "10663": "uwangle;",
    "10664": "angmsdaa;",
    "10665": "angmsdab;",
    "10666": "angmsdac;",
    "10667": "angmsdad;",
    "10668": "angmsdae;",
    "10669": "angmsdaf;",
    "10670": "angmsdag;",
    "10671": "angmsdah;",
    "10672": "bemptyv;",
    "10673": "demptyv;",
    "10674": "cemptyv;",
    "10675": "raemptyv;",
    "10676": "laemptyv;",
    "10677": "ohbar;",
    "10678": "omid;",
    "10679": "opar;",
    "10681": "operp;",
    "10683": "olcross;",
    "10684": "odsold;",
    "10686": "olcir;",
    "10687": "ofcir;",
    "10688": "olt;",
    "10689": "ogt;",
    "10690": "cirscir;",
    "10691": "cirE;",
    "10692": "solb;",
    "10693": "bsolb;",
    "10697": "boxbox;",
    "10701": "trisb;",
    "10702": "rtriltri;",
    "10703": "LeftTriangleBar;",
    "10704": "RightTriangleBar;",
    "10716": "iinfin;",
    "10717": "infintie;",
    "10718": "nvinfin;",
    "10723": "eparsl;",
    "10724": "smeparsl;",
    "10725": "eqvparsl;",
    "10731": "lozf;",
    "10740": "RuleDelayed;",
    "10742": "dsol;",
    "10752": "xodot;",
    "10753": "xoplus;",
    "10754": "xotime;",
    "10756": "xuplus;",
    "10758": "xsqcup;",
    "10764": "qint;",
    "10765": "fpartint;",
    "10768": "cirfnint;",
    "10769": "awint;",
    "10770": "rppolint;",
    "10771": "scpolint;",
    "10772": "npolint;",
    "10773": "pointint;",
    "10774": "quatint;",
    "10775": "intlarhk;",
    "10786": "pluscir;",
    "10787": "plusacir;",
    "10788": "simplus;",
    "10789": "plusdu;",
    "10790": "plussim;",
    "10791": "plustwo;",
    "10793": "mcomma;",
    "10794": "minusdu;",
    "10797": "loplus;",
    "10798": "roplus;",
    "10799": "Cross;",
    "10800": "timesd;",
    "10801": "timesbar;",
    "10803": "smashp;",
    "10804": "lotimes;",
    "10805": "rotimes;",
    "10806": "otimesas;",
    "10807": "Otimes;",
    "10808": "odiv;",
    "10809": "triplus;",
    "10810": "triminus;",
    "10811": "tritime;",
    "10812": "iprod;",
    "10815": "amalg;",
    "10816": "capdot;",
    "10818": "ncup;",
    "10819": "ncap;",
    "10820": "capand;",
    "10821": "cupor;",
    "10822": "cupcap;",
    "10823": "capcup;",
    "10824": "cupbrcap;",
    "10825": "capbrcup;",
    "10826": "cupcup;",
    "10827": "capcap;",
    "10828": "ccups;",
    "10829": "ccaps;",
    "10832": "ccupssm;",
    "10835": "And;",
    "10836": "Or;",
    "10837": "andand;",
    "10838": "oror;",
    "10839": "orslope;",
    "10840": "andslope;",
    "10842": "andv;",
    "10843": "orv;",
    "10844": "andd;",
    "10845": "ord;",
    "10847": "wedbar;",
    "10854": "sdote;",
    "10858": "simdot;",
    "10861": "congdot;",
    "10862": "easter;",
    "10863": "apacir;",
    "10864": "apE;",
    "10865": "eplus;",
    "10866": "pluse;",
    "10867": "Esim;",
    "10868": "Colone;",
    "10869": "Equal;",
    "10871": "eDDot;",
    "10872": "equivDD;",
    "10873": "ltcir;",
    "10874": "gtcir;",
    "10875": "ltquest;",
    "10876": "gtquest;",
    "10877": "LessSlantEqual;",
    "10878": "GreaterSlantEqual;",
    "10879": "lesdot;",
    "10880": "gesdot;",
    "10881": "lesdoto;",
    "10882": "gesdoto;",
    "10883": "lesdotor;",
    "10884": "gesdotol;",
    "10885": "lessapprox;",
    "10886": "gtrapprox;",
    "10887": "lneq;",
    "10888": "gneq;",
    "10889": "lnapprox;",
    "10890": "gnapprox;",
    "10891": "lesseqqgtr;",
    "10892": "gtreqqless;",
    "10893": "lsime;",
    "10894": "gsime;",
    "10895": "lsimg;",
    "10896": "gsiml;",
    "10897": "lgE;",
    "10898": "glE;",
    "10899": "lesges;",
    "10900": "gesles;",
    "10901": "eqslantless;",
    "10902": "eqslantgtr;",
    "10903": "elsdot;",
    "10904": "egsdot;",
    "10905": "el;",
    "10906": "eg;",
    "10909": "siml;",
    "10910": "simg;",
    "10911": "simlE;",
    "10912": "simgE;",
    "10913": "LessLess;",
    "10914": "GreaterGreater;",
    "10916": "glj;",
    "10917": "gla;",
    "10918": "ltcc;",
    "10919": "gtcc;",
    "10920": "lescc;",
    "10921": "gescc;",
    "10922": "smt;",
    "10923": "lat;",
    "10924": "smte;",
    "10925": "late;",
    "10926": "bumpE;",
    "10927": "preceq;",
    "10928": "succeq;",
    "10931": "prE;",
    "10932": "scE;",
    "10933": "prnE;",
    "10934": "succneqq;",
    "10935": "precapprox;",
    "10936": "succapprox;",
    "10937": "prnap;",
    "10938": "succnapprox;",
    "10939": "Pr;",
    "10940": "Sc;",
    "10941": "subdot;",
    "10942": "supdot;",
    "10943": "subplus;",
    "10944": "supplus;",
    "10945": "submult;",
    "10946": "supmult;",
    "10947": "subedot;",
    "10948": "supedot;",
    "10949": "subseteqq;",
    "10950": "supseteqq;",
    "10951": "subsim;",
    "10952": "supsim;",
    "10955": "subsetneqq;",
    "10956": "supsetneqq;",
    "10959": "csub;",
    "10960": "csup;",
    "10961": "csube;",
    "10962": "csupe;",
    "10963": "subsup;",
    "10964": "supsub;",
    "10965": "subsub;",
    "10966": "supsup;",
    "10967": "suphsub;",
    "10968": "supdsub;",
    "10969": "forkv;",
    "10970": "topfork;",
    "10971": "mlcp;",
    "10980": "DoubleLeftTee;",
    "10982": "Vdashl;",
    "10983": "Barv;",
    "10984": "vBar;",
    "10985": "vBarv;",
    "10987": "Vbar;",
    "10988": "Not;",
    "10989": "bNot;",
    "10990": "rnmid;",
    "10991": "cirmid;",
    "10992": "midcir;",
    "10993": "topcir;",
    "10994": "nhpar;",
    "10995": "parsim;",
    "11005": "parsl;",
    "64256": "fflig;",
    "64257": "filig;",
    "64258": "fllig;",
    "64259": "ffilig;",
    "64260": "ffllig;"
  };
});

// node_modules/ent/encode.js
var require_encode = __commonJS((exports, module) => {
  var punycode = require_punycode();
  var $decode = punycode.ucs2.decode;
  var $encode = punycode.ucs2.encode;
  var $TypeError = require_type();
  var regexTest = require_safe_regex_test();
  var revEntities = require_reversed();
  var endsInSemicolon = regexTest(/;$/);
  var defaultSpecial = {
    '"': true,
    "'": true,
    "<": true,
    ">": true,
    "&": true
  };
  module.exports = function encode(str, opts) {
    if (typeof str !== "string") {
      throw new $TypeError("Expected a String");
    }
    var numeric = !opts || !opts.named;
    if (opts && typeof opts.numeric !== "undefined") {
      numeric = opts.numeric;
    }
    var special = opts && opts.special || defaultSpecial;
    var codePoints = $decode(str);
    var chars = [];
    for (var i = 0;i < codePoints.length; i++) {
      var cc = codePoints[i];
      var c = $encode([cc]);
      var e = revEntities[cc];
      if (e && (cc >= 127 || special[c]) && !numeric) {
        var hasSemi = endsInSemicolon(e);
        chars[chars.length] = "&" + (hasSemi ? e : e + ";");
      } else if (cc < 32 || cc >= 127 || special[c]) {
        chars[chars.length] = "&#" + cc + ";";
      } else {
        chars[chars.length] = c;
      }
    }
    return chars.join("");
  };
});

// node_modules/ent/entities.json
var require_entities = __commonJS((exports, module) => {
  module.exports = {
    "Aacute;": "Á",
    Aacute: "Á",
    "aacute;": "á",
    aacute: "á",
    "Abreve;": "Ă",
    "abreve;": "ă",
    "ac;": "∾",
    "acd;": "∿",
    "acE;": "∾̳",
    "Acirc;": "Â",
    Acirc: "Â",
    "acirc;": "â",
    acirc: "â",
    "acute;": "´",
    acute: "´",
    "Acy;": "А",
    "acy;": "а",
    "AElig;": "Æ",
    AElig: "Æ",
    "aelig;": "æ",
    aelig: "æ",
    "af;": "⁡",
    "Afr;": "𝔄",
    "afr;": "𝔞",
    "Agrave;": "À",
    Agrave: "À",
    "agrave;": "à",
    agrave: "à",
    "alefsym;": "ℵ",
    "aleph;": "ℵ",
    "Alpha;": "Α",
    "alpha;": "α",
    "Amacr;": "Ā",
    "amacr;": "ā",
    "amalg;": "⨿",
    "AMP;": "&",
    AMP: "&",
    "amp;": "&",
    amp: "&",
    "And;": "⩓",
    "and;": "∧",
    "andand;": "⩕",
    "andd;": "⩜",
    "andslope;": "⩘",
    "andv;": "⩚",
    "ang;": "∠",
    "ange;": "⦤",
    "angle;": "∠",
    "angmsd;": "∡",
    "angmsdaa;": "⦨",
    "angmsdab;": "⦩",
    "angmsdac;": "⦪",
    "angmsdad;": "⦫",
    "angmsdae;": "⦬",
    "angmsdaf;": "⦭",
    "angmsdag;": "⦮",
    "angmsdah;": "⦯",
    "angrt;": "∟",
    "angrtvb;": "⊾",
    "angrtvbd;": "⦝",
    "angsph;": "∢",
    "angst;": "Å",
    "angzarr;": "⍼",
    "Aogon;": "Ą",
    "aogon;": "ą",
    "Aopf;": "𝔸",
    "aopf;": "𝕒",
    "ap;": "≈",
    "apacir;": "⩯",
    "apE;": "⩰",
    "ape;": "≊",
    "apid;": "≋",
    "apos;": "'",
    "ApplyFunction;": "⁡",
    "approx;": "≈",
    "approxeq;": "≊",
    "Aring;": "Å",
    Aring: "Å",
    "aring;": "å",
    aring: "å",
    "Ascr;": "𝒜",
    "ascr;": "𝒶",
    "Assign;": "≔",
    "ast;": "*",
    "asymp;": "≈",
    "asympeq;": "≍",
    "Atilde;": "Ã",
    Atilde: "Ã",
    "atilde;": "ã",
    atilde: "ã",
    "Auml;": "Ä",
    Auml: "Ä",
    "auml;": "ä",
    auml: "ä",
    "awconint;": "∳",
    "awint;": "⨑",
    "backcong;": "≌",
    "backepsilon;": "϶",
    "backprime;": "‵",
    "backsim;": "∽",
    "backsimeq;": "⋍",
    "Backslash;": "∖",
    "Barv;": "⫧",
    "barvee;": "⊽",
    "Barwed;": "⌆",
    "barwed;": "⌅",
    "barwedge;": "⌅",
    "bbrk;": "⎵",
    "bbrktbrk;": "⎶",
    "bcong;": "≌",
    "Bcy;": "Б",
    "bcy;": "б",
    "bdquo;": "„",
    "becaus;": "∵",
    "Because;": "∵",
    "because;": "∵",
    "bemptyv;": "⦰",
    "bepsi;": "϶",
    "bernou;": "ℬ",
    "Bernoullis;": "ℬ",
    "Beta;": "Β",
    "beta;": "β",
    "beth;": "ℶ",
    "between;": "≬",
    "Bfr;": "𝔅",
    "bfr;": "𝔟",
    "bigcap;": "⋂",
    "bigcirc;": "◯",
    "bigcup;": "⋃",
    "bigodot;": "⨀",
    "bigoplus;": "⨁",
    "bigotimes;": "⨂",
    "bigsqcup;": "⨆",
    "bigstar;": "★",
    "bigtriangledown;": "▽",
    "bigtriangleup;": "△",
    "biguplus;": "⨄",
    "bigvee;": "⋁",
    "bigwedge;": "⋀",
    "bkarow;": "⤍",
    "blacklozenge;": "⧫",
    "blacksquare;": "▪",
    "blacktriangle;": "▴",
    "blacktriangledown;": "▾",
    "blacktriangleleft;": "◂",
    "blacktriangleright;": "▸",
    "blank;": "␣",
    "blk12;": "▒",
    "blk14;": "░",
    "blk34;": "▓",
    "block;": "█",
    "bne;": "=⃥",
    "bnequiv;": "≡⃥",
    "bNot;": "⫭",
    "bnot;": "⌐",
    "Bopf;": "𝔹",
    "bopf;": "𝕓",
    "bot;": "⊥",
    "bottom;": "⊥",
    "bowtie;": "⋈",
    "boxbox;": "⧉",
    "boxDL;": "╗",
    "boxDl;": "╖",
    "boxdL;": "╕",
    "boxdl;": "┐",
    "boxDR;": "╔",
    "boxDr;": "╓",
    "boxdR;": "╒",
    "boxdr;": "┌",
    "boxH;": "═",
    "boxh;": "─",
    "boxHD;": "╦",
    "boxHd;": "╤",
    "boxhD;": "╥",
    "boxhd;": "┬",
    "boxHU;": "╩",
    "boxHu;": "╧",
    "boxhU;": "╨",
    "boxhu;": "┴",
    "boxminus;": "⊟",
    "boxplus;": "⊞",
    "boxtimes;": "⊠",
    "boxUL;": "╝",
    "boxUl;": "╜",
    "boxuL;": "╛",
    "boxul;": "┘",
    "boxUR;": "╚",
    "boxUr;": "╙",
    "boxuR;": "╘",
    "boxur;": "└",
    "boxV;": "║",
    "boxv;": "│",
    "boxVH;": "╬",
    "boxVh;": "╫",
    "boxvH;": "╪",
    "boxvh;": "┼",
    "boxVL;": "╣",
    "boxVl;": "╢",
    "boxvL;": "╡",
    "boxvl;": "┤",
    "boxVR;": "╠",
    "boxVr;": "╟",
    "boxvR;": "╞",
    "boxvr;": "├",
    "bprime;": "‵",
    "Breve;": "˘",
    "breve;": "˘",
    "brvbar;": "¦",
    brvbar: "¦",
    "Bscr;": "ℬ",
    "bscr;": "𝒷",
    "bsemi;": "⁏",
    "bsim;": "∽",
    "bsime;": "⋍",
    "bsol;": "\\",
    "bsolb;": "⧅",
    "bsolhsub;": "⟈",
    "bull;": "•",
    "bullet;": "•",
    "bump;": "≎",
    "bumpE;": "⪮",
    "bumpe;": "≏",
    "Bumpeq;": "≎",
    "bumpeq;": "≏",
    "Cacute;": "Ć",
    "cacute;": "ć",
    "Cap;": "⋒",
    "cap;": "∩",
    "capand;": "⩄",
    "capbrcup;": "⩉",
    "capcap;": "⩋",
    "capcup;": "⩇",
    "capdot;": "⩀",
    "CapitalDifferentialD;": "ⅅ",
    "caps;": "∩︀",
    "caret;": "⁁",
    "caron;": "ˇ",
    "Cayleys;": "ℭ",
    "ccaps;": "⩍",
    "Ccaron;": "Č",
    "ccaron;": "č",
    "Ccedil;": "Ç",
    Ccedil: "Ç",
    "ccedil;": "ç",
    ccedil: "ç",
    "Ccirc;": "Ĉ",
    "ccirc;": "ĉ",
    "Cconint;": "∰",
    "ccups;": "⩌",
    "ccupssm;": "⩐",
    "Cdot;": "Ċ",
    "cdot;": "ċ",
    "cedil;": "¸",
    cedil: "¸",
    "Cedilla;": "¸",
    "cemptyv;": "⦲",
    "cent;": "¢",
    cent: "¢",
    "CenterDot;": "·",
    "centerdot;": "·",
    "Cfr;": "ℭ",
    "cfr;": "𝔠",
    "CHcy;": "Ч",
    "chcy;": "ч",
    "check;": "✓",
    "checkmark;": "✓",
    "Chi;": "Χ",
    "chi;": "χ",
    "cir;": "○",
    "circ;": "ˆ",
    "circeq;": "≗",
    "circlearrowleft;": "↺",
    "circlearrowright;": "↻",
    "circledast;": "⊛",
    "circledcirc;": "⊚",
    "circleddash;": "⊝",
    "CircleDot;": "⊙",
    "circledR;": "®",
    "circledS;": "Ⓢ",
    "CircleMinus;": "⊖",
    "CirclePlus;": "⊕",
    "CircleTimes;": "⊗",
    "cirE;": "⧃",
    "cire;": "≗",
    "cirfnint;": "⨐",
    "cirmid;": "⫯",
    "cirscir;": "⧂",
    "ClockwiseContourIntegral;": "∲",
    "CloseCurlyDoubleQuote;": "”",
    "CloseCurlyQuote;": "’",
    "clubs;": "♣",
    "clubsuit;": "♣",
    "Colon;": "∷",
    "colon;": ":",
    "Colone;": "⩴",
    "colone;": "≔",
    "coloneq;": "≔",
    "comma;": ",",
    "commat;": "@",
    "comp;": "∁",
    "compfn;": "∘",
    "complement;": "∁",
    "complexes;": "ℂ",
    "cong;": "≅",
    "congdot;": "⩭",
    "Congruent;": "≡",
    "Conint;": "∯",
    "conint;": "∮",
    "ContourIntegral;": "∮",
    "Copf;": "ℂ",
    "copf;": "𝕔",
    "coprod;": "∐",
    "Coproduct;": "∐",
    "COPY;": "©",
    COPY: "©",
    "copy;": "©",
    copy: "©",
    "copysr;": "℗",
    "CounterClockwiseContourIntegral;": "∳",
    "crarr;": "↵",
    "Cross;": "⨯",
    "cross;": "✗",
    "Cscr;": "𝒞",
    "cscr;": "𝒸",
    "csub;": "⫏",
    "csube;": "⫑",
    "csup;": "⫐",
    "csupe;": "⫒",
    "ctdot;": "⋯",
    "cudarrl;": "⤸",
    "cudarrr;": "⤵",
    "cuepr;": "⋞",
    "cuesc;": "⋟",
    "cularr;": "↶",
    "cularrp;": "⤽",
    "Cup;": "⋓",
    "cup;": "∪",
    "cupbrcap;": "⩈",
    "CupCap;": "≍",
    "cupcap;": "⩆",
    "cupcup;": "⩊",
    "cupdot;": "⊍",
    "cupor;": "⩅",
    "cups;": "∪︀",
    "curarr;": "↷",
    "curarrm;": "⤼",
    "curlyeqprec;": "⋞",
    "curlyeqsucc;": "⋟",
    "curlyvee;": "⋎",
    "curlywedge;": "⋏",
    "curren;": "¤",
    curren: "¤",
    "curvearrowleft;": "↶",
    "curvearrowright;": "↷",
    "cuvee;": "⋎",
    "cuwed;": "⋏",
    "cwconint;": "∲",
    "cwint;": "∱",
    "cylcty;": "⌭",
    "Dagger;": "‡",
    "dagger;": "†",
    "daleth;": "ℸ",
    "Darr;": "↡",
    "dArr;": "⇓",
    "darr;": "↓",
    "dash;": "‐",
    "Dashv;": "⫤",
    "dashv;": "⊣",
    "dbkarow;": "⤏",
    "dblac;": "˝",
    "Dcaron;": "Ď",
    "dcaron;": "ď",
    "Dcy;": "Д",
    "dcy;": "д",
    "DD;": "ⅅ",
    "dd;": "ⅆ",
    "ddagger;": "‡",
    "ddarr;": "⇊",
    "DDotrahd;": "⤑",
    "ddotseq;": "⩷",
    "deg;": "°",
    deg: "°",
    "Del;": "∇",
    "Delta;": "Δ",
    "delta;": "δ",
    "demptyv;": "⦱",
    "dfisht;": "⥿",
    "Dfr;": "𝔇",
    "dfr;": "𝔡",
    "dHar;": "⥥",
    "dharl;": "⇃",
    "dharr;": "⇂",
    "DiacriticalAcute;": "´",
    "DiacriticalDot;": "˙",
    "DiacriticalDoubleAcute;": "˝",
    "DiacriticalGrave;": "`",
    "DiacriticalTilde;": "˜",
    "diam;": "⋄",
    "Diamond;": "⋄",
    "diamond;": "⋄",
    "diamondsuit;": "♦",
    "diams;": "♦",
    "die;": "¨",
    "DifferentialD;": "ⅆ",
    "digamma;": "ϝ",
    "disin;": "⋲",
    "div;": "÷",
    "divide;": "÷",
    divide: "÷",
    "divideontimes;": "⋇",
    "divonx;": "⋇",
    "DJcy;": "Ђ",
    "djcy;": "ђ",
    "dlcorn;": "⌞",
    "dlcrop;": "⌍",
    "dollar;": "$",
    "Dopf;": "𝔻",
    "dopf;": "𝕕",
    "Dot;": "¨",
    "dot;": "˙",
    "DotDot;": "⃜",
    "doteq;": "≐",
    "doteqdot;": "≑",
    "DotEqual;": "≐",
    "dotminus;": "∸",
    "dotplus;": "∔",
    "dotsquare;": "⊡",
    "doublebarwedge;": "⌆",
    "DoubleContourIntegral;": "∯",
    "DoubleDot;": "¨",
    "DoubleDownArrow;": "⇓",
    "DoubleLeftArrow;": "⇐",
    "DoubleLeftRightArrow;": "⇔",
    "DoubleLeftTee;": "⫤",
    "DoubleLongLeftArrow;": "⟸",
    "DoubleLongLeftRightArrow;": "⟺",
    "DoubleLongRightArrow;": "⟹",
    "DoubleRightArrow;": "⇒",
    "DoubleRightTee;": "⊨",
    "DoubleUpArrow;": "⇑",
    "DoubleUpDownArrow;": "⇕",
    "DoubleVerticalBar;": "∥",
    "DownArrow;": "↓",
    "Downarrow;": "⇓",
    "downarrow;": "↓",
    "DownArrowBar;": "⤓",
    "DownArrowUpArrow;": "⇵",
    "DownBreve;": "̑",
    "downdownarrows;": "⇊",
    "downharpoonleft;": "⇃",
    "downharpoonright;": "⇂",
    "DownLeftRightVector;": "⥐",
    "DownLeftTeeVector;": "⥞",
    "DownLeftVector;": "↽",
    "DownLeftVectorBar;": "⥖",
    "DownRightTeeVector;": "⥟",
    "DownRightVector;": "⇁",
    "DownRightVectorBar;": "⥗",
    "DownTee;": "⊤",
    "DownTeeArrow;": "↧",
    "drbkarow;": "⤐",
    "drcorn;": "⌟",
    "drcrop;": "⌌",
    "Dscr;": "𝒟",
    "dscr;": "𝒹",
    "DScy;": "Ѕ",
    "dscy;": "ѕ",
    "dsol;": "⧶",
    "Dstrok;": "Đ",
    "dstrok;": "đ",
    "dtdot;": "⋱",
    "dtri;": "▿",
    "dtrif;": "▾",
    "duarr;": "⇵",
    "duhar;": "⥯",
    "dwangle;": "⦦",
    "DZcy;": "Џ",
    "dzcy;": "џ",
    "dzigrarr;": "⟿",
    "Eacute;": "É",
    Eacute: "É",
    "eacute;": "é",
    eacute: "é",
    "easter;": "⩮",
    "Ecaron;": "Ě",
    "ecaron;": "ě",
    "ecir;": "≖",
    "Ecirc;": "Ê",
    Ecirc: "Ê",
    "ecirc;": "ê",
    ecirc: "ê",
    "ecolon;": "≕",
    "Ecy;": "Э",
    "ecy;": "э",
    "eDDot;": "⩷",
    "Edot;": "Ė",
    "eDot;": "≑",
    "edot;": "ė",
    "ee;": "ⅇ",
    "efDot;": "≒",
    "Efr;": "𝔈",
    "efr;": "𝔢",
    "eg;": "⪚",
    "Egrave;": "È",
    Egrave: "È",
    "egrave;": "è",
    egrave: "è",
    "egs;": "⪖",
    "egsdot;": "⪘",
    "el;": "⪙",
    "Element;": "∈",
    "elinters;": "⏧",
    "ell;": "ℓ",
    "els;": "⪕",
    "elsdot;": "⪗",
    "Emacr;": "Ē",
    "emacr;": "ē",
    "empty;": "∅",
    "emptyset;": "∅",
    "EmptySmallSquare;": "◻",
    "emptyv;": "∅",
    "EmptyVerySmallSquare;": "▫",
    "emsp;": " ",
    "emsp13;": " ",
    "emsp14;": " ",
    "ENG;": "Ŋ",
    "eng;": "ŋ",
    "ensp;": " ",
    "Eogon;": "Ę",
    "eogon;": "ę",
    "Eopf;": "𝔼",
    "eopf;": "𝕖",
    "epar;": "⋕",
    "eparsl;": "⧣",
    "eplus;": "⩱",
    "epsi;": "ε",
    "Epsilon;": "Ε",
    "epsilon;": "ε",
    "epsiv;": "ϵ",
    "eqcirc;": "≖",
    "eqcolon;": "≕",
    "eqsim;": "≂",
    "eqslantgtr;": "⪖",
    "eqslantless;": "⪕",
    "Equal;": "⩵",
    "equals;": "=",
    "EqualTilde;": "≂",
    "equest;": "≟",
    "Equilibrium;": "⇌",
    "equiv;": "≡",
    "equivDD;": "⩸",
    "eqvparsl;": "⧥",
    "erarr;": "⥱",
    "erDot;": "≓",
    "Escr;": "ℰ",
    "escr;": "ℯ",
    "esdot;": "≐",
    "Esim;": "⩳",
    "esim;": "≂",
    "Eta;": "Η",
    "eta;": "η",
    "ETH;": "Ð",
    ETH: "Ð",
    "eth;": "ð",
    eth: "ð",
    "Euml;": "Ë",
    Euml: "Ë",
    "euml;": "ë",
    euml: "ë",
    "euro;": "€",
    "excl;": "!",
    "exist;": "∃",
    "Exists;": "∃",
    "expectation;": "ℰ",
    "ExponentialE;": "ⅇ",
    "exponentiale;": "ⅇ",
    "fallingdotseq;": "≒",
    "Fcy;": "Ф",
    "fcy;": "ф",
    "female;": "♀",
    "ffilig;": "ﬃ",
    "fflig;": "ﬀ",
    "ffllig;": "ﬄ",
    "Ffr;": "𝔉",
    "ffr;": "𝔣",
    "filig;": "ﬁ",
    "FilledSmallSquare;": "◼",
    "FilledVerySmallSquare;": "▪",
    "fjlig;": "fj",
    "flat;": "♭",
    "fllig;": "ﬂ",
    "fltns;": "▱",
    "fnof;": "ƒ",
    "Fopf;": "𝔽",
    "fopf;": "𝕗",
    "ForAll;": "∀",
    "forall;": "∀",
    "fork;": "⋔",
    "forkv;": "⫙",
    "Fouriertrf;": "ℱ",
    "fpartint;": "⨍",
    "frac12;": "½",
    frac12: "½",
    "frac13;": "⅓",
    "frac14;": "¼",
    frac14: "¼",
    "frac15;": "⅕",
    "frac16;": "⅙",
    "frac18;": "⅛",
    "frac23;": "⅔",
    "frac25;": "⅖",
    "frac34;": "¾",
    frac34: "¾",
    "frac35;": "⅗",
    "frac38;": "⅜",
    "frac45;": "⅘",
    "frac56;": "⅚",
    "frac58;": "⅝",
    "frac78;": "⅞",
    "frasl;": "⁄",
    "frown;": "⌢",
    "Fscr;": "ℱ",
    "fscr;": "𝒻",
    "gacute;": "ǵ",
    "Gamma;": "Γ",
    "gamma;": "γ",
    "Gammad;": "Ϝ",
    "gammad;": "ϝ",
    "gap;": "⪆",
    "Gbreve;": "Ğ",
    "gbreve;": "ğ",
    "Gcedil;": "Ģ",
    "Gcirc;": "Ĝ",
    "gcirc;": "ĝ",
    "Gcy;": "Г",
    "gcy;": "г",
    "Gdot;": "Ġ",
    "gdot;": "ġ",
    "gE;": "≧",
    "ge;": "≥",
    "gEl;": "⪌",
    "gel;": "⋛",
    "geq;": "≥",
    "geqq;": "≧",
    "geqslant;": "⩾",
    "ges;": "⩾",
    "gescc;": "⪩",
    "gesdot;": "⪀",
    "gesdoto;": "⪂",
    "gesdotol;": "⪄",
    "gesl;": "⋛︀",
    "gesles;": "⪔",
    "Gfr;": "𝔊",
    "gfr;": "𝔤",
    "Gg;": "⋙",
    "gg;": "≫",
    "ggg;": "⋙",
    "gimel;": "ℷ",
    "GJcy;": "Ѓ",
    "gjcy;": "ѓ",
    "gl;": "≷",
    "gla;": "⪥",
    "glE;": "⪒",
    "glj;": "⪤",
    "gnap;": "⪊",
    "gnapprox;": "⪊",
    "gnE;": "≩",
    "gne;": "⪈",
    "gneq;": "⪈",
    "gneqq;": "≩",
    "gnsim;": "⋧",
    "Gopf;": "𝔾",
    "gopf;": "𝕘",
    "grave;": "`",
    "GreaterEqual;": "≥",
    "GreaterEqualLess;": "⋛",
    "GreaterFullEqual;": "≧",
    "GreaterGreater;": "⪢",
    "GreaterLess;": "≷",
    "GreaterSlantEqual;": "⩾",
    "GreaterTilde;": "≳",
    "Gscr;": "𝒢",
    "gscr;": "ℊ",
    "gsim;": "≳",
    "gsime;": "⪎",
    "gsiml;": "⪐",
    "GT;": ">",
    GT: ">",
    "Gt;": "≫",
    "gt;": ">",
    gt: ">",
    "gtcc;": "⪧",
    "gtcir;": "⩺",
    "gtdot;": "⋗",
    "gtlPar;": "⦕",
    "gtquest;": "⩼",
    "gtrapprox;": "⪆",
    "gtrarr;": "⥸",
    "gtrdot;": "⋗",
    "gtreqless;": "⋛",
    "gtreqqless;": "⪌",
    "gtrless;": "≷",
    "gtrsim;": "≳",
    "gvertneqq;": "≩︀",
    "gvnE;": "≩︀",
    "Hacek;": "ˇ",
    "hairsp;": " ",
    "half;": "½",
    "hamilt;": "ℋ",
    "HARDcy;": "Ъ",
    "hardcy;": "ъ",
    "hArr;": "⇔",
    "harr;": "↔",
    "harrcir;": "⥈",
    "harrw;": "↭",
    "Hat;": "^",
    "hbar;": "ℏ",
    "Hcirc;": "Ĥ",
    "hcirc;": "ĥ",
    "hearts;": "♥",
    "heartsuit;": "♥",
    "hellip;": "…",
    "hercon;": "⊹",
    "Hfr;": "ℌ",
    "hfr;": "𝔥",
    "HilbertSpace;": "ℋ",
    "hksearow;": "⤥",
    "hkswarow;": "⤦",
    "hoarr;": "⇿",
    "homtht;": "∻",
    "hookleftarrow;": "↩",
    "hookrightarrow;": "↪",
    "Hopf;": "ℍ",
    "hopf;": "𝕙",
    "horbar;": "―",
    "HorizontalLine;": "─",
    "Hscr;": "ℋ",
    "hscr;": "𝒽",
    "hslash;": "ℏ",
    "Hstrok;": "Ħ",
    "hstrok;": "ħ",
    "HumpDownHump;": "≎",
    "HumpEqual;": "≏",
    "hybull;": "⁃",
    "hyphen;": "‐",
    "Iacute;": "Í",
    Iacute: "Í",
    "iacute;": "í",
    iacute: "í",
    "ic;": "⁣",
    "Icirc;": "Î",
    Icirc: "Î",
    "icirc;": "î",
    icirc: "î",
    "Icy;": "И",
    "icy;": "и",
    "Idot;": "İ",
    "IEcy;": "Е",
    "iecy;": "е",
    "iexcl;": "¡",
    iexcl: "¡",
    "iff;": "⇔",
    "Ifr;": "ℑ",
    "ifr;": "𝔦",
    "Igrave;": "Ì",
    Igrave: "Ì",
    "igrave;": "ì",
    igrave: "ì",
    "ii;": "ⅈ",
    "iiiint;": "⨌",
    "iiint;": "∭",
    "iinfin;": "⧜",
    "iiota;": "℩",
    "IJlig;": "Ĳ",
    "ijlig;": "ĳ",
    "Im;": "ℑ",
    "Imacr;": "Ī",
    "imacr;": "ī",
    "image;": "ℑ",
    "ImaginaryI;": "ⅈ",
    "imagline;": "ℐ",
    "imagpart;": "ℑ",
    "imath;": "ı",
    "imof;": "⊷",
    "imped;": "Ƶ",
    "Implies;": "⇒",
    "in;": "∈",
    "incare;": "℅",
    "infin;": "∞",
    "infintie;": "⧝",
    "inodot;": "ı",
    "Int;": "∬",
    "int;": "∫",
    "intcal;": "⊺",
    "integers;": "ℤ",
    "Integral;": "∫",
    "intercal;": "⊺",
    "Intersection;": "⋂",
    "intlarhk;": "⨗",
    "intprod;": "⨼",
    "InvisibleComma;": "⁣",
    "InvisibleTimes;": "⁢",
    "IOcy;": "Ё",
    "iocy;": "ё",
    "Iogon;": "Į",
    "iogon;": "į",
    "Iopf;": "𝕀",
    "iopf;": "𝕚",
    "Iota;": "Ι",
    "iota;": "ι",
    "iprod;": "⨼",
    "iquest;": "¿",
    iquest: "¿",
    "Iscr;": "ℐ",
    "iscr;": "𝒾",
    "isin;": "∈",
    "isindot;": "⋵",
    "isinE;": "⋹",
    "isins;": "⋴",
    "isinsv;": "⋳",
    "isinv;": "∈",
    "it;": "⁢",
    "Itilde;": "Ĩ",
    "itilde;": "ĩ",
    "Iukcy;": "І",
    "iukcy;": "і",
    "Iuml;": "Ï",
    Iuml: "Ï",
    "iuml;": "ï",
    iuml: "ï",
    "Jcirc;": "Ĵ",
    "jcirc;": "ĵ",
    "Jcy;": "Й",
    "jcy;": "й",
    "Jfr;": "𝔍",
    "jfr;": "𝔧",
    "jmath;": "ȷ",
    "Jopf;": "𝕁",
    "jopf;": "𝕛",
    "Jscr;": "𝒥",
    "jscr;": "𝒿",
    "Jsercy;": "Ј",
    "jsercy;": "ј",
    "Jukcy;": "Є",
    "jukcy;": "є",
    "Kappa;": "Κ",
    "kappa;": "κ",
    "kappav;": "ϰ",
    "Kcedil;": "Ķ",
    "kcedil;": "ķ",
    "Kcy;": "К",
    "kcy;": "к",
    "Kfr;": "𝔎",
    "kfr;": "𝔨",
    "kgreen;": "ĸ",
    "KHcy;": "Х",
    "khcy;": "х",
    "KJcy;": "Ќ",
    "kjcy;": "ќ",
    "Kopf;": "𝕂",
    "kopf;": "𝕜",
    "Kscr;": "𝒦",
    "kscr;": "𝓀",
    "lAarr;": "⇚",
    "Lacute;": "Ĺ",
    "lacute;": "ĺ",
    "laemptyv;": "⦴",
    "lagran;": "ℒ",
    "Lambda;": "Λ",
    "lambda;": "λ",
    "Lang;": "⟪",
    "lang;": "⟨",
    "langd;": "⦑",
    "langle;": "⟨",
    "lap;": "⪅",
    "Laplacetrf;": "ℒ",
    "laquo;": "«",
    laquo: "«",
    "Larr;": "↞",
    "lArr;": "⇐",
    "larr;": "←",
    "larrb;": "⇤",
    "larrbfs;": "⤟",
    "larrfs;": "⤝",
    "larrhk;": "↩",
    "larrlp;": "↫",
    "larrpl;": "⤹",
    "larrsim;": "⥳",
    "larrtl;": "↢",
    "lat;": "⪫",
    "lAtail;": "⤛",
    "latail;": "⤙",
    "late;": "⪭",
    "lates;": "⪭︀",
    "lBarr;": "⤎",
    "lbarr;": "⤌",
    "lbbrk;": "❲",
    "lbrace;": "{",
    "lbrack;": "[",
    "lbrke;": "⦋",
    "lbrksld;": "⦏",
    "lbrkslu;": "⦍",
    "Lcaron;": "Ľ",
    "lcaron;": "ľ",
    "Lcedil;": "Ļ",
    "lcedil;": "ļ",
    "lceil;": "⌈",
    "lcub;": "{",
    "Lcy;": "Л",
    "lcy;": "л",
    "ldca;": "⤶",
    "ldquo;": "“",
    "ldquor;": "„",
    "ldrdhar;": "⥧",
    "ldrushar;": "⥋",
    "ldsh;": "↲",
    "lE;": "≦",
    "le;": "≤",
    "LeftAngleBracket;": "⟨",
    "LeftArrow;": "←",
    "Leftarrow;": "⇐",
    "leftarrow;": "←",
    "LeftArrowBar;": "⇤",
    "LeftArrowRightArrow;": "⇆",
    "leftarrowtail;": "↢",
    "LeftCeiling;": "⌈",
    "LeftDoubleBracket;": "⟦",
    "LeftDownTeeVector;": "⥡",
    "LeftDownVector;": "⇃",
    "LeftDownVectorBar;": "⥙",
    "LeftFloor;": "⌊",
    "leftharpoondown;": "↽",
    "leftharpoonup;": "↼",
    "leftleftarrows;": "⇇",
    "LeftRightArrow;": "↔",
    "Leftrightarrow;": "⇔",
    "leftrightarrow;": "↔",
    "leftrightarrows;": "⇆",
    "leftrightharpoons;": "⇋",
    "leftrightsquigarrow;": "↭",
    "LeftRightVector;": "⥎",
    "LeftTee;": "⊣",
    "LeftTeeArrow;": "↤",
    "LeftTeeVector;": "⥚",
    "leftthreetimes;": "⋋",
    "LeftTriangle;": "⊲",
    "LeftTriangleBar;": "⧏",
    "LeftTriangleEqual;": "⊴",
    "LeftUpDownVector;": "⥑",
    "LeftUpTeeVector;": "⥠",
    "LeftUpVector;": "↿",
    "LeftUpVectorBar;": "⥘",
    "LeftVector;": "↼",
    "LeftVectorBar;": "⥒",
    "lEg;": "⪋",
    "leg;": "⋚",
    "leq;": "≤",
    "leqq;": "≦",
    "leqslant;": "⩽",
    "les;": "⩽",
    "lescc;": "⪨",
    "lesdot;": "⩿",
    "lesdoto;": "⪁",
    "lesdotor;": "⪃",
    "lesg;": "⋚︀",
    "lesges;": "⪓",
    "lessapprox;": "⪅",
    "lessdot;": "⋖",
    "lesseqgtr;": "⋚",
    "lesseqqgtr;": "⪋",
    "LessEqualGreater;": "⋚",
    "LessFullEqual;": "≦",
    "LessGreater;": "≶",
    "lessgtr;": "≶",
    "LessLess;": "⪡",
    "lesssim;": "≲",
    "LessSlantEqual;": "⩽",
    "LessTilde;": "≲",
    "lfisht;": "⥼",
    "lfloor;": "⌊",
    "Lfr;": "𝔏",
    "lfr;": "𝔩",
    "lg;": "≶",
    "lgE;": "⪑",
    "lHar;": "⥢",
    "lhard;": "↽",
    "lharu;": "↼",
    "lharul;": "⥪",
    "lhblk;": "▄",
    "LJcy;": "Љ",
    "ljcy;": "љ",
    "Ll;": "⋘",
    "ll;": "≪",
    "llarr;": "⇇",
    "llcorner;": "⌞",
    "Lleftarrow;": "⇚",
    "llhard;": "⥫",
    "lltri;": "◺",
    "Lmidot;": "Ŀ",
    "lmidot;": "ŀ",
    "lmoust;": "⎰",
    "lmoustache;": "⎰",
    "lnap;": "⪉",
    "lnapprox;": "⪉",
    "lnE;": "≨",
    "lne;": "⪇",
    "lneq;": "⪇",
    "lneqq;": "≨",
    "lnsim;": "⋦",
    "loang;": "⟬",
    "loarr;": "⇽",
    "lobrk;": "⟦",
    "LongLeftArrow;": "⟵",
    "Longleftarrow;": "⟸",
    "longleftarrow;": "⟵",
    "LongLeftRightArrow;": "⟷",
    "Longleftrightarrow;": "⟺",
    "longleftrightarrow;": "⟷",
    "longmapsto;": "⟼",
    "LongRightArrow;": "⟶",
    "Longrightarrow;": "⟹",
    "longrightarrow;": "⟶",
    "looparrowleft;": "↫",
    "looparrowright;": "↬",
    "lopar;": "⦅",
    "Lopf;": "𝕃",
    "lopf;": "𝕝",
    "loplus;": "⨭",
    "lotimes;": "⨴",
    "lowast;": "∗",
    "lowbar;": "_",
    "LowerLeftArrow;": "↙",
    "LowerRightArrow;": "↘",
    "loz;": "◊",
    "lozenge;": "◊",
    "lozf;": "⧫",
    "lpar;": "(",
    "lparlt;": "⦓",
    "lrarr;": "⇆",
    "lrcorner;": "⌟",
    "lrhar;": "⇋",
    "lrhard;": "⥭",
    "lrm;": "‎",
    "lrtri;": "⊿",
    "lsaquo;": "‹",
    "Lscr;": "ℒ",
    "lscr;": "𝓁",
    "Lsh;": "↰",
    "lsh;": "↰",
    "lsim;": "≲",
    "lsime;": "⪍",
    "lsimg;": "⪏",
    "lsqb;": "[",
    "lsquo;": "‘",
    "lsquor;": "‚",
    "Lstrok;": "Ł",
    "lstrok;": "ł",
    "LT;": "<",
    LT: "<",
    "Lt;": "≪",
    "lt;": "<",
    lt: "<",
    "ltcc;": "⪦",
    "ltcir;": "⩹",
    "ltdot;": "⋖",
    "lthree;": "⋋",
    "ltimes;": "⋉",
    "ltlarr;": "⥶",
    "ltquest;": "⩻",
    "ltri;": "◃",
    "ltrie;": "⊴",
    "ltrif;": "◂",
    "ltrPar;": "⦖",
    "lurdshar;": "⥊",
    "luruhar;": "⥦",
    "lvertneqq;": "≨︀",
    "lvnE;": "≨︀",
    "macr;": "¯",
    macr: "¯",
    "male;": "♂",
    "malt;": "✠",
    "maltese;": "✠",
    "Map;": "⤅",
    "map;": "↦",
    "mapsto;": "↦",
    "mapstodown;": "↧",
    "mapstoleft;": "↤",
    "mapstoup;": "↥",
    "marker;": "▮",
    "mcomma;": "⨩",
    "Mcy;": "М",
    "mcy;": "м",
    "mdash;": "—",
    "mDDot;": "∺",
    "measuredangle;": "∡",
    "MediumSpace;": " ",
    "Mellintrf;": "ℳ",
    "Mfr;": "𝔐",
    "mfr;": "𝔪",
    "mho;": "℧",
    "micro;": "µ",
    micro: "µ",
    "mid;": "∣",
    "midast;": "*",
    "midcir;": "⫰",
    "middot;": "·",
    middot: "·",
    "minus;": "−",
    "minusb;": "⊟",
    "minusd;": "∸",
    "minusdu;": "⨪",
    "MinusPlus;": "∓",
    "mlcp;": "⫛",
    "mldr;": "…",
    "mnplus;": "∓",
    "models;": "⊧",
    "Mopf;": "𝕄",
    "mopf;": "𝕞",
    "mp;": "∓",
    "Mscr;": "ℳ",
    "mscr;": "𝓂",
    "mstpos;": "∾",
    "Mu;": "Μ",
    "mu;": "μ",
    "multimap;": "⊸",
    "mumap;": "⊸",
    "nabla;": "∇",
    "Nacute;": "Ń",
    "nacute;": "ń",
    "nang;": "∠⃒",
    "nap;": "≉",
    "napE;": "⩰̸",
    "napid;": "≋̸",
    "napos;": "ŉ",
    "napprox;": "≉",
    "natur;": "♮",
    "natural;": "♮",
    "naturals;": "ℕ",
    "nbsp;": " ",
    nbsp: " ",
    "nbump;": "≎̸",
    "nbumpe;": "≏̸",
    "ncap;": "⩃",
    "Ncaron;": "Ň",
    "ncaron;": "ň",
    "Ncedil;": "Ņ",
    "ncedil;": "ņ",
    "ncong;": "≇",
    "ncongdot;": "⩭̸",
    "ncup;": "⩂",
    "Ncy;": "Н",
    "ncy;": "н",
    "ndash;": "–",
    "ne;": "≠",
    "nearhk;": "⤤",
    "neArr;": "⇗",
    "nearr;": "↗",
    "nearrow;": "↗",
    "nedot;": "≐̸",
    "NegativeMediumSpace;": "​",
    "NegativeThickSpace;": "​",
    "NegativeThinSpace;": "​",
    "NegativeVeryThinSpace;": "​",
    "nequiv;": "≢",
    "nesear;": "⤨",
    "nesim;": "≂̸",
    "NestedGreaterGreater;": "≫",
    "NestedLessLess;": "≪",
    "NewLine;": `
`,
    "nexist;": "∄",
    "nexists;": "∄",
    "Nfr;": "𝔑",
    "nfr;": "𝔫",
    "ngE;": "≧̸",
    "nge;": "≱",
    "ngeq;": "≱",
    "ngeqq;": "≧̸",
    "ngeqslant;": "⩾̸",
    "nges;": "⩾̸",
    "nGg;": "⋙̸",
    "ngsim;": "≵",
    "nGt;": "≫⃒",
    "ngt;": "≯",
    "ngtr;": "≯",
    "nGtv;": "≫̸",
    "nhArr;": "⇎",
    "nharr;": "↮",
    "nhpar;": "⫲",
    "ni;": "∋",
    "nis;": "⋼",
    "nisd;": "⋺",
    "niv;": "∋",
    "NJcy;": "Њ",
    "njcy;": "њ",
    "nlArr;": "⇍",
    "nlarr;": "↚",
    "nldr;": "‥",
    "nlE;": "≦̸",
    "nle;": "≰",
    "nLeftarrow;": "⇍",
    "nleftarrow;": "↚",
    "nLeftrightarrow;": "⇎",
    "nleftrightarrow;": "↮",
    "nleq;": "≰",
    "nleqq;": "≦̸",
    "nleqslant;": "⩽̸",
    "nles;": "⩽̸",
    "nless;": "≮",
    "nLl;": "⋘̸",
    "nlsim;": "≴",
    "nLt;": "≪⃒",
    "nlt;": "≮",
    "nltri;": "⋪",
    "nltrie;": "⋬",
    "nLtv;": "≪̸",
    "nmid;": "∤",
    "NoBreak;": "⁠",
    "NonBreakingSpace;": " ",
    "Nopf;": "ℕ",
    "nopf;": "𝕟",
    "Not;": "⫬",
    "not;": "¬",
    not: "¬",
    "NotCongruent;": "≢",
    "NotCupCap;": "≭",
    "NotDoubleVerticalBar;": "∦",
    "NotElement;": "∉",
    "NotEqual;": "≠",
    "NotEqualTilde;": "≂̸",
    "NotExists;": "∄",
    "NotGreater;": "≯",
    "NotGreaterEqual;": "≱",
    "NotGreaterFullEqual;": "≧̸",
    "NotGreaterGreater;": "≫̸",
    "NotGreaterLess;": "≹",
    "NotGreaterSlantEqual;": "⩾̸",
    "NotGreaterTilde;": "≵",
    "NotHumpDownHump;": "≎̸",
    "NotHumpEqual;": "≏̸",
    "notin;": "∉",
    "notindot;": "⋵̸",
    "notinE;": "⋹̸",
    "notinva;": "∉",
    "notinvb;": "⋷",
    "notinvc;": "⋶",
    "NotLeftTriangle;": "⋪",
    "NotLeftTriangleBar;": "⧏̸",
    "NotLeftTriangleEqual;": "⋬",
    "NotLess;": "≮",
    "NotLessEqual;": "≰",
    "NotLessGreater;": "≸",
    "NotLessLess;": "≪̸",
    "NotLessSlantEqual;": "⩽̸",
    "NotLessTilde;": "≴",
    "NotNestedGreaterGreater;": "⪢̸",
    "NotNestedLessLess;": "⪡̸",
    "notni;": "∌",
    "notniva;": "∌",
    "notnivb;": "⋾",
    "notnivc;": "⋽",
    "NotPrecedes;": "⊀",
    "NotPrecedesEqual;": "⪯̸",
    "NotPrecedesSlantEqual;": "⋠",
    "NotReverseElement;": "∌",
    "NotRightTriangle;": "⋫",
    "NotRightTriangleBar;": "⧐̸",
    "NotRightTriangleEqual;": "⋭",
    "NotSquareSubset;": "⊏̸",
    "NotSquareSubsetEqual;": "⋢",
    "NotSquareSuperset;": "⊐̸",
    "NotSquareSupersetEqual;": "⋣",
    "NotSubset;": "⊂⃒",
    "NotSubsetEqual;": "⊈",
    "NotSucceeds;": "⊁",
    "NotSucceedsEqual;": "⪰̸",
    "NotSucceedsSlantEqual;": "⋡",
    "NotSucceedsTilde;": "≿̸",
    "NotSuperset;": "⊃⃒",
    "NotSupersetEqual;": "⊉",
    "NotTilde;": "≁",
    "NotTildeEqual;": "≄",
    "NotTildeFullEqual;": "≇",
    "NotTildeTilde;": "≉",
    "NotVerticalBar;": "∤",
    "npar;": "∦",
    "nparallel;": "∦",
    "nparsl;": "⫽⃥",
    "npart;": "∂̸",
    "npolint;": "⨔",
    "npr;": "⊀",
    "nprcue;": "⋠",
    "npre;": "⪯̸",
    "nprec;": "⊀",
    "npreceq;": "⪯̸",
    "nrArr;": "⇏",
    "nrarr;": "↛",
    "nrarrc;": "⤳̸",
    "nrarrw;": "↝̸",
    "nRightarrow;": "⇏",
    "nrightarrow;": "↛",
    "nrtri;": "⋫",
    "nrtrie;": "⋭",
    "nsc;": "⊁",
    "nsccue;": "⋡",
    "nsce;": "⪰̸",
    "Nscr;": "𝒩",
    "nscr;": "𝓃",
    "nshortmid;": "∤",
    "nshortparallel;": "∦",
    "nsim;": "≁",
    "nsime;": "≄",
    "nsimeq;": "≄",
    "nsmid;": "∤",
    "nspar;": "∦",
    "nsqsube;": "⋢",
    "nsqsupe;": "⋣",
    "nsub;": "⊄",
    "nsubE;": "⫅̸",
    "nsube;": "⊈",
    "nsubset;": "⊂⃒",
    "nsubseteq;": "⊈",
    "nsubseteqq;": "⫅̸",
    "nsucc;": "⊁",
    "nsucceq;": "⪰̸",
    "nsup;": "⊅",
    "nsupE;": "⫆̸",
    "nsupe;": "⊉",
    "nsupset;": "⊃⃒",
    "nsupseteq;": "⊉",
    "nsupseteqq;": "⫆̸",
    "ntgl;": "≹",
    "Ntilde;": "Ñ",
    Ntilde: "Ñ",
    "ntilde;": "ñ",
    ntilde: "ñ",
    "ntlg;": "≸",
    "ntriangleleft;": "⋪",
    "ntrianglelefteq;": "⋬",
    "ntriangleright;": "⋫",
    "ntrianglerighteq;": "⋭",
    "Nu;": "Ν",
    "nu;": "ν",
    "num;": "#",
    "numero;": "№",
    "numsp;": " ",
    "nvap;": "≍⃒",
    "nVDash;": "⊯",
    "nVdash;": "⊮",
    "nvDash;": "⊭",
    "nvdash;": "⊬",
    "nvge;": "≥⃒",
    "nvgt;": ">⃒",
    "nvHarr;": "⤄",
    "nvinfin;": "⧞",
    "nvlArr;": "⤂",
    "nvle;": "≤⃒",
    "nvlt;": "<⃒",
    "nvltrie;": "⊴⃒",
    "nvrArr;": "⤃",
    "nvrtrie;": "⊵⃒",
    "nvsim;": "∼⃒",
    "nwarhk;": "⤣",
    "nwArr;": "⇖",
    "nwarr;": "↖",
    "nwarrow;": "↖",
    "nwnear;": "⤧",
    "Oacute;": "Ó",
    Oacute: "Ó",
    "oacute;": "ó",
    oacute: "ó",
    "oast;": "⊛",
    "ocir;": "⊚",
    "Ocirc;": "Ô",
    Ocirc: "Ô",
    "ocirc;": "ô",
    ocirc: "ô",
    "Ocy;": "О",
    "ocy;": "о",
    "odash;": "⊝",
    "Odblac;": "Ő",
    "odblac;": "ő",
    "odiv;": "⨸",
    "odot;": "⊙",
    "odsold;": "⦼",
    "OElig;": "Œ",
    "oelig;": "œ",
    "ofcir;": "⦿",
    "Ofr;": "𝔒",
    "ofr;": "𝔬",
    "ogon;": "˛",
    "Ograve;": "Ò",
    Ograve: "Ò",
    "ograve;": "ò",
    ograve: "ò",
    "ogt;": "⧁",
    "ohbar;": "⦵",
    "ohm;": "Ω",
    "oint;": "∮",
    "olarr;": "↺",
    "olcir;": "⦾",
    "olcross;": "⦻",
    "oline;": "‾",
    "olt;": "⧀",
    "Omacr;": "Ō",
    "omacr;": "ō",
    "Omega;": "Ω",
    "omega;": "ω",
    "Omicron;": "Ο",
    "omicron;": "ο",
    "omid;": "⦶",
    "ominus;": "⊖",
    "Oopf;": "𝕆",
    "oopf;": "𝕠",
    "opar;": "⦷",
    "OpenCurlyDoubleQuote;": "“",
    "OpenCurlyQuote;": "‘",
    "operp;": "⦹",
    "oplus;": "⊕",
    "Or;": "⩔",
    "or;": "∨",
    "orarr;": "↻",
    "ord;": "⩝",
    "order;": "ℴ",
    "orderof;": "ℴ",
    "ordf;": "ª",
    ordf: "ª",
    "ordm;": "º",
    ordm: "º",
    "origof;": "⊶",
    "oror;": "⩖",
    "orslope;": "⩗",
    "orv;": "⩛",
    "oS;": "Ⓢ",
    "Oscr;": "𝒪",
    "oscr;": "ℴ",
    "Oslash;": "Ø",
    Oslash: "Ø",
    "oslash;": "ø",
    oslash: "ø",
    "osol;": "⊘",
    "Otilde;": "Õ",
    Otilde: "Õ",
    "otilde;": "õ",
    otilde: "õ",
    "Otimes;": "⨷",
    "otimes;": "⊗",
    "otimesas;": "⨶",
    "Ouml;": "Ö",
    Ouml: "Ö",
    "ouml;": "ö",
    ouml: "ö",
    "ovbar;": "⌽",
    "OverBar;": "‾",
    "OverBrace;": "⏞",
    "OverBracket;": "⎴",
    "OverParenthesis;": "⏜",
    "par;": "∥",
    "para;": "¶",
    para: "¶",
    "parallel;": "∥",
    "parsim;": "⫳",
    "parsl;": "⫽",
    "part;": "∂",
    "PartialD;": "∂",
    "Pcy;": "П",
    "pcy;": "п",
    "percnt;": "%",
    "period;": ".",
    "permil;": "‰",
    "perp;": "⊥",
    "pertenk;": "‱",
    "Pfr;": "𝔓",
    "pfr;": "𝔭",
    "Phi;": "Φ",
    "phi;": "φ",
    "phiv;": "ϕ",
    "phmmat;": "ℳ",
    "phone;": "☎",
    "Pi;": "Π",
    "pi;": "π",
    "pitchfork;": "⋔",
    "piv;": "ϖ",
    "planck;": "ℏ",
    "planckh;": "ℎ",
    "plankv;": "ℏ",
    "plus;": "+",
    "plusacir;": "⨣",
    "plusb;": "⊞",
    "pluscir;": "⨢",
    "plusdo;": "∔",
    "plusdu;": "⨥",
    "pluse;": "⩲",
    "PlusMinus;": "±",
    "plusmn;": "±",
    plusmn: "±",
    "plussim;": "⨦",
    "plustwo;": "⨧",
    "pm;": "±",
    "Poincareplane;": "ℌ",
    "pointint;": "⨕",
    "Popf;": "ℙ",
    "popf;": "𝕡",
    "pound;": "£",
    pound: "£",
    "Pr;": "⪻",
    "pr;": "≺",
    "prap;": "⪷",
    "prcue;": "≼",
    "prE;": "⪳",
    "pre;": "⪯",
    "prec;": "≺",
    "precapprox;": "⪷",
    "preccurlyeq;": "≼",
    "Precedes;": "≺",
    "PrecedesEqual;": "⪯",
    "PrecedesSlantEqual;": "≼",
    "PrecedesTilde;": "≾",
    "preceq;": "⪯",
    "precnapprox;": "⪹",
    "precneqq;": "⪵",
    "precnsim;": "⋨",
    "precsim;": "≾",
    "Prime;": "″",
    "prime;": "′",
    "primes;": "ℙ",
    "prnap;": "⪹",
    "prnE;": "⪵",
    "prnsim;": "⋨",
    "prod;": "∏",
    "Product;": "∏",
    "profalar;": "⌮",
    "profline;": "⌒",
    "profsurf;": "⌓",
    "prop;": "∝",
    "Proportion;": "∷",
    "Proportional;": "∝",
    "propto;": "∝",
    "prsim;": "≾",
    "prurel;": "⊰",
    "Pscr;": "𝒫",
    "pscr;": "𝓅",
    "Psi;": "Ψ",
    "psi;": "ψ",
    "puncsp;": " ",
    "Qfr;": "𝔔",
    "qfr;": "𝔮",
    "qint;": "⨌",
    "Qopf;": "ℚ",
    "qopf;": "𝕢",
    "qprime;": "⁗",
    "Qscr;": "𝒬",
    "qscr;": "𝓆",
    "quaternions;": "ℍ",
    "quatint;": "⨖",
    "quest;": "?",
    "questeq;": "≟",
    "QUOT;": '"',
    QUOT: '"',
    "quot;": '"',
    quot: '"',
    "rAarr;": "⇛",
    "race;": "∽̱",
    "Racute;": "Ŕ",
    "racute;": "ŕ",
    "radic;": "√",
    "raemptyv;": "⦳",
    "Rang;": "⟫",
    "rang;": "⟩",
    "rangd;": "⦒",
    "range;": "⦥",
    "rangle;": "⟩",
    "raquo;": "»",
    raquo: "»",
    "Rarr;": "↠",
    "rArr;": "⇒",
    "rarr;": "→",
    "rarrap;": "⥵",
    "rarrb;": "⇥",
    "rarrbfs;": "⤠",
    "rarrc;": "⤳",
    "rarrfs;": "⤞",
    "rarrhk;": "↪",
    "rarrlp;": "↬",
    "rarrpl;": "⥅",
    "rarrsim;": "⥴",
    "Rarrtl;": "⤖",
    "rarrtl;": "↣",
    "rarrw;": "↝",
    "rAtail;": "⤜",
    "ratail;": "⤚",
    "ratio;": "∶",
    "rationals;": "ℚ",
    "RBarr;": "⤐",
    "rBarr;": "⤏",
    "rbarr;": "⤍",
    "rbbrk;": "❳",
    "rbrace;": "}",
    "rbrack;": "]",
    "rbrke;": "⦌",
    "rbrksld;": "⦎",
    "rbrkslu;": "⦐",
    "Rcaron;": "Ř",
    "rcaron;": "ř",
    "Rcedil;": "Ŗ",
    "rcedil;": "ŗ",
    "rceil;": "⌉",
    "rcub;": "}",
    "Rcy;": "Р",
    "rcy;": "р",
    "rdca;": "⤷",
    "rdldhar;": "⥩",
    "rdquo;": "”",
    "rdquor;": "”",
    "rdsh;": "↳",
    "Re;": "ℜ",
    "real;": "ℜ",
    "realine;": "ℛ",
    "realpart;": "ℜ",
    "reals;": "ℝ",
    "rect;": "▭",
    "REG;": "®",
    REG: "®",
    "reg;": "®",
    reg: "®",
    "ReverseElement;": "∋",
    "ReverseEquilibrium;": "⇋",
    "ReverseUpEquilibrium;": "⥯",
    "rfisht;": "⥽",
    "rfloor;": "⌋",
    "Rfr;": "ℜ",
    "rfr;": "𝔯",
    "rHar;": "⥤",
    "rhard;": "⇁",
    "rharu;": "⇀",
    "rharul;": "⥬",
    "Rho;": "Ρ",
    "rho;": "ρ",
    "rhov;": "ϱ",
    "RightAngleBracket;": "⟩",
    "RightArrow;": "→",
    "Rightarrow;": "⇒",
    "rightarrow;": "→",
    "RightArrowBar;": "⇥",
    "RightArrowLeftArrow;": "⇄",
    "rightarrowtail;": "↣",
    "RightCeiling;": "⌉",
    "RightDoubleBracket;": "⟧",
    "RightDownTeeVector;": "⥝",
    "RightDownVector;": "⇂",
    "RightDownVectorBar;": "⥕",
    "RightFloor;": "⌋",
    "rightharpoondown;": "⇁",
    "rightharpoonup;": "⇀",
    "rightleftarrows;": "⇄",
    "rightleftharpoons;": "⇌",
    "rightrightarrows;": "⇉",
    "rightsquigarrow;": "↝",
    "RightTee;": "⊢",
    "RightTeeArrow;": "↦",
    "RightTeeVector;": "⥛",
    "rightthreetimes;": "⋌",
    "RightTriangle;": "⊳",
    "RightTriangleBar;": "⧐",
    "RightTriangleEqual;": "⊵",
    "RightUpDownVector;": "⥏",
    "RightUpTeeVector;": "⥜",
    "RightUpVector;": "↾",
    "RightUpVectorBar;": "⥔",
    "RightVector;": "⇀",
    "RightVectorBar;": "⥓",
    "ring;": "˚",
    "risingdotseq;": "≓",
    "rlarr;": "⇄",
    "rlhar;": "⇌",
    "rlm;": "‏",
    "rmoust;": "⎱",
    "rmoustache;": "⎱",
    "rnmid;": "⫮",
    "roang;": "⟭",
    "roarr;": "⇾",
    "robrk;": "⟧",
    "ropar;": "⦆",
    "Ropf;": "ℝ",
    "ropf;": "𝕣",
    "roplus;": "⨮",
    "rotimes;": "⨵",
    "RoundImplies;": "⥰",
    "rpar;": ")",
    "rpargt;": "⦔",
    "rppolint;": "⨒",
    "rrarr;": "⇉",
    "Rrightarrow;": "⇛",
    "rsaquo;": "›",
    "Rscr;": "ℛ",
    "rscr;": "𝓇",
    "Rsh;": "↱",
    "rsh;": "↱",
    "rsqb;": "]",
    "rsquo;": "’",
    "rsquor;": "’",
    "rthree;": "⋌",
    "rtimes;": "⋊",
    "rtri;": "▹",
    "rtrie;": "⊵",
    "rtrif;": "▸",
    "rtriltri;": "⧎",
    "RuleDelayed;": "⧴",
    "ruluhar;": "⥨",
    "rx;": "℞",
    "Sacute;": "Ś",
    "sacute;": "ś",
    "sbquo;": "‚",
    "Sc;": "⪼",
    "sc;": "≻",
    "scap;": "⪸",
    "Scaron;": "Š",
    "scaron;": "š",
    "sccue;": "≽",
    "scE;": "⪴",
    "sce;": "⪰",
    "Scedil;": "Ş",
    "scedil;": "ş",
    "Scirc;": "Ŝ",
    "scirc;": "ŝ",
    "scnap;": "⪺",
    "scnE;": "⪶",
    "scnsim;": "⋩",
    "scpolint;": "⨓",
    "scsim;": "≿",
    "Scy;": "С",
    "scy;": "с",
    "sdot;": "⋅",
    "sdotb;": "⊡",
    "sdote;": "⩦",
    "searhk;": "⤥",
    "seArr;": "⇘",
    "searr;": "↘",
    "searrow;": "↘",
    "sect;": "§",
    sect: "§",
    "semi;": ";",
    "seswar;": "⤩",
    "setminus;": "∖",
    "setmn;": "∖",
    "sext;": "✶",
    "Sfr;": "𝔖",
    "sfr;": "𝔰",
    "sfrown;": "⌢",
    "sharp;": "♯",
    "SHCHcy;": "Щ",
    "shchcy;": "щ",
    "SHcy;": "Ш",
    "shcy;": "ш",
    "ShortDownArrow;": "↓",
    "ShortLeftArrow;": "←",
    "shortmid;": "∣",
    "shortparallel;": "∥",
    "ShortRightArrow;": "→",
    "ShortUpArrow;": "↑",
    "shy;": "­",
    shy: "­",
    "Sigma;": "Σ",
    "sigma;": "σ",
    "sigmaf;": "ς",
    "sigmav;": "ς",
    "sim;": "∼",
    "simdot;": "⩪",
    "sime;": "≃",
    "simeq;": "≃",
    "simg;": "⪞",
    "simgE;": "⪠",
    "siml;": "⪝",
    "simlE;": "⪟",
    "simne;": "≆",
    "simplus;": "⨤",
    "simrarr;": "⥲",
    "slarr;": "←",
    "SmallCircle;": "∘",
    "smallsetminus;": "∖",
    "smashp;": "⨳",
    "smeparsl;": "⧤",
    "smid;": "∣",
    "smile;": "⌣",
    "smt;": "⪪",
    "smte;": "⪬",
    "smtes;": "⪬︀",
    "SOFTcy;": "Ь",
    "softcy;": "ь",
    "sol;": "/",
    "solb;": "⧄",
    "solbar;": "⌿",
    "Sopf;": "𝕊",
    "sopf;": "𝕤",
    "spades;": "♠",
    "spadesuit;": "♠",
    "spar;": "∥",
    "sqcap;": "⊓",
    "sqcaps;": "⊓︀",
    "sqcup;": "⊔",
    "sqcups;": "⊔︀",
    "Sqrt;": "√",
    "sqsub;": "⊏",
    "sqsube;": "⊑",
    "sqsubset;": "⊏",
    "sqsubseteq;": "⊑",
    "sqsup;": "⊐",
    "sqsupe;": "⊒",
    "sqsupset;": "⊐",
    "sqsupseteq;": "⊒",
    "squ;": "□",
    "Square;": "□",
    "square;": "□",
    "SquareIntersection;": "⊓",
    "SquareSubset;": "⊏",
    "SquareSubsetEqual;": "⊑",
    "SquareSuperset;": "⊐",
    "SquareSupersetEqual;": "⊒",
    "SquareUnion;": "⊔",
    "squarf;": "▪",
    "squf;": "▪",
    "srarr;": "→",
    "Sscr;": "𝒮",
    "sscr;": "𝓈",
    "ssetmn;": "∖",
    "ssmile;": "⌣",
    "sstarf;": "⋆",
    "Star;": "⋆",
    "star;": "☆",
    "starf;": "★",
    "straightepsilon;": "ϵ",
    "straightphi;": "ϕ",
    "strns;": "¯",
    "Sub;": "⋐",
    "sub;": "⊂",
    "subdot;": "⪽",
    "subE;": "⫅",
    "sube;": "⊆",
    "subedot;": "⫃",
    "submult;": "⫁",
    "subnE;": "⫋",
    "subne;": "⊊",
    "subplus;": "⪿",
    "subrarr;": "⥹",
    "Subset;": "⋐",
    "subset;": "⊂",
    "subseteq;": "⊆",
    "subseteqq;": "⫅",
    "SubsetEqual;": "⊆",
    "subsetneq;": "⊊",
    "subsetneqq;": "⫋",
    "subsim;": "⫇",
    "subsub;": "⫕",
    "subsup;": "⫓",
    "succ;": "≻",
    "succapprox;": "⪸",
    "succcurlyeq;": "≽",
    "Succeeds;": "≻",
    "SucceedsEqual;": "⪰",
    "SucceedsSlantEqual;": "≽",
    "SucceedsTilde;": "≿",
    "succeq;": "⪰",
    "succnapprox;": "⪺",
    "succneqq;": "⪶",
    "succnsim;": "⋩",
    "succsim;": "≿",
    "SuchThat;": "∋",
    "Sum;": "∑",
    "sum;": "∑",
    "sung;": "♪",
    "Sup;": "⋑",
    "sup;": "⊃",
    "sup1;": "¹",
    sup1: "¹",
    "sup2;": "²",
    sup2: "²",
    "sup3;": "³",
    sup3: "³",
    "supdot;": "⪾",
    "supdsub;": "⫘",
    "supE;": "⫆",
    "supe;": "⊇",
    "supedot;": "⫄",
    "Superset;": "⊃",
    "SupersetEqual;": "⊇",
    "suphsol;": "⟉",
    "suphsub;": "⫗",
    "suplarr;": "⥻",
    "supmult;": "⫂",
    "supnE;": "⫌",
    "supne;": "⊋",
    "supplus;": "⫀",
    "Supset;": "⋑",
    "supset;": "⊃",
    "supseteq;": "⊇",
    "supseteqq;": "⫆",
    "supsetneq;": "⊋",
    "supsetneqq;": "⫌",
    "supsim;": "⫈",
    "supsub;": "⫔",
    "supsup;": "⫖",
    "swarhk;": "⤦",
    "swArr;": "⇙",
    "swarr;": "↙",
    "swarrow;": "↙",
    "swnwar;": "⤪",
    "szlig;": "ß",
    szlig: "ß",
    "Tab;": "\t",
    "target;": "⌖",
    "Tau;": "Τ",
    "tau;": "τ",
    "tbrk;": "⎴",
    "Tcaron;": "Ť",
    "tcaron;": "ť",
    "Tcedil;": "Ţ",
    "tcedil;": "ţ",
    "Tcy;": "Т",
    "tcy;": "т",
    "tdot;": "⃛",
    "telrec;": "⌕",
    "Tfr;": "𝔗",
    "tfr;": "𝔱",
    "there4;": "∴",
    "Therefore;": "∴",
    "therefore;": "∴",
    "Theta;": "Θ",
    "theta;": "θ",
    "thetasym;": "ϑ",
    "thetav;": "ϑ",
    "thickapprox;": "≈",
    "thicksim;": "∼",
    "ThickSpace;": "  ",
    "thinsp;": " ",
    "ThinSpace;": " ",
    "thkap;": "≈",
    "thksim;": "∼",
    "THORN;": "Þ",
    THORN: "Þ",
    "thorn;": "þ",
    thorn: "þ",
    "Tilde;": "∼",
    "tilde;": "˜",
    "TildeEqual;": "≃",
    "TildeFullEqual;": "≅",
    "TildeTilde;": "≈",
    "times;": "×",
    times: "×",
    "timesb;": "⊠",
    "timesbar;": "⨱",
    "timesd;": "⨰",
    "tint;": "∭",
    "toea;": "⤨",
    "top;": "⊤",
    "topbot;": "⌶",
    "topcir;": "⫱",
    "Topf;": "𝕋",
    "topf;": "𝕥",
    "topfork;": "⫚",
    "tosa;": "⤩",
    "tprime;": "‴",
    "TRADE;": "™",
    "trade;": "™",
    "triangle;": "▵",
    "triangledown;": "▿",
    "triangleleft;": "◃",
    "trianglelefteq;": "⊴",
    "triangleq;": "≜",
    "triangleright;": "▹",
    "trianglerighteq;": "⊵",
    "tridot;": "◬",
    "trie;": "≜",
    "triminus;": "⨺",
    "TripleDot;": "⃛",
    "triplus;": "⨹",
    "trisb;": "⧍",
    "tritime;": "⨻",
    "trpezium;": "⏢",
    "Tscr;": "𝒯",
    "tscr;": "𝓉",
    "TScy;": "Ц",
    "tscy;": "ц",
    "TSHcy;": "Ћ",
    "tshcy;": "ћ",
    "Tstrok;": "Ŧ",
    "tstrok;": "ŧ",
    "twixt;": "≬",
    "twoheadleftarrow;": "↞",
    "twoheadrightarrow;": "↠",
    "Uacute;": "Ú",
    Uacute: "Ú",
    "uacute;": "ú",
    uacute: "ú",
    "Uarr;": "↟",
    "uArr;": "⇑",
    "uarr;": "↑",
    "Uarrocir;": "⥉",
    "Ubrcy;": "Ў",
    "ubrcy;": "ў",
    "Ubreve;": "Ŭ",
    "ubreve;": "ŭ",
    "Ucirc;": "Û",
    Ucirc: "Û",
    "ucirc;": "û",
    ucirc: "û",
    "Ucy;": "У",
    "ucy;": "у",
    "udarr;": "⇅",
    "Udblac;": "Ű",
    "udblac;": "ű",
    "udhar;": "⥮",
    "ufisht;": "⥾",
    "Ufr;": "𝔘",
    "ufr;": "𝔲",
    "Ugrave;": "Ù",
    Ugrave: "Ù",
    "ugrave;": "ù",
    ugrave: "ù",
    "uHar;": "⥣",
    "uharl;": "↿",
    "uharr;": "↾",
    "uhblk;": "▀",
    "ulcorn;": "⌜",
    "ulcorner;": "⌜",
    "ulcrop;": "⌏",
    "ultri;": "◸",
    "Umacr;": "Ū",
    "umacr;": "ū",
    "uml;": "¨",
    uml: "¨",
    "UnderBar;": "_",
    "UnderBrace;": "⏟",
    "UnderBracket;": "⎵",
    "UnderParenthesis;": "⏝",
    "Union;": "⋃",
    "UnionPlus;": "⊎",
    "Uogon;": "Ų",
    "uogon;": "ų",
    "Uopf;": "𝕌",
    "uopf;": "𝕦",
    "UpArrow;": "↑",
    "Uparrow;": "⇑",
    "uparrow;": "↑",
    "UpArrowBar;": "⤒",
    "UpArrowDownArrow;": "⇅",
    "UpDownArrow;": "↕",
    "Updownarrow;": "⇕",
    "updownarrow;": "↕",
    "UpEquilibrium;": "⥮",
    "upharpoonleft;": "↿",
    "upharpoonright;": "↾",
    "uplus;": "⊎",
    "UpperLeftArrow;": "↖",
    "UpperRightArrow;": "↗",
    "Upsi;": "ϒ",
    "upsi;": "υ",
    "upsih;": "ϒ",
    "Upsilon;": "Υ",
    "upsilon;": "υ",
    "UpTee;": "⊥",
    "UpTeeArrow;": "↥",
    "upuparrows;": "⇈",
    "urcorn;": "⌝",
    "urcorner;": "⌝",
    "urcrop;": "⌎",
    "Uring;": "Ů",
    "uring;": "ů",
    "urtri;": "◹",
    "Uscr;": "𝒰",
    "uscr;": "𝓊",
    "utdot;": "⋰",
    "Utilde;": "Ũ",
    "utilde;": "ũ",
    "utri;": "▵",
    "utrif;": "▴",
    "uuarr;": "⇈",
    "Uuml;": "Ü",
    Uuml: "Ü",
    "uuml;": "ü",
    uuml: "ü",
    "uwangle;": "⦧",
    "vangrt;": "⦜",
    "varepsilon;": "ϵ",
    "varkappa;": "ϰ",
    "varnothing;": "∅",
    "varphi;": "ϕ",
    "varpi;": "ϖ",
    "varpropto;": "∝",
    "vArr;": "⇕",
    "varr;": "↕",
    "varrho;": "ϱ",
    "varsigma;": "ς",
    "varsubsetneq;": "⊊︀",
    "varsubsetneqq;": "⫋︀",
    "varsupsetneq;": "⊋︀",
    "varsupsetneqq;": "⫌︀",
    "vartheta;": "ϑ",
    "vartriangleleft;": "⊲",
    "vartriangleright;": "⊳",
    "Vbar;": "⫫",
    "vBar;": "⫨",
    "vBarv;": "⫩",
    "Vcy;": "В",
    "vcy;": "в",
    "VDash;": "⊫",
    "Vdash;": "⊩",
    "vDash;": "⊨",
    "vdash;": "⊢",
    "Vdashl;": "⫦",
    "Vee;": "⋁",
    "vee;": "∨",
    "veebar;": "⊻",
    "veeeq;": "≚",
    "vellip;": "⋮",
    "Verbar;": "‖",
    "verbar;": "|",
    "Vert;": "‖",
    "vert;": "|",
    "VerticalBar;": "∣",
    "VerticalLine;": "|",
    "VerticalSeparator;": "❘",
    "VerticalTilde;": "≀",
    "VeryThinSpace;": " ",
    "Vfr;": "𝔙",
    "vfr;": "𝔳",
    "vltri;": "⊲",
    "vnsub;": "⊂⃒",
    "vnsup;": "⊃⃒",
    "Vopf;": "𝕍",
    "vopf;": "𝕧",
    "vprop;": "∝",
    "vrtri;": "⊳",
    "Vscr;": "𝒱",
    "vscr;": "𝓋",
    "vsubnE;": "⫋︀",
    "vsubne;": "⊊︀",
    "vsupnE;": "⫌︀",
    "vsupne;": "⊋︀",
    "Vvdash;": "⊪",
    "vzigzag;": "⦚",
    "Wcirc;": "Ŵ",
    "wcirc;": "ŵ",
    "wedbar;": "⩟",
    "Wedge;": "⋀",
    "wedge;": "∧",
    "wedgeq;": "≙",
    "weierp;": "℘",
    "Wfr;": "𝔚",
    "wfr;": "𝔴",
    "Wopf;": "𝕎",
    "wopf;": "𝕨",
    "wp;": "℘",
    "wr;": "≀",
    "wreath;": "≀",
    "Wscr;": "𝒲",
    "wscr;": "𝓌",
    "xcap;": "⋂",
    "xcirc;": "◯",
    "xcup;": "⋃",
    "xdtri;": "▽",
    "Xfr;": "𝔛",
    "xfr;": "𝔵",
    "xhArr;": "⟺",
    "xharr;": "⟷",
    "Xi;": "Ξ",
    "xi;": "ξ",
    "xlArr;": "⟸",
    "xlarr;": "⟵",
    "xmap;": "⟼",
    "xnis;": "⋻",
    "xodot;": "⨀",
    "Xopf;": "𝕏",
    "xopf;": "𝕩",
    "xoplus;": "⨁",
    "xotime;": "⨂",
    "xrArr;": "⟹",
    "xrarr;": "⟶",
    "Xscr;": "𝒳",
    "xscr;": "𝓍",
    "xsqcup;": "⨆",
    "xuplus;": "⨄",
    "xutri;": "△",
    "xvee;": "⋁",
    "xwedge;": "⋀",
    "Yacute;": "Ý",
    Yacute: "Ý",
    "yacute;": "ý",
    yacute: "ý",
    "YAcy;": "Я",
    "yacy;": "я",
    "Ycirc;": "Ŷ",
    "ycirc;": "ŷ",
    "Ycy;": "Ы",
    "ycy;": "ы",
    "yen;": "¥",
    yen: "¥",
    "Yfr;": "𝔜",
    "yfr;": "𝔶",
    "YIcy;": "Ї",
    "yicy;": "ї",
    "Yopf;": "𝕐",
    "yopf;": "𝕪",
    "Yscr;": "𝒴",
    "yscr;": "𝓎",
    "YUcy;": "Ю",
    "yucy;": "ю",
    "Yuml;": "Ÿ",
    "yuml;": "ÿ",
    yuml: "ÿ",
    "Zacute;": "Ź",
    "zacute;": "ź",
    "Zcaron;": "Ž",
    "zcaron;": "ž",
    "Zcy;": "З",
    "zcy;": "з",
    "Zdot;": "Ż",
    "zdot;": "ż",
    "zeetrf;": "ℨ",
    "ZeroWidthSpace;": "​",
    "Zeta;": "Ζ",
    "zeta;": "ζ",
    "Zfr;": "ℨ",
    "zfr;": "𝔷",
    "ZHcy;": "Ж",
    "zhcy;": "ж",
    "zigrarr;": "⇝",
    "Zopf;": "ℤ",
    "zopf;": "𝕫",
    "Zscr;": "𝒵",
    "zscr;": "𝓏",
    "zwj;": "‍",
    "zwnj;": "‌"
  };
});

// node_modules/ent/decode.js
var require_decode = __commonJS((exports, module) => {
  var punycode = require_punycode();
  var $encode = punycode.ucs2.encode;
  var regexTest = require_safe_regex_test();
  var callBound = require_call_bound();
  var $TypeError = require_type();
  var entities = require_entities();
  var endsInSemicolon = regexTest(/;$/);
  var $replace = callBound("String.prototype.replace");
  var $exec = callBound("RegExp.prototype.exec");
  var $parseInt = parseInt;
  module.exports = function decode(str) {
    if (typeof str !== "string") {
      throw new $TypeError("Expected a String");
    }
    return $replace(str, /&(#?[^;\W]+;?)/g, function(_, match) {
      var m = $exec(/^#(\d+);?$/, match);
      if (m) {
        return $encode([$parseInt(m[1], 10)]);
      }
      var m2 = $exec(/^#[Xx]([A-Fa-f0-9]+);?/, match);
      if (m2) {
        return $encode([$parseInt(m2[1], 16)]);
      }
      var hasSemi = endsInSemicolon(match);
      var withoutSemi = hasSemi ? $replace(match, /;$/, "") : match;
      var target = entities[withoutSemi] || hasSemi && entities[match];
      if (typeof target === "number") {
        return $encode([target]);
      } else if (typeof target === "string") {
        return target;
      }
      return "&" + match;
    });
  };
});

// node_modules/ent/index.js
var require_ent = __commonJS((exports) => {
  exports.encode = require_encode();
  exports.decode = require_decode();
});

// node_modules/html-to-vdom/lib/convert-tag-attributes.js
var require_convert_tag_attributes = __commonJS((exports, module) => {
  var decode2 = require_ent().decode;
  var MUST_USE_ATTRIBUTE = 1;
  var MUST_USE_PROPERTY = 2;
  var HAS_BOOLEAN_VALUE = 8;
  var HAS_NUMERIC_VALUE = 16;
  var HAS_POSITIVE_NUMERIC_VALUE = 32 | 16;
  var HAS_OVERLOADED_BOOLEAN_VALUE = 64;
  function checkMask(value, bitmask) {
    return (value & bitmask) === bitmask;
  }
  var isCustomAttribute = RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/);
  var HTMLDOMPropertyConfig = {
    Properties: {
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoFocus: HAS_BOOLEAN_VALUE,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      challenge: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      className: MUST_USE_ATTRIBUTE,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      dateTime: MUST_USE_ATTRIBUTE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      headers: null,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      high: null,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      is: MUST_USE_ATTRIBUTE,
      keyParams: MUST_USE_ATTRIBUTE,
      keyType: MUST_USE_ATTRIBUTE,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      low: null,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      minLength: MUST_USE_ATTRIBUTE,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      autoCapitalize: null,
      autoCorrect: null,
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      itemID: MUST_USE_ATTRIBUTE,
      itemRef: MUST_USE_ATTRIBUTE,
      property: null,
      unselectable: MUST_USE_ATTRIBUTE
    }
  };
  var parseStyles = function(input) {
    var attributes = input.split(";");
    var styles = attributes.reduce(function(object, attribute2) {
      var entry = attribute2.split(/:(.+)/);
      if (entry[0] && entry[1]) {
        object[entry[0].trim()] = entry[1].trim();
      }
      return object;
    }, {});
    return styles;
  };
  var propertyToAttributeMapping = {
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv",
    acceptCharset: "accept-charset"
  };
  var propertyValueConversions = {
    style: parseStyles,
    placeholder: decode2,
    title: decode2,
    alt: decode2
  };
  var getPropertyInfo = function() {
    var propInfoByAttributeName = {};
    Object.keys(HTMLDOMPropertyConfig.Properties).forEach(function(propName) {
      var propConfig = HTMLDOMPropertyConfig.Properties[propName];
      var attributeName = propertyToAttributeMapping[propName] || propName.toLowerCase();
      var propertyInfo = {
        attributeName,
        propertyName: propName,
        mustUseAttribute: checkMask(propConfig, MUST_USE_ATTRIBUTE),
        mustUseProperty: checkMask(propConfig, MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      propInfoByAttributeName[attributeName] = propertyInfo;
    });
    return function(attributeName) {
      return propInfoByAttributeName[attributeName];
    };
  }();
  var convertTagAttributes = function(tag) {
    var attributes = tag.attribs;
    var vdomProperties = {
      attributes: {}
    };
    Object.keys(attributes).forEach(function(attributeName) {
      var lowerCased = attributeName.toLowerCase();
      var propInfo = getPropertyInfo(lowerCased);
      var value = attributes[attributeName];
      if (isCustomAttribute(attributeName) || !propInfo) {
        vdomProperties.attributes[attributeName] = value;
        return;
      }
      var valueConverter = propertyValueConversions[propInfo.propertyName];
      if (valueConverter) {
        value = valueConverter(value);
      }
      if (propInfo.mustUseAttribute) {
        if (propInfo.hasBooleanValue) {
          vdomProperties.attributes[propInfo.attributeName] = "";
        } else {
          vdomProperties.attributes[propInfo.attributeName] = value;
        }
      } else {
        var isTrue;
        if (propInfo.hasBooleanValue) {
          isTrue = value === "" || value.toLowerCase() === propInfo.attributeName;
          vdomProperties[propInfo.propertyName] = isTrue ? true : false;
        } else if (propInfo.hasOverloadedBooleanValue) {
          isTrue = value === "";
          vdomProperties[propInfo.propertyName] = isTrue ? true : value;
        } else if (propInfo.hasNumericValue || propInfo.hasPositiveNumericValue) {
          vdomProperties[propInfo.propertyName] = Number(value);
        } else {
          vdomProperties[propInfo.propertyName] = value;
        }
      }
    });
    return vdomProperties;
  };
  module.exports = convertTagAttributes;
});

// node_modules/html-to-vdom/lib/htmlparser-to-vdom.js
var require_htmlparser_to_vdom = __commonJS((exports, module) => {
  var decode2 = require_ent().decode;
  var convertTagAttributes = require_convert_tag_attributes();
  module.exports = function createConverter(VNode, VText) {
    var converter = {
      convert: function(node, getVNodeKey) {
        if (node.type === "tag" || node.type === "script" || node.type === "style") {
          return converter.convertTag(node, getVNodeKey);
        } else if (node.type === "text") {
          return new VText(decode2(node.data));
        } else {
          return new VText("");
        }
      },
      convertTag: function(tag, getVNodeKey) {
        var attributes = convertTagAttributes(tag);
        var key;
        if (getVNodeKey) {
          key = getVNodeKey(attributes);
        }
        var children = Array.prototype.map.call(tag.children || [], function(node) {
          return converter.convert(node, getVNodeKey);
        });
        return new VNode(tag.name, attributes, children, key);
      }
    };
    return converter;
  };
});

// node_modules/entities/maps/decode.json
var require_decode2 = __commonJS((exports, module) => {
  module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS((exports, module) => {
  var decodeMap = require_decode2();
  module.exports = decodeCodePoint;
  function decodeCodePoint(codePoint) {
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "�";
    }
    if (codePoint in decodeMap) {
      codePoint = decodeMap[codePoint];
    }
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
});

// node_modules/entities/maps/entities.json
var require_entities2 = __commonJS((exports, module) => {
  module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: `
`, nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "\t", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
});

// node_modules/entities/maps/legacy.json
var require_legacy = __commonJS((exports, module) => {
  module.exports = { Aacute: "Á", aacute: "á", Acirc: "Â", acirc: "â", acute: "´", AElig: "Æ", aelig: "æ", Agrave: "À", agrave: "à", amp: "&", AMP: "&", Aring: "Å", aring: "å", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", brvbar: "¦", Ccedil: "Ç", ccedil: "ç", cedil: "¸", cent: "¢", copy: "©", COPY: "©", curren: "¤", deg: "°", divide: "÷", Eacute: "É", eacute: "é", Ecirc: "Ê", ecirc: "ê", Egrave: "È", egrave: "è", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", frac12: "½", frac14: "¼", frac34: "¾", gt: ">", GT: ">", Iacute: "Í", iacute: "í", Icirc: "Î", icirc: "î", iexcl: "¡", Igrave: "Ì", igrave: "ì", iquest: "¿", Iuml: "Ï", iuml: "ï", laquo: "«", lt: "<", LT: "<", macr: "¯", micro: "µ", middot: "·", nbsp: " ", not: "¬", Ntilde: "Ñ", ntilde: "ñ", Oacute: "Ó", oacute: "ó", Ocirc: "Ô", ocirc: "ô", Ograve: "Ò", ograve: "ò", ordf: "ª", ordm: "º", Oslash: "Ø", oslash: "ø", Otilde: "Õ", otilde: "õ", Ouml: "Ö", ouml: "ö", para: "¶", plusmn: "±", pound: "£", quot: '"', QUOT: '"', raquo: "»", reg: "®", REG: "®", sect: "§", shy: "­", sup1: "¹", sup2: "²", sup3: "³", szlig: "ß", THORN: "Þ", thorn: "þ", times: "×", Uacute: "Ú", uacute: "ú", Ucirc: "Û", ucirc: "û", Ugrave: "Ù", ugrave: "ù", uml: "¨", Uuml: "Ü", uuml: "ü", Yacute: "Ý", yacute: "ý", yen: "¥", yuml: "ÿ" };
});

// node_modules/entities/maps/xml.json
var require_xml = __commonJS((exports, module) => {
  module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});

// node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS((exports, module) => {
  module.exports = Tokenizer;
  var decodeCodePoint = require_decode_codepoint();
  var entityMap = require_entities2();
  var legacyMap = require_legacy();
  var xmlMap = require_xml();
  var i = 0;
  var TEXT = i++;
  var BEFORE_TAG_NAME = i++;
  var IN_TAG_NAME = i++;
  var IN_SELF_CLOSING_TAG = i++;
  var BEFORE_CLOSING_TAG_NAME = i++;
  var IN_CLOSING_TAG_NAME = i++;
  var AFTER_CLOSING_TAG_NAME = i++;
  var BEFORE_ATTRIBUTE_NAME = i++;
  var IN_ATTRIBUTE_NAME = i++;
  var AFTER_ATTRIBUTE_NAME = i++;
  var BEFORE_ATTRIBUTE_VALUE = i++;
  var IN_ATTRIBUTE_VALUE_DQ = i++;
  var IN_ATTRIBUTE_VALUE_SQ = i++;
  var IN_ATTRIBUTE_VALUE_NQ = i++;
  var BEFORE_DECLARATION = i++;
  var IN_DECLARATION = i++;
  var IN_PROCESSING_INSTRUCTION = i++;
  var BEFORE_COMMENT = i++;
  var IN_COMMENT = i++;
  var AFTER_COMMENT_1 = i++;
  var AFTER_COMMENT_2 = i++;
  var BEFORE_CDATA_1 = i++;
  var BEFORE_CDATA_2 = i++;
  var BEFORE_CDATA_3 = i++;
  var BEFORE_CDATA_4 = i++;
  var BEFORE_CDATA_5 = i++;
  var BEFORE_CDATA_6 = i++;
  var IN_CDATA = i++;
  var AFTER_CDATA_1 = i++;
  var AFTER_CDATA_2 = i++;
  var BEFORE_SPECIAL = i++;
  var BEFORE_SPECIAL_END = i++;
  var BEFORE_SCRIPT_1 = i++;
  var BEFORE_SCRIPT_2 = i++;
  var BEFORE_SCRIPT_3 = i++;
  var BEFORE_SCRIPT_4 = i++;
  var BEFORE_SCRIPT_5 = i++;
  var AFTER_SCRIPT_1 = i++;
  var AFTER_SCRIPT_2 = i++;
  var AFTER_SCRIPT_3 = i++;
  var AFTER_SCRIPT_4 = i++;
  var AFTER_SCRIPT_5 = i++;
  var BEFORE_STYLE_1 = i++;
  var BEFORE_STYLE_2 = i++;
  var BEFORE_STYLE_3 = i++;
  var BEFORE_STYLE_4 = i++;
  var AFTER_STYLE_1 = i++;
  var AFTER_STYLE_2 = i++;
  var AFTER_STYLE_3 = i++;
  var AFTER_STYLE_4 = i++;
  var BEFORE_ENTITY = i++;
  var BEFORE_NUMERIC_ENTITY = i++;
  var IN_NAMED_ENTITY = i++;
  var IN_NUMERIC_ENTITY = i++;
  var IN_HEX_ENTITY = i++;
  var j = 0;
  var SPECIAL_NONE = j++;
  var SPECIAL_SCRIPT = j++;
  var SPECIAL_STYLE = j++;
  function whitespace(c) {
    return c === " " || c === `
` || c === "\t" || c === "\f" || c === "\r";
  }
  function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
      return function(c) {
        if (c === lower) {
          this._state = SUCCESS;
        } else {
          this._state = FAILURE;
          this._index--;
        }
      };
    } else {
      return function(c) {
        if (c === lower || c === upper) {
          this._state = SUCCESS;
        } else {
          this._state = FAILURE;
          this._index--;
        }
      };
    }
  }
  function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function(c) {
      if (c === lower || c === upper) {
        this._state = NEXT_STATE;
      } else {
        this._state = IN_TAG_NAME;
        this._index--;
      }
    };
  }
  function Tokenizer(options, cbs) {
    this._state = TEXT;
    this._buffer = "";
    this._sectionStart = 0;
    this._index = 0;
    this._bufferOffset = 0;
    this._baseState = TEXT;
    this._special = SPECIAL_NONE;
    this._cbs = cbs;
    this._running = true;
    this._ended = false;
    this._xmlMode = !!(options && options.xmlMode);
    this._decodeEntities = !!(options && options.decodeEntities);
  }
  Tokenizer.prototype._stateText = function(c) {
    if (c === "<") {
      if (this._index > this._sectionStart) {
        this._cbs.ontext(this._getSection());
      }
      this._state = BEFORE_TAG_NAME;
      this._sectionStart = this._index;
    } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
      if (this._index > this._sectionStart) {
        this._cbs.ontext(this._getSection());
      }
      this._baseState = TEXT;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeTagName = function(c) {
    if (c === "/") {
      this._state = BEFORE_CLOSING_TAG_NAME;
    } else if (c === "<") {
      this._cbs.ontext(this._getSection());
      this._sectionStart = this._index;
    } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
      this._state = TEXT;
    } else if (c === "!") {
      this._state = BEFORE_DECLARATION;
      this._sectionStart = this._index + 1;
    } else if (c === "?") {
      this._state = IN_PROCESSING_INSTRUCTION;
      this._sectionStart = this._index + 1;
    } else {
      this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInTagName = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._emitToken("onopentagname");
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateBeforeCloseingTagName = function(c) {
    if (whitespace(c))
      ;
    else if (c === ">") {
      this._state = TEXT;
    } else if (this._special !== SPECIAL_NONE) {
      if (c === "s" || c === "S") {
        this._state = BEFORE_SPECIAL_END;
      } else {
        this._state = TEXT;
        this._index--;
      }
    } else {
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInCloseingTagName = function(c) {
    if (c === ">" || whitespace(c)) {
      this._emitToken("onclosetag");
      this._state = AFTER_CLOSING_TAG_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateAfterCloseingTagName = function(c) {
    if (c === ">") {
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateBeforeAttributeName = function(c) {
    if (c === ">") {
      this._cbs.onopentagend();
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c === "/") {
      this._state = IN_SELF_CLOSING_TAG;
    } else if (!whitespace(c)) {
      this._state = IN_ATTRIBUTE_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInSelfClosingTag = function(c) {
    if (c === ">") {
      this._cbs.onselfclosingtag();
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInAttributeName = function(c) {
    if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
      this._cbs.onattribname(this._getSection());
      this._sectionStart = -1;
      this._state = AFTER_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateAfterAttributeName = function(c) {
    if (c === "=") {
      this._state = BEFORE_ATTRIBUTE_VALUE;
    } else if (c === "/" || c === ">") {
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    } else if (!whitespace(c)) {
      this._cbs.onattribend();
      this._state = IN_ATTRIBUTE_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeAttributeValue = function(c) {
    if (c === '"') {
      this._state = IN_ATTRIBUTE_VALUE_DQ;
      this._sectionStart = this._index + 1;
    } else if (c === "'") {
      this._state = IN_ATTRIBUTE_VALUE_SQ;
      this._sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
      this._state = IN_ATTRIBUTE_VALUE_NQ;
      this._sectionStart = this._index;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c) {
    if (c === '"') {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c) {
    if (c === "'") {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c) {
    if (whitespace(c) || c === ">") {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeDeclaration = function(c) {
    this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;
  };
  Tokenizer.prototype._stateInDeclaration = function(c) {
    if (c === ">") {
      this._cbs.ondeclaration(this._getSection());
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateInProcessingInstruction = function(c) {
    if (c === ">") {
      this._cbs.onprocessinginstruction(this._getSection());
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateBeforeComment = function(c) {
    if (c === "-") {
      this._state = IN_COMMENT;
      this._sectionStart = this._index + 1;
    } else {
      this._state = IN_DECLARATION;
    }
  };
  Tokenizer.prototype._stateInComment = function(c) {
    if (c === "-")
      this._state = AFTER_COMMENT_1;
  };
  Tokenizer.prototype._stateAfterComment1 = function(c) {
    if (c === "-") {
      this._state = AFTER_COMMENT_2;
    } else {
      this._state = IN_COMMENT;
    }
  };
  Tokenizer.prototype._stateAfterComment2 = function(c) {
    if (c === ">") {
      this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c !== "-") {
      this._state = IN_COMMENT;
    }
  };
  Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata6 = function(c) {
    if (c === "[") {
      this._state = IN_CDATA;
      this._sectionStart = this._index + 1;
    } else {
      this._state = IN_DECLARATION;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInCdata = function(c) {
    if (c === "]")
      this._state = AFTER_CDATA_1;
  };
  Tokenizer.prototype._stateAfterCdata1 = function(c) {
    if (c === "]")
      this._state = AFTER_CDATA_2;
    else
      this._state = IN_CDATA;
  };
  Tokenizer.prototype._stateAfterCdata2 = function(c) {
    if (c === ">") {
      this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c !== "]") {
      this._state = IN_CDATA;
    }
  };
  Tokenizer.prototype._stateBeforeSpecial = function(c) {
    if (c === "c" || c === "C") {
      this._state = BEFORE_SCRIPT_1;
    } else if (c === "t" || c === "T") {
      this._state = BEFORE_STYLE_1;
    } else {
      this._state = IN_TAG_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateBeforeSpecialEnd = function(c) {
    if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {
      this._state = AFTER_SCRIPT_1;
    } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {
      this._state = AFTER_STYLE_1;
    } else
      this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
  Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
  Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
  Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);
  Tokenizer.prototype._stateBeforeScript5 = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._special = SPECIAL_SCRIPT;
    }
    this._state = IN_TAG_NAME;
    this._index--;
  };
  Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
  Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
  Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
  Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
  Tokenizer.prototype._stateAfterScript5 = function(c) {
    if (c === ">" || whitespace(c)) {
      this._special = SPECIAL_NONE;
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index - 6;
      this._index--;
    } else
      this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
  Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
  Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);
  Tokenizer.prototype._stateBeforeStyle4 = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._special = SPECIAL_STYLE;
    }
    this._state = IN_TAG_NAME;
    this._index--;
  };
  Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
  Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
  Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
  Tokenizer.prototype._stateAfterStyle4 = function(c) {
    if (c === ">" || whitespace(c)) {
      this._special = SPECIAL_NONE;
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index - 5;
      this._index--;
    } else
      this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
  Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);
  Tokenizer.prototype._parseNamedEntityStrict = function() {
    if (this._sectionStart + 1 < this._index) {
      var entity = this._buffer.substring(this._sectionStart + 1, this._index), map = this._xmlMode ? xmlMap : entityMap;
      if (map.hasOwnProperty(entity)) {
        this._emitPartial(map[entity]);
        this._sectionStart = this._index + 1;
      }
    }
  };
  Tokenizer.prototype._parseLegacyEntity = function() {
    var start = this._sectionStart + 1, limit = this._index - start;
    if (limit > 6)
      limit = 6;
    while (limit >= 2) {
      var entity = this._buffer.substr(start, limit);
      if (legacyMap.hasOwnProperty(entity)) {
        this._emitPartial(legacyMap[entity]);
        this._sectionStart += limit + 1;
        return;
      } else {
        limit--;
      }
    }
  };
  Tokenizer.prototype._stateInNamedEntity = function(c) {
    if (c === ";") {
      this._parseNamedEntityStrict();
      if (this._sectionStart + 1 < this._index && !this._xmlMode) {
        this._parseLegacyEntity();
      }
      this._state = this._baseState;
    } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
      if (this._xmlMode)
        ;
      else if (this._sectionStart + 1 === this._index)
        ;
      else if (this._baseState !== TEXT) {
        if (c !== "=") {
          this._parseNamedEntityStrict();
        }
      } else {
        this._parseLegacyEntity();
      }
      this._state = this._baseState;
      this._index--;
    }
  };
  Tokenizer.prototype._decodeNumericEntity = function(offset, base) {
    var sectionStart = this._sectionStart + offset;
    if (sectionStart !== this._index) {
      var entity = this._buffer.substring(sectionStart, this._index);
      var parsed = parseInt(entity, base);
      this._emitPartial(decodeCodePoint(parsed));
      this._sectionStart = this._index;
    } else {
      this._sectionStart--;
    }
    this._state = this._baseState;
  };
  Tokenizer.prototype._stateInNumericEntity = function(c) {
    if (c === ";") {
      this._decodeNumericEntity(2, 10);
      this._sectionStart++;
    } else if (c < "0" || c > "9") {
      if (!this._xmlMode) {
        this._decodeNumericEntity(2, 10);
      } else {
        this._state = this._baseState;
      }
      this._index--;
    }
  };
  Tokenizer.prototype._stateInHexEntity = function(c) {
    if (c === ";") {
      this._decodeNumericEntity(3, 16);
      this._sectionStart++;
    } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
      if (!this._xmlMode) {
        this._decodeNumericEntity(3, 16);
      } else {
        this._state = this._baseState;
      }
      this._index--;
    }
  };
  Tokenizer.prototype._cleanup = function() {
    if (this._sectionStart < 0) {
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else if (this._running) {
      if (this._state === TEXT) {
        if (this._sectionStart !== this._index) {
          this._cbs.ontext(this._buffer.substr(this._sectionStart));
        }
        this._buffer = "";
        this._bufferOffset += this._index;
        this._index = 0;
      } else if (this._sectionStart === this._index) {
        this._buffer = "";
        this._bufferOffset += this._index;
        this._index = 0;
      } else {
        this._buffer = this._buffer.substr(this._sectionStart);
        this._index -= this._sectionStart;
        this._bufferOffset += this._sectionStart;
      }
      this._sectionStart = 0;
    }
  };
  Tokenizer.prototype.write = function(chunk) {
    if (this._ended)
      this._cbs.onerror(Error(".write() after done!"));
    this._buffer += chunk;
    this._parse();
  };
  Tokenizer.prototype._parse = function() {
    while (this._index < this._buffer.length && this._running) {
      var c = this._buffer.charAt(this._index);
      if (this._state === TEXT) {
        this._stateText(c);
      } else if (this._state === BEFORE_TAG_NAME) {
        this._stateBeforeTagName(c);
      } else if (this._state === IN_TAG_NAME) {
        this._stateInTagName(c);
      } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
        this._stateBeforeCloseingTagName(c);
      } else if (this._state === IN_CLOSING_TAG_NAME) {
        this._stateInCloseingTagName(c);
      } else if (this._state === AFTER_CLOSING_TAG_NAME) {
        this._stateAfterCloseingTagName(c);
      } else if (this._state === IN_SELF_CLOSING_TAG) {
        this._stateInSelfClosingTag(c);
      } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
        this._stateBeforeAttributeName(c);
      } else if (this._state === IN_ATTRIBUTE_NAME) {
        this._stateInAttributeName(c);
      } else if (this._state === AFTER_ATTRIBUTE_NAME) {
        this._stateAfterAttributeName(c);
      } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
        this._stateBeforeAttributeValue(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
        this._stateInAttributeValueDoubleQuotes(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
        this._stateInAttributeValueSingleQuotes(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
        this._stateInAttributeValueNoQuotes(c);
      } else if (this._state === BEFORE_DECLARATION) {
        this._stateBeforeDeclaration(c);
      } else if (this._state === IN_DECLARATION) {
        this._stateInDeclaration(c);
      } else if (this._state === IN_PROCESSING_INSTRUCTION) {
        this._stateInProcessingInstruction(c);
      } else if (this._state === BEFORE_COMMENT) {
        this._stateBeforeComment(c);
      } else if (this._state === IN_COMMENT) {
        this._stateInComment(c);
      } else if (this._state === AFTER_COMMENT_1) {
        this._stateAfterComment1(c);
      } else if (this._state === AFTER_COMMENT_2) {
        this._stateAfterComment2(c);
      } else if (this._state === BEFORE_CDATA_1) {
        this._stateBeforeCdata1(c);
      } else if (this._state === BEFORE_CDATA_2) {
        this._stateBeforeCdata2(c);
      } else if (this._state === BEFORE_CDATA_3) {
        this._stateBeforeCdata3(c);
      } else if (this._state === BEFORE_CDATA_4) {
        this._stateBeforeCdata4(c);
      } else if (this._state === BEFORE_CDATA_5) {
        this._stateBeforeCdata5(c);
      } else if (this._state === BEFORE_CDATA_6) {
        this._stateBeforeCdata6(c);
      } else if (this._state === IN_CDATA) {
        this._stateInCdata(c);
      } else if (this._state === AFTER_CDATA_1) {
        this._stateAfterCdata1(c);
      } else if (this._state === AFTER_CDATA_2) {
        this._stateAfterCdata2(c);
      } else if (this._state === BEFORE_SPECIAL) {
        this._stateBeforeSpecial(c);
      } else if (this._state === BEFORE_SPECIAL_END) {
        this._stateBeforeSpecialEnd(c);
      } else if (this._state === BEFORE_SCRIPT_1) {
        this._stateBeforeScript1(c);
      } else if (this._state === BEFORE_SCRIPT_2) {
        this._stateBeforeScript2(c);
      } else if (this._state === BEFORE_SCRIPT_3) {
        this._stateBeforeScript3(c);
      } else if (this._state === BEFORE_SCRIPT_4) {
        this._stateBeforeScript4(c);
      } else if (this._state === BEFORE_SCRIPT_5) {
        this._stateBeforeScript5(c);
      } else if (this._state === AFTER_SCRIPT_1) {
        this._stateAfterScript1(c);
      } else if (this._state === AFTER_SCRIPT_2) {
        this._stateAfterScript2(c);
      } else if (this._state === AFTER_SCRIPT_3) {
        this._stateAfterScript3(c);
      } else if (this._state === AFTER_SCRIPT_4) {
        this._stateAfterScript4(c);
      } else if (this._state === AFTER_SCRIPT_5) {
        this._stateAfterScript5(c);
      } else if (this._state === BEFORE_STYLE_1) {
        this._stateBeforeStyle1(c);
      } else if (this._state === BEFORE_STYLE_2) {
        this._stateBeforeStyle2(c);
      } else if (this._state === BEFORE_STYLE_3) {
        this._stateBeforeStyle3(c);
      } else if (this._state === BEFORE_STYLE_4) {
        this._stateBeforeStyle4(c);
      } else if (this._state === AFTER_STYLE_1) {
        this._stateAfterStyle1(c);
      } else if (this._state === AFTER_STYLE_2) {
        this._stateAfterStyle2(c);
      } else if (this._state === AFTER_STYLE_3) {
        this._stateAfterStyle3(c);
      } else if (this._state === AFTER_STYLE_4) {
        this._stateAfterStyle4(c);
      } else if (this._state === BEFORE_ENTITY) {
        this._stateBeforeEntity(c);
      } else if (this._state === BEFORE_NUMERIC_ENTITY) {
        this._stateBeforeNumericEntity(c);
      } else if (this._state === IN_NAMED_ENTITY) {
        this._stateInNamedEntity(c);
      } else if (this._state === IN_NUMERIC_ENTITY) {
        this._stateInNumericEntity(c);
      } else if (this._state === IN_HEX_ENTITY) {
        this._stateInHexEntity(c);
      } else {
        this._cbs.onerror(Error("unknown _state"), this._state);
      }
      this._index++;
    }
    this._cleanup();
  };
  Tokenizer.prototype.pause = function() {
    this._running = false;
  };
  Tokenizer.prototype.resume = function() {
    this._running = true;
    if (this._index < this._buffer.length) {
      this._parse();
    }
    if (this._ended) {
      this._finish();
    }
  };
  Tokenizer.prototype.end = function(chunk) {
    if (this._ended)
      this._cbs.onerror(Error(".end() after done!"));
    if (chunk)
      this.write(chunk);
    this._ended = true;
    if (this._running)
      this._finish();
  };
  Tokenizer.prototype._finish = function() {
    if (this._sectionStart < this._index) {
      this._handleTrailingData();
    }
    this._cbs.onend();
  };
  Tokenizer.prototype._handleTrailingData = function() {
    var data = this._buffer.substr(this._sectionStart);
    if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
      this._cbs.oncdata(data);
    } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
      this._cbs.oncomment(data);
    } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
      this._parseLegacyEntity();
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
      this._decodeNumericEntity(2, 10);
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
      this._decodeNumericEntity(3, 16);
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
      this._cbs.ontext(data);
    }
  };
  Tokenizer.prototype.reset = function() {
    Tokenizer.call(this, { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities }, this._cbs);
  };
  Tokenizer.prototype.getAbsoluteIndex = function() {
    return this._bufferOffset + this._index;
  };
  Tokenizer.prototype._getSection = function() {
    return this._buffer.substring(this._sectionStart, this._index);
  };
  Tokenizer.prototype._emitToken = function(name) {
    this._cbs[name](this._getSection());
    this._sectionStart = -1;
  };
  Tokenizer.prototype._emitPartial = function(value) {
    if (this._baseState !== TEXT) {
      this._cbs.onattribdata(value);
    } else {
      this._cbs.ontext(value);
    }
  };
});

// node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS((exports, module) => {
  var Tokenizer = require_Tokenizer();
  var formTags = {
    input: true,
    option: true,
    optgroup: true,
    select: true,
    button: true,
    datalist: true,
    textarea: true
  };
  var openImpliesClose = {
    tr: { tr: true, th: true, td: true },
    th: { th: true },
    td: { thead: true, th: true, td: true },
    body: { head: true, link: true, script: true },
    li: { li: true },
    p: { p: true },
    h1: { p: true },
    h2: { p: true },
    h3: { p: true },
    h4: { p: true },
    h5: { p: true },
    h6: { p: true },
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: { option: true },
    optgroup: { optgroup: true }
  };
  var voidElements = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
  var foreignContextElements = {
    __proto__: null,
    math: true,
    svg: true
  };
  var htmlIntegrationElements = {
    __proto__: null,
    mi: true,
    mo: true,
    mn: true,
    ms: true,
    mtext: true,
    "annotation-xml": true,
    foreignObject: true,
    desc: true,
    title: true
  };
  var re_nameEnd = /\s|\//;
  function Parser(cbs, options) {
    this._options = options || {};
    this._cbs = cbs || {};
    this._tagname = "";
    this._attribname = "";
    this._attribvalue = "";
    this._attribs = null;
    this._stack = [];
    this._foreignContext = [];
    this.startIndex = 0;
    this.endIndex = null;
    this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
    this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
    if (this._options.Tokenizer) {
      Tokenizer = this._options.Tokenizer;
    }
    this._tokenizer = new Tokenizer(this._options, this);
    if (this._cbs.onparserinit)
      this._cbs.onparserinit(this);
  }
  require_inherits()(Parser, __require("events").EventEmitter);
  Parser.prototype._updatePosition = function(initialOffset) {
    if (this.endIndex === null) {
      if (this._tokenizer._sectionStart <= initialOffset) {
        this.startIndex = 0;
      } else {
        this.startIndex = this._tokenizer._sectionStart - initialOffset;
      }
    } else
      this.startIndex = this.endIndex + 1;
    this.endIndex = this._tokenizer.getAbsoluteIndex();
  };
  Parser.prototype.ontext = function(data) {
    this._updatePosition(1);
    this.endIndex--;
    if (this._cbs.ontext)
      this._cbs.ontext(data);
  };
  Parser.prototype.onopentagname = function(name) {
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this._tagname = name;
    if (!this._options.xmlMode && name in openImpliesClose) {
      for (var el;(el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el))
        ;
    }
    if (this._options.xmlMode || !(name in voidElements)) {
      this._stack.push(name);
      if (name in foreignContextElements)
        this._foreignContext.push(true);
      else if (name in htmlIntegrationElements)
        this._foreignContext.push(false);
    }
    if (this._cbs.onopentagname)
      this._cbs.onopentagname(name);
    if (this._cbs.onopentag)
      this._attribs = {};
  };
  Parser.prototype.onopentagend = function() {
    this._updatePosition(1);
    if (this._attribs) {
      if (this._cbs.onopentag)
        this._cbs.onopentag(this._tagname, this._attribs);
      this._attribs = null;
    }
    if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
      this._cbs.onclosetag(this._tagname);
    }
    this._tagname = "";
  };
  Parser.prototype.onclosetag = function(name) {
    this._updatePosition(1);
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (name in foreignContextElements || name in htmlIntegrationElements) {
      this._foreignContext.pop();
    }
    if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
      var pos = this._stack.lastIndexOf(name);
      if (pos !== -1) {
        if (this._cbs.onclosetag) {
          pos = this._stack.length - pos;
          while (pos--)
            this._cbs.onclosetag(this._stack.pop());
        } else
          this._stack.length = pos;
      } else if (name === "p" && !this._options.xmlMode) {
        this.onopentagname(name);
        this._closeCurrentTag();
      }
    } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
      this.onopentagname(name);
      this._closeCurrentTag();
    }
  };
  Parser.prototype.onselfclosingtag = function() {
    if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
      this._closeCurrentTag();
    } else {
      this.onopentagend();
    }
  };
  Parser.prototype._closeCurrentTag = function() {
    var name = this._tagname;
    this.onopentagend();
    if (this._stack[this._stack.length - 1] === name) {
      if (this._cbs.onclosetag) {
        this._cbs.onclosetag(name);
      }
      this._stack.pop();
    }
  };
  Parser.prototype.onattribname = function(name) {
    if (this._lowerCaseAttributeNames) {
      name = name.toLowerCase();
    }
    this._attribname = name;
  };
  Parser.prototype.onattribdata = function(value) {
    this._attribvalue += value;
  };
  Parser.prototype.onattribend = function() {
    if (this._cbs.onattribute)
      this._cbs.onattribute(this._attribname, this._attribvalue);
    if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
      this._attribs[this._attribname] = this._attribvalue;
    }
    this._attribname = "";
    this._attribvalue = "";
  };
  Parser.prototype._getInstructionName = function(value) {
    var idx = value.search(re_nameEnd), name = idx < 0 ? value : value.substr(0, idx);
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  };
  Parser.prototype.ondeclaration = function(value) {
    if (this._cbs.onprocessinginstruction) {
      var name = this._getInstructionName(value);
      this._cbs.onprocessinginstruction("!" + name, "!" + value);
    }
  };
  Parser.prototype.onprocessinginstruction = function(value) {
    if (this._cbs.onprocessinginstruction) {
      var name = this._getInstructionName(value);
      this._cbs.onprocessinginstruction("?" + name, "?" + value);
    }
  };
  Parser.prototype.oncomment = function(value) {
    this._updatePosition(4);
    if (this._cbs.oncomment)
      this._cbs.oncomment(value);
    if (this._cbs.oncommentend)
      this._cbs.oncommentend();
  };
  Parser.prototype.oncdata = function(value) {
    this._updatePosition(1);
    if (this._options.xmlMode || this._options.recognizeCDATA) {
      if (this._cbs.oncdatastart)
        this._cbs.oncdatastart();
      if (this._cbs.ontext)
        this._cbs.ontext(value);
      if (this._cbs.oncdataend)
        this._cbs.oncdataend();
    } else {
      this.oncomment("[CDATA[" + value + "]]");
    }
  };
  Parser.prototype.onerror = function(err) {
    if (this._cbs.onerror)
      this._cbs.onerror(err);
  };
  Parser.prototype.onend = function() {
    if (this._cbs.onclosetag) {
      for (var i = this._stack.length;i > 0; this._cbs.onclosetag(this._stack[--i]))
        ;
    }
    if (this._cbs.onend)
      this._cbs.onend();
  };
  Parser.prototype.reset = function() {
    if (this._cbs.onreset)
      this._cbs.onreset();
    this._tokenizer.reset();
    this._tagname = "";
    this._attribname = "";
    this._attribs = null;
    this._stack = [];
    if (this._cbs.onparserinit)
      this._cbs.onparserinit(this);
  };
  Parser.prototype.parseComplete = function(data) {
    this.reset();
    this.end(data);
  };
  Parser.prototype.write = function(chunk) {
    this._tokenizer.write(chunk);
  };
  Parser.prototype.end = function(chunk) {
    this._tokenizer.end(chunk);
  };
  Parser.prototype.pause = function() {
    this._tokenizer.pause();
  };
  Parser.prototype.resume = function() {
    this._tokenizer.resume();
  };
  Parser.prototype.parseChunk = Parser.prototype.write;
  Parser.prototype.done = Parser.prototype.end;
  module.exports = Parser;
});

// node_modules/domelementtype/index.js
var require_domelementtype = __commonJS((exports, module) => {
  module.exports = {
    Text: "text",
    Directive: "directive",
    Comment: "comment",
    Script: "script",
    Style: "style",
    Tag: "tag",
    CDATA: "cdata",
    Doctype: "doctype",
    isTag: function(elem) {
      return elem.type === "tag" || elem.type === "script" || elem.type === "style";
    }
  };
});

// node_modules/domhandler/lib/node.js
var require_node2 = __commonJS((exports, module) => {
  var NodePrototype = module.exports = {
    get firstChild() {
      var children = this.children;
      return children && children[0] || null;
    },
    get lastChild() {
      var children = this.children;
      return children && children[children.length - 1] || null;
    },
    get nodeType() {
      return nodeTypes[this.type] || nodeTypes.element;
    }
  };
  var domLvl1 = {
    tagName: "name",
    childNodes: "children",
    parentNode: "parent",
    previousSibling: "prev",
    nextSibling: "next",
    nodeValue: "data"
  };
  var nodeTypes = {
    element: 1,
    text: 3,
    cdata: 4,
    comment: 8
  };
  Object.keys(domLvl1).forEach(function(key) {
    var shorthand = domLvl1[key];
    Object.defineProperty(NodePrototype, key, {
      get: function() {
        return this[shorthand] || null;
      },
      set: function(val) {
        this[shorthand] = val;
        return val;
      }
    });
  });
});

// node_modules/domhandler/lib/element.js
var require_element = __commonJS((exports, module) => {
  var NodePrototype = require_node2();
  var ElementPrototype = module.exports = Object.create(NodePrototype);
  var domLvl1 = {
    tagName: "name"
  };
  Object.keys(domLvl1).forEach(function(key) {
    var shorthand = domLvl1[key];
    Object.defineProperty(ElementPrototype, key, {
      get: function() {
        return this[shorthand] || null;
      },
      set: function(val) {
        this[shorthand] = val;
        return val;
      }
    });
  });
});

// node_modules/domhandler/index.js
var require_domhandler = __commonJS((exports, module) => {
  var ElementType = require_domelementtype();
  var re_whitespace = /\s+/g;
  var NodePrototype = require_node2();
  var ElementPrototype = require_element();
  function DomHandler(callback, options, elementCB) {
    if (typeof callback === "object") {
      elementCB = options;
      options = callback;
      callback = null;
    } else if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    this._callback = callback;
    this._options = options || defaultOpts;
    this._elementCB = elementCB;
    this.dom = [];
    this._done = false;
    this._tagStack = [];
    this._parser = this._parser || null;
  }
  var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false
  };
  DomHandler.prototype.onparserinit = function(parser) {
    this._parser = parser;
  };
  DomHandler.prototype.onreset = function() {
    DomHandler.call(this, this._callback, this._options, this._elementCB);
  };
  DomHandler.prototype.onend = function() {
    if (this._done)
      return;
    this._done = true;
    this._parser = null;
    this._handleCallback(null);
  };
  DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function(error) {
    if (typeof this._callback === "function") {
      this._callback(error, this.dom);
    } else {
      if (error)
        throw error;
    }
  };
  DomHandler.prototype.onclosetag = function() {
    var elem = this._tagStack.pop();
    if (this._options.withEndIndices && elem) {
      elem.endIndex = this._parser.endIndex;
    }
    if (this._elementCB)
      this._elementCB(elem);
  };
  DomHandler.prototype._createDomElement = function(properties) {
    if (!this._options.withDomLvl1)
      return properties;
    var element;
    if (properties.type === "tag") {
      element = Object.create(ElementPrototype);
    } else {
      element = Object.create(NodePrototype);
    }
    for (var key in properties) {
      if (properties.hasOwnProperty(key)) {
        element[key] = properties[key];
      }
    }
    return element;
  };
  DomHandler.prototype._addDomElement = function(element) {
    var parent = this._tagStack[this._tagStack.length - 1];
    var siblings = parent ? parent.children : this.dom;
    var previousSibling = siblings[siblings.length - 1];
    element.next = null;
    if (this._options.withStartIndices) {
      element.startIndex = this._parser.startIndex;
    }
    if (this._options.withEndIndices) {
      element.endIndex = this._parser.endIndex;
    }
    if (previousSibling) {
      element.prev = previousSibling;
      previousSibling.next = element;
    } else {
      element.prev = null;
    }
    siblings.push(element);
    element.parent = parent || null;
  };
  DomHandler.prototype.onopentag = function(name, attribs) {
    var properties = {
      type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
      name,
      attribs,
      children: []
    };
    var element = this._createDomElement(properties);
    this._addDomElement(element);
    this._tagStack.push(element);
  };
  DomHandler.prototype.ontext = function(data) {
    var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
    var lastTag;
    if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {
      if (normalize) {
        lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
      } else {
        lastTag.data += data;
      }
    } else {
      if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {
        if (normalize) {
          lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
        } else {
          lastTag.data += data;
        }
      } else {
        if (normalize) {
          data = data.replace(re_whitespace, " ");
        }
        var element = this._createDomElement({
          data,
          type: ElementType.Text
        });
        this._addDomElement(element);
      }
    }
  };
  DomHandler.prototype.oncomment = function(data) {
    var lastTag = this._tagStack[this._tagStack.length - 1];
    if (lastTag && lastTag.type === ElementType.Comment) {
      lastTag.data += data;
      return;
    }
    var properties = {
      data,
      type: ElementType.Comment
    };
    var element = this._createDomElement(properties);
    this._addDomElement(element);
    this._tagStack.push(element);
  };
  DomHandler.prototype.oncdatastart = function() {
    var properties = {
      children: [{
        data: "",
        type: ElementType.Text
      }],
      type: ElementType.CDATA
    };
    var element = this._createDomElement(properties);
    this._addDomElement(element);
    this._tagStack.push(element);
  };
  DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function() {
    this._tagStack.pop();
  };
  DomHandler.prototype.onprocessinginstruction = function(name, data) {
    var element = this._createDomElement({
      name,
      data,
      type: ElementType.Directive
    });
    this._addDomElement(element);
  };
  module.exports = DomHandler;
});

// node_modules/dom-serializer/node_modules/domelementtype/lib/index.js
var require_lib4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = undefined;
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType = exports.ElementType || (exports.ElementType = {}));
  function isTag(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
  }
  exports.isTag = isTag;
  exports.Root = ElementType.Root;
  exports.Text = ElementType.Text;
  exports.Directive = ElementType.Directive;
  exports.Comment = ElementType.Comment;
  exports.Script = ElementType.Script;
  exports.Style = ElementType.Style;
  exports.Tag = ElementType.Tag;
  exports.CDATA = ElementType.CDATA;
  exports.Doctype = ElementType.Doctype;
});

// node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json
var require_entities3 = __commonJS((exports, module) => {
  module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: `
`, nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "\t", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
});

// node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json
var require_legacy2 = __commonJS((exports, module) => {
  module.exports = { Aacute: "Á", aacute: "á", Acirc: "Â", acirc: "â", acute: "´", AElig: "Æ", aelig: "æ", Agrave: "À", agrave: "à", amp: "&", AMP: "&", Aring: "Å", aring: "å", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", brvbar: "¦", Ccedil: "Ç", ccedil: "ç", cedil: "¸", cent: "¢", copy: "©", COPY: "©", curren: "¤", deg: "°", divide: "÷", Eacute: "É", eacute: "é", Ecirc: "Ê", ecirc: "ê", Egrave: "È", egrave: "è", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", frac12: "½", frac14: "¼", frac34: "¾", gt: ">", GT: ">", Iacute: "Í", iacute: "í", Icirc: "Î", icirc: "î", iexcl: "¡", Igrave: "Ì", igrave: "ì", iquest: "¿", Iuml: "Ï", iuml: "ï", laquo: "«", lt: "<", LT: "<", macr: "¯", micro: "µ", middot: "·", nbsp: " ", not: "¬", Ntilde: "Ñ", ntilde: "ñ", Oacute: "Ó", oacute: "ó", Ocirc: "Ô", ocirc: "ô", Ograve: "Ò", ograve: "ò", ordf: "ª", ordm: "º", Oslash: "Ø", oslash: "ø", Otilde: "Õ", otilde: "õ", Ouml: "Ö", ouml: "ö", para: "¶", plusmn: "±", pound: "£", quot: '"', QUOT: '"', raquo: "»", reg: "®", REG: "®", sect: "§", shy: "­", sup1: "¹", sup2: "²", sup3: "³", szlig: "ß", THORN: "Þ", thorn: "þ", times: "×", Uacute: "Ú", uacute: "ú", Ucirc: "Û", ucirc: "û", Ugrave: "Ù", ugrave: "ù", uml: "¨", Uuml: "Ü", uuml: "ü", Yacute: "Ý", yacute: "ý", yen: "¥", yuml: "ÿ" };
});

// node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json
var require_xml2 = __commonJS((exports, module) => {
  module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});

// node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json
var require_decode3 = __commonJS((exports, module) => {
  module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
});

// node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var decode_json_1 = __importDefault(require_decode3());
  var fromCodePoint2 = String.fromCodePoint || function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function decodeCodePoint(codePoint) {
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "�";
    }
    if (codePoint in decode_json_1.default) {
      codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint2(codePoint);
  }
  exports.default = decodeCodePoint;
});

// node_modules/dom-serializer/node_modules/entities/lib/decode.js
var require_decode4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = undefined;
  var entities_json_1 = __importDefault(require_entities3());
  var legacy_json_1 = __importDefault(require_legacy2());
  var xml_json_1 = __importDefault(require_xml2());
  var decode_codepoint_1 = __importDefault(require_decode_codepoint2());
  var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  exports.decodeXML = getStrictDecoder(xml_json_1.default);
  exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function(str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }
  var sorter = function(a, b) {
    return a < b ? 1 : -1;
  };
  exports.decodeHTML = function() {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0;i < keys.length; i++) {
      if (legacy[j] === keys[i]) {
        keys[i] += ";?";
        j++;
      } else {
        keys[i] += ";";
      }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
      if (str.substr(-1) !== ";")
        str += ";";
      return replace(str);
    }
    return function(str) {
      return String(str).replace(re, replacer);
    };
  }();
  function getReplacer(map) {
    return function replace(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);
        if (secondChar === "X" || secondChar === "x") {
          return decode_codepoint_1.default(parseInt(str.substr(3), 16));
        }
        return decode_codepoint_1.default(parseInt(str.substr(2), 10));
      }
      return map[str.slice(1, -1)] || str;
    };
  }
});

// node_modules/dom-serializer/node_modules/entities/lib/encode.js
var require_encode2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = undefined;
  var xml_json_1 = __importDefault(require_xml2());
  var inverseXML = getInverseObj(xml_json_1.default);
  var xmlReplacer = getInverseReplacer(inverseXML);
  exports.encodeXML = getASCIIEncoder(inverseXML);
  var entities_json_1 = __importDefault(require_entities3());
  var inverseHTML = getInverseObj(entities_json_1.default);
  var htmlReplacer = getInverseReplacer(inverseHTML);
  exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function(inverse, name) {
      inverse[obj[name]] = "&" + name + ";";
      return inverse;
    }, {});
  }
  function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse);_i < _a.length; _i++) {
      var k = _a[_i];
      if (k.length === 1) {
        single.push("\\" + k);
      } else {
        multiple.push(k);
      }
    }
    single.sort();
    for (var start = 0;start < single.length - 1; start++) {
      var end = start;
      while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
        end += 1;
      }
      var count = 1 + end - start;
      if (count < 3)
        continue;
      single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
  }
  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
  var getCodePoint2 = String.prototype.codePointAt != null ? function(str) {
    return str.codePointAt(0);
  } : function(c) {
    return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
  };
  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint2(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re) {
    return function(data) {
      return data.replace(re, function(name) {
        return inverse[name];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }
  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }
  exports.escape = escape;
  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }
  exports.escapeUTF8 = escapeUTF8;
  function getASCIIEncoder(obj) {
    return function(data) {
      return data.replace(reEscapeChars, function(c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
});

// node_modules/dom-serializer/node_modules/entities/lib/index.js
var require_lib5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = undefined;
  var decode_1 = require_decode4();
  var encode_1 = require_encode2();
  function decode2(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
  }
  exports.decode = decode2;
  function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
  }
  exports.decodeStrict = decodeStrict;
  function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
  }
  exports.encode = encode;
  var encode_2 = require_encode2();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return encode_2.encodeXML;
  } });
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return encode_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return encode_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  var decode_2 = require_decode4();
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
});

// node_modules/dom-serializer/foreignNames.json
var require_foreignNames = __commonJS((exports, module) => {
  module.exports = {
    elementNames: {
      altglyph: "altGlyph",
      altglyphdef: "altGlyphDef",
      altglyphitem: "altGlyphItem",
      animatecolor: "animateColor",
      animatemotion: "animateMotion",
      animatetransform: "animateTransform",
      clippath: "clipPath",
      feblend: "feBlend",
      fecolormatrix: "feColorMatrix",
      fecomponenttransfer: "feComponentTransfer",
      fecomposite: "feComposite",
      feconvolvematrix: "feConvolveMatrix",
      fediffuselighting: "feDiffuseLighting",
      fedisplacementmap: "feDisplacementMap",
      fedistantlight: "feDistantLight",
      fedropshadow: "feDropShadow",
      feflood: "feFlood",
      fefunca: "feFuncA",
      fefuncb: "feFuncB",
      fefuncg: "feFuncG",
      fefuncr: "feFuncR",
      fegaussianblur: "feGaussianBlur",
      feimage: "feImage",
      femerge: "feMerge",
      femergenode: "feMergeNode",
      femorphology: "feMorphology",
      feoffset: "feOffset",
      fepointlight: "fePointLight",
      fespecularlighting: "feSpecularLighting",
      fespotlight: "feSpotLight",
      fetile: "feTile",
      feturbulence: "feTurbulence",
      foreignobject: "foreignObject",
      glyphref: "glyphRef",
      lineargradient: "linearGradient",
      radialgradient: "radialGradient",
      textpath: "textPath"
    },
    attributeNames: {
      definitionurl: "definitionURL",
      attributename: "attributeName",
      attributetype: "attributeType",
      basefrequency: "baseFrequency",
      baseprofile: "baseProfile",
      calcmode: "calcMode",
      clippathunits: "clipPathUnits",
      diffuseconstant: "diffuseConstant",
      edgemode: "edgeMode",
      filterunits: "filterUnits",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      limitingconeangle: "limitingConeAngle",
      markerheight: "markerHeight",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      numoctaves: "numOctaves",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      refx: "refX",
      refy: "refY",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stitchtiles: "stitchTiles",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textlength: "textLength",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      xchannelselector: "xChannelSelector",
      ychannelselector: "yChannelSelector",
      zoomandpan: "zoomAndPan"
    }
  };
});

// node_modules/dom-serializer/index.js
var require_dom_serializer = __commonJS((exports, module) => {
  var ElementType = require_lib4();
  var entities = require_lib5();
  var foreignNames = require_foreignNames();
  foreignNames.elementNames.__proto__ = null;
  foreignNames.attributeNames.__proto__ = null;
  var unencodedElements = {
    __proto__: null,
    style: true,
    script: true,
    xmp: true,
    iframe: true,
    noembed: true,
    noframes: true,
    plaintext: true,
    noscript: true
  };
  function formatAttrs(attributes, opts) {
    if (!attributes)
      return;
    var output = "";
    var value;
    for (var key in attributes) {
      value = attributes[key];
      if (output) {
        output += " ";
      }
      if (opts.xmlMode === "foreign") {
        key = foreignNames.attributeNames[key] || key;
      }
      output += key;
      if (value !== null && value !== "" || opts.xmlMode) {
        output += '="' + (opts.decodeEntities ? entities.encodeXML(value) : value.replace(/\"/g, "&quot;")) + '"';
      }
    }
    return output;
  }
  var singleTag = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
  var render = module.exports = function(dom, opts) {
    if (!Array.isArray(dom) && !dom.cheerio)
      dom = [dom];
    opts = opts || {};
    var output = "";
    for (var i = 0;i < dom.length; i++) {
      var elem = dom[i];
      if (elem.type === "root")
        output += render(elem.children, opts);
      else if (ElementType.isTag(elem))
        output += renderTag(elem, opts);
      else if (elem.type === ElementType.Directive)
        output += renderDirective(elem);
      else if (elem.type === ElementType.Comment)
        output += renderComment(elem);
      else if (elem.type === ElementType.CDATA)
        output += renderCdata(elem);
      else
        output += renderText(elem, opts);
    }
    return output;
  };
  var foreignModeIntegrationPoints = [
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ];
  function renderTag(elem, opts) {
    if (opts.xmlMode === "foreign") {
      elem.name = foreignNames.elementNames[elem.name] || elem.name;
      if (elem.parent && foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0)
        opts = Object.assign({}, opts, { xmlMode: false });
    }
    if (!opts.xmlMode && ["svg", "math"].indexOf(elem.name) >= 0) {
      opts = Object.assign({}, opts, { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttrs(elem.attribs, opts);
    if (attribs) {
      tag += " " + attribs;
    }
    if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children) {
        tag += render(elem.children, opts);
      }
      if (!singleTag[elem.name] || opts.xmlMode) {
        tag += "</" + elem.name + ">";
      }
    }
    return tag;
  }
  function renderDirective(elem) {
    return "<" + elem.data + ">";
  }
  function renderText(elem, opts) {
    var data = elem.data || "";
    if (opts.decodeEntities && !(elem.parent && (elem.parent.name in unencodedElements))) {
      data = entities.encodeXML(data);
    }
    return data;
  }
  function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
  }
  function renderComment(elem) {
    return "<!--" + elem.data + "-->";
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var ElementType = require_domelementtype();
  var getOuterHTML = require_dom_serializer();
  var isTag = ElementType.isTag;
  module.exports = {
    getInnerHTML,
    getOuterHTML,
    getText
  };
  function getInnerHTML(elem, opts) {
    return elem.children ? elem.children.map(function(elem2) {
      return getOuterHTML(elem2, opts);
    }).join("") : "";
  }
  function getText(elem) {
    if (Array.isArray(elem))
      return elem.map(getText).join("");
    if (isTag(elem))
      return elem.name === "br" ? `
` : getText(elem.children);
    if (elem.type === ElementType.CDATA)
      return getText(elem.children);
    if (elem.type === ElementType.Text)
      return elem.data;
    return "";
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS((exports) => {
  var getChildren = exports.getChildren = function(elem) {
    return elem.children;
  };
  var getParent = exports.getParent = function(elem) {
    return elem.parent;
  };
  exports.getSiblings = function(elem) {
    var parent = getParent(elem);
    return parent ? getChildren(parent) : [elem];
  };
  exports.getAttributeValue = function(elem, name) {
    return elem.attribs && elem.attribs[name];
  };
  exports.hasAttrib = function(elem, name) {
    return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
  };
  exports.getName = function(elem) {
    return elem.name;
  };
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS((exports) => {
  exports.removeElement = function(elem) {
    if (elem.prev)
      elem.prev.next = elem.next;
    if (elem.next)
      elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      childs.splice(childs.lastIndexOf(elem), 1);
    }
  };
  exports.replaceElement = function(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
    }
  };
  exports.appendChild = function(elem, child) {
    child.parent = elem;
    if (elem.children.push(child) !== 1) {
      var sibling = elem.children[elem.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
      child.next = null;
    }
  };
  exports.append = function(elem, next) {
    var { parent, next: currNext } = elem;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  };
  exports.prepend = function(elem, prev) {
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  };
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS((exports, module) => {
  var isTag = require_domelementtype().isTag;
  module.exports = {
    filter,
    find,
    findOneChild,
    findOne,
    existsOne,
    findAll
  };
  function filter(test, element, recurse, limit) {
    if (!Array.isArray(element))
      element = [element];
    if (typeof limit !== "number" || !isFinite(limit)) {
      limit = Infinity;
    }
    return find(test, element, recurse !== false, limit);
  }
  function find(test, elems, recurse, limit) {
    var result = [], childs;
    for (var i = 0, j = elems.length;i < j; i++) {
      if (test(elems[i])) {
        result.push(elems[i]);
        if (--limit <= 0)
          break;
      }
      childs = elems[i].children;
      if (recurse && childs && childs.length > 0) {
        childs = find(test, childs, recurse, limit);
        result = result.concat(childs);
        limit -= childs.length;
        if (limit <= 0)
          break;
      }
    }
    return result;
  }
  function findOneChild(test, elems) {
    for (var i = 0, l = elems.length;i < l; i++) {
      if (test(elems[i]))
        return elems[i];
    }
    return null;
  }
  function findOne(test, elems) {
    var elem = null;
    for (var i = 0, l = elems.length;i < l && !elem; i++) {
      if (!isTag(elems[i])) {
        continue;
      } else if (test(elems[i])) {
        elem = elems[i];
      } else if (elems[i].children.length > 0) {
        elem = findOne(test, elems[i].children);
      }
    }
    return elem;
  }
  function existsOne(test, elems) {
    for (var i = 0, l = elems.length;i < l; i++) {
      if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
        return true;
      }
    }
    return false;
  }
  function findAll(test, rootElems) {
    var result = [];
    var stack = rootElems.slice();
    while (stack.length) {
      var elem = stack.shift();
      if (!isTag(elem))
        continue;
      if (elem.children && elem.children.length > 0) {
        stack.unshift.apply(stack, elem.children);
      }
      if (test(elem))
        result.push(elem);
    }
    return result;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy3 = __commonJS((exports) => {
  var ElementType = require_domelementtype();
  var isTag = exports.isTag = ElementType.isTag;
  exports.testElement = function(options, element) {
    for (var key in options) {
      if (!options.hasOwnProperty(key))
        ;
      else if (key === "tag_name") {
        if (!isTag(element) || !options.tag_name(element.name)) {
          return false;
        }
      } else if (key === "tag_type") {
        if (!options.tag_type(element.type))
          return false;
      } else if (key === "tag_contains") {
        if (isTag(element) || !options.tag_contains(element.data)) {
          return false;
        }
      } else if (!element.attribs || !options[key](element.attribs[key])) {
        return false;
      }
    }
    return true;
  };
  var Checks = {
    tag_name: function(name) {
      if (typeof name === "function") {
        return function(elem) {
          return isTag(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return isTag;
      } else {
        return function(elem) {
          return isTag(elem) && elem.name === name;
        };
      }
    },
    tag_type: function(type) {
      if (typeof type === "function") {
        return function(elem) {
          return type(elem.type);
        };
      } else {
        return function(elem) {
          return elem.type === type;
        };
      }
    },
    tag_contains: function(data) {
      if (typeof data === "function") {
        return function(elem) {
          return !isTag(elem) && data(elem.data);
        };
      } else {
        return function(elem) {
          return !isTag(elem) && elem.data === data;
        };
      }
    }
  };
  function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
      return function(elem) {
        return elem.attribs && value(elem.attribs[attrib]);
      };
    } else {
      return function(elem) {
        return elem.attribs && elem.attribs[attrib] === value;
      };
    }
  }
  function combineFuncs(a, b) {
    return function(elem) {
      return a(elem) || b(elem);
    };
  }
  exports.getElements = function(options, element, recurse, limit) {
    var funcs = Object.keys(options).map(function(key) {
      var value = options[key];
      return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
  };
  exports.getElementById = function(id, element, recurse) {
    if (!Array.isArray(element))
      element = [element];
    return this.findOne(getAttribCheck("id", id), element, recurse !== false);
  };
  exports.getElementsByTagName = function(name, element, recurse, limit) {
    return this.filter(Checks.tag_name(name), element, recurse, limit);
  };
  exports.getElementsByTagType = function(type, element, recurse, limit) {
    return this.filter(Checks.tag_type(type), element, recurse, limit);
  };
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  exports.removeSubsets = function(nodes) {
    var idx = nodes.length, node, ancestor, replace;
    while (--idx > -1) {
      node = ancestor = nodes[idx];
      nodes[idx] = null;
      replace = true;
      while (ancestor) {
        if (nodes.indexOf(ancestor) > -1) {
          replace = false;
          nodes.splice(idx, 1);
          break;
        }
        ancestor = ancestor.parent;
      }
      if (replace) {
        nodes[idx] = node;
      }
    }
    return nodes;
  };
  var POSITION = {
    DISCONNECTED: 1,
    PRECEDING: 2,
    FOLLOWING: 4,
    CONTAINS: 8,
    CONTAINED_BY: 16
  };
  var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    var current, sharedParent, siblings, aSibling, bSibling, idx;
    if (nodeA === nodeB) {
      return 0;
    }
    current = nodeA;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = nodeB;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    idx = 0;
    while (aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return POSITION.DISCONNECTED;
    }
    sharedParent = aParents[idx - 1];
    siblings = sharedParent.children;
    aSibling = aParents[idx];
    bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
      }
      return POSITION.FOLLOWING;
    } else {
      if (sharedParent === nodeA) {
        return POSITION.PRECEDING | POSITION.CONTAINS;
      }
      return POSITION.PRECEDING;
    }
  };
  exports.uniqueSort = function(nodes) {
    var idx = nodes.length, node, position;
    nodes = nodes.slice();
    while (--idx > -1) {
      node = nodes[idx];
      position = nodes.indexOf(node);
      if (position > -1 && position < idx) {
        nodes.splice(idx, 1);
      }
    }
    nodes.sort(function(a, b) {
      var relative = comparePos(a, b);
      if (relative & POSITION.PRECEDING) {
        return -1;
      } else if (relative & POSITION.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  };
});

// node_modules/domutils/index.js
var require_domutils = __commonJS((exports, module) => {
  var DomUtils = exports;
  [
    require_stringify(),
    require_traversal(),
    require_manipulation(),
    require_querying(),
    require_legacy3(),
    require_helpers()
  ].forEach(function(ext) {
    Object.keys(ext).forEach(function(key) {
      DomUtils[key] = ext[key].bind(DomUtils);
    });
  });
});

// node_modules/htmlparser2/lib/FeedHandler.js
var require_FeedHandler = __commonJS((exports, module) => {
  var DomHandler = require_domhandler();
  var DomUtils = require_domutils();
  function FeedHandler(callback, options) {
    this.init(callback, options);
  }
  require_inherits()(FeedHandler, DomHandler);
  FeedHandler.prototype.init = DomHandler;
  function getElements(what, where) {
    return DomUtils.getElementsByTagName(what, where, true);
  }
  function getOneElement(what, where) {
    return DomUtils.getElementsByTagName(what, where, true, 1)[0];
  }
  function fetch2(what, where, recurse) {
    return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
  }
  function addConditionally(obj, prop, what, where, recurse) {
    var tmp = fetch2(what, where, recurse);
    if (tmp)
      obj[prop] = tmp;
  }
  var isValidFeed = function(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  };
  FeedHandler.prototype.onend = function() {
    var feed = {}, feedRoot = getOneElement(isValidFeed, this.dom), tmp, childs;
    if (feedRoot) {
      if (feedRoot.name === "feed") {
        childs = feedRoot.children;
        feed.type = "atom";
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href))
          feed.link = tmp;
        addConditionally(feed, "description", "subtitle", childs);
        if (tmp = fetch2("updated", childs))
          feed.updated = new Date(tmp);
        addConditionally(feed, "author", "email", childs, true);
        feed.items = getElements("entry", childs).map(function(item) {
          var entry = {}, tmp2;
          item = item.children;
          addConditionally(entry, "id", "id", item);
          addConditionally(entry, "title", "title", item);
          if ((tmp2 = getOneElement("link", item)) && (tmp2 = tmp2.attribs) && (tmp2 = tmp2.href))
            entry.link = tmp2;
          if (tmp2 = fetch2("summary", item) || fetch2("content", item))
            entry.description = tmp2;
          if (tmp2 = fetch2("updated", item))
            entry.pubDate = new Date(tmp2);
          return entry;
        });
      } else {
        childs = getOneElement("channel", feedRoot.children).children;
        feed.type = feedRoot.name.substr(0, 3);
        feed.id = "";
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        if (tmp = fetch2("lastBuildDate", childs))
          feed.updated = new Date(tmp);
        addConditionally(feed, "author", "managingEditor", childs, true);
        feed.items = getElements("item", feedRoot.children).map(function(item) {
          var entry = {}, tmp2;
          item = item.children;
          addConditionally(entry, "id", "guid", item);
          addConditionally(entry, "title", "title", item);
          addConditionally(entry, "link", "link", item);
          addConditionally(entry, "description", "description", item);
          if (tmp2 = fetch2("pubDate", item))
            entry.pubDate = new Date(tmp2);
          return entry;
        });
      }
    }
    this.dom = feed;
    DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
  };
  module.exports = FeedHandler;
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var _require = __require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = __require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  module.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports, module) => {
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/errors.js
var require_errors = __commonJS((exports, module) => {
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports.codes = codes;
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  module.exports = {
    getHighWaterMark
  };
});

// node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable2 = __commonJS((exports, module) => {
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = __require("stream");
  var Buffer2 = __require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy2();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  function nop() {}
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex2();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex2();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex2 = __commonJS((exports, module) => {
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj)
      keys2.push(key);
    return keys2;
  };
  module.exports = Duplex;
  var Readable = require__stream_readable2();
  var Writable = require__stream_writable2();
  require_inherits()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer2().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {}
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  module.exports = eos;
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports, module) => {
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module.exports = createReadableStreamAsyncIterator;
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  }
  module.exports = from;
});

// node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable2 = __commonJS((exports, module) => {
  module.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = __require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = __require("util");
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug() {};
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy2();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex2();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex2();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder2().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === undefined) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform2 = __commonJS((exports, module) => {
  module.exports = Transform;
  var _require$codes = require_errors().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require__stream_duplex2();
  require_inherits()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough2 = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform2();
  require_inherits()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  }
  var _require$codes = require_errors().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === undefined)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  module.exports = pipeline;
});

// node_modules/readable-stream/readable.js
var require_readable2 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable2();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable2();
    exports.Duplex = require__stream_duplex2();
    exports.Transform = require__stream_transform2();
    exports.PassThrough = require__stream_passthrough2();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/htmlparser2/lib/WritableStream.js
var require_WritableStream = __commonJS((exports, module) => {
  module.exports = Stream;
  var Parser = require_Parser();
  var WritableStream = require_readable2().Writable;
  var StringDecoder = __require("string_decoder").StringDecoder;
  var Buffer2 = __require("buffer").Buffer;
  function Stream(cbs, options) {
    var parser = this._parser = new Parser(cbs, options);
    var decoder = this._decoder = new StringDecoder;
    WritableStream.call(this, { decodeStrings: false });
    this.once("finish", function() {
      parser.end(decoder.end());
    });
  }
  require_inherits()(Stream, WritableStream);
  Stream.prototype._write = function(chunk, encoding, cb) {
    if (chunk instanceof Buffer2)
      chunk = this._decoder.write(chunk);
    this._parser.write(chunk);
    cb();
  };
});

// node_modules/htmlparser2/lib/Stream.js
var require_Stream = __commonJS((exports, module) => {
  module.exports = Stream;
  var Parser = require_WritableStream();
  function Stream(options) {
    Parser.call(this, new Cbs(this), options);
  }
  require_inherits()(Stream, Parser);
  Stream.prototype.readable = true;
  function Cbs(scope) {
    this.scope = scope;
  }
  var EVENTS = require_lib6().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      Cbs.prototype["on" + name] = function() {
        this.scope.emit(name);
      };
    } else if (EVENTS[name] === 1) {
      Cbs.prototype["on" + name] = function(a) {
        this.scope.emit(name, a);
      };
    } else if (EVENTS[name] === 2) {
      Cbs.prototype["on" + name] = function(a, b) {
        this.scope.emit(name, a, b);
      };
    } else {
      throw Error("wrong number of arguments!");
    }
  });
});

// node_modules/htmlparser2/lib/ProxyHandler.js
var require_ProxyHandler = __commonJS((exports, module) => {
  module.exports = ProxyHandler;
  function ProxyHandler(cbs) {
    this._cbs = cbs || {};
  }
  var EVENTS = require_lib6().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function() {
        if (this._cbs[name])
          this._cbs[name]();
      };
    } else if (EVENTS[name] === 1) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function(a) {
        if (this._cbs[name])
          this._cbs[name](a);
      };
    } else if (EVENTS[name] === 2) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function(a, b) {
        if (this._cbs[name])
          this._cbs[name](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
});

// node_modules/htmlparser2/lib/CollectingHandler.js
var require_CollectingHandler = __commonJS((exports, module) => {
  module.exports = CollectingHandler;
  function CollectingHandler(cbs) {
    this._cbs = cbs || {};
    this.events = [];
  }
  var EVENTS = require_lib6().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function() {
        this.events.push([name]);
        if (this._cbs[name])
          this._cbs[name]();
      };
    } else if (EVENTS[name] === 1) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function(a) {
        this.events.push([name, a]);
        if (this._cbs[name])
          this._cbs[name](a);
      };
    } else if (EVENTS[name] === 2) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function(a, b) {
        this.events.push([name, a, b]);
        if (this._cbs[name])
          this._cbs[name](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
  CollectingHandler.prototype.onreset = function() {
    this.events = [];
    if (this._cbs.onreset)
      this._cbs.onreset();
  };
  CollectingHandler.prototype.restart = function() {
    if (this._cbs.onreset)
      this._cbs.onreset();
    for (var i = 0, len = this.events.length;i < len; i++) {
      if (this._cbs[this.events[i][0]]) {
        var num = this.events[i].length;
        if (num === 1) {
          this._cbs[this.events[i][0]]();
        } else if (num === 2) {
          this._cbs[this.events[i][0]](this.events[i][1]);
        } else {
          this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
        }
      }
    }
  };
});

// node_modules/htmlparser2/lib/index.js
var require_lib6 = __commonJS((exports, module) => {
  var Parser = require_Parser();
  var DomHandler = require_domhandler();
  function defineProp(name, value) {
    delete module.exports[name];
    module.exports[name] = value;
    return value;
  }
  module.exports = {
    Parser,
    Tokenizer: require_Tokenizer(),
    ElementType: require_domelementtype(),
    DomHandler,
    get FeedHandler() {
      return defineProp("FeedHandler", require_FeedHandler());
    },
    get Stream() {
      return defineProp("Stream", require_Stream());
    },
    get WritableStream() {
      return defineProp("WritableStream", require_WritableStream());
    },
    get ProxyHandler() {
      return defineProp("ProxyHandler", require_ProxyHandler());
    },
    get DomUtils() {
      return defineProp("DomUtils", require_domutils());
    },
    get CollectingHandler() {
      return defineProp("CollectingHandler", require_CollectingHandler());
    },
    DefaultHandler: DomHandler,
    get RssHandler() {
      return defineProp("RssHandler", this.FeedHandler);
    },
    parseDOM: function(data, options) {
      var handler = new DomHandler(options);
      new Parser(handler, options).end(data);
      return handler.dom;
    },
    parseFeed: function(feed, options) {
      var handler = new module.exports.FeedHandler(options);
      new Parser(handler, options).end(feed);
      return handler.dom;
    },
    createDomStream: function(cb, options, elementCb) {
      var handler = new DomHandler(cb, options, elementCb);
      return new Parser(handler, options);
    },
    EVENTS: {
      attribute: 2,
      cdatastart: 0,
      cdataend: 0,
      text: 1,
      processinginstruction: 2,
      comment: 1,
      commentend: 0,
      closetag: 1,
      opentag: 2,
      opentagname: 1,
      error: 1,
      end: 0
    }
  };
});

// node_modules/html-to-vdom/lib/parse-html.js
var require_parse_html = __commonJS((exports, module) => {
  var htmlparser = require_lib6();
  var parseHTML = function parseHTML(html) {
    var handler = new htmlparser.DomHandler;
    var parser = new htmlparser.Parser(handler, {
      lowerCaseAttributeNames: false
    });
    parser.parseComplete(html);
    return handler.dom;
  };
  module.exports = parseHTML;
});

// node_modules/html-to-vdom/lib/html-to-vdom.js
var require_html_to_vdom = __commonJS((exports, module) => {
  var createConverter = require_htmlparser_to_vdom();
  var parseHTML = require_parse_html();
  module.exports = function initializeHtmlToVdom(VTree, VText) {
    var htmlparserToVdom = createConverter(VTree, VText);
    return function convertHTML(options, html) {
      var noOptions = typeof html === "undefined" && typeof options === "string";
      var hasOptions = !noOptions;
      var htmlToConvert = noOptions ? options : html;
      var getVNodeKey = hasOptions ? options.getVNodeKey : undefined;
      var tags = parseHTML(htmlToConvert);
      var convertedHTML;
      if (tags.length > 1) {
        convertedHTML = tags.map(function(tag) {
          return htmlparserToVdom.convert(tag, getVNodeKey);
        });
      } else {
        convertedHTML = htmlparserToVdom.convert(tags[0], getVNodeKey);
      }
      return convertedHTML;
    };
  };
});

// node_modules/html-to-vdom/index.js
var require_html_to_vdom2 = __commonJS((exports, module) => {
  var convertHTML = require_html_to_vdom();
  module.exports = function initializeConverter(dependencies) {
    if (!dependencies.VNode || !dependencies.VText) {
      throw new Error("html-to-vdom needs to be initialized with VNode and VText");
    }
    return convertHTML(dependencies.VNode, dependencies.VText);
  };
});

// node_modules/virtual-dom/vnode/version.js
var require_version = __commonJS((exports, module) => {
  module.exports = "2";
});

// node_modules/virtual-dom/vnode/is-vnode.js
var require_is_vnode = __commonJS((exports, module) => {
  var version = require_version();
  module.exports = isVirtualNode;
  function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version;
  }
});

// node_modules/virtual-dom/vnode/is-widget.js
var require_is_widget = __commonJS((exports, module) => {
  module.exports = isWidget;
  function isWidget(w) {
    return w && w.type === "Widget";
  }
});

// node_modules/virtual-dom/vnode/is-thunk.js
var require_is_thunk = __commonJS((exports, module) => {
  module.exports = isThunk;
  function isThunk(t) {
    return t && t.type === "Thunk";
  }
});

// node_modules/virtual-dom/vnode/is-vhook.js
var require_is_vhook = __commonJS((exports, module) => {
  module.exports = isHook;
  function isHook(hook) {
    return hook && (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") || typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"));
  }
});

// node_modules/virtual-dom/vnode/vnode.js
var require_vnode = __commonJS((exports, module) => {
  var version = require_version();
  var isVNode = require_is_vnode();
  var isWidget = require_is_widget();
  var isThunk = require_is_thunk();
  var isVHook = require_is_vhook();
  module.exports = VirtualNode;
  var noProperties = {};
  var noChildren = [];
  function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName;
    this.properties = properties || noProperties;
    this.children = children || noChildren;
    this.key = key != null ? String(key) : undefined;
    this.namespace = typeof namespace === "string" ? namespace : null;
    var count = children && children.length || 0;
    var descendants = 0;
    var hasWidgets = false;
    var hasThunks = false;
    var descendantHooks = false;
    var hooks;
    for (var propName in properties) {
      if (properties.hasOwnProperty(propName)) {
        var property = properties[propName];
        if (isVHook(property) && property.unhook) {
          if (!hooks) {
            hooks = {};
          }
          hooks[propName] = property;
        }
      }
    }
    for (var i = 0;i < count; i++) {
      var child = children[i];
      if (isVNode(child)) {
        descendants += child.count || 0;
        if (!hasWidgets && child.hasWidgets) {
          hasWidgets = true;
        }
        if (!hasThunks && child.hasThunks) {
          hasThunks = true;
        }
        if (!descendantHooks && (child.hooks || child.descendantHooks)) {
          descendantHooks = true;
        }
      } else if (!hasWidgets && isWidget(child)) {
        if (typeof child.destroy === "function") {
          hasWidgets = true;
        }
      } else if (!hasThunks && isThunk(child)) {
        hasThunks = true;
      }
    }
    this.count = count + descendants;
    this.hasWidgets = hasWidgets;
    this.hasThunks = hasThunks;
    this.hooks = hooks;
    this.descendantHooks = descendantHooks;
  }
  VirtualNode.prototype.version = version;
  VirtualNode.prototype.type = "VirtualNode";
});

// node_modules/virtual-dom/vnode/vtext.js
var require_vtext = __commonJS((exports, module) => {
  var version = require_version();
  module.exports = VirtualText;
  function VirtualText(text) {
    this.text = String(text);
  }
  VirtualText.prototype.version = version;
  VirtualText.prototype.type = "VirtualText";
});

// node_modules/xmlbuilder2/lib/interfaces.js
var require_interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultXMLBuilderCBOptions = exports.XMLBuilderOptionKeys = exports.DefaultBuilderOptions = undefined;
  exports.DefaultBuilderOptions = {
    version: "1.0",
    encoding: undefined,
    standalone: undefined,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    skipWhitespaceOnlyText: true,
    convert: {
      att: "@",
      ins: "?",
      text: "#",
      cdata: "$",
      comment: "!"
    },
    defaultNamespace: {
      ele: undefined,
      att: undefined
    },
    namespaceAlias: {
      html: "http://www.w3.org/1999/xhtml",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/",
      mathml: "http://www.w3.org/1998/Math/MathML",
      svg: "http://www.w3.org/2000/svg",
      xlink: "http://www.w3.org/1999/xlink"
    },
    invalidCharReplacement: undefined,
    parser: undefined
  };
  exports.XMLBuilderOptionKeys = new Set(Object.keys(exports.DefaultBuilderOptions));
  exports.DefaultXMLBuilderCBOptions = {
    format: "xml",
    wellFormed: false,
    prettyPrint: false,
    indent: "  ",
    newline: `
`,
    offset: 0,
    width: 0,
    allowEmptyTags: false,
    spaceBeforeSlash: false,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    convert: {
      att: "@",
      ins: "?",
      text: "#",
      cdata: "$",
      comment: "!"
    },
    defaultNamespace: {
      ele: undefined,
      att: undefined
    },
    namespaceAlias: {
      html: "http://www.w3.org/1999/xhtml",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/",
      mathml: "http://www.w3.org/1998/Math/MathML",
      svg: "http://www.w3.org/2000/svg",
      xlink: "http://www.w3.org/1999/xlink"
    }
  };
});

// node_modules/@oozcitak/util/lib/FixedSizeSet.js
var FixedSizeSet;
var init_FixedSizeSet = __esm(() => {
  FixedSizeSet = class FixedSizeSet {
    _limit;
    _items = new Set;
    constructor(limit = 1000) {
      this._limit = limit;
    }
    add(item) {
      this._items.add(item);
      if (this._items.size > this._limit) {
        const it = this._items.values().next();
        if (!it.done) {
          this._items.delete(it.value);
        }
      }
      return this;
    }
    delete(item) {
      return this._items.delete(item);
    }
    has(item) {
      return this._items.has(item);
    }
    clear() {
      this._items.clear();
    }
    get size() {
      return this._items.size;
    }
    forEach(callback, thisArg) {
      this._items.forEach((e) => callback.call(thisArg, e, e, this));
    }
    *keys() {
      yield* this._items.keys();
    }
    *values() {
      yield* this._items.values();
    }
    *entries() {
      yield* this._items.entries();
    }
    *[Symbol.iterator]() {
      yield* this._items;
    }
    get [Symbol.toStringTag]() {
      return "FixedSizeSet";
    }
  };
});

// node_modules/@oozcitak/util/lib/ObjectCache.js
var ObjectCache;
var init_ObjectCache = __esm(() => {
  ObjectCache = class ObjectCache {
    _limit;
    _items = new Map;
    constructor(limit = 1000) {
      this._limit = limit;
    }
    get(key) {
      return this._items.get(key);
    }
    set(key, value) {
      this._items.set(key, value);
      if (this._items.size > this._limit) {
        const it = this._items.keys().next();
        if (!it.done) {
          this._items.delete(it.value);
        }
      }
    }
    delete(key) {
      return this._items.delete(key);
    }
    has(key) {
      return this._items.has(key);
    }
    clear() {
      this._items.clear();
    }
    get size() {
      return this._items.size;
    }
    forEach(callback, thisArg) {
      this._items.forEach((v, k) => callback.call(thisArg, k, v));
    }
    *keys() {
      yield* this._items.keys();
    }
    *values() {
      yield* this._items.values();
    }
    *entries() {
      yield* this._items.entries();
    }
    *[Symbol.iterator]() {
      yield* this._items;
    }
    get [Symbol.toStringTag]() {
      return "ObjectCache";
    }
  };
});

// node_modules/@oozcitak/util/lib/CompareCache.js
class CompareCache {
  _limit;
  _items = new Map;
  constructor(limit = 1000) {
    this._limit = limit;
  }
  check(objA, objB) {
    if (this._items.get(objA) === objB)
      return true;
    else if (this._items.get(objB) === objA)
      return false;
    const result = Math.random() < 0.5;
    if (result) {
      this._items.set(objA, objB);
    } else {
      this._items.set(objB, objA);
    }
    if (this._items.size > this._limit) {
      const it = this._items.keys().next();
      if (!it.done) {
        this._items.delete(it.value);
      }
    }
    return result;
  }
}

// node_modules/@oozcitak/util/lib/Lazy.js
class Lazy {
  _initialized = false;
  _initFunc;
  _value;
  constructor(initFunc) {
    this._value = undefined;
    this._initFunc = initFunc;
  }
  get value() {
    if (!this._initialized) {
      this._value = this._initFunc();
      this._initialized = true;
    }
    return this._value;
  }
}

// node_modules/@oozcitak/util/lib/StringWalker.js
class StringWalker {
  _chars;
  _length;
  _pointer = 0;
  _codePoint;
  _c;
  _remaining;
  _substring;
  constructor(input) {
    this._chars = Array.from(input);
    this._length = this._chars.length;
  }
  get eof() {
    return this._pointer >= this._length;
  }
  get length() {
    return this._length;
  }
  codePoint() {
    if (this._codePoint === undefined) {
      if (this.eof) {
        this._codePoint = -1;
      } else {
        const cp = this._chars[this._pointer].codePointAt(0);
        if (cp !== undefined) {
          this._codePoint = cp;
        } else {
          this._codePoint = -1;
        }
      }
    }
    return this._codePoint;
  }
  c() {
    if (this._c === undefined) {
      this._c = this.eof ? "" : this._chars[this._pointer];
    }
    return this._c;
  }
  remaining() {
    if (this._remaining === undefined) {
      this._remaining = this.eof ? "" : this._chars.slice(this._pointer + 1).join("");
    }
    return this._remaining;
  }
  substring() {
    if (this._substring === undefined) {
      this._substring = this.eof ? "" : this._chars.slice(this._pointer).join("");
    }
    return this._substring;
  }
  get pointer() {
    return this._pointer;
  }
  set pointer(val) {
    if (val === this._pointer)
      return;
    this._pointer = val;
    this._codePoint = undefined;
    this._c = undefined;
    this._remaining = undefined;
    this._substring = undefined;
  }
}

// node_modules/@oozcitak/util/lib/index.js
var exports_lib = {};
__export(exports_lib, {
  utf8Encode: () => utf8Encode,
  utf8Decode: () => utf8Decode,
  removeObjectValue: () => removeObjectValue,
  objectLength: () => objectLength,
  isString: () => isString,
  isSet: () => isSet,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  isNumber: () => isNumber,
  isMap: () => isMap,
  isIterable: () => isIterable,
  isFunction: () => isFunction,
  isEmpty: () => isEmpty,
  isBoolean: () => isBoolean,
  isArray: () => isArray,
  getValue: () => getValue,
  getObjectValue: () => getObjectValue,
  forEachObject: () => forEachObject,
  forEachArray: () => forEachArray,
  clone: () => clone,
  arrayLength: () => arrayLength,
  applyMixin: () => applyMixin,
  applyDefaults: () => applyDefaults,
  StringWalker: () => StringWalker,
  ObjectCache: () => ObjectCache,
  Lazy: () => Lazy,
  FixedSizeSet: () => FixedSizeSet,
  CompareCache: () => CompareCache
});
function applyMixin(baseClass, mixinClass, ...overrides) {
  Object.getOwnPropertyNames(mixinClass.prototype).forEach((name) => {
    if (name !== "constructor") {
      if (overrides.indexOf(name) !== -1) {
        const orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
        if (orgPropDesc) {
          Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
        }
      }
      const propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
      if (propDesc) {
        Object.defineProperty(baseClass.prototype, name, propDesc);
      }
    }
  });
}
function applyDefaults(obj, defaults, overwrite = false) {
  const result = clone(obj || {});
  forEachObject(defaults, (key, val) => {
    if (isPlainObject(val)) {
      result[key] = applyDefaults(result[key], val, overwrite);
    } else if (overwrite || result[key] === undefined) {
      result[key] = val;
    }
  });
  return result;
}
function forEachArray(arr, callback, thisArg) {
  arr.forEach(callback, thisArg);
}
function forEachObject(obj, callback, thisArg) {
  if (isMap(obj)) {
    obj.forEach((value, key) => callback.call(thisArg, key, value));
  } else {
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        callback.call(thisArg, key, obj[key]);
      }
    }
  }
}
function arrayLength(obj) {
  if (isSet(obj)) {
    return obj.size;
  } else {
    return obj.length;
  }
}
function objectLength(obj) {
  if (isMap(obj)) {
    return obj.size;
  } else {
    return Object.keys(obj).length;
  }
}
function getObjectValue(obj, key) {
  if (isMap(obj)) {
    return obj.get(key);
  } else {
    return obj[key];
  }
}
function removeObjectValue(obj, key) {
  if (isMap(obj)) {
    obj.delete(key);
  } else {
    delete obj[key];
  }
}
function clone(obj) {
  if (isFunction(obj)) {
    return obj;
  } else if (isArray(obj)) {
    const result = [];
    for (const item of obj) {
      result.push(clone(item));
    }
    return result;
  } else if (isPlainObject(obj)) {
    const result = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const val = obj[key];
        result[key] = clone(val);
      }
    }
    return result;
  } else {
    return obj;
  }
}
function isBoolean(x) {
  return typeof x === "boolean";
}
function isNumber(x) {
  return typeof x === "number";
}
function isString(x) {
  return typeof x === "string";
}
function isFunction(x) {
  return !!x && typeof x === "function";
}
function isObject(x) {
  const type = typeof x;
  return !!x && (type === "function" || type === "object");
}
function isArray(x) {
  return Array.isArray(x);
}
function isSet(x) {
  return x instanceof Set;
}
function isMap(x) {
  return x instanceof Map;
}
function isEmpty(x) {
  if (isArray(x)) {
    return !x.length;
  } else if (isSet(x)) {
    return !x.size;
  } else if (isMap(x)) {
    return !x.size;
  } else if (isObject(x)) {
    for (const key in x) {
      if (x.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function isPlainObject(x) {
  if (isObject(x)) {
    const proto = Object.getPrototypeOf(x);
    const ctor = proto.constructor;
    return proto && ctor && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
  }
  return false;
}
function isIterable(x) {
  return x && typeof x[Symbol.iterator] === "function";
}
function getValue(obj) {
  if (isFunction(obj.valueOf)) {
    return obj.valueOf();
  } else {
    return obj;
  }
}
function utf8Encode(input) {
  const bytes = new Uint8Array(input.length * 4);
  let byteIndex = 0;
  for (let i = 0;i < input.length; i++) {
    let char = input.charCodeAt(i);
    if (char < 128) {
      bytes[byteIndex++] = char;
      continue;
    } else if (char < 2048) {
      bytes[byteIndex++] = char >> 6 | 192;
    } else {
      if (char > 55295 && char < 56320) {
        if (++i >= input.length) {
          throw new Error("Incomplete surrogate pair.");
        }
        const c2 = input.charCodeAt(i);
        if (c2 < 56320 || c2 > 57343) {
          throw new Error("Invalid surrogate character.");
        }
        char = 65536 + ((char & 1023) << 10) + (c2 & 1023);
        bytes[byteIndex++] = char >> 18 | 240;
        bytes[byteIndex++] = char >> 12 & 63 | 128;
      } else {
        bytes[byteIndex++] = char >> 12 | 224;
      }
      bytes[byteIndex++] = char >> 6 & 63 | 128;
    }
    bytes[byteIndex++] = char & 63 | 128;
  }
  return bytes.subarray(0, byteIndex);
}
function utf8Decode(bytes) {
  let result = "";
  let i = 0;
  while (i < bytes.length) {
    var c = bytes[i++];
    if (c > 127) {
      if (c > 191 && c < 224) {
        if (i >= bytes.length) {
          throw new Error("Incomplete 2-byte sequence.");
        }
        c = (c & 31) << 6 | bytes[i++] & 63;
      } else if (c > 223 && c < 240) {
        if (i + 1 >= bytes.length) {
          throw new Error("Incomplete 3-byte sequence.");
        }
        c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
      } else if (c > 239 && c < 248) {
        if (i + 2 >= bytes.length) {
          throw new Error("Incomplete 4-byte sequence.");
        }
        c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
      } else {
        throw new Error("Unknown multi-byte start.");
      }
    }
    if (c <= 65535) {
      result += String.fromCharCode(c);
    } else if (c <= 1114111) {
      c -= 65536;
      result += String.fromCharCode(c >> 10 | 55296);
      result += String.fromCharCode(c & 1023 | 56320);
    } else {
      throw new Error("Code point exceeds UTF-16 limit.");
    }
  }
  return result;
}
var init_lib = __esm(() => {
  init_FixedSizeSet();
  init_ObjectCache();
});

// node_modules/@oozcitak/dom/lib/dom/interfaces.js
var require_interfaces2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HowToCompare = exports.WhatToShow = exports.FilterResult = exports.Position = exports.NodeType = exports.EventPhase = exports.BoundaryPosition = undefined;
  var BoundaryPosition;
  (function(BoundaryPosition2) {
    BoundaryPosition2[BoundaryPosition2["Before"] = 0] = "Before";
    BoundaryPosition2[BoundaryPosition2["Equal"] = 1] = "Equal";
    BoundaryPosition2[BoundaryPosition2["After"] = 2] = "After";
  })(BoundaryPosition || (exports.BoundaryPosition = BoundaryPosition = {}));
  var EventPhase;
  (function(EventPhase2) {
    EventPhase2[EventPhase2["None"] = 0] = "None";
    EventPhase2[EventPhase2["Capturing"] = 1] = "Capturing";
    EventPhase2[EventPhase2["AtTarget"] = 2] = "AtTarget";
    EventPhase2[EventPhase2["Bubbling"] = 3] = "Bubbling";
  })(EventPhase || (exports.EventPhase = EventPhase = {}));
  var NodeType;
  (function(NodeType2) {
    NodeType2[NodeType2["Element"] = 1] = "Element";
    NodeType2[NodeType2["Attribute"] = 2] = "Attribute";
    NodeType2[NodeType2["Text"] = 3] = "Text";
    NodeType2[NodeType2["CData"] = 4] = "CData";
    NodeType2[NodeType2["EntityReference"] = 5] = "EntityReference";
    NodeType2[NodeType2["Entity"] = 6] = "Entity";
    NodeType2[NodeType2["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    NodeType2[NodeType2["Comment"] = 8] = "Comment";
    NodeType2[NodeType2["Document"] = 9] = "Document";
    NodeType2[NodeType2["DocumentType"] = 10] = "DocumentType";
    NodeType2[NodeType2["DocumentFragment"] = 11] = "DocumentFragment";
    NodeType2[NodeType2["Notation"] = 12] = "Notation";
  })(NodeType || (exports.NodeType = NodeType = {}));
  var Position;
  (function(Position2) {
    Position2[Position2["SameNode"] = 0] = "SameNode";
    Position2[Position2["Disconnected"] = 1] = "Disconnected";
    Position2[Position2["Preceding"] = 2] = "Preceding";
    Position2[Position2["Following"] = 4] = "Following";
    Position2[Position2["Contains"] = 8] = "Contains";
    Position2[Position2["ContainedBy"] = 16] = "ContainedBy";
    Position2[Position2["ImplementationSpecific"] = 32] = "ImplementationSpecific";
  })(Position || (exports.Position = Position = {}));
  var FilterResult;
  (function(FilterResult2) {
    FilterResult2[FilterResult2["Accept"] = 1] = "Accept";
    FilterResult2[FilterResult2["Reject"] = 2] = "Reject";
    FilterResult2[FilterResult2["Skip"] = 3] = "Skip";
  })(FilterResult || (exports.FilterResult = FilterResult = {}));
  var WhatToShow;
  (function(WhatToShow2) {
    WhatToShow2[WhatToShow2["All"] = 4294967295] = "All";
    WhatToShow2[WhatToShow2["Element"] = 1] = "Element";
    WhatToShow2[WhatToShow2["Attribute"] = 2] = "Attribute";
    WhatToShow2[WhatToShow2["Text"] = 4] = "Text";
    WhatToShow2[WhatToShow2["CDataSection"] = 8] = "CDataSection";
    WhatToShow2[WhatToShow2["EntityReference"] = 16] = "EntityReference";
    WhatToShow2[WhatToShow2["Entity"] = 32] = "Entity";
    WhatToShow2[WhatToShow2["ProcessingInstruction"] = 64] = "ProcessingInstruction";
    WhatToShow2[WhatToShow2["Comment"] = 128] = "Comment";
    WhatToShow2[WhatToShow2["Document"] = 256] = "Document";
    WhatToShow2[WhatToShow2["DocumentType"] = 512] = "DocumentType";
    WhatToShow2[WhatToShow2["DocumentFragment"] = 1024] = "DocumentFragment";
    WhatToShow2[WhatToShow2["Notation"] = 2048] = "Notation";
  })(WhatToShow || (exports.WhatToShow = WhatToShow = {}));
  var HowToCompare;
  (function(HowToCompare2) {
    HowToCompare2[HowToCompare2["StartToStart"] = 0] = "StartToStart";
    HowToCompare2[HowToCompare2["StartToEnd"] = 1] = "StartToEnd";
    HowToCompare2[HowToCompare2["EndToEnd"] = 2] = "EndToEnd";
    HowToCompare2[HowToCompare2["EndToStart"] = 3] = "EndToStart";
  })(HowToCompare || (exports.HowToCompare = HowToCompare = {}));
});

// node_modules/@oozcitak/dom/lib/serializer/LocalNameSet.js
var require_LocalNameSet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LocalNameSet = undefined;

  class LocalNameSet {
    _items = {};
    _nullItems = {};
    set(ns, localName) {
      if (ns === null) {
        this._nullItems[localName] = true;
      } else if (this._items[ns]) {
        this._items[ns][localName] = true;
      } else {
        this._items[ns] = {};
        this._items[ns][localName] = true;
      }
    }
    has(ns, localName) {
      if (ns === null) {
        return this._nullItems[localName] === true;
      } else if (this._items[ns]) {
        return this._items[ns][localName] === true;
      } else {
        return false;
      }
    }
  }
  exports.LocalNameSet = LocalNameSet;
});

// node_modules/@oozcitak/dom/lib/serializer/NamespacePrefixMap.js
var require_NamespacePrefixMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NamespacePrefixMap = undefined;

  class NamespacePrefixMap {
    _items = {};
    _nullItems = [];
    copy() {
      const mapCopy = new NamespacePrefixMap;
      for (const key in this._items) {
        mapCopy._items[key] = this._items[key].slice(0);
      }
      mapCopy._nullItems = this._nullItems.slice(0);
      return mapCopy;
    }
    get(preferredPrefix, ns) {
      const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (candidatesList === null) {
        return null;
      }
      let prefix = null;
      for (let i = 0;i < candidatesList.length; i++) {
        prefix = candidatesList[i];
        if (prefix === preferredPrefix) {
          return prefix;
        }
      }
      return prefix;
    }
    has(prefix, ns) {
      const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (candidatesList === null) {
        return false;
      }
      return candidatesList.indexOf(prefix) !== -1;
    }
    hasPrefix(prefix) {
      if (this._nullItems.indexOf(prefix) !== -1)
        return true;
      for (const key in this._items) {
        if (this._items[key].indexOf(prefix) !== -1)
          return true;
      }
      return false;
    }
    set(prefix, ns) {
      const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (ns !== null && candidatesList === null) {
        this._items[ns] = [prefix];
      } else {
        candidatesList.push(prefix);
      }
    }
  }
  exports.NamespacePrefixMap = NamespacePrefixMap;
});

// node_modules/@oozcitak/infra/lib/CodePoints.js
var require_CodePoints = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ASCIIAlphanumeric = exports.ASCIIAlpha = exports.ASCIILowerAlpha = exports.ASCIIUpperAlpha = exports.ASCIIHexDigit = exports.ASCIILowerHexDigit = exports.ASCIIUpperHexDigit = exports.ASCIIDigit = exports.Control = exports.C0ControlOrSpace = exports.C0Control = exports.ASCIIWhiteSpace = exports.ASCIITabOrNewLine = exports.ASCIICodePoint = exports.NonCharacter = exports.ScalarValue = exports.Surrogate = undefined;
  exports.Surrogate = /[\uD800-\uDFFF]/;
  exports.ScalarValue = /[\uD800-\uDFFF]/;
  exports.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
  exports.ASCIICodePoint = /[\u0000-\u007F]/;
  exports.ASCIITabOrNewLine = /[\t\n\r]/;
  exports.ASCIIWhiteSpace = /[\t\n\f\r ]/;
  exports.C0Control = /[\u0000-\u001F]/;
  exports.C0ControlOrSpace = /[\u0000-\u001F ]/;
  exports.Control = /[\u0000-\u001F\u007F-\u009F]/;
  exports.ASCIIDigit = /[0-9]/;
  exports.ASCIIUpperHexDigit = /[0-9A-F]/;
  exports.ASCIILowerHexDigit = /[0-9a-f]/;
  exports.ASCIIHexDigit = /[0-9A-Fa-f]/;
  exports.ASCIIUpperAlpha = /[A-Z]/;
  exports.ASCIILowerAlpha = /[a-z]/;
  exports.ASCIIAlpha = /[A-Za-z]/;
  exports.ASCIIAlphanumeric = /[0-9A-Za-z]/;
});

// node_modules/@oozcitak/infra/lib/Base64.js
var require_Base64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.forgivingBase64Encode = forgivingBase64Encode;
  exports.forgivingBase64Decode = forgivingBase64Decode;
  var CodePoints_1 = require_CodePoints();
  function forgivingBase64Encode(input) {
    return Buffer.from(input).toString("base64");
  }
  function forgivingBase64Decode(input) {
    if (input === "")
      return "";
    input = input.replace(CodePoints_1.ASCIIWhiteSpace, "");
    if (input.length % 4 === 0) {
      if (input.endsWith("==")) {
        input = input.substr(0, input.length - 2);
      } else if (input.endsWith("=")) {
        input = input.substr(0, input.length - 1);
      }
    }
    if (input.length % 4 === 1)
      return null;
    if (!/[0-9A-Za-z+/]/.test(input))
      return null;
    return Buffer.from(input, "base64").toString("utf8");
  }
});

// node_modules/@oozcitak/infra/lib/Byte.js
var require_Byte = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isASCIIByte = isASCIIByte;
  function isASCIIByte(byte) {
    return byte >= 0 && byte <= 127;
  }
});

// node_modules/@oozcitak/infra/lib/ByteSequence.js
var require_ByteSequence = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.length = length;
  exports.byteLowercase = byteLowercase;
  exports.byteUppercase = byteUppercase;
  exports.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
  exports.startsWith = startsWith;
  exports.byteLessThan = byteLessThan;
  exports.isomorphicDecode = isomorphicDecode;
  function length(list) {
    return list.length;
  }
  function byteLowercase(list) {
    for (let i = 0;i < list.length; i++) {
      const c = list[i];
      if (c >= 65 && c <= 90) {
        list[i] = c + 32;
      }
    }
  }
  function byteUppercase(list) {
    for (let i = 0;i < list.length; i++) {
      const c = list[i];
      if (c >= 97 && c <= 122) {
        list[i] = c - 32;
      }
    }
  }
  function byteCaseInsensitiveMatch(listA, listB) {
    if (listA.length !== listB.length)
      return false;
    for (let i = 0;i < listA.length; i++) {
      let a = listA[i];
      let b = listB[i];
      if (a >= 65 && a <= 90)
        a += 32;
      if (b >= 65 && b <= 90)
        b += 32;
      if (a !== b)
        return false;
    }
    return true;
  }
  function startsWith(listA, listB) {
    let i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      if (listA[i] !== listB[i])
        return false;
      i++;
    }
  }
  function byteLessThan(listA, listB) {
    let i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      const a = listA[i];
      const b = listB[i];
      if (a < b)
        return true;
      else if (a > b)
        return false;
      i++;
    }
  }
  function isomorphicDecode(list) {
    return String.fromCodePoint(...list);
  }
});

// node_modules/@oozcitak/infra/lib/JSON.js
var require_JSON = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseJSONFromBytes = parseJSONFromBytes;
  exports.serializeJSONToBytes = serializeJSONToBytes;
  exports.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
  exports.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  function parseJSONFromBytes(bytes) {
    const jsonText = (0, util_1.utf8Decode)(bytes);
    return JSON.parse.call(undefined, jsonText);
  }
  function serializeJSONToBytes(value) {
    const jsonString = JSON.stringify.call(undefined, value);
    return (0, util_1.utf8Encode)(jsonString);
  }
  function parseJSONIntoInfraValues(jsonText) {
    const jsValue = JSON.parse.call(undefined, jsonText);
    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
  }
  function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
    if (jsValue === null || (0, util_1.isString)(jsValue) || (0, util_1.isNumber)(jsValue))
      return jsValue;
    if ((0, util_1.isArray)(jsValue)) {
      const result = new Array;
      for (const jsValueAtIndex of jsValue) {
        result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
      }
      return result;
    } else if ((0, util_1.isObject)(jsValue)) {
      const result = new Map;
      for (const key in jsValue) {
        if (jsValue.hasOwnProperty(key)) {
          const jsValueAtKey = jsValue[key];
          result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
        }
      }
      return result;
    }
    return jsValue;
  }
});

// node_modules/@oozcitak/infra/lib/List.js
var require_List = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.append = append;
  exports.extend = extend;
  exports.prepend = prepend;
  exports.replace = replace;
  exports.insert = insert;
  exports.remove = remove;
  exports.empty = empty;
  exports.contains = contains;
  exports.size = size;
  exports.isEmpty = isEmpty2;
  exports.forEach = forEach;
  exports.clone = clone2;
  exports.sortInAscendingOrder = sortInAscendingOrder;
  exports.sortInDescendingOrder = sortInDescendingOrder;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  function append(list, item) {
    list.push(item);
  }
  function extend(listA, listB) {
    listA.push(...listB);
  }
  function prepend(list, item) {
    list.unshift(item);
  }
  function replace(list, conditionOrItem, newItem) {
    let i = 0;
    for (const oldItem of list) {
      if ((0, util_1.isFunction)(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list[i] = newItem;
        }
      } else if (oldItem === conditionOrItem) {
        list[i] = newItem;
        return;
      }
      i++;
    }
  }
  function insert(list, item, index) {
    list.splice(index, 0, item);
  }
  function remove(list, conditionOrItem) {
    let i = list.length;
    while (i--) {
      const oldItem = list[i];
      if ((0, util_1.isFunction)(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list.splice(i, 1);
        }
      } else if (oldItem === conditionOrItem) {
        list.splice(i, 1);
        return;
      }
    }
  }
  function empty(list) {
    list.length = 0;
  }
  function contains(list, conditionOrItem) {
    for (const oldItem of list) {
      if ((0, util_1.isFunction)(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          return true;
        }
      } else if (oldItem === conditionOrItem) {
        return true;
      }
    }
    return false;
  }
  function size(list, condition) {
    if (condition === undefined) {
      return list.length;
    } else {
      let count = 0;
      for (const item of list) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  function isEmpty2(list) {
    return list.length === 0;
  }
  function* forEach(list, condition) {
    if (condition === undefined) {
      yield* list;
    } else {
      for (const item of list) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  function clone2(list) {
    return new Array(...list);
  }
  function sortInAscendingOrder(list, lessThanAlgo) {
    return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
  }
  function sortInDescendingOrder(list, lessThanAlgo) {
    return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
  }
});

// node_modules/@oozcitak/infra/lib/Map.js
var require_Map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.get = get;
  exports.set = set;
  exports.remove = remove;
  exports.contains = contains;
  exports.keys = keys;
  exports.values = values;
  exports.size = size;
  exports.isEmpty = isEmpty2;
  exports.forEach = forEach;
  exports.clone = clone2;
  exports.sortInAscendingOrder = sortInAscendingOrder;
  exports.sortInDescendingOrder = sortInDescendingOrder;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  function get(map, key) {
    return map.get(key);
  }
  function set(map, key, val) {
    map.set(key, val);
  }
  function remove(map, conditionOrItem) {
    if (!(0, util_1.isFunction)(conditionOrItem)) {
      map.delete(conditionOrItem);
    } else {
      const toRemove = [];
      for (const item of map) {
        if (!!conditionOrItem.call(null, item)) {
          toRemove.push(item[0]);
        }
      }
      for (const key of toRemove) {
        map.delete(key);
      }
    }
  }
  function contains(map, conditionOrItem) {
    if (!(0, util_1.isFunction)(conditionOrItem)) {
      return map.has(conditionOrItem);
    } else {
      for (const item of map) {
        if (!!conditionOrItem.call(null, item)) {
          return true;
        }
      }
      return false;
    }
  }
  function keys(map) {
    return new Set(map.keys());
  }
  function values(map) {
    return [...map.values()];
  }
  function size(map, condition) {
    if (condition === undefined) {
      return map.size;
    } else {
      let count = 0;
      for (const item of map) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  function isEmpty2(map) {
    return map.size === 0;
  }
  function* forEach(map, condition) {
    if (condition === undefined) {
      yield* map;
    } else {
      for (const item of map) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  function clone2(map) {
    return new Map(map);
  }
  function sortInAscendingOrder(map, lessThanAlgo) {
    const list = new Array(...map);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
    return new Map(list);
  }
  function sortInDescendingOrder(map, lessThanAlgo) {
    const list = new Array(...map);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
    return new Map(list);
  }
});

// node_modules/@oozcitak/infra/lib/Namespace.js
var require_Namespace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XLink = exports.SVG = exports.MathML = exports.XMLNS = exports.XML = exports.HTML = undefined;
  exports.HTML = "http://www.w3.org/1999/xhtml";
  exports.XML = "http://www.w3.org/XML/1998/namespace";
  exports.XMLNS = "http://www.w3.org/2000/xmlns/";
  exports.MathML = "http://www.w3.org/1998/Math/MathML";
  exports.SVG = "http://www.w3.org/2000/svg";
  exports.XLink = "http://www.w3.org/1999/xlink";
});

// node_modules/@oozcitak/infra/lib/Queue.js
var require_Queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enqueue = enqueue;
  exports.dequeue = dequeue;
  function enqueue(list, item) {
    list.push(item);
  }
  function dequeue(list) {
    return list.shift() || null;
  }
});

// node_modules/@oozcitak/infra/lib/Set.js
var require_Set = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.append = append;
  exports.extend = extend;
  exports.prepend = prepend;
  exports.replace = replace;
  exports.insert = insert;
  exports.remove = remove;
  exports.empty = empty;
  exports.contains = contains;
  exports.size = size;
  exports.isEmpty = isEmpty2;
  exports.forEach = forEach;
  exports.clone = clone2;
  exports.sortInAscendingOrder = sortInAscendingOrder;
  exports.sortInDescendingOrder = sortInDescendingOrder;
  exports.isSubsetOf = isSubsetOf;
  exports.isSupersetOf = isSupersetOf;
  exports.intersection = intersection;
  exports.union = union;
  exports.range = range;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  function append(set, item) {
    set.add(item);
  }
  function extend(setA, setB) {
    setB.forEach(setA.add, setA);
  }
  function prepend(set, item) {
    const cloned = new Set(set);
    set.clear();
    set.add(item);
    cloned.forEach(set.add, set);
  }
  function replace(set, conditionOrItem, newItem) {
    const newSet = new Set;
    for (const oldItem of set) {
      if ((0, util_1.isFunction)(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          newSet.add(newItem);
        } else {
          newSet.add(oldItem);
        }
      } else if (oldItem === conditionOrItem) {
        newSet.add(newItem);
      } else {
        newSet.add(oldItem);
      }
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  function insert(set, item, index) {
    const newSet = new Set;
    let i = 0;
    for (const oldItem of set) {
      if (i === index)
        newSet.add(item);
      newSet.add(oldItem);
      i++;
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  function remove(set, conditionOrItem) {
    if (!(0, util_1.isFunction)(conditionOrItem)) {
      set.delete(conditionOrItem);
    } else {
      const toRemove = [];
      for (const item of set) {
        if (!!conditionOrItem.call(null, item)) {
          toRemove.push(item);
        }
      }
      for (const oldItem of toRemove) {
        set.delete(oldItem);
      }
    }
  }
  function empty(set) {
    set.clear();
  }
  function contains(set, conditionOrItem) {
    if (!(0, util_1.isFunction)(conditionOrItem)) {
      return set.has(conditionOrItem);
    } else {
      for (const oldItem of set) {
        if (!!conditionOrItem.call(null, oldItem)) {
          return true;
        }
      }
    }
    return false;
  }
  function size(set, condition) {
    if (condition === undefined) {
      return set.size;
    } else {
      let count = 0;
      for (const item of set) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  function isEmpty2(set) {
    return set.size === 0;
  }
  function* forEach(set, condition) {
    if (condition === undefined) {
      yield* set;
    } else {
      for (const item of set) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  function clone2(set) {
    return new Set(set);
  }
  function sortInAscendingOrder(set, lessThanAlgo) {
    const list = new Array(...set);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
    return new Set(list);
  }
  function sortInDescendingOrder(set, lessThanAlgo) {
    const list = new Array(...set);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
    return new Set(list);
  }
  function isSubsetOf(subset, superset) {
    for (const item of subset) {
      if (!superset.has(item))
        return false;
    }
    return true;
  }
  function isSupersetOf(superset, subset) {
    return isSubsetOf(subset, superset);
  }
  function intersection(setA, setB) {
    const newSet = new Set;
    for (const item of setA) {
      if (setB.has(item))
        newSet.add(item);
    }
    return newSet;
  }
  function union(setA, setB) {
    const newSet = new Set(setA);
    setB.forEach(newSet.add, newSet);
    return newSet;
  }
  function range(n, m) {
    const newSet = new Set;
    for (let i = n;i <= m; i++) {
      newSet.add(i);
    }
    return newSet;
  }
});

// node_modules/@oozcitak/infra/lib/Stack.js
var require_Stack = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.push = push;
  exports.pop = pop;
  function push(list, item) {
    list.push(item);
  }
  function pop(list) {
    return list.pop() || null;
  }
});

// node_modules/@oozcitak/infra/lib/String.js
var require_String = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCodeUnitPrefix = isCodeUnitPrefix;
  exports.isCodeUnitLessThan = isCodeUnitLessThan;
  exports.isomorphicEncode = isomorphicEncode;
  exports.isASCIIString = isASCIIString;
  exports.asciiLowercase = asciiLowercase;
  exports.asciiUppercase = asciiUppercase;
  exports.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
  exports.asciiEncode = asciiEncode;
  exports.asciiDecode = asciiDecode;
  exports.stripNewlines = stripNewlines;
  exports.normalizeNewlines = normalizeNewlines;
  exports.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
  exports.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
  exports.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
  exports.skipASCIIWhitespace = skipASCIIWhitespace;
  exports.strictlySplit = strictlySplit;
  exports.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
  exports.splitAStringOnCommas = splitAStringOnCommas;
  exports.concatenate = concatenate;
  var CodePoints_1 = require_CodePoints();
  var ByteSequence_1 = require_ByteSequence();
  var Byte_1 = require_Byte();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  function isCodeUnitPrefix(a, b) {
    let i = 0;
    while (true) {
      const aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
      const bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
      if (aCodeUnit === null)
        return true;
      if (aCodeUnit !== bCodeUnit)
        return false;
      i++;
    }
  }
  function isCodeUnitLessThan(a, b) {
    if (isCodeUnitPrefix(b, a))
      return false;
    if (isCodeUnitPrefix(a, b))
      return true;
    for (let i = 0;i < Math.min(a.length, b.length); i++) {
      const aCodeUnit = a.charCodeAt(i);
      const bCodeUnit = b.charCodeAt(i);
      if (aCodeUnit === bCodeUnit)
        continue;
      return aCodeUnit < bCodeUnit;
    }
    return false;
  }
  function isomorphicEncode(str) {
    const codePoints = Array.from(str);
    const bytes = new Uint8Array(codePoints.length);
    let i = 0;
    for (const codePoint of str) {
      const byte = codePoint.codePointAt(0);
      console.assert(byte !== undefined && byte <= 255, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
      if (byte !== undefined && byte <= 255) {
        bytes[i++] = byte;
      }
    }
    return bytes;
  }
  function isASCIIString(str) {
    return /^[\u0000-\u007F]*$/.test(str);
  }
  function asciiLowercase(str) {
    let result = "";
    for (const c of str) {
      const code = c.codePointAt(0);
      if (code !== undefined && code >= 65 && code <= 90) {
        result += String.fromCodePoint(code + 32);
      } else {
        result += c;
      }
    }
    return result;
  }
  function asciiUppercase(str) {
    let result = "";
    for (const c of str) {
      const code = c.codePointAt(0);
      if (code !== undefined && code >= 97 && code <= 122) {
        result += String.fromCodePoint(code - 32);
      } else {
        result += c;
      }
    }
    return result;
  }
  function asciiCaseInsensitiveMatch(a, b) {
    return asciiLowercase(a) === asciiLowercase(b);
  }
  function asciiEncode(str) {
    console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
    return isomorphicEncode(str);
  }
  function asciiDecode(bytes) {
    for (const byte of bytes) {
      console.assert((0, Byte_1.isASCIIByte)(byte), "asciiDecode requires an ASCII byte sequence.");
    }
    return (0, ByteSequence_1.isomorphicDecode)(bytes);
  }
  function stripNewlines(str) {
    return str.replace(/[\n\r]/g, "");
  }
  function normalizeNewlines(str) {
    return str.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
  }
  function stripLeadingAndTrailingASCIIWhitespace(str) {
    return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
  }
  function stripAndCollapseASCIIWhitespace(str) {
    return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
  }
  function collectASequenceOfCodePoints(condition, input, options) {
    if (!(0, util_1.isArray)(input))
      return collectASequenceOfCodePoints(condition, Array.from(input), options);
    let result = "";
    while (options.position < input.length && !!condition.call(null, input[options.position])) {
      result += input[options.position];
      options.position++;
    }
    return result;
  }
  function skipASCIIWhitespace(input, options) {
    collectASequenceOfCodePoints((str) => CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
  }
  function strictlySplit(input, delimiter) {
    if (!(0, util_1.isArray)(input))
      return strictlySplit(Array.from(input), delimiter);
    const options = { position: 0 };
    const tokens = [];
    let token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
    tokens.push(token);
    while (options.position < input.length) {
      console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
      options.position++;
      token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
      tokens.push(token);
    }
    return tokens;
  }
  function splitAStringOnASCIIWhitespace(input) {
    if (!(0, util_1.isArray)(input))
      return splitAStringOnASCIIWhitespace(Array.from(input));
    const options = { position: 0 };
    const tokens = [];
    skipASCIIWhitespace(input, options);
    while (options.position < input.length) {
      const token = collectASequenceOfCodePoints((str) => !CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
      tokens.push(token);
      skipASCIIWhitespace(input, options);
    }
    return tokens;
  }
  function splitAStringOnCommas(input) {
    if (!(0, util_1.isArray)(input))
      return splitAStringOnCommas(Array.from(input));
    const options = { position: 0 };
    const tokens = [];
    while (options.position < input.length) {
      const token = collectASequenceOfCodePoints((str) => str !== ",", input, options);
      tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
      if (options.position < input.length) {
        console.assert(input[options.position] === ",", "splitAStringOnCommas found no delimiter in input string.");
        options.position++;
      }
    }
    return tokens;
  }
  function concatenate(list, separator = "") {
    if (list.length === 0)
      return "";
    return list.join(separator);
  }
});

// node_modules/@oozcitak/infra/lib/index.js
var require_lib7 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.string = exports.stack = exports.set = exports.queue = exports.namespace = exports.map = exports.list = exports.json = exports.codePoint = exports.byteSequence = exports.byte = exports.base64 = undefined;
  var base64 = __importStar(require_Base64());
  exports.base64 = base64;
  var byte = __importStar(require_Byte());
  exports.byte = byte;
  var byteSequence = __importStar(require_ByteSequence());
  exports.byteSequence = byteSequence;
  var codePoint = __importStar(require_CodePoints());
  exports.codePoint = codePoint;
  var json = __importStar(require_JSON());
  exports.json = json;
  var list = __importStar(require_List());
  exports.list = list;
  var map = __importStar(require_Map());
  exports.map = map;
  var namespace = __importStar(require_Namespace());
  exports.namespace = namespace;
  var queue = __importStar(require_Queue());
  exports.queue = queue;
  var set = __importStar(require_Set());
  exports.set = set;
  var stack = __importStar(require_Stack());
  exports.stack = stack;
  var string = __importStar(require_String());
  exports.string = string;
});

// node_modules/@oozcitak/dom/lib/algorithm/WebIDLAlgorithm.js
var require_WebIDLAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.idl_defineConst = idl_defineConst;
  function idl_defineConst(o, name, value) {
    Object.defineProperty(o, name, { writable: false, enumerable: true, configurable: false, value });
  }
});

// node_modules/@oozcitak/dom/lib/dom/DOMImplementationImpl.js
var require_DOMImplementationImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DOMImplementationImpl = undefined;
  var DOMImpl_1 = require_DOMImpl();
  var infra_1 = require_lib7();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class DOMImplementationImpl {
    _ID = "@oozcitak/dom";
    _associatedDocument;
    constructor(document2) {
      this._associatedDocument = document2 || DOMImpl_1.dom.window.document;
    }
    createDocumentType(qualifiedName, publicId, systemId) {
      (0, algorithm_1.namespace_validate)(qualifiedName);
      return (0, algorithm_1.create_documentType)(this._associatedDocument, qualifiedName, publicId, systemId);
    }
    createDocument(namespace, qualifiedName, doctype = null) {
      const document2 = (0, algorithm_1.create_xmlDocument)();
      let element = null;
      if (qualifiedName) {
        element = (0, algorithm_1.document_internalCreateElementNS)(document2, namespace, qualifiedName);
      }
      if (doctype)
        document2.appendChild(doctype);
      if (element)
        document2.appendChild(element);
      document2._origin = this._associatedDocument._origin;
      if (namespace === infra_1.namespace.HTML)
        document2._contentType = "application/xhtml+xml";
      else if (namespace === infra_1.namespace.SVG)
        document2._contentType = "image/svg+xml";
      else
        document2._contentType = "application/xml";
      return document2;
    }
    createHTMLDocument(title) {
      const doc = (0, algorithm_1.create_document)();
      doc._type = "html";
      doc._contentType = "text/html";
      doc.appendChild((0, algorithm_1.create_documentType)(doc, "html", "", ""));
      const htmlElement = (0, algorithm_1.element_createAnElement)(doc, "html", infra_1.namespace.HTML);
      doc.appendChild(htmlElement);
      const headElement = (0, algorithm_1.element_createAnElement)(doc, "head", infra_1.namespace.HTML);
      htmlElement.appendChild(headElement);
      if (title !== undefined) {
        const titleElement = (0, algorithm_1.element_createAnElement)(doc, "title", infra_1.namespace.HTML);
        headElement.appendChild(titleElement);
        const textElement = (0, algorithm_1.create_text)(doc, title);
        titleElement.appendChild(textElement);
      }
      const bodyElement = (0, algorithm_1.element_createAnElement)(doc, "body", infra_1.namespace.HTML);
      htmlElement.appendChild(bodyElement);
      doc._origin = this._associatedDocument._origin;
      return doc;
    }
    hasFeature() {
      return true;
    }
    static _create(document2) {
      return new DOMImplementationImpl(document2);
    }
  }
  exports.DOMImplementationImpl = DOMImplementationImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(DOMImplementationImpl.prototype, "_ID", "@oozcitak/dom");
});

// node_modules/@oozcitak/dom/lib/dom/DOMException.js
var require_DOMException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidCharacterError = exports.SyntaxError = exports.IndexSizeError = exports.NotFoundError = exports.HierarchyRequestError = exports.NotImplementedError = exports.DataCloneError = exports.InvalidNodeTypeError = exports.TimeoutError = exports.QuotaExceededError = exports.URLMismatchError = exports.AbortError = exports.NetworkError = exports.SecurityError = exports.TypeMismatchError = exports.ValidationError = exports.InvalidAccessError = exports.NamespaceError = exports.InvalidModificationError = exports.InvalidStateError = exports.InUseAttributeError = exports.NotSupportedError = exports.NoModificationAllowedError = exports.NoDataAllowedError = exports.WrongDocumentError = exports.DOMStringSizeError = exports.DOMException = undefined;

  class DOMException extends Error {
    name;
    constructor(name, message = "") {
      super(message);
      this.name = name;
    }
  }
  exports.DOMException = DOMException;

  class DOMStringSizeError extends DOMException {
    constructor(message = "") {
      super("DOMStringSizeError", message);
    }
  }
  exports.DOMStringSizeError = DOMStringSizeError;

  class WrongDocumentError extends DOMException {
    constructor(message = "") {
      super("WrongDocumentError", "The object is in the wrong document. " + message);
    }
  }
  exports.WrongDocumentError = WrongDocumentError;

  class NoDataAllowedError extends DOMException {
    constructor(message = "") {
      super("NoDataAllowedError", message);
    }
  }
  exports.NoDataAllowedError = NoDataAllowedError;

  class NoModificationAllowedError extends DOMException {
    constructor(message = "") {
      super("NoModificationAllowedError", "The object can not be modified. " + message);
    }
  }
  exports.NoModificationAllowedError = NoModificationAllowedError;

  class NotSupportedError extends DOMException {
    constructor(message = "") {
      super("NotSupportedError", "The operation is not supported. " + message);
    }
  }
  exports.NotSupportedError = NotSupportedError;

  class InUseAttributeError extends DOMException {
    constructor(message = "") {
      super("InUseAttributeError", message);
    }
  }
  exports.InUseAttributeError = InUseAttributeError;

  class InvalidStateError extends DOMException {
    constructor(message = "") {
      super("InvalidStateError", "The object is in an invalid state. " + message);
    }
  }
  exports.InvalidStateError = InvalidStateError;

  class InvalidModificationError extends DOMException {
    constructor(message = "") {
      super("InvalidModificationError", "The object can not be modified in this way. " + message);
    }
  }
  exports.InvalidModificationError = InvalidModificationError;

  class NamespaceError extends DOMException {
    constructor(message = "") {
      super("NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + message);
    }
  }
  exports.NamespaceError = NamespaceError;

  class InvalidAccessError extends DOMException {
    constructor(message = "") {
      super("InvalidAccessError", "The object does not support the operation or argument. " + message);
    }
  }
  exports.InvalidAccessError = InvalidAccessError;

  class ValidationError extends DOMException {
    constructor(message = "") {
      super("ValidationError", message);
    }
  }
  exports.ValidationError = ValidationError;

  class TypeMismatchError extends DOMException {
    constructor(message = "") {
      super("TypeMismatchError", message);
    }
  }
  exports.TypeMismatchError = TypeMismatchError;

  class SecurityError extends DOMException {
    constructor(message = "") {
      super("SecurityError", "The operation is insecure. " + message);
    }
  }
  exports.SecurityError = SecurityError;

  class NetworkError extends DOMException {
    constructor(message = "") {
      super("NetworkError", "A network error occurred. " + message);
    }
  }
  exports.NetworkError = NetworkError;

  class AbortError extends DOMException {
    constructor(message = "") {
      super("AbortError", "The operation was aborted. " + message);
    }
  }
  exports.AbortError = AbortError;

  class URLMismatchError extends DOMException {
    constructor(message = "") {
      super("URLMismatchError", "The given URL does not match another URL. " + message);
    }
  }
  exports.URLMismatchError = URLMismatchError;

  class QuotaExceededError extends DOMException {
    constructor(message = "") {
      super("QuotaExceededError", "The quota has been exceeded. " + message);
    }
  }
  exports.QuotaExceededError = QuotaExceededError;

  class TimeoutError extends DOMException {
    constructor(message = "") {
      super("TimeoutError", "The operation timed out. " + message);
    }
  }
  exports.TimeoutError = TimeoutError;

  class InvalidNodeTypeError extends DOMException {
    constructor(message = "") {
      super("InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + message);
    }
  }
  exports.InvalidNodeTypeError = InvalidNodeTypeError;

  class DataCloneError extends DOMException {
    constructor(message = "") {
      super("DataCloneError", "The object can not be cloned. " + message);
    }
  }
  exports.DataCloneError = DataCloneError;

  class NotImplementedError extends DOMException {
    constructor(message = "") {
      super("NotImplementedError", "The DOM method is not implemented by this module. " + message);
    }
  }
  exports.NotImplementedError = NotImplementedError;

  class HierarchyRequestError extends DOMException {
    constructor(message = "") {
      super("HierarchyRequestError", "The operation would yield an incorrect node tree. " + message);
    }
  }
  exports.HierarchyRequestError = HierarchyRequestError;

  class NotFoundError extends DOMException {
    constructor(message = "") {
      super("NotFoundError", "The object can not be found here. " + message);
    }
  }
  exports.NotFoundError = NotFoundError;

  class IndexSizeError extends DOMException {
    constructor(message = "") {
      super("IndexSizeError", "The index is not in the allowed range. " + message);
    }
  }
  exports.IndexSizeError = IndexSizeError;

  class SyntaxError2 extends DOMException {
    constructor(message = "") {
      super("SyntaxError", "The string did not match the expected pattern. " + message);
    }
  }
  exports.SyntaxError = SyntaxError2;

  class InvalidCharacterError extends DOMException {
    constructor(message = "") {
      super("InvalidCharacterError", "The string contains invalid characters. " + message);
    }
  }
  exports.InvalidCharacterError = InvalidCharacterError;
});

// node_modules/@oozcitak/dom/lib/util/Guard.js
var require_Guard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Guard = undefined;
  var interfaces_1 = require_interfaces2();

  class Guard {
    static isNode(a) {
      return !!a && a._nodeType !== undefined;
    }
    static isDocumentNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Document;
    }
    static isDocumentTypeNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentType;
    }
    static isDocumentFragmentNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentFragment;
    }
    static isAttrNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Attribute;
    }
    static isCharacterDataNode(a) {
      if (!Guard.isNode(a))
        return false;
      const type = a._nodeType;
      return type === interfaces_1.NodeType.Text || type === interfaces_1.NodeType.ProcessingInstruction || type === interfaces_1.NodeType.Comment || type === interfaces_1.NodeType.CData;
    }
    static isTextNode(a) {
      return Guard.isNode(a) && (a._nodeType === interfaces_1.NodeType.Text || a._nodeType === interfaces_1.NodeType.CData);
    }
    static isExclusiveTextNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Text;
    }
    static isCDATASectionNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.CData;
    }
    static isCommentNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Comment;
    }
    static isProcessingInstructionNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.ProcessingInstruction;
    }
    static isElementNode(a) {
      return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Element;
    }
    static isCustomElementNode(a) {
      return Guard.isElementNode(a) && a._customElementState === "custom";
    }
    static isShadowRoot(a) {
      return !!a && a.host !== undefined;
    }
    static isMouseEvent(a) {
      return !!a && a.screenX !== undefined && a.screenY != null;
    }
    static isSlotable(a) {
      return !!a && a._name !== undefined && a._assignedSlot !== undefined && (Guard.isTextNode(a) || Guard.isElementNode(a));
    }
    static isSlot(a) {
      return !!a && a._name !== undefined && a._assignedNodes !== undefined && Guard.isElementNode(a);
    }
    static isWindow(a) {
      return !!a && a.navigator !== undefined;
    }
    static isEventListener(a) {
      return !!a && a.handleEvent !== undefined;
    }
    static isRegisteredObserver(a) {
      return !!a && a.observer !== undefined && a.options !== undefined;
    }
    static isTransientRegisteredObserver(a) {
      return !!a && a.source !== undefined && Guard.isRegisteredObserver(a);
    }
  }
  exports.Guard = Guard;
});

// node_modules/@oozcitak/dom/lib/util/Cast.js
var require_Cast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cast = undefined;
  var Guard_1 = require_Guard();

  class Cast {
    static asNode(a) {
      if (Guard_1.Guard.isNode(a)) {
        return a;
      } else {
        throw new Error("Invalid object. Node expected.");
      }
    }
  }
  exports.Cast = Cast;
});

// node_modules/@oozcitak/dom/lib/util/EmptySet.js
var require_EmptySet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmptySet = undefined;

  class EmptySet {
    get size() {
      return 0;
    }
    add(value) {
      throw new Error("Cannot add to an empty set.");
    }
    clear() {}
    delete(value) {
      return false;
    }
    forEach(callbackfn, thisArg) {}
    has(value) {
      return false;
    }
    [Symbol.iterator]() {
      return new EmptySetIterator;
    }
    entries() {
      return new EmptySetIterator;
    }
    keys() {
      return new EmptySetIterator;
    }
    values() {
      return new EmptySetIterator;
    }
    get [Symbol.toStringTag]() {
      return "EmptySet";
    }
  }
  exports.EmptySet = EmptySet;

  class EmptySetIterator {
    [Symbol.iterator]() {
      return this;
    }
    next() {
      return { done: true, value: null };
    }
  }
});

// node_modules/@oozcitak/dom/lib/util/index.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmptySet = exports.Guard = exports.Cast = undefined;
  var Cast_1 = require_Cast();
  Object.defineProperty(exports, "Cast", { enumerable: true, get: function() {
    return Cast_1.Cast;
  } });
  var Guard_1 = require_Guard();
  Object.defineProperty(exports, "Guard", { enumerable: true, get: function() {
    return Guard_1.Guard;
  } });
  var EmptySet_1 = require_EmptySet();
  Object.defineProperty(exports, "EmptySet", { enumerable: true, get: function() {
    return EmptySet_1.EmptySet;
  } });
});

// node_modules/@oozcitak/dom/lib/dom/EventTargetImpl.js
var require_EventTargetImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTargetImpl = undefined;
  var DOMException_1 = require_DOMException();
  var util_1 = require_util2();
  var algorithm_1 = require_algorithm();

  class EventTargetImpl {
    __eventListenerList;
    get _eventListenerList() {
      return this.__eventListenerList || (this.__eventListenerList = []);
    }
    __eventHandlerMap;
    get _eventHandlerMap() {
      return this.__eventHandlerMap || (this.__eventHandlerMap = {});
    }
    constructor() {}
    addEventListener(type, callback, options = { passive: false, once: false, capture: false }) {
      const [capture, passive, once] = (0, algorithm_1.eventTarget_flattenMore)(options);
      let listenerCallback;
      if (!callback) {
        return;
      } else if (util_1.Guard.isEventListener(callback)) {
        listenerCallback = callback;
      } else {
        listenerCallback = { handleEvent: callback };
      }
      (0, algorithm_1.eventTarget_addEventListener)(this, {
        type,
        callback: listenerCallback,
        capture,
        passive,
        once,
        removed: false
      });
    }
    removeEventListener(type, callback, options = { capture: false }) {
      const capture = (0, algorithm_1.eventTarget_flatten)(options);
      if (!callback)
        return;
      for (let i = 0;i < this._eventListenerList.length; i++) {
        const entry = this._eventListenerList[i];
        if (entry.type !== type || entry.capture !== capture)
          continue;
        if (util_1.Guard.isEventListener(callback) && entry.callback === callback) {
          (0, algorithm_1.eventTarget_removeEventListener)(this, entry, i);
          break;
        } else if (callback && entry.callback.handleEvent === callback) {
          (0, algorithm_1.eventTarget_removeEventListener)(this, entry, i);
          break;
        }
      }
    }
    dispatchEvent(event) {
      if (event._dispatchFlag || !event._initializedFlag) {
        throw new DOMException_1.InvalidStateError;
      }
      event._isTrusted = false;
      return (0, algorithm_1.event_dispatch)(event, this);
    }
    _getTheParent(event) {
      return null;
    }
  }
  exports.EventTargetImpl = EventTargetImpl;
});

// node_modules/@oozcitak/dom/lib/dom/WindowImpl.js
var require_WindowImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WindowImpl = undefined;
  var EventTargetImpl_1 = require_EventTargetImpl();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var algorithm_1 = require_algorithm();

  class WindowImpl extends EventTargetImpl_1.EventTargetImpl {
    _currentEvent;
    _signalSlots = new Set;
    _mutationObserverMicrotaskQueued = false;
    _mutationObservers = new Set;
    _associatedDocument;
    _iteratorList = new util_1.FixedSizeSet;
    constructor() {
      super();
      this._associatedDocument = (0, algorithm_1.create_document)();
    }
    get document() {
      return this._associatedDocument;
    }
    get event() {
      return this._currentEvent;
    }
    static _create() {
      return new WindowImpl;
    }
  }
  exports.WindowImpl = WindowImpl;
});

// node_modules/@oozcitak/url/lib/interfaces.js
var require_interfaces3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OpaqueOrigin = exports.ParserState = undefined;
  var ParserState;
  (function(ParserState2) {
    ParserState2[ParserState2["SchemeStart"] = 0] = "SchemeStart";
    ParserState2[ParserState2["Scheme"] = 1] = "Scheme";
    ParserState2[ParserState2["NoScheme"] = 2] = "NoScheme";
    ParserState2[ParserState2["SpecialRelativeOrAuthority"] = 3] = "SpecialRelativeOrAuthority";
    ParserState2[ParserState2["PathOrAuthority"] = 4] = "PathOrAuthority";
    ParserState2[ParserState2["Relative"] = 5] = "Relative";
    ParserState2[ParserState2["RelativeSlash"] = 6] = "RelativeSlash";
    ParserState2[ParserState2["SpecialAuthoritySlashes"] = 7] = "SpecialAuthoritySlashes";
    ParserState2[ParserState2["SpecialAuthorityIgnoreSlashes"] = 8] = "SpecialAuthorityIgnoreSlashes";
    ParserState2[ParserState2["Authority"] = 9] = "Authority";
    ParserState2[ParserState2["Host"] = 10] = "Host";
    ParserState2[ParserState2["Hostname"] = 11] = "Hostname";
    ParserState2[ParserState2["Port"] = 12] = "Port";
    ParserState2[ParserState2["File"] = 13] = "File";
    ParserState2[ParserState2["FileSlash"] = 14] = "FileSlash";
    ParserState2[ParserState2["FileHost"] = 15] = "FileHost";
    ParserState2[ParserState2["PathStart"] = 16] = "PathStart";
    ParserState2[ParserState2["Path"] = 17] = "Path";
    ParserState2[ParserState2["CannotBeABaseURLPath"] = 18] = "CannotBeABaseURLPath";
    ParserState2[ParserState2["Query"] = 19] = "Query";
    ParserState2[ParserState2["Fragment"] = 20] = "Fragment";
  })(ParserState || (exports.ParserState = ParserState = {}));
  exports.OpaqueOrigin = ["", "", null, null];
});

// node_modules/@oozcitak/url/lib/URLAlgorithm.js
var require_URLAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setValidationErrorCallback = setValidationErrorCallback;
  exports.newURL = newURL;
  exports.isSpecialScheme = isSpecialScheme;
  exports.isSpecial = isSpecial;
  exports.defaultPort = defaultPort;
  exports.includesCredentials = includesCredentials;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.urlSerializer = urlSerializer;
  exports.hostSerializer = hostSerializer;
  exports.iPv4Serializer = iPv4Serializer;
  exports.iPv6Serializer = iPv6Serializer;
  exports.urlParser = urlParser;
  exports.basicURLParser = basicURLParser;
  exports.setTheUsername = setTheUsername;
  exports.setThePassword = setThePassword;
  exports.isSingleDotPathSegment = isSingleDotPathSegment;
  exports.isDoubleDotPathSegment = isDoubleDotPathSegment;
  exports.shorten = shorten;
  exports.isNormalizedWindowsDriveLetter = isNormalizedWindowsDriveLetter;
  exports.isWindowsDriveLetter = isWindowsDriveLetter;
  exports.startsWithAWindowsDriveLetter = startsWithAWindowsDriveLetter;
  exports.hostParser = hostParser;
  exports.iPv4NumberParser = iPv4NumberParser;
  exports.iPv4Parser = iPv4Parser;
  exports.iPv6Parser = iPv6Parser;
  exports.opaqueHostParser = opaqueHostParser;
  exports.resolveABlobURL = resolveABlobURL;
  exports.percentEncode = percentEncode;
  exports.percentDecode = percentDecode;
  exports.stringPercentDecode = stringPercentDecode;
  exports.utf8PercentEncode = utf8PercentEncode;
  exports.hostEquals = hostEquals;
  exports.urlEquals = urlEquals;
  exports.urlEncodedStringParser = urlEncodedStringParser;
  exports.urlEncodedParser = urlEncodedParser;
  exports.urlEncodedByteSerializer = urlEncodedByteSerializer;
  exports.urlEncodedSerializer = urlEncodedSerializer;
  exports.origin = origin;
  exports.domainToASCII = domainToASCII;
  exports.domainToUnicode = domainToUnicode;
  exports.asciiSerializationOfAnOrigin = asciiSerializationOfAnOrigin;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var interfaces_1 = require_interfaces3();
  var infra_1 = require_lib7();
  var url_1 = __require("url");
  var _validationErrorCallback;
  var _defaultPorts = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var _c0ControlPercentEncodeSet = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var _fragmentPercentEncodeSet = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var _pathPercentEncodeSet = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var _userInfoPercentEncodeSet = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var _urlCodePoints = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/;
  var _forbiddenHostCodePoint = /[\0\t\f\r #%/:?@\[\\\]]/;
  function setValidationErrorCallback(validationErrorCallback) {
    _validationErrorCallback = validationErrorCallback;
  }
  function validationError(message) {
    if (_validationErrorCallback !== undefined) {
      _validationErrorCallback.call(null, "Validation Error: " + message);
    }
  }
  function newURL() {
    return {
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,
      _cannotBeABaseURLFlag: false,
      _blobURLEntry: null
    };
  }
  function isSpecialScheme(scheme) {
    return scheme in _defaultPorts;
  }
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  function defaultPort(scheme) {
    return _defaultPorts[scheme] || null;
  }
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url._cannotBeABaseURLFlag || url.scheme === "file";
  }
  function urlSerializer(url, excludeFragmentFlag = false) {
    let output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (includesCredentials(url)) {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += hostSerializer(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url._cannotBeABaseURLFlag) {
      output += url.path[0];
    } else {
      for (const str of url.path) {
        output += "/" + str;
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragmentFlag && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  }
  function hostSerializer(host) {
    if ((0, util_1.isNumber)(host)) {
      return iPv4Serializer(host);
    } else if ((0, util_1.isArray)(host)) {
      return "[" + iPv6Serializer(host) + "]";
    } else {
      return host;
    }
  }
  function iPv4Serializer(address) {
    let output = "";
    let n = address;
    for (let i = 1;i <= 4; i++) {
      output = (n % 256).toString() + output;
      if (i !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  }
  function iPv6Serializer(address) {
    let output = "";
    let compress = null;
    let lastIndex = -1;
    let count = 0;
    let lastCount = 0;
    for (let i = 0;i < 8; i++) {
      if (address[i] !== 0)
        continue;
      count = 1;
      for (let j = i + 1;j < 8; j++) {
        if (address[j] !== 0)
          break;
        count++;
        continue;
      }
      if (count > lastCount) {
        lastCount = count;
        lastIndex = i;
      }
    }
    if (lastCount > 1)
      compress = lastIndex;
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex < 8; pieceIndex++) {
      if (ignore0 && address[pieceIndex] === 0)
        continue;
      if (ignore0)
        ignore0 = false;
      if (compress === pieceIndex) {
        output += pieceIndex === 0 ? "::" : ":";
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7)
        output += ":";
    }
    return output;
  }
  function urlParser(input, baseURL, encodingOverride) {
    const url = basicURLParser(input, baseURL, encodingOverride);
    if (url === null)
      return null;
    if (url.scheme !== "blob")
      return url;
    const entry = resolveABlobURL(url);
    if (entry !== null) {
      url._blobURLEntry = entry;
    } else {
      url._blobURLEntry = null;
    }
    return url;
  }
  function basicURLParser(input, baseURL, encodingOverride, url, stateOverride) {
    if (url === undefined) {
      url = newURL();
      const leadingControlOrSpace = /^[\u0000-\u001F\u0020]+/;
      const trailingControlOrSpace = /[\u0000-\u001F\u0020]+$/;
      if (leadingControlOrSpace.test(input) || trailingControlOrSpace.test(input)) {
        validationError("Input string contains leading or trailing control characters or space.");
      }
      input = input.replace(leadingControlOrSpace, "");
      input = input.replace(trailingControlOrSpace, "");
    }
    const tabOrNewline = /[\u0009\u000A\u000D]/g;
    if (tabOrNewline.test(input)) {
      validationError("Input string contains tab or newline characters.");
    }
    input = input.replace(tabOrNewline, "");
    let state = stateOverride === undefined ? interfaces_1.ParserState.SchemeStart : stateOverride;
    if (baseURL === undefined)
      baseURL = null;
    let encoding = encodingOverride === undefined || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
    let buffer = "";
    let atFlag = false;
    let arrayFlag = false;
    let passwordTokenSeenFlag = false;
    const EOF = "";
    const walker = new util_1.StringWalker(input);
    while (true) {
      switch (state) {
        case interfaces_1.ParserState.SchemeStart:
          if (infra_1.codePoint.ASCIIAlpha.test(walker.c())) {
            buffer += walker.c().toLowerCase();
            state = interfaces_1.ParserState.Scheme;
          } else if (stateOverride === undefined) {
            state = interfaces_1.ParserState.NoScheme;
            walker.pointer--;
          } else {
            validationError("Invalid scheme start character.");
            return null;
          }
          break;
        case interfaces_1.ParserState.Scheme:
          if (infra_1.codePoint.ASCIIAlphanumeric.test(walker.c()) || walker.c() === "+" || walker.c() === "-" || walker.c() === ".") {
            buffer += walker.c().toLowerCase();
          } else if (walker.c() === ":") {
            if (stateOverride !== undefined) {
              if (isSpecialScheme(url.scheme) && !isSpecialScheme(buffer))
                return url;
              if (!isSpecialScheme(url.scheme) && isSpecialScheme(buffer))
                return url;
              if ((includesCredentials(url) || url.port !== null) && buffer === "file")
                return url;
              if (url.scheme === "file" && (url.host === "" || url.host === null))
                return url;
            }
            url.scheme = buffer;
            if (stateOverride !== undefined) {
              if (url.port === defaultPort(url.scheme)) {
                url.port = null;
              }
              return url;
            }
            buffer = "";
            if (url.scheme === "file") {
              if (!walker.remaining().startsWith("//")) {
                validationError("Invalid file URL scheme, '//' expected.");
              }
              state = interfaces_1.ParserState.File;
            } else if (isSpecial(url) && baseURL !== null && baseURL.scheme === url.scheme) {
              state = interfaces_1.ParserState.SpecialRelativeOrAuthority;
            } else if (isSpecial(url)) {
              state = interfaces_1.ParserState.SpecialAuthoritySlashes;
            } else if (walker.remaining().startsWith("/")) {
              state = interfaces_1.ParserState.PathOrAuthority;
              walker.pointer++;
            } else {
              url._cannotBeABaseURLFlag = true;
              url.path.push("");
              state = interfaces_1.ParserState.CannotBeABaseURLPath;
            }
          } else if (stateOverride === undefined) {
            buffer = "";
            state = interfaces_1.ParserState.NoScheme;
            walker.pointer = 0;
            continue;
          } else {
            validationError("Invalid input string.");
            return null;
          }
          break;
        case interfaces_1.ParserState.NoScheme:
          if (baseURL === null || baseURL._cannotBeABaseURLFlag && walker.c() !== "#") {
            validationError("Invalid input string.");
            return null;
          } else if (baseURL._cannotBeABaseURLFlag && walker.c() === "#") {
            url.scheme = baseURL.scheme;
            url.path = infra_1.list.clone(baseURL.path);
            url.query = baseURL.query;
            url.fragment = "";
            url._cannotBeABaseURLFlag = true;
            state = interfaces_1.ParserState.Fragment;
          } else if (baseURL.scheme !== "file") {
            state = interfaces_1.ParserState.Relative;
            walker.pointer--;
          } else {
            state = interfaces_1.ParserState.File;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialRelativeOrAuthority:
          if (walker.c() === "/" && walker.remaining().startsWith("/")) {
            state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer++;
          } else {
            validationError("Invalid input string.");
            state = interfaces_1.ParserState.Relative;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.PathOrAuthority:
          if (walker.c() === "/") {
            state = interfaces_1.ParserState.Authority;
          } else {
            state = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.Relative:
          if (baseURL === null) {
            throw new Error("Invalid parser state. Base URL is null.");
          }
          url.scheme = baseURL.scheme;
          switch (walker.c()) {
            case EOF:
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = baseURL.query;
              break;
            case "/":
              state = interfaces_1.ParserState.RelativeSlash;
              break;
            case "?":
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = "";
              state = interfaces_1.ParserState.Query;
              break;
            case "#":
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = baseURL.query;
              url.fragment = "";
              state = interfaces_1.ParserState.Fragment;
              break;
            default:
              if (isSpecial(url) && walker.c() === "\\") {
                validationError("Invalid input string.");
                state = interfaces_1.ParserState.RelativeSlash;
              } else {
                url.username = baseURL.username;
                url.password = baseURL.password;
                url.host = baseURL.host;
                url.port = baseURL.port;
                url.path = infra_1.list.clone(baseURL.path);
                if (url.path.length !== 0)
                  url.path.splice(url.path.length - 1, 1);
                state = interfaces_1.ParserState.Path;
                walker.pointer--;
              }
              break;
          }
          break;
        case interfaces_1.ParserState.RelativeSlash:
          if (isSpecial(url) && (walker.c() === "/" || walker.c() === "\\")) {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
          } else if (walker.c() === "/") {
            state = interfaces_1.ParserState.Authority;
          } else {
            if (baseURL === null) {
              throw new Error("Invalid parser state. Base URL is null.");
            }
            url.username = baseURL.username;
            url.password = baseURL.password;
            url.host = baseURL.host;
            url.port = baseURL.port;
            state = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialAuthoritySlashes:
          if (walker.c() === "/" && walker.remaining().startsWith("/")) {
            state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer++;
          } else {
            validationError("Expected '//'.");
            state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes:
          if (walker.c() !== "/" && walker.c() !== "\\") {
            state = interfaces_1.ParserState.Authority;
            walker.pointer--;
          } else {
            validationError("Unexpected '/' or '\\'.");
          }
          break;
        case interfaces_1.ParserState.Authority:
          if (walker.c() === "@") {
            validationError("Unexpected '@'.");
            if (atFlag)
              buffer = "%40" + buffer;
            atFlag = true;
            for (const codePoint of buffer) {
              if (codePoint === ":" && !passwordTokenSeenFlag) {
                passwordTokenSeenFlag = true;
                continue;
              }
              const encodedCodePoints = utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
              if (passwordTokenSeenFlag) {
                url.password += encodedCodePoints;
              } else {
                url.username += encodedCodePoints;
              }
            }
            buffer = "";
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
            if (atFlag && buffer === "") {
              validationError("Invalid input string.");
              return null;
            }
            walker.pointer -= buffer.length + 1;
            buffer = "";
            state = interfaces_1.ParserState.Host;
          } else {
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.Host:
        case interfaces_1.ParserState.Hostname:
          if (stateOverride !== undefined && url.scheme === "file") {
            walker.pointer--;
            state = interfaces_1.ParserState.FileHost;
          } else if (walker.c() === ":" && !arrayFlag) {
            if (buffer === "") {
              validationError("Invalid input string.");
              return null;
            }
            const host = hostParser(buffer, !isSpecial(url));
            if (host === null)
              return null;
            url.host = host;
            buffer = "";
            state = interfaces_1.ParserState.Port;
            if (stateOverride === interfaces_1.ParserState.Hostname)
              return url;
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
            walker.pointer--;
            if (isSpecial(url) && buffer === "") {
              validationError("Invalid input string.");
              return null;
            } else if (stateOverride !== undefined && buffer === "" && (includesCredentials(url) || url.port !== null)) {
              validationError("Invalid input string.");
              return url;
            }
            const host = hostParser(buffer, !isSpecial(url));
            if (host === null)
              return null;
            url.host = host;
            buffer = "";
            state = interfaces_1.ParserState.PathStart;
            if (stateOverride !== undefined)
              return url;
          } else {
            if (walker.c() === "[")
              arrayFlag = true;
            if (walker.c() === "]")
              arrayFlag = false;
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.Port:
          if (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            buffer += walker.c();
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\" || stateOverride) {
            if (buffer !== "") {
              if (buffer !== "") {
                const port = parseInt(buffer, 10);
                if (port > Math.pow(2, 16) - 1) {
                  validationError("Invalid port number.");
                  return null;
                }
                url.port = port === defaultPort(url.scheme) ? null : port;
                buffer = "";
              }
            }
            if (stateOverride !== undefined) {
              return url;
            }
            state = interfaces_1.ParserState.PathStart;
            walker.pointer--;
          } else {
            validationError("Invalid input string.");
            return null;
          }
          break;
        case interfaces_1.ParserState.File:
          url.scheme = "file";
          if (walker.c() === "/" || walker.c() === "\\") {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state = interfaces_1.ParserState.FileSlash;
          } else if (baseURL !== null && baseURL.scheme === "file") {
            switch (walker.c()) {
              case EOF:
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = baseURL.query;
                break;
              case "?":
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = "";
                state = interfaces_1.ParserState.Query;
                break;
              case "#":
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = baseURL.query;
                url.fragment = "";
                state = interfaces_1.ParserState.Fragment;
                break;
              default:
                if (!startsWithAWindowsDriveLetter(walker.substring())) {
                  url.host = baseURL.host;
                  url.path = infra_1.list.clone(baseURL.path);
                  shorten(url);
                } else {
                  validationError("Unexpected windows drive letter in input string.");
                }
                state = interfaces_1.ParserState.Path;
                walker.pointer--;
                break;
            }
          } else {
            state = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.FileSlash:
          if (walker.c() === "/" || walker.c() === "\\") {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state = interfaces_1.ParserState.FileHost;
          } else {
            if (baseURL !== null && baseURL.scheme === "file" && !startsWithAWindowsDriveLetter(walker.substring())) {
              if (isNormalizedWindowsDriveLetter(baseURL.path[0])) {
                url.path.push(baseURL.path[0]);
              } else {
                url.host = baseURL.host;
              }
            }
            state = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.FileHost:
          if (walker.c() === EOF || walker.c() === "/" || walker.c() === "\\" || walker.c() === "?" || walker.c() === "#") {
            walker.pointer--;
            if (stateOverride === undefined && isWindowsDriveLetter(buffer)) {
              validationError("Unexpected windows drive letter in input string.");
              state = interfaces_1.ParserState.Path;
            } else if (buffer === "") {
              url.host = "";
              if (stateOverride !== undefined)
                return url;
              state = interfaces_1.ParserState.PathStart;
            } else {
              let host = hostParser(buffer, !isSpecial(url));
              if (host === null)
                return null;
              if (host === "localhost")
                host = "";
              url.host = host;
              if (stateOverride !== undefined)
                return url;
              buffer = "";
              state = interfaces_1.ParserState.PathStart;
            }
          } else {
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.PathStart:
          if (isSpecial(url)) {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state = interfaces_1.ParserState.Path;
            if (walker.c() !== "/" && walker.c() !== "\\")
              walker.pointer--;
          } else if (stateOverride === undefined && walker.c() === "?") {
            url.query = "";
            state = interfaces_1.ParserState.Query;
          } else if (stateOverride === undefined && walker.c() === "#") {
            url.fragment = "";
            state = interfaces_1.ParserState.Fragment;
          } else if (walker.c() !== EOF) {
            state = interfaces_1.ParserState.Path;
            if (walker.c() !== "/")
              walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.Path:
          if (walker.c() === EOF || walker.c() === "/" || isSpecial(url) && walker.c() === "\\" || stateOverride === undefined && (walker.c() === "?" || walker.c() === "#")) {
            if (isSpecial(url) && walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            if (isDoubleDotPathSegment(buffer)) {
              shorten(url);
              if (walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
                url.path.push("");
              }
            } else if (isSingleDotPathSegment(buffer) && walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
              url.path.push("");
            } else if (!isSingleDotPathSegment(buffer)) {
              if (url.scheme === "file" && url.path.length === 0 && isWindowsDriveLetter(buffer)) {
                if (url.host !== null && url.host !== "") {
                  validationError("Invalid input string.");
                  url.host = "";
                }
                const bufferCodePoints = Array.from(buffer);
                buffer = bufferCodePoints.slice(0, 1) + ":" + bufferCodePoints.slice(2);
              }
              url.path.push(buffer);
            }
            buffer = "";
            if (url.scheme === "file" && (walker.c() === EOF || walker.c() === "?" || walker.c() === "#")) {
              while (url.path.length > 1 && url.path[0] === "") {
                validationError("Invalid input string.");
                url.path.splice(0, 1);
              }
            }
            if (walker.c() === "?") {
              url.query = "";
              state = interfaces_1.ParserState.Query;
            }
            if (walker.c() === "#") {
              url.fragment = "";
              state = interfaces_1.ParserState.Fragment;
            }
          } else {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            buffer += utf8PercentEncode(walker.c(), _pathPercentEncodeSet);
          }
          break;
        case interfaces_1.ParserState.CannotBeABaseURLPath:
          if (walker.c() === "?") {
            url.query = "";
            state = interfaces_1.ParserState.Query;
          } else if (walker.c() === "#") {
            url.fragment = "";
            state = interfaces_1.ParserState.Fragment;
          } else {
            if (walker.c() !== EOF && !_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            if (walker.c() !== EOF) {
              url.path[0] += utf8PercentEncode(walker.c(), _c0ControlPercentEncodeSet);
            }
          }
          break;
        case interfaces_1.ParserState.Query:
          if (encoding !== "UTF-8" && (!isSpecial(url) || url.scheme === "ws" || url.scheme === "wss")) {
            encoding = "UTF-8";
          }
          if (stateOverride === undefined && walker.c() === "#") {
            url.fragment = "";
            state = interfaces_1.ParserState.Fragment;
          } else if (walker.c() !== EOF) {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            if (encoding.toUpperCase() !== "UTF-8") {
              throw new Error("Only UTF-8 encoding is supported.");
            }
            let bytes = (0, util_1.utf8Encode)(walker.c());
            if (bytes.length >= 3 && bytes[0] === 38 && bytes[1] === 35 && bytes[bytes.length - 1] === 59) {
              bytes = bytes.subarray(2, bytes.length - 1);
              url.query += "%26%23" + infra_1.byteSequence.isomorphicDecode(bytes) + "%3B";
            } else {
              for (const byte of bytes) {
                if (byte < 33 || byte > 126 || byte === 34 || byte === 35 || byte === 60 || byte === 62 || byte === 39 && isSpecial(url)) {
                  url.query += percentEncode(byte);
                } else {
                  url.query += String.fromCharCode(byte);
                }
              }
            }
          }
          break;
        case interfaces_1.ParserState.Fragment:
          if (walker.c() === EOF) {} else if (walker.c() === "\x00") {
            validationError("NULL character in input string.");
          } else {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Unexpected character in fragment string.");
            }
            if (walker.c() === "%" && !/^[A-Za-z0-9][A-Za-z0-9]/.test(walker.remaining())) {
              validationError("Unexpected character in fragment string.");
            }
            url.fragment += utf8PercentEncode(walker.c(), _fragmentPercentEncodeSet);
          }
          break;
      }
      if (walker.eof)
        break;
      else
        walker.pointer++;
    }
    return url;
  }
  function setTheUsername(url, username) {
    let result = "";
    for (const codePoint of username) {
      result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
    }
    url.username = result;
  }
  function setThePassword(url, password) {
    let result = "";
    for (const codePoint of password) {
      result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
    }
    url.password = result;
  }
  function isSingleDotPathSegment(str) {
    return str === "." || str.toLowerCase() === "%2e";
  }
  function isDoubleDotPathSegment(str) {
    const lowerStr = str.toLowerCase();
    return lowerStr === ".." || lowerStr === ".%2e" || lowerStr === "%2e." || lowerStr === "%2e%2e";
  }
  function shorten(url) {
    const path = url.path;
    if (path.length === 0)
      return;
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0]))
      return;
    url.path.splice(url.path.length - 1, 1);
  }
  function isNormalizedWindowsDriveLetter(str) {
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && str[1] === ":";
  }
  function isWindowsDriveLetter(str) {
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && (str[1] === ":" || str[1] === "|");
  }
  function startsWithAWindowsDriveLetter(str) {
    return str.length >= 2 && isWindowsDriveLetter(str) && (str.length === 2 || (str[2] === "/" || str[2] === "\\" || str[2] === "?" || str[2] === "#"));
  }
  function hostParser(input, isNotSpecial = false) {
    if (input.startsWith("[")) {
      if (!input.endsWith("]")) {
        validationError("Expected ']' after '['.");
        return null;
      }
      return iPv6Parser(input.substring(1, input.length - 1));
    }
    if (isNotSpecial) {
      return opaqueHostParser(input);
    }
    const domain = (0, util_1.utf8Decode)(stringPercentDecode(input));
    const asciiDomain = domainToASCII(domain);
    if (asciiDomain === null) {
      validationError("Invalid domain.");
      return null;
    }
    if (_forbiddenHostCodePoint.test(asciiDomain)) {
      validationError("Invalid domain.");
      return null;
    }
    const ipv4Host = iPv4Parser(asciiDomain);
    if (ipv4Host === null || (0, util_1.isNumber)(ipv4Host))
      return ipv4Host;
    return asciiDomain;
  }
  function iPv4NumberParser(input, validationErrorFlag = { value: false }) {
    let R = 10;
    if (input.startsWith("0x") || input.startsWith("0X")) {
      validationErrorFlag.value = true;
      input = input.substr(2);
      R = 16;
    } else if (input.length >= 2 && input[0] === "0") {
      validationErrorFlag.value = true;
      input = input.substr(1);
      R = 8;
    }
    if (input === "")
      return 0;
    const radixRDigits = R === 10 ? /^[0-9]+$/ : R === 16 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/;
    if (!radixRDigits.test(input))
      return null;
    return parseInt(input, R);
  }
  function iPv4Parser(input) {
    const validationErrorFlag = { value: false };
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      validationErrorFlag.value = true;
      if (parts.length > 1)
        parts.pop();
    }
    if (parts.length > 4)
      return input;
    const numbers = [];
    for (const part of parts) {
      if (part === "")
        return input;
      const n = iPv4NumberParser(part, validationErrorFlag);
      if (n === null)
        return input;
      numbers.push(n);
    }
    if (validationErrorFlag.value)
      validationError("Invalid IP v4 address.");
    for (let i = 0;i < numbers.length; i++) {
      const item = numbers[i];
      if (item > 255) {
        validationError("Invalid IP v4 address.");
        if (i < numbers.length - 1)
          return null;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      validationError("Invalid IP v4 address.");
      return null;
    }
    let ipv4 = numbers[numbers.length - 1];
    numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * Math.pow(256, 3 - counter);
      counter++;
    }
    return ipv4;
  }
  function iPv6Parser(input) {
    const EOF = "";
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    const walker = new util_1.StringWalker(input);
    if (walker.c() === ":") {
      if (!walker.remaining().startsWith(":")) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      walker.pointer += 2;
      pieceIndex += 1;
      compress = pieceIndex;
    }
    while (walker.c() !== EOF) {
      if (pieceIndex === 8) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      if (walker.c() === ":") {
        if (compress !== null) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        walker.pointer++;
        pieceIndex++;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && infra_1.codePoint.ASCIIHexDigit.test(walker.c())) {
        value = value * 16 + parseInt(walker.c(), 16);
        walker.pointer++;
        length++;
      }
      if (walker.c() === ".") {
        if (length === 0) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        walker.pointer -= length;
        if (pieceIndex > 6) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        let numbersSeen = 0;
        while (walker.c() !== EOF) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (walker.c() === "." && numbersSeen < 4) {
              walker.pointer++;
            } else {
              validationError("Invalid IP v6 address.");
              return null;
            }
          }
          if (!infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          while (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            const number = parseInt(walker.c(), 10);
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              validationError("Invalid IP v6 address.");
              return null;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              validationError("Invalid IP v6 address.");
              return null;
            }
            walker.pointer++;
          }
          if (ipv4Piece === null) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          numbersSeen++;
          if (numbersSeen === 2 || numbersSeen === 4)
            pieceIndex++;
        }
        if (numbersSeen !== 4) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        break;
      } else if (walker.c() === ":") {
        walker.pointer++;
        if (walker.c() === EOF) {
          validationError("Invalid IP v6 address.");
          return null;
        }
      } else if (walker.c() !== EOF) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      address[pieceIndex] = value;
      pieceIndex++;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        [address[pieceIndex], address[compress + swaps - 1]] = [address[compress + swaps - 1], address[pieceIndex]];
        pieceIndex--;
        swaps--;
      }
    } else if (compress === null && pieceIndex !== 8) {
      validationError("Invalid IP v6 address.");
      return null;
    }
    return address;
  }
  function opaqueHostParser(input) {
    const forbiddenChars = /[\x00\t\f\r #/:?@\[\\\]]/;
    if (forbiddenChars.test(input)) {
      validationError("Invalid host string.");
      return null;
    }
    let output = "";
    for (const codePoint of input) {
      output += utf8PercentEncode(codePoint, _c0ControlPercentEncodeSet);
    }
    return output;
  }
  function resolveABlobURL(url) {
    return null;
  }
  function percentEncode(value) {
    return "%" + ("00" + value.toString(16).toUpperCase()).slice(-2);
  }
  function percentDecode(input) {
    const isHexDigit = (byte) => {
      return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
    };
    const output = new Uint8Array(input.length);
    let n = 0;
    for (let i = 0;i < input.length; i++) {
      const byte = input[i];
      if (byte !== 37) {
        output[n] = byte;
        n++;
      } else if (byte === 37 && i >= input.length - 2) {
        output[n] = byte;
        n++;
      } else if (byte === 37 && (!isHexDigit(input[i + 1]) || !isHexDigit(input[i + 2]))) {
        output[n] = byte;
        n++;
      } else {
        const bytePoint = parseInt((0, util_1.utf8Decode)(Uint8Array.of(input[i + 1], input[i + 2])), 16);
        output[n] = bytePoint;
        n++;
        i += 2;
      }
    }
    return output.subarray(0, n);
  }
  function stringPercentDecode(input) {
    return percentDecode((0, util_1.utf8Encode)(input));
  }
  function utf8PercentEncode(codePoint, percentEncodeSet) {
    if (!percentEncodeSet.test(codePoint))
      return codePoint;
    const bytes = (0, util_1.utf8Encode)(codePoint);
    let result = "";
    for (const byte of bytes) {
      result += percentEncode(byte);
    }
    return result;
  }
  function hostEquals(hostA, hostB) {
    return hostA === hostB;
  }
  function urlEquals(urlA, urlB, excludeFragmentsFlag = false) {
    return urlSerializer(urlA, excludeFragmentsFlag) === urlSerializer(urlB, excludeFragmentsFlag);
  }
  function urlEncodedStringParser(input) {
    return urlEncodedParser((0, util_1.utf8Encode)(input));
  }
  function urlEncodedParser(input) {
    const sequences = [];
    let currentSequence = [];
    for (const byte of input) {
      if (byte === 38) {
        sequences.push(Uint8Array.from(currentSequence));
        currentSequence = [];
      } else {
        currentSequence.push(byte);
      }
    }
    if (currentSequence.length !== 0) {
      sequences.push(Uint8Array.from(currentSequence));
    }
    const output = [];
    for (const bytes of sequences) {
      if (bytes.length === 0)
        continue;
      const index = bytes.indexOf(61);
      const name = index !== -1 ? bytes.slice(0, index) : bytes;
      const value = index !== -1 ? bytes.slice(index + 1) : new Uint8Array;
      for (let i = 0;i < name.length; i++)
        if (name[i] === 43)
          name[i] = 32;
      for (let i = 0;i < value.length; i++)
        if (value[i] === 43)
          value[i] = 32;
      const nameString = (0, util_1.utf8Decode)(name);
      const valueString = (0, util_1.utf8Decode)(value);
      output.push([nameString, valueString]);
    }
    return output;
  }
  function urlEncodedByteSerializer(input) {
    let output = "";
    for (const byte of input) {
      if (byte === 32) {
        output += "+";
      } else if (byte === 42 || byte === 45 || byte === 46 || byte >= 48 && byte <= 57 || byte >= 65 && byte <= 90 || byte === 95 || byte >= 97 && byte <= 122) {
        output += String.fromCodePoint(byte);
      } else {
        output += percentEncode(byte);
      }
    }
    return output;
  }
  function urlEncodedSerializer(tuples, encodingOverride) {
    const encoding = encodingOverride === undefined || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
    if (encoding.toUpperCase() !== "UTF-8") {
      throw new Error("Only UTF-8 encoding is supported.");
    }
    let output = "";
    for (const tuple of tuples) {
      const name = urlEncodedByteSerializer((0, util_1.utf8Encode)(tuple[0]));
      let value = tuple[1];
      value = urlEncodedByteSerializer((0, util_1.utf8Encode)(value));
      if (output !== "")
        output += "&";
      output += name + "=" + value;
    }
    return output;
  }
  function origin(url) {
    switch (url.scheme) {
      case "blob":
        if (url._blobURLEntry !== null) {}
        const parsedURL = basicURLParser(url.path[0]);
        if (parsedURL === null)
          return interfaces_1.OpaqueOrigin;
        else
          return origin(parsedURL);
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return [url.scheme, url.host === null ? "" : url.host, url.port, null];
      case "file":
        return interfaces_1.OpaqueOrigin;
      default:
        return interfaces_1.OpaqueOrigin;
    }
  }
  function domainToASCII(domain, beStrict = false) {
    const result = (0, url_1.domainToASCII)(domain);
    if (result === "") {
      validationError("Invalid domain name.");
      return null;
    }
    return result;
  }
  function domainToUnicode(domain, beStrict = false) {
    const result = (0, url_1.domainToUnicode)(domain);
    if (result === "") {
      validationError("Invalid domain name.");
    }
    return result;
  }
  function asciiSerializationOfAnOrigin(origin2) {
    if (origin2[0] === "" && origin2[1] === "" && origin2[2] === null && origin2[3] === null) {
      return "null";
    }
    let result = origin2[0] + "://" + hostSerializer(origin2[1]);
    if (origin2[2] !== null)
      result += ":" + origin2[2].toString();
    return result;
  }
});

// node_modules/@oozcitak/dom/lib/dom/NodeImpl.js
var require_NodeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeImpl = undefined;
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var EventTargetImpl_1 = require_EventTargetImpl();
  var util_1 = require_util2();
  var DOMException_1 = require_DOMException();
  var algorithm_1 = require_algorithm();
  var URLAlgorithm_1 = require_URLAlgorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class NodeImpl extends EventTargetImpl_1.EventTargetImpl {
    static ELEMENT_NODE = 1;
    static ATTRIBUTE_NODE = 2;
    static TEXT_NODE = 3;
    static CDATA_SECTION_NODE = 4;
    static ENTITY_REFERENCE_NODE = 5;
    static ENTITY_NODE = 6;
    static PROCESSING_INSTRUCTION_NODE = 7;
    static COMMENT_NODE = 8;
    static DOCUMENT_NODE = 9;
    static DOCUMENT_TYPE_NODE = 10;
    static DOCUMENT_FRAGMENT_NODE = 11;
    static NOTATION_NODE = 12;
    static DOCUMENT_POSITION_DISCONNECTED = 1;
    static DOCUMENT_POSITION_PRECEDING = 2;
    static DOCUMENT_POSITION_FOLLOWING = 4;
    static DOCUMENT_POSITION_CONTAINS = 8;
    static DOCUMENT_POSITION_CONTAINED_BY = 16;
    static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
    ELEMENT_NODE = 1;
    ATTRIBUTE_NODE = 2;
    TEXT_NODE = 3;
    CDATA_SECTION_NODE = 4;
    ENTITY_REFERENCE_NODE = 5;
    ENTITY_NODE = 6;
    PROCESSING_INSTRUCTION_NODE = 7;
    COMMENT_NODE = 8;
    DOCUMENT_NODE = 9;
    DOCUMENT_TYPE_NODE = 10;
    DOCUMENT_FRAGMENT_NODE = 11;
    NOTATION_NODE = 12;
    DOCUMENT_POSITION_DISCONNECTED = 1;
    DOCUMENT_POSITION_PRECEDING = 2;
    DOCUMENT_POSITION_FOLLOWING = 4;
    DOCUMENT_POSITION_CONTAINS = 8;
    DOCUMENT_POSITION_CONTAINED_BY = 16;
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
    __childNodes;
    get _childNodes() {
      return this.__childNodes || (this.__childNodes = (0, algorithm_1.create_nodeList)(this));
    }
    _nodeDocumentOverride;
    get _nodeDocument() {
      return this._nodeDocumentOverride || DOMImpl_1.dom.window._associatedDocument;
    }
    set _nodeDocument(val) {
      this._nodeDocumentOverride = val;
    }
    __registeredObserverList;
    get _registeredObserverList() {
      return this.__registeredObserverList || (this.__registeredObserverList = []);
    }
    _parent = null;
    _children = new util_1.EmptySet;
    _firstChild = null;
    _lastChild = null;
    _previousSibling = null;
    _nextSibling = null;
    constructor() {
      super();
    }
    get nodeType() {
      return this._nodeType;
    }
    get nodeName() {
      if (util_1.Guard.isElementNode(this)) {
        return this._htmlUppercasedQualifiedName;
      } else if (util_1.Guard.isAttrNode(this)) {
        return this._qualifiedName;
      } else if (util_1.Guard.isExclusiveTextNode(this)) {
        return "#text";
      } else if (util_1.Guard.isCDATASectionNode(this)) {
        return "#cdata-section";
      } else if (util_1.Guard.isProcessingInstructionNode(this)) {
        return this._target;
      } else if (util_1.Guard.isCommentNode(this)) {
        return "#comment";
      } else if (util_1.Guard.isDocumentNode(this)) {
        return "#document";
      } else if (util_1.Guard.isDocumentTypeNode(this)) {
        return this._name;
      } else if (util_1.Guard.isDocumentFragmentNode(this)) {
        return "#document-fragment";
      } else {
        return "";
      }
    }
    get baseURI() {
      return (0, URLAlgorithm_1.urlSerializer)(this._nodeDocument._URL);
    }
    get isConnected() {
      return util_1.Guard.isElementNode(this) && (0, algorithm_1.shadowTree_isConnected)(this);
    }
    get ownerDocument() {
      if (this._nodeType === interfaces_1.NodeType.Document)
        return null;
      else
        return this._nodeDocument;
    }
    getRootNode(options) {
      return (0, algorithm_1.tree_rootNode)(this, !!options && options.composed);
    }
    get parentNode() {
      if (this._nodeType === interfaces_1.NodeType.Attribute) {
        return null;
      } else {
        return this._parent;
      }
    }
    get parentElement() {
      if (this._parent && util_1.Guard.isElementNode(this._parent)) {
        return this._parent;
      } else {
        return null;
      }
    }
    hasChildNodes() {
      return this._firstChild !== null;
    }
    get childNodes() {
      return this._childNodes;
    }
    get firstChild() {
      return this._firstChild;
    }
    get lastChild() {
      return this._lastChild;
    }
    get previousSibling() {
      return this._previousSibling;
    }
    get nextSibling() {
      return this._nextSibling;
    }
    get nodeValue() {
      if (util_1.Guard.isAttrNode(this)) {
        return this._value;
      } else if (util_1.Guard.isCharacterDataNode(this)) {
        return this._data;
      } else {
        return null;
      }
    }
    set nodeValue(value) {
      if (value === null) {
        value = "";
      }
      if (util_1.Guard.isAttrNode(this)) {
        (0, algorithm_1.attr_setAnExistingAttributeValue)(this, value);
      } else if (util_1.Guard.isCharacterDataNode(this)) {
        (0, algorithm_1.characterData_replaceData)(this, 0, this._data.length, value);
      }
    }
    get textContent() {
      if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
        return (0, algorithm_1.text_descendantTextContent)(this);
      } else if (util_1.Guard.isAttrNode(this)) {
        return this._value;
      } else if (util_1.Guard.isCharacterDataNode(this)) {
        return this._data;
      } else {
        return null;
      }
    }
    set textContent(value) {
      if (value === null) {
        value = "";
      }
      if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
        (0, algorithm_1.node_stringReplaceAll)(value, this);
      } else if (util_1.Guard.isAttrNode(this)) {
        (0, algorithm_1.attr_setAnExistingAttributeValue)(this, value);
      } else if (util_1.Guard.isCharacterDataNode(this)) {
        (0, algorithm_1.characterData_replaceData)(this, 0, (0, algorithm_1.tree_nodeLength)(this), value);
      }
    }
    normalize() {
      const descendantNodes = [];
      let node = (0, algorithm_1.tree_getFirstDescendantNode)(this, false, false, (e) => util_1.Guard.isExclusiveTextNode(e));
      while (node !== null) {
        descendantNodes.push(node);
        node = (0, algorithm_1.tree_getNextDescendantNode)(this, node, false, false, (e) => util_1.Guard.isExclusiveTextNode(e));
      }
      for (let i = 0;i < descendantNodes.length; i++) {
        const node2 = descendantNodes[i];
        if (node2._parent === null)
          continue;
        let length = (0, algorithm_1.tree_nodeLength)(node2);
        if (length === 0) {
          (0, algorithm_1.mutation_remove)(node2, node2._parent);
          continue;
        }
        const textSiblings = [];
        let data = "";
        for (const sibling of (0, algorithm_1.text_contiguousExclusiveTextNodes)(node2)) {
          textSiblings.push(sibling);
          data += sibling._data;
        }
        (0, algorithm_1.characterData_replaceData)(node2, length, 0, data);
        if (DOMImpl_1.dom.rangeList.size !== 0) {
          let currentNode = node2._nextSibling;
          while (currentNode !== null && util_1.Guard.isExclusiveTextNode(currentNode)) {
            const cn = currentNode;
            const index = (0, algorithm_1.tree_index)(cn);
            for (const range of DOMImpl_1.dom.rangeList) {
              if (range._start[0] === cn) {
                range._start[0] = node2;
                range._start[1] += length;
              }
              if (range._end[0] === cn) {
                range._end[0] = node2;
                range._end[1] += length;
              }
              if (range._start[0] === cn._parent && range._start[1] === index) {
                range._start[0] = node2;
                range._start[1] = length;
              }
              if (range._end[0] === cn._parent && range._end[1] === index) {
                range._end[0] = node2;
                range._end[1] = length;
              }
            }
            length += (0, algorithm_1.tree_nodeLength)(currentNode);
            currentNode = currentNode._nextSibling;
          }
        }
        for (let i2 = 0;i2 < textSiblings.length; i2++) {
          const sibling = textSiblings[i2];
          if (sibling._parent === null)
            continue;
          (0, algorithm_1.mutation_remove)(sibling, sibling._parent);
        }
      }
    }
    cloneNode(deep = false) {
      if (util_1.Guard.isShadowRoot(this))
        throw new DOMException_1.NotSupportedError;
      return (0, algorithm_1.node_clone)(this, null, deep);
    }
    isEqualNode(node = null) {
      return node !== null && (0, algorithm_1.node_equals)(this, node);
    }
    isSameNode(node = null) {
      return this === node;
    }
    compareDocumentPosition(other) {
      if (other === this)
        return interfaces_1.Position.SameNode;
      let node1 = other;
      let node2 = this;
      let attr1 = null;
      let attr2 = null;
      if (util_1.Guard.isAttrNode(node1)) {
        attr1 = node1;
        node1 = attr1._element;
      }
      if (util_1.Guard.isAttrNode(node2)) {
        attr2 = node2;
        node2 = attr2._element;
        if (attr1 && node1 && node1 === node2) {
          for (let i = 0;i < node2._attributeList.length; i++) {
            const attr = node2._attributeList[i];
            if ((0, algorithm_1.node_equals)(attr, attr1)) {
              return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Preceding;
            } else if ((0, algorithm_1.node_equals)(attr, attr2)) {
              return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Following;
            }
          }
        }
      }
      if (node1 === null || node2 === null || (0, algorithm_1.tree_rootNode)(node1) !== (0, algorithm_1.tree_rootNode)(node2)) {
        return interfaces_1.Position.Disconnected | interfaces_1.Position.ImplementationSpecific | (DOMImpl_1.dom.compareCache.check(this, other) ? interfaces_1.Position.Preceding : interfaces_1.Position.Following);
      }
      if (!attr1 && (0, algorithm_1.tree_isAncestorOf)(node2, node1) || attr2 && node1 === node2) {
        return interfaces_1.Position.Contains | interfaces_1.Position.Preceding;
      }
      if (!attr2 && (0, algorithm_1.tree_isDescendantOf)(node2, node1) || attr1 && node1 === node2) {
        return interfaces_1.Position.ContainedBy | interfaces_1.Position.Following;
      }
      if ((0, algorithm_1.tree_isPreceding)(node2, node1))
        return interfaces_1.Position.Preceding;
      return interfaces_1.Position.Following;
    }
    contains(other) {
      if (other === null)
        return false;
      return (0, algorithm_1.tree_isDescendantOf)(this, other, true);
    }
    lookupPrefix(namespace) {
      if (!namespace)
        return null;
      if (util_1.Guard.isElementNode(this)) {
        return (0, algorithm_1.node_locateANamespacePrefix)(this, namespace);
      } else if (util_1.Guard.isDocumentNode(this)) {
        if (this.documentElement === null) {
          return null;
        } else {
          return (0, algorithm_1.node_locateANamespacePrefix)(this.documentElement, namespace);
        }
      } else if (util_1.Guard.isDocumentTypeNode(this) || util_1.Guard.isDocumentFragmentNode(this)) {
        return null;
      } else if (util_1.Guard.isAttrNode(this)) {
        if (this._element === null) {
          return null;
        } else {
          return (0, algorithm_1.node_locateANamespacePrefix)(this._element, namespace);
        }
      } else {
        if (this._parent !== null && util_1.Guard.isElementNode(this._parent)) {
          return (0, algorithm_1.node_locateANamespacePrefix)(this._parent, namespace);
        } else {
          return null;
        }
      }
    }
    lookupNamespaceURI(prefix) {
      return (0, algorithm_1.node_locateANamespace)(this, prefix || null);
    }
    isDefaultNamespace(namespace) {
      if (!namespace)
        namespace = null;
      const defaultNamespace = (0, algorithm_1.node_locateANamespace)(this, null);
      return defaultNamespace === namespace;
    }
    insertBefore(newChild, refChild) {
      return (0, algorithm_1.mutation_preInsert)(newChild, this, refChild);
    }
    appendChild(newChild) {
      return (0, algorithm_1.mutation_append)(newChild, this);
    }
    replaceChild(newChild, oldChild) {
      return (0, algorithm_1.mutation_replace)(oldChild, newChild, this);
    }
    removeChild(oldChild) {
      return (0, algorithm_1.mutation_preRemove)(oldChild, this);
    }
    _getTheParent(event) {
      if (util_1.Guard.isSlotable(this) && (0, algorithm_1.shadowTree_isAssigned)(this)) {
        return this._assignedSlot;
      } else {
        return this._parent;
      }
    }
  }
  exports.NodeImpl = NodeImpl;
  NodeImpl.prototype._children = new util_1.EmptySet;
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "ELEMENT_NODE", 1);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "ATTRIBUTE_NODE", 2);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "TEXT_NODE", 3);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "CDATA_SECTION_NODE", 4);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "ENTITY_REFERENCE_NODE", 5);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "ENTITY_NODE", 6);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "PROCESSING_INSTRUCTION_NODE", 7);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "COMMENT_NODE", 8);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_NODE", 9);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_TYPE_NODE", 10);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_FRAGMENT_NODE", 11);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "NOTATION_NODE", 12);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_DISCONNECTED", 1);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_PRECEDING", 2);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_FOLLOWING", 4);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINS", 8);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 16);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 32);
});

// node_modules/@oozcitak/dom/lib/dom/DocumentImpl.js
var require_DocumentImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocumentImpl = undefined;
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var DOMException_1 = require_DOMException();
  var NodeImpl_1 = require_NodeImpl();
  var util_1 = require_util2();
  var util_2 = (init_lib(), __toCommonJS(exports_lib));
  var infra_1 = require_lib7();
  var URLAlgorithm_1 = require_URLAlgorithm();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class DocumentImpl extends NodeImpl_1.NodeImpl {
    _nodeType = interfaces_1.NodeType.Document;
    _children = new Set;
    _encoding = {
      name: "UTF-8",
      labels: ["unicode-1-1-utf-8", "utf-8", "utf8"]
    };
    _contentType = "application/xml";
    _URL = {
      scheme: "about",
      username: "",
      password: "",
      host: null,
      port: null,
      path: ["blank"],
      query: null,
      fragment: null,
      _cannotBeABaseURLFlag: true,
      _blobURLEntry: null
    };
    _origin = null;
    _type = "xml";
    _mode = "no-quirks";
    _implementation;
    _documentElement = null;
    _hasNamespaces = false;
    _nodeDocumentOverwrite = null;
    get _nodeDocument() {
      return this._nodeDocumentOverwrite || this;
    }
    set _nodeDocument(val) {
      this._nodeDocumentOverwrite = val;
    }
    constructor() {
      super();
    }
    get implementation() {
      return this._implementation || (this._implementation = (0, algorithm_1.create_domImplementation)(this));
    }
    get URL() {
      return (0, URLAlgorithm_1.urlSerializer)(this._URL);
    }
    get documentURI() {
      return this.URL;
    }
    get origin() {
      return "null";
    }
    get compatMode() {
      return this._mode === "quirks" ? "BackCompat" : "CSS1Compat";
    }
    get characterSet() {
      return this._encoding.name;
    }
    get charset() {
      return this._encoding.name;
    }
    get inputEncoding() {
      return this._encoding.name;
    }
    get contentType() {
      return this._contentType;
    }
    get doctype() {
      for (const child of this._children) {
        if (util_1.Guard.isDocumentTypeNode(child))
          return child;
      }
      return null;
    }
    get documentElement() {
      return this._documentElement;
    }
    getElementsByTagName(qualifiedName) {
      return (0, algorithm_1.node_listOfElementsWithQualifiedName)(qualifiedName, this);
    }
    getElementsByTagNameNS(namespace, localName) {
      return (0, algorithm_1.node_listOfElementsWithNamespace)(namespace, localName, this);
    }
    getElementsByClassName(classNames) {
      return (0, algorithm_1.node_listOfElementsWithClassNames)(classNames, this);
    }
    createElement(localName, options) {
      if (!(0, algorithm_1.xml_isName)(localName))
        throw new DOMException_1.InvalidCharacterError;
      if (this._type === "html")
        localName = localName.toLowerCase();
      let is = null;
      if (options !== undefined) {
        if ((0, util_2.isString)(options)) {
          is = options;
        } else {
          is = options.is;
        }
      }
      const namespace = this._type === "html" || this._contentType === "application/xhtml+xml" ? infra_1.namespace.HTML : null;
      return (0, algorithm_1.element_createAnElement)(this, localName, namespace, null, is, true);
    }
    createElementNS(namespace, qualifiedName, options) {
      return (0, algorithm_1.document_internalCreateElementNS)(this, namespace, qualifiedName, options);
    }
    createDocumentFragment() {
      return (0, algorithm_1.create_documentFragment)(this);
    }
    createTextNode(data) {
      return (0, algorithm_1.create_text)(this, data);
    }
    createCDATASection(data) {
      if (this._type === "html")
        throw new DOMException_1.NotSupportedError;
      if (data.indexOf("]]>") !== -1)
        throw new DOMException_1.InvalidCharacterError;
      return (0, algorithm_1.create_cdataSection)(this, data);
    }
    createComment(data) {
      return (0, algorithm_1.create_comment)(this, data);
    }
    createProcessingInstruction(target, data) {
      if (!(0, algorithm_1.xml_isName)(target))
        throw new DOMException_1.InvalidCharacterError;
      if (data.indexOf("?>") !== -1)
        throw new DOMException_1.InvalidCharacterError;
      return (0, algorithm_1.create_processingInstruction)(this, target, data);
    }
    importNode(node, deep = false) {
      if (util_1.Guard.isDocumentNode(node) || util_1.Guard.isShadowRoot(node))
        throw new DOMException_1.NotSupportedError;
      return (0, algorithm_1.node_clone)(node, this, deep);
    }
    adoptNode(node) {
      if (util_1.Guard.isDocumentNode(node))
        throw new DOMException_1.NotSupportedError;
      if (util_1.Guard.isShadowRoot(node))
        throw new DOMException_1.HierarchyRequestError;
      (0, algorithm_1.document_adopt)(node, this);
      return node;
    }
    createAttribute(localName) {
      if (!(0, algorithm_1.xml_isName)(localName))
        throw new DOMException_1.InvalidCharacterError;
      if (this._type === "html") {
        localName = localName.toLowerCase();
      }
      const attr = (0, algorithm_1.create_attr)(this, localName);
      return attr;
    }
    createAttributeNS(namespace, qualifiedName) {
      const [ns, prefix, localName] = (0, algorithm_1.namespace_validateAndExtract)(namespace, qualifiedName);
      const attr = (0, algorithm_1.create_attr)(this, localName);
      attr._namespace = ns;
      attr._namespacePrefix = prefix;
      return attr;
    }
    createEvent(eventInterface) {
      return (0, algorithm_1.event_createLegacyEvent)(eventInterface);
    }
    createRange() {
      const range = (0, algorithm_1.create_range)();
      range._start = [this, 0];
      range._end = [this, 0];
      return range;
    }
    createNodeIterator(root, whatToShow = interfaces_1.WhatToShow.All, filter = null) {
      const iterator = (0, algorithm_1.create_nodeIterator)(root, root, true);
      iterator._whatToShow = whatToShow;
      iterator._iteratorCollection = (0, algorithm_1.create_nodeList)(root);
      if ((0, util_2.isFunction)(filter)) {
        iterator._filter = (0, algorithm_1.create_nodeFilter)();
        iterator._filter.acceptNode = filter;
      } else {
        iterator._filter = filter;
      }
      return iterator;
    }
    createTreeWalker(root, whatToShow = interfaces_1.WhatToShow.All, filter = null) {
      const walker = (0, algorithm_1.create_treeWalker)(root, root);
      walker._whatToShow = whatToShow;
      if ((0, util_2.isFunction)(filter)) {
        walker._filter = (0, algorithm_1.create_nodeFilter)();
        walker._filter.acceptNode = filter;
      } else {
        walker._filter = filter;
      }
      return walker;
    }
    _getTheParent(event) {
      if (event._type === "load") {
        return null;
      } else {
        return DOMImpl_1.dom.window;
      }
    }
    getElementById(elementId) {
      throw new Error("Mixin: NonElementParentNode not implemented.");
    }
    get children() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get firstElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get lastElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get childElementCount() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    prepend(...nodes) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    append(...nodes) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    querySelector(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    querySelectorAll(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
  }
  exports.DocumentImpl = DocumentImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(DocumentImpl.prototype, "_nodeType", interfaces_1.NodeType.Document);
});

// node_modules/@oozcitak/dom/lib/dom/XMLDocumentImpl.js
var require_XMLDocumentImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLDocumentImpl = undefined;
  var DocumentImpl_1 = require_DocumentImpl();

  class XMLDocumentImpl extends DocumentImpl_1.DocumentImpl {
    constructor() {
      super();
    }
  }
  exports.XMLDocumentImpl = XMLDocumentImpl;
});

// node_modules/@oozcitak/dom/lib/dom/AbortControllerImpl.js
var require_AbortControllerImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortControllerImpl = undefined;
  var algorithm_1 = require_algorithm();

  class AbortControllerImpl {
    _signal;
    constructor() {
      this._signal = (0, algorithm_1.create_abortSignal)();
    }
    get signal() {
      return this._signal;
    }
    abort() {
      (0, algorithm_1.abort_signalAbort)(this._signal);
    }
  }
  exports.AbortControllerImpl = AbortControllerImpl;
});

// node_modules/@oozcitak/dom/lib/dom/AbortSignalImpl.js
var require_AbortSignalImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortSignalImpl = undefined;
  var EventTargetImpl_1 = require_EventTargetImpl();
  var algorithm_1 = require_algorithm();

  class AbortSignalImpl extends EventTargetImpl_1.EventTargetImpl {
    _abortedFlag = false;
    _abortAlgorithms = new Set;
    constructor() {
      super();
    }
    get aborted() {
      return this._abortedFlag;
    }
    get onabort() {
      return (0, algorithm_1.event_getterEventHandlerIDLAttribute)(this, "onabort");
    }
    set onabort(val) {
      (0, algorithm_1.event_setterEventHandlerIDLAttribute)(this, "onabort", val);
    }
    static _create() {
      return new AbortSignalImpl;
    }
  }
  exports.AbortSignalImpl = AbortSignalImpl;
});

// node_modules/@oozcitak/dom/lib/dom/DocumentTypeImpl.js
var require_DocumentTypeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocumentTypeImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var NodeImpl_1 = require_NodeImpl();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class DocumentTypeImpl extends NodeImpl_1.NodeImpl {
    _nodeType = interfaces_1.NodeType.DocumentType;
    _name = "";
    _publicId = "";
    _systemId = "";
    constructor(name, publicId, systemId) {
      super();
      this._name = name;
      this._publicId = publicId;
      this._systemId = systemId;
    }
    get name() {
      return this._name;
    }
    get publicId() {
      return this._publicId;
    }
    get systemId() {
      return this._systemId;
    }
    before(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    after(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    replaceWith(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    remove() {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    static _create(document2, name, publicId = "", systemId = "") {
      const node = new DocumentTypeImpl(name, publicId, systemId);
      node._nodeDocument = document2;
      return node;
    }
  }
  exports.DocumentTypeImpl = DocumentTypeImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(DocumentTypeImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentType);
});

// node_modules/@oozcitak/dom/lib/dom/ElementImpl.js
var require_ElementImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElementImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var NodeImpl_1 = require_NodeImpl();
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib7();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class ElementImpl extends NodeImpl_1.NodeImpl {
    _nodeType = interfaces_1.NodeType.Element;
    _children = new Set;
    _namespace = null;
    _namespacePrefix = null;
    _localName = "";
    _customElementState = "undefined";
    _customElementDefinition = null;
    _is = null;
    _shadowRoot = null;
    _attributeList = (0, algorithm_1.create_namedNodeMap)(this);
    _uniqueIdentifier;
    _attributeChangeSteps = [];
    _name = "";
    _assignedSlot = null;
    constructor() {
      super();
    }
    get namespaceURI() {
      return this._namespace;
    }
    get prefix() {
      return this._namespacePrefix;
    }
    get localName() {
      return this._localName;
    }
    get tagName() {
      return this._htmlUppercasedQualifiedName;
    }
    get id() {
      return (0, algorithm_1.element_getAnAttributeValue)(this, "id");
    }
    set id(value) {
      (0, algorithm_1.element_setAnAttributeValue)(this, "id", value);
    }
    get className() {
      return (0, algorithm_1.element_getAnAttributeValue)(this, "class");
    }
    set className(value) {
      (0, algorithm_1.element_setAnAttributeValue)(this, "class", value);
    }
    get classList() {
      let attr = (0, algorithm_1.element_getAnAttributeByName)("class", this);
      if (attr === null) {
        attr = (0, algorithm_1.create_attr)(this._nodeDocument, "class");
      }
      return (0, algorithm_1.create_domTokenList)(this, attr);
    }
    get slot() {
      return (0, algorithm_1.element_getAnAttributeValue)(this, "slot");
    }
    set slot(value) {
      (0, algorithm_1.element_setAnAttributeValue)(this, "slot", value);
    }
    hasAttributes() {
      return this._attributeList.length !== 0;
    }
    get attributes() {
      return this._attributeList;
    }
    getAttributeNames() {
      const names = [];
      for (const attr of this._attributeList) {
        names.push(attr._qualifiedName);
      }
      return names;
    }
    getAttribute(qualifiedName) {
      const attr = (0, algorithm_1.element_getAnAttributeByName)(qualifiedName, this);
      return attr ? attr._value : null;
    }
    getAttributeNS(namespace, localName) {
      const attr = (0, algorithm_1.element_getAnAttributeByNamespaceAndLocalName)(namespace, localName, this);
      return attr ? attr._value : null;
    }
    setAttribute(qualifiedName, value) {
      if (!(0, algorithm_1.xml_isName)(qualifiedName))
        throw new DOMException_1.InvalidCharacterError;
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      let attribute2 = null;
      for (let i = 0;i < this._attributeList.length; i++) {
        const attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          attribute2 = attr;
          break;
        }
      }
      if (attribute2 === null) {
        attribute2 = (0, algorithm_1.create_attr)(this._nodeDocument, qualifiedName);
        attribute2._value = value;
        (0, algorithm_1.element_append)(attribute2, this);
        return;
      }
      (0, algorithm_1.element_change)(attribute2, this, value);
    }
    setAttributeNS(namespace, qualifiedName, value) {
      const [ns, prefix, localName] = (0, algorithm_1.namespace_validateAndExtract)(namespace, qualifiedName);
      (0, algorithm_1.element_setAnAttributeValue)(this, localName, value, prefix, ns);
    }
    removeAttribute(qualifiedName) {
      (0, algorithm_1.element_removeAnAttributeByName)(qualifiedName, this);
    }
    removeAttributeNS(namespace, localName) {
      (0, algorithm_1.element_removeAnAttributeByNamespaceAndLocalName)(namespace, localName, this);
    }
    hasAttribute(qualifiedName) {
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      for (let i = 0;i < this._attributeList.length; i++) {
        const attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          return true;
        }
      }
      return false;
    }
    toggleAttribute(qualifiedName, force) {
      if (!(0, algorithm_1.xml_isName)(qualifiedName))
        throw new DOMException_1.InvalidCharacterError;
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      let attribute2 = null;
      for (let i = 0;i < this._attributeList.length; i++) {
        const attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          attribute2 = attr;
          break;
        }
      }
      if (attribute2 === null) {
        if (force === undefined || force === true) {
          attribute2 = (0, algorithm_1.create_attr)(this._nodeDocument, qualifiedName);
          attribute2._value = "";
          (0, algorithm_1.element_append)(attribute2, this);
          return true;
        }
        return false;
      } else if (force === undefined || force === false) {
        (0, algorithm_1.element_removeAnAttributeByName)(qualifiedName, this);
        return false;
      }
      return true;
    }
    hasAttributeNS(namespace, localName) {
      const ns = namespace || null;
      for (let i = 0;i < this._attributeList.length; i++) {
        const attr = this._attributeList[i];
        if (attr._namespace === ns && attr._localName === localName) {
          return true;
        }
      }
      return false;
    }
    getAttributeNode(qualifiedName) {
      return (0, algorithm_1.element_getAnAttributeByName)(qualifiedName, this);
    }
    getAttributeNodeNS(namespace, localName) {
      return (0, algorithm_1.element_getAnAttributeByNamespaceAndLocalName)(namespace, localName, this);
    }
    setAttributeNode(attr) {
      return (0, algorithm_1.element_setAnAttribute)(attr, this);
    }
    setAttributeNodeNS(attr) {
      return (0, algorithm_1.element_setAnAttribute)(attr, this);
    }
    removeAttributeNode(attr) {
      let found = false;
      for (let i = 0;i < this._attributeList.length; i++) {
        const attribute2 = this._attributeList[i];
        if (attribute2 === attr) {
          found = true;
          break;
        }
      }
      if (!found)
        throw new DOMException_1.NotFoundError;
      (0, algorithm_1.element_remove)(attr, this);
      return attr;
    }
    attachShadow(init) {
      if (this._namespace !== infra_1.namespace.HTML)
        throw new DOMException_1.NotSupportedError;
      if (!(0, algorithm_1.customElement_isValidCustomElementName)(this._localName) && !(0, algorithm_1.customElement_isValidShadowHostName)(this._localName))
        throw new DOMException_1.NotSupportedError;
      if ((0, algorithm_1.customElement_isValidCustomElementName)(this._localName) || this._is !== null) {
        const definition = (0, algorithm_1.customElement_lookUpACustomElementDefinition)(this._nodeDocument, this._namespace, this._localName, this._is);
        if (definition !== null && definition.disableShadow === true) {
          throw new DOMException_1.NotSupportedError;
        }
      }
      if (this._shadowRoot !== null)
        throw new DOMException_1.NotSupportedError;
      const shadow = (0, algorithm_1.create_shadowRoot)(this._nodeDocument, this);
      shadow._mode = init.mode;
      this._shadowRoot = shadow;
      return shadow;
    }
    get shadowRoot() {
      const shadow = this._shadowRoot;
      if (shadow === null || shadow.mode === "closed")
        return null;
      else
        return shadow;
    }
    closest(selectors) {
      throw new DOMException_1.NotImplementedError;
    }
    matches(selectors) {
      throw new DOMException_1.NotImplementedError;
    }
    webkitMatchesSelector(selectors) {
      return this.matches(selectors);
    }
    getElementsByTagName(qualifiedName) {
      return (0, algorithm_1.node_listOfElementsWithQualifiedName)(qualifiedName, this);
    }
    getElementsByTagNameNS(namespace, localName) {
      return (0, algorithm_1.node_listOfElementsWithNamespace)(namespace, localName, this);
    }
    getElementsByClassName(classNames) {
      return (0, algorithm_1.node_listOfElementsWithClassNames)(classNames, this);
    }
    insertAdjacentElement(where, element) {
      return (0, algorithm_1.element_insertAdjacent)(this, where, element);
    }
    insertAdjacentText(where, data) {
      const text = (0, algorithm_1.create_text)(this._nodeDocument, data);
      (0, algorithm_1.element_insertAdjacent)(this, where, text);
    }
    get _qualifiedName() {
      return this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
    }
    get _htmlUppercasedQualifiedName() {
      let qualifiedName = this._qualifiedName;
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toUpperCase();
      }
      return qualifiedName;
    }
    get children() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get firstElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get lastElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get childElementCount() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    prepend(...nodes) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    append(...nodes) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    querySelector(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    querySelectorAll(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get previousElementSibling() {
      throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
    }
    get nextElementSibling() {
      throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
    }
    before(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    after(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    replaceWith(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    remove() {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    get assignedSlot() {
      throw new Error("Mixin: Slotable not implemented.");
    }
    static _create(document2, localName, namespace = null, namespacePrefix = null) {
      const node = new ElementImpl;
      node._localName = localName;
      node._namespace = namespace;
      node._namespacePrefix = namespacePrefix;
      node._nodeDocument = document2;
      return node;
    }
  }
  exports.ElementImpl = ElementImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(ElementImpl.prototype, "_nodeType", interfaces_1.NodeType.Element);
});

// node_modules/@oozcitak/dom/lib/dom/DocumentFragmentImpl.js
var require_DocumentFragmentImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocumentFragmentImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var NodeImpl_1 = require_NodeImpl();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class DocumentFragmentImpl extends NodeImpl_1.NodeImpl {
    _nodeType = interfaces_1.NodeType.DocumentFragment;
    _children = new Set;
    _host;
    constructor(host = null) {
      super();
      this._host = host;
    }
    getElementById(elementId) {
      throw new Error("Mixin: NonElementParentNode not implemented.");
    }
    get children() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get firstElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get lastElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    get childElementCount() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    prepend(...nodes) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    append(...nodes) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    querySelector(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    querySelectorAll(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    static _create(document2, host = null) {
      const node = new DocumentFragmentImpl(host);
      node._nodeDocument = document2;
      return node;
    }
  }
  exports.DocumentFragmentImpl = DocumentFragmentImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(DocumentFragmentImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentFragment);
});

// node_modules/@oozcitak/dom/lib/dom/ShadowRootImpl.js
var require_ShadowRootImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ShadowRootImpl = undefined;
  var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var algorithm_1 = require_algorithm();

  class ShadowRootImpl extends DocumentFragmentImpl_1.DocumentFragmentImpl {
    _host;
    _mode;
    constructor(host, mode) {
      super();
      this._host = host;
      this._mode = mode;
    }
    get mode() {
      return this._mode;
    }
    get host() {
      return this._host;
    }
    _getTheParent(event) {
      if (!event._composedFlag && !(0, util_1.isEmpty)(event._path) && (0, algorithm_1.tree_rootNode)(event._path[0].invocationTarget) === this) {
        return null;
      } else {
        return this._host;
      }
    }
    static _create(document2, host) {
      return new ShadowRootImpl(host, "closed");
    }
  }
  exports.ShadowRootImpl = ShadowRootImpl;
});

// node_modules/@oozcitak/dom/lib/dom/AttrImpl.js
var require_AttrImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttrImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var NodeImpl_1 = require_NodeImpl();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class AttrImpl extends NodeImpl_1.NodeImpl {
    _nodeType = interfaces_1.NodeType.Attribute;
    _localName;
    _namespace = null;
    _namespacePrefix = null;
    _element = null;
    _value = "";
    constructor(localName) {
      super();
      this._localName = localName;
    }
    specified;
    get ownerElement() {
      return this._element;
    }
    get namespaceURI() {
      return this._namespace;
    }
    get prefix() {
      return this._namespacePrefix;
    }
    get localName() {
      return this._localName;
    }
    get name() {
      return this._qualifiedName;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      (0, algorithm_1.attr_setAnExistingAttributeValue)(this, value);
    }
    get _qualifiedName() {
      return this._namespacePrefix !== null ? this._namespacePrefix + ":" + this._localName : this._localName;
    }
    static _create(document2, localName) {
      const node = new AttrImpl(localName);
      node._nodeDocument = document2;
      return node;
    }
  }
  exports.AttrImpl = AttrImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(AttrImpl.prototype, "_nodeType", interfaces_1.NodeType.Attribute);
  (0, WebIDLAlgorithm_1.idl_defineConst)(AttrImpl.prototype, "specified", true);
});

// node_modules/@oozcitak/dom/lib/dom/CharacterDataImpl.js
var require_CharacterDataImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CharacterDataImpl = undefined;
  var NodeImpl_1 = require_NodeImpl();
  var algorithm_1 = require_algorithm();

  class CharacterDataImpl extends NodeImpl_1.NodeImpl {
    _data;
    constructor(data) {
      super();
      this._data = data;
    }
    get data() {
      return this._data;
    }
    set data(value) {
      (0, algorithm_1.characterData_replaceData)(this, 0, this._data.length, value);
    }
    get length() {
      return this._data.length;
    }
    substringData(offset, count) {
      return (0, algorithm_1.characterData_substringData)(this, offset, count);
    }
    appendData(data) {
      return (0, algorithm_1.characterData_replaceData)(this, this._data.length, 0, data);
    }
    insertData(offset, data) {
      (0, algorithm_1.characterData_replaceData)(this, offset, 0, data);
    }
    deleteData(offset, count) {
      (0, algorithm_1.characterData_replaceData)(this, offset, count, "");
    }
    replaceData(offset, count, data) {
      (0, algorithm_1.characterData_replaceData)(this, offset, count, data);
    }
    get previousElementSibling() {
      throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
    }
    get nextElementSibling() {
      throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
    }
    before(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    after(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    replaceWith(...nodes) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    remove() {
      throw new Error("Mixin: ChildNode not implemented.");
    }
  }
  exports.CharacterDataImpl = CharacterDataImpl;
});

// node_modules/@oozcitak/dom/lib/dom/TextImpl.js
var require_TextImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TextImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var CharacterDataImpl_1 = require_CharacterDataImpl();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class TextImpl extends CharacterDataImpl_1.CharacterDataImpl {
    _nodeType = interfaces_1.NodeType.Text;
    _name = "";
    _assignedSlot = null;
    constructor(data = "") {
      super(data);
    }
    get wholeText() {
      let text = "";
      for (const node of (0, algorithm_1.text_contiguousTextNodes)(this, true)) {
        text = text + node._data;
      }
      return text;
    }
    splitText(offset) {
      return (0, algorithm_1.text_split)(this, offset);
    }
    get assignedSlot() {
      throw new Error("Mixin: Slotable not implemented.");
    }
    static _create(document2, data = "") {
      const node = new TextImpl(data);
      node._nodeDocument = document2;
      return node;
    }
  }
  exports.TextImpl = TextImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(TextImpl.prototype, "_nodeType", interfaces_1.NodeType.Text);
});

// node_modules/@oozcitak/dom/lib/dom/CDATASectionImpl.js
var require_CDATASectionImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CDATASectionImpl = undefined;
  var TextImpl_1 = require_TextImpl();
  var interfaces_1 = require_interfaces2();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class CDATASectionImpl extends TextImpl_1.TextImpl {
    _nodeType = interfaces_1.NodeType.CData;
    constructor(data) {
      super(data);
    }
    static _create(document2, data = "") {
      const node = new CDATASectionImpl(data);
      node._nodeDocument = document2;
      return node;
    }
  }
  exports.CDATASectionImpl = CDATASectionImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(CDATASectionImpl.prototype, "_nodeType", interfaces_1.NodeType.CData);
});

// node_modules/@oozcitak/dom/lib/dom/CommentImpl.js
var require_CommentImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommentImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var CharacterDataImpl_1 = require_CharacterDataImpl();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class CommentImpl extends CharacterDataImpl_1.CharacterDataImpl {
    _nodeType = interfaces_1.NodeType.Comment;
    constructor(data = "") {
      super(data);
    }
    static _create(document2, data = "") {
      const node = new CommentImpl(data);
      node._nodeDocument = document2;
      return node;
    }
  }
  exports.CommentImpl = CommentImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(CommentImpl.prototype, "_nodeType", interfaces_1.NodeType.Comment);
});

// node_modules/@oozcitak/dom/lib/dom/ProcessingInstructionImpl.js
var require_ProcessingInstructionImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProcessingInstructionImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var CharacterDataImpl_1 = require_CharacterDataImpl();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class ProcessingInstructionImpl extends CharacterDataImpl_1.CharacterDataImpl {
    _nodeType = interfaces_1.NodeType.ProcessingInstruction;
    _target;
    constructor(target, data) {
      super(data);
      this._target = target;
    }
    get target() {
      return this._target;
    }
    static _create(document2, target, data) {
      const node = new ProcessingInstructionImpl(target, data);
      node._nodeDocument = document2;
      return node;
    }
  }
  exports.ProcessingInstructionImpl = ProcessingInstructionImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(ProcessingInstructionImpl.prototype, "_nodeType", interfaces_1.NodeType.ProcessingInstruction);
});

// node_modules/@oozcitak/dom/lib/dom/HTMLCollectionImpl.js
var require_HTMLCollectionImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTMLCollectionImpl = undefined;
  var infra_1 = require_lib7();
  var algorithm_1 = require_algorithm();
  var util_1 = require_util2();
  var util_2 = (init_lib(), __toCommonJS(exports_lib));

  class HTMLCollectionImpl {
    _live = true;
    _root;
    _filter;
    static reservedNames = [
      "_root",
      "_live",
      "_filter",
      "length",
      "item",
      "namedItem",
      "get",
      "set"
    ];
    constructor(root, filter) {
      this._root = root;
      this._filter = filter;
      return new Proxy(this, this);
    }
    get length() {
      let count = 0;
      let node = (0, algorithm_1.tree_getFirstDescendantNode)(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      while (node !== null) {
        count++;
        node = (0, algorithm_1.tree_getNextDescendantNode)(this._root, node, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      }
      return count;
    }
    item(index) {
      let i = 0;
      let node = (0, algorithm_1.tree_getFirstDescendantNode)(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      while (node !== null) {
        if (i === index)
          return node;
        else
          i++;
        node = (0, algorithm_1.tree_getNextDescendantNode)(this._root, node, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      }
      return null;
    }
    namedItem(key) {
      if (key === "")
        return null;
      let ele = (0, algorithm_1.tree_getFirstDescendantNode)(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      while (ele != null) {
        if (ele._uniqueIdentifier === key) {
          return ele;
        } else if (ele._namespace === infra_1.namespace.HTML) {
          for (let i = 0;i < ele._attributeList.length; i++) {
            const attr = ele._attributeList[i];
            if (attr._localName === "name" && attr._namespace === null && attr._namespacePrefix === null && attr._value === key)
              return ele;
          }
        }
        ele = (0, algorithm_1.tree_getNextDescendantNode)(this._root, ele, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      }
      return null;
    }
    [Symbol.iterator]() {
      const root = this._root;
      const filter = this._filter;
      let currentNode = (0, algorithm_1.tree_getFirstDescendantNode)(root, false, false, (e) => util_1.Guard.isElementNode(e) && filter(e));
      return {
        next() {
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            const result = { done: false, value: currentNode };
            currentNode = (0, algorithm_1.tree_getNextDescendantNode)(root, currentNode, false, false, (e) => util_1.Guard.isElementNode(e) && filter(e));
            return result;
          }
        }
      };
    }
    get(target, key, receiver) {
      if (!(0, util_2.isString)(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
        return Reflect.get(target, key, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return target.namedItem(key) || undefined;
      } else {
        return target.item(index) || undefined;
      }
    }
    set(target, key, value, receiver) {
      if (!(0, util_2.isString)(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
        return Reflect.set(target, key, value, receiver);
      }
      const index = Number(key);
      const node = isNaN(index) ? target.namedItem(key) || undefined : target.item(index) || undefined;
      if (node && node._parent) {
        (0, algorithm_1.mutation_replace)(node, value, node._parent);
        return true;
      } else {
        return false;
      }
    }
    static _create(root, filter = () => true) {
      return new HTMLCollectionImpl(root, filter);
    }
  }
  exports.HTMLCollectionImpl = HTMLCollectionImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NodeListImpl.js
var require_NodeListImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeListImpl = undefined;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var algorithm_1 = require_algorithm();

  class NodeListImpl {
    _live = true;
    _root;
    _filter = null;
    _length = 0;
    constructor(root) {
      this._root = root;
      return new Proxy(this, this);
    }
    get length() {
      return this._root._children.size;
    }
    item(index) {
      if (index < 0 || index > this.length - 1)
        return null;
      if (index < this.length / 2) {
        let i = 0;
        let node = this._root._firstChild;
        while (node !== null && i !== index) {
          node = node._nextSibling;
          i++;
        }
        return node;
      } else {
        let i = this.length - 1;
        let node = this._root._lastChild;
        while (node !== null && i !== index) {
          node = node._previousSibling;
          i--;
        }
        return node;
      }
    }
    keys() {
      return {
        [Symbol.iterator]: function() {
          let index = 0;
          return {
            next: function() {
              if (index === this.length) {
                return { done: true, value: null };
              } else {
                return { done: false, value: index++ };
              }
            }.bind(this)
          };
        }.bind(this)
      };
    }
    values() {
      return {
        [Symbol.iterator]: function() {
          const it = this[Symbol.iterator]();
          return {
            next() {
              return it.next();
            }
          };
        }.bind(this)
      };
    }
    entries() {
      return {
        [Symbol.iterator]: function() {
          const it = this[Symbol.iterator]();
          let index = 0;
          return {
            next() {
              const itResult = it.next();
              if (itResult.done) {
                return { done: true, value: null };
              } else {
                return { done: false, value: [index++, itResult.value] };
              }
            }
          };
        }.bind(this)
      };
    }
    [Symbol.iterator]() {
      return this._root._children[Symbol.iterator]();
    }
    forEach(callback, thisArg) {
      if (thisArg === undefined) {
        thisArg = DOMImpl_1.dom.window;
      }
      let index = 0;
      for (const node of this._root._children) {
        callback.call(thisArg, node, index++, this);
      }
    }
    get(target, key, receiver) {
      if (!(0, util_1.isString)(key)) {
        return Reflect.get(target, key, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return Reflect.get(target, key, receiver);
      }
      return target.item(index) || undefined;
    }
    set(target, key, value, receiver) {
      if (!(0, util_1.isString)(key)) {
        return Reflect.set(target, key, value, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return Reflect.set(target, key, value, receiver);
      }
      const node = target.item(index) || undefined;
      if (!node)
        return false;
      if (node._parent) {
        (0, algorithm_1.mutation_replace)(node, value, node._parent);
        return true;
      } else {
        return false;
      }
    }
    static _create(root) {
      return new NodeListImpl(root);
    }
  }
  exports.NodeListImpl = NodeListImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NodeListStaticImpl.js
var require_NodeListStaticImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeListStaticImpl = undefined;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));

  class NodeListStaticImpl {
    _live = false;
    _root;
    _filter;
    _items = [];
    _length = 0;
    constructor(root) {
      this._root = root;
      this._items = [];
      this._filter = function(node) {
        return true;
      };
      return new Proxy(this, this);
    }
    get length() {
      return this._items.length;
    }
    item(index) {
      if (index < 0 || index > this.length - 1)
        return null;
      return this._items[index];
    }
    keys() {
      return {
        [Symbol.iterator]: function() {
          let index = 0;
          return {
            next: function() {
              if (index === this.length) {
                return { done: true, value: null };
              } else {
                return { done: false, value: index++ };
              }
            }.bind(this)
          };
        }.bind(this)
      };
    }
    values() {
      return {
        [Symbol.iterator]: function() {
          const it = this[Symbol.iterator]();
          return {
            next() {
              return it.next();
            }
          };
        }.bind(this)
      };
    }
    entries() {
      return {
        [Symbol.iterator]: function() {
          const it = this[Symbol.iterator]();
          let index = 0;
          return {
            next() {
              const itResult = it.next();
              if (itResult.done) {
                return { done: true, value: null };
              } else {
                return { done: false, value: [index++, itResult.value] };
              }
            }
          };
        }.bind(this)
      };
    }
    [Symbol.iterator]() {
      const it = this._items[Symbol.iterator]();
      return {
        next() {
          return it.next();
        }
      };
    }
    forEach(callback, thisArg) {
      if (thisArg === undefined) {
        thisArg = DOMImpl_1.dom.window;
      }
      let index = 0;
      for (const node of this._items) {
        callback.call(thisArg, node, index++, this);
      }
    }
    get(target, key, receiver) {
      if (!(0, util_1.isString)(key)) {
        return Reflect.get(target, key, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return Reflect.get(target, key, receiver);
      }
      return target._items[index] || undefined;
    }
    set(target, key, value, receiver) {
      if (!(0, util_1.isString)(key)) {
        return Reflect.set(target, key, value, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return Reflect.set(target, key, value, receiver);
      }
      if (index >= 0 && index < target._items.length) {
        target._items[index] = value;
        return true;
      } else {
        return false;
      }
    }
    static _create(root, items) {
      const list = new NodeListStaticImpl(root);
      list._items = items;
      return list;
    }
  }
  exports.NodeListStaticImpl = NodeListStaticImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NamedNodeMapImpl.js
var require_NamedNodeMapImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NamedNodeMapImpl = undefined;
  var DOMException_1 = require_DOMException();
  var algorithm_1 = require_algorithm();

  class NamedNodeMapImpl extends Array {
    _element;
    constructor(element) {
      super();
      this._element = element;
      Object.setPrototypeOf(this, NamedNodeMapImpl.prototype);
    }
    _asArray() {
      return this;
    }
    item(index) {
      return this[index] || null;
    }
    getNamedItem(qualifiedName) {
      return (0, algorithm_1.element_getAnAttributeByName)(qualifiedName, this._element);
    }
    getNamedItemNS(namespace, localName) {
      return (0, algorithm_1.element_getAnAttributeByNamespaceAndLocalName)(namespace || "", localName, this._element);
    }
    setNamedItem(attr) {
      return (0, algorithm_1.element_setAnAttribute)(attr, this._element);
    }
    setNamedItemNS(attr) {
      return (0, algorithm_1.element_setAnAttribute)(attr, this._element);
    }
    removeNamedItem(qualifiedName) {
      const attr = (0, algorithm_1.element_removeAnAttributeByName)(qualifiedName, this._element);
      if (attr === null)
        throw new DOMException_1.NotFoundError;
      return attr;
    }
    removeNamedItemNS(namespace, localName) {
      const attr = (0, algorithm_1.element_removeAnAttributeByNamespaceAndLocalName)(namespace || "", localName, this._element);
      if (attr === null)
        throw new DOMException_1.NotFoundError;
      return attr;
    }
    static _create(element) {
      return new NamedNodeMapImpl(element);
    }
  }
  exports.NamedNodeMapImpl = NamedNodeMapImpl;
});

// node_modules/@oozcitak/dom/lib/dom/AbstractRangeImpl.js
var require_AbstractRangeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractRangeImpl = undefined;

  class AbstractRangeImpl {
    get _startNode() {
      return this._start[0];
    }
    get _startOffset() {
      return this._start[1];
    }
    get _endNode() {
      return this._end[0];
    }
    get _endOffset() {
      return this._end[1];
    }
    get _collapsed() {
      return this._start[0] === this._end[0] && this._start[1] === this._end[1];
    }
    get startContainer() {
      return this._startNode;
    }
    get startOffset() {
      return this._startOffset;
    }
    get endContainer() {
      return this._endNode;
    }
    get endOffset() {
      return this._endOffset;
    }
    get collapsed() {
      return this._collapsed;
    }
  }
  exports.AbstractRangeImpl = AbstractRangeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/RangeImpl.js
var require_RangeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RangeImpl = undefined;
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var AbstractRangeImpl_1 = require_AbstractRangeImpl();
  var DOMException_1 = require_DOMException();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var util_1 = require_util2();

  class RangeImpl extends AbstractRangeImpl_1.AbstractRangeImpl {
    static START_TO_START = 0;
    static START_TO_END = 1;
    static END_TO_END = 2;
    static END_TO_START = 3;
    START_TO_START = 0;
    START_TO_END = 1;
    END_TO_END = 2;
    END_TO_START = 3;
    _start;
    _end;
    constructor() {
      super();
      const doc = DOMImpl_1.dom.window._associatedDocument;
      this._start = [doc, 0];
      this._end = [doc, 0];
      DOMImpl_1.dom.rangeList.add(this);
    }
    get commonAncestorContainer() {
      let container = this._start[0];
      while (!(0, algorithm_1.tree_isAncestorOf)(this._end[0], container, true)) {
        if (container._parent === null) {
          throw new Error("Parent node  is null.");
        }
        container = container._parent;
      }
      return container;
    }
    setStart(node, offset) {
      (0, algorithm_1.range_setTheStart)(this, node, offset);
    }
    setEnd(node, offset) {
      (0, algorithm_1.range_setTheEnd)(this, node, offset);
    }
    setStartBefore(node) {
      let parent = node._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError;
      (0, algorithm_1.range_setTheStart)(this, parent, (0, algorithm_1.tree_index)(node));
    }
    setStartAfter(node) {
      let parent = node._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError;
      (0, algorithm_1.range_setTheStart)(this, parent, (0, algorithm_1.tree_index)(node) + 1);
    }
    setEndBefore(node) {
      let parent = node._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError;
      (0, algorithm_1.range_setTheEnd)(this, parent, (0, algorithm_1.tree_index)(node));
    }
    setEndAfter(node) {
      let parent = node._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError;
      (0, algorithm_1.range_setTheEnd)(this, parent, (0, algorithm_1.tree_index)(node) + 1);
    }
    collapse(toStart) {
      if (toStart) {
        this._end = this._start;
      } else {
        this._start = this._end;
      }
    }
    selectNode(node) {
      (0, algorithm_1.range_select)(node, this);
    }
    selectNodeContents(node) {
      if (util_1.Guard.isDocumentTypeNode(node))
        throw new DOMException_1.InvalidNodeTypeError;
      const length = (0, algorithm_1.tree_nodeLength)(node);
      this._start = [node, 0];
      this._end = [node, length];
    }
    compareBoundaryPoints(how, sourceRange) {
      if (how !== interfaces_1.HowToCompare.StartToStart && how !== interfaces_1.HowToCompare.StartToEnd && how !== interfaces_1.HowToCompare.EndToEnd && how !== interfaces_1.HowToCompare.EndToStart)
        throw new DOMException_1.NotSupportedError;
      if ((0, algorithm_1.range_root)(this) !== (0, algorithm_1.range_root)(sourceRange))
        throw new DOMException_1.WrongDocumentError;
      let thisPoint;
      let otherPoint;
      switch (how) {
        case interfaces_1.HowToCompare.StartToStart:
          thisPoint = this._start;
          otherPoint = sourceRange._start;
          break;
        case interfaces_1.HowToCompare.StartToEnd:
          thisPoint = this._end;
          otherPoint = sourceRange._start;
          break;
        case interfaces_1.HowToCompare.EndToEnd:
          thisPoint = this._end;
          otherPoint = sourceRange._end;
          break;
        case interfaces_1.HowToCompare.EndToStart:
          thisPoint = this._start;
          otherPoint = sourceRange._end;
          break;
        default:
          throw new DOMException_1.NotSupportedError;
      }
      const position = (0, algorithm_1.boundaryPoint_position)(thisPoint, otherPoint);
      if (position === interfaces_1.BoundaryPosition.Before) {
        return -1;
      } else if (position === interfaces_1.BoundaryPosition.After) {
        return 1;
      } else {
        return 0;
      }
    }
    deleteContents() {
      if ((0, algorithm_1.range_collapsed)(this))
        return;
      const originalStartNode = this._startNode;
      const originalStartOffset = this._startOffset;
      const originalEndNode = this._endNode;
      const originalEndOffset = this._endOffset;
      if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
        (0, algorithm_1.characterData_replaceData)(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
        return;
      }
      const nodesToRemove = [];
      for (const node of (0, algorithm_1.range_getContainedNodes)(this)) {
        const parent = node._parent;
        if (parent !== null && (0, algorithm_1.range_isContained)(parent, this)) {
          continue;
        }
        nodesToRemove.push(node);
      }
      let newNode;
      let newOffset;
      if ((0, algorithm_1.tree_isAncestorOf)(originalEndNode, originalStartNode, true)) {
        newNode = originalStartNode;
        newOffset = originalStartOffset;
      } else {
        let referenceNode = originalStartNode;
        while (referenceNode._parent !== null && !(0, algorithm_1.tree_isAncestorOf)(originalEndNode, referenceNode._parent, true)) {
          referenceNode = referenceNode._parent;
        }
        if (referenceNode._parent === null) {
          throw new Error("Parent node is null.");
        }
        newNode = referenceNode._parent;
        newOffset = (0, algorithm_1.tree_index)(referenceNode) + 1;
      }
      if (util_1.Guard.isCharacterDataNode(originalStartNode)) {
        (0, algorithm_1.characterData_replaceData)(originalStartNode, originalStartOffset, (0, algorithm_1.tree_nodeLength)(originalStartNode) - originalStartOffset, "");
      }
      for (const node of nodesToRemove) {
        if (node._parent) {
          (0, algorithm_1.mutation_remove)(node, node._parent);
        }
      }
      if (util_1.Guard.isCharacterDataNode(originalEndNode)) {
        (0, algorithm_1.characterData_replaceData)(originalEndNode, 0, originalEndOffset, "");
      }
      this._start = [newNode, newOffset];
      this._end = [newNode, newOffset];
    }
    extractContents() {
      return (0, algorithm_1.range_extract)(this);
    }
    cloneContents() {
      return (0, algorithm_1.range_cloneTheContents)(this);
    }
    insertNode(node) {
      return (0, algorithm_1.range_insert)(node, this);
    }
    surroundContents(newParent) {
      for (const node of (0, algorithm_1.range_getPartiallyContainedNodes)(this)) {
        if (!util_1.Guard.isTextNode(node)) {
          throw new DOMException_1.InvalidStateError;
        }
      }
      if (util_1.Guard.isDocumentNode(newParent) || util_1.Guard.isDocumentTypeNode(newParent) || util_1.Guard.isDocumentFragmentNode(newParent)) {
        throw new DOMException_1.InvalidNodeTypeError;
      }
      const fragment = (0, algorithm_1.range_extract)(this);
      if (newParent._children.size !== 0) {
        (0, algorithm_1.mutation_replaceAll)(null, newParent);
      }
      (0, algorithm_1.range_insert)(newParent, this);
      (0, algorithm_1.mutation_append)(fragment, newParent);
      (0, algorithm_1.range_select)(newParent, this);
    }
    cloneRange() {
      return (0, algorithm_1.create_range)(this._start, this._end);
    }
    detach() {
      DOMImpl_1.dom.rangeList.delete(this);
    }
    isPointInRange(node, offset) {
      if ((0, algorithm_1.tree_rootNode)(node) !== (0, algorithm_1.range_root)(this)) {
        return false;
      }
      if (util_1.Guard.isDocumentTypeNode(node))
        throw new DOMException_1.InvalidNodeTypeError;
      if (offset > (0, algorithm_1.tree_nodeLength)(node))
        throw new DOMException_1.IndexSizeError;
      const bp = [node, offset];
      if ((0, algorithm_1.boundaryPoint_position)(bp, this._start) === interfaces_1.BoundaryPosition.Before || (0, algorithm_1.boundaryPoint_position)(bp, this._end) === interfaces_1.BoundaryPosition.After) {
        return false;
      }
      return true;
    }
    comparePoint(node, offset) {
      if ((0, algorithm_1.tree_rootNode)(node) !== (0, algorithm_1.range_root)(this))
        throw new DOMException_1.WrongDocumentError;
      if (util_1.Guard.isDocumentTypeNode(node))
        throw new DOMException_1.InvalidNodeTypeError;
      if (offset > (0, algorithm_1.tree_nodeLength)(node))
        throw new DOMException_1.IndexSizeError;
      const bp = [node, offset];
      if ((0, algorithm_1.boundaryPoint_position)(bp, this._start) === interfaces_1.BoundaryPosition.Before) {
        return -1;
      } else if ((0, algorithm_1.boundaryPoint_position)(bp, this._end) === interfaces_1.BoundaryPosition.After) {
        return 1;
      } else {
        return 0;
      }
    }
    intersectsNode(node) {
      if ((0, algorithm_1.tree_rootNode)(node) !== (0, algorithm_1.range_root)(this)) {
        return false;
      }
      const parent = node._parent;
      if (parent === null)
        return true;
      const offset = (0, algorithm_1.tree_index)(node);
      if ((0, algorithm_1.boundaryPoint_position)([parent, offset], this._end) === interfaces_1.BoundaryPosition.Before && (0, algorithm_1.boundaryPoint_position)([parent, offset + 1], this._start) === interfaces_1.BoundaryPosition.After) {
        return true;
      }
      return false;
    }
    toString() {
      let s = "";
      if (this._startNode === this._endNode && util_1.Guard.isTextNode(this._startNode)) {
        return this._startNode._data.substring(this._startOffset, this._endOffset);
      }
      if (util_1.Guard.isTextNode(this._startNode)) {
        s += this._startNode._data.substring(this._startOffset);
      }
      for (const child of (0, algorithm_1.range_getContainedNodes)(this)) {
        if (util_1.Guard.isTextNode(child)) {
          s += child._data;
        }
      }
      if (util_1.Guard.isTextNode(this._endNode)) {
        s += this._endNode._data.substring(0, this._endOffset);
      }
      return s;
    }
    static _create(start, end) {
      const range = new RangeImpl;
      if (start)
        range._start = start;
      if (end)
        range._end = end;
      return range;
    }
  }
  exports.RangeImpl = RangeImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(RangeImpl.prototype, "START_TO_START", 0);
  (0, WebIDLAlgorithm_1.idl_defineConst)(RangeImpl.prototype, "START_TO_END", 1);
  (0, WebIDLAlgorithm_1.idl_defineConst)(RangeImpl.prototype, "END_TO_END", 2);
  (0, WebIDLAlgorithm_1.idl_defineConst)(RangeImpl.prototype, "END_TO_START", 3);
});

// node_modules/@oozcitak/dom/lib/dom/TraverserImpl.js
var require_TraverserImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraverserImpl = undefined;
  var interfaces_1 = require_interfaces2();

  class TraverserImpl {
    _activeFlag;
    _root;
    _whatToShow;
    _filter;
    constructor(root) {
      this._activeFlag = false;
      this._root = root;
      this._whatToShow = interfaces_1.WhatToShow.All;
      this._filter = null;
    }
    get root() {
      return this._root;
    }
    get whatToShow() {
      return this._whatToShow;
    }
    get filter() {
      return this._filter;
    }
  }
  exports.TraverserImpl = TraverserImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NodeIteratorImpl.js
var require_NodeIteratorImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeIteratorImpl = undefined;
  var TraverserImpl_1 = require_TraverserImpl();
  var algorithm_1 = require_algorithm();

  class NodeIteratorImpl extends TraverserImpl_1.TraverserImpl {
    _iteratorCollection;
    _reference;
    _pointerBeforeReference;
    constructor(root, reference, pointerBeforeReference) {
      super(root);
      this._iteratorCollection = undefined;
      this._reference = reference;
      this._pointerBeforeReference = pointerBeforeReference;
      (0, algorithm_1.nodeIterator_iteratorList)().add(this);
    }
    get referenceNode() {
      return this._reference;
    }
    get pointerBeforeReferenceNode() {
      return this._pointerBeforeReference;
    }
    nextNode() {
      return (0, algorithm_1.nodeIterator_traverse)(this, true);
    }
    previousNode() {
      return (0, algorithm_1.nodeIterator_traverse)(this, false);
    }
    detach() {
      (0, algorithm_1.nodeIterator_iteratorList)().delete(this);
    }
    static _create(root, reference, pointerBeforeReference) {
      return new NodeIteratorImpl(root, reference, pointerBeforeReference);
    }
  }
  exports.NodeIteratorImpl = NodeIteratorImpl;
});

// node_modules/@oozcitak/dom/lib/dom/TreeWalkerImpl.js
var require_TreeWalkerImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TreeWalkerImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var TraverserImpl_1 = require_TraverserImpl();
  var algorithm_1 = require_algorithm();

  class TreeWalkerImpl extends TraverserImpl_1.TraverserImpl {
    _current;
    constructor(root, current) {
      super(root);
      this._current = current;
    }
    get currentNode() {
      return this._current;
    }
    set currentNode(value) {
      this._current = value;
    }
    parentNode() {
      let node = this._current;
      while (node !== null && node !== this._root) {
        node = node._parent;
        if (node !== null && (0, algorithm_1.traversal_filter)(this, node) === interfaces_1.FilterResult.Accept) {
          this._current = node;
          return node;
        }
      }
      return null;
    }
    firstChild() {
      return (0, algorithm_1.treeWalker_traverseChildren)(this, true);
    }
    lastChild() {
      return (0, algorithm_1.treeWalker_traverseChildren)(this, false);
    }
    nextSibling() {
      return (0, algorithm_1.treeWalker_traverseSiblings)(this, true);
    }
    previousNode() {
      let node = this._current;
      while (node !== this._root) {
        let sibling = node._previousSibling;
        while (sibling) {
          node = sibling;
          let result = (0, algorithm_1.traversal_filter)(this, node);
          while (result !== interfaces_1.FilterResult.Reject && node._lastChild) {
            node = node._lastChild;
            result = (0, algorithm_1.traversal_filter)(this, node);
          }
          if (result === interfaces_1.FilterResult.Accept) {
            this._current = node;
            return node;
          }
          sibling = node._previousSibling;
        }
        if (node === this._root || node._parent === null) {
          return null;
        }
        node = node._parent;
        if ((0, algorithm_1.traversal_filter)(this, node) === interfaces_1.FilterResult.Accept) {
          this._current = node;
          return node;
        }
      }
      return null;
    }
    previousSibling() {
      return (0, algorithm_1.treeWalker_traverseSiblings)(this, false);
    }
    nextNode() {
      let node = this._current;
      let result = interfaces_1.FilterResult.Accept;
      while (true) {
        while (result !== interfaces_1.FilterResult.Reject && node._firstChild) {
          node = node._firstChild;
          result = (0, algorithm_1.traversal_filter)(this, node);
          if (result === interfaces_1.FilterResult.Accept) {
            this._current = node;
            return node;
          }
        }
        let sibling = null;
        let temporary = node;
        while (temporary !== null) {
          if (temporary === this._root) {
            return null;
          }
          sibling = temporary._nextSibling;
          if (sibling !== null) {
            node = sibling;
            break;
          }
          temporary = temporary._parent;
        }
        result = (0, algorithm_1.traversal_filter)(this, node);
        if (result === interfaces_1.FilterResult.Accept) {
          this._current = node;
          return node;
        }
      }
    }
    static _create(root, current) {
      return new TreeWalkerImpl(root, current);
    }
  }
  exports.TreeWalkerImpl = TreeWalkerImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NodeFilterImpl.js
var require_NodeFilterImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeFilterImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class NodeFilterImpl {
    static FILTER_ACCEPT = 1;
    static FILTER_REJECT = 2;
    static FILTER_SKIP = 3;
    static SHOW_ALL = 4294967295;
    static SHOW_ELEMENT = 1;
    static SHOW_ATTRIBUTE = 2;
    static SHOW_TEXT = 4;
    static SHOW_CDATA_SECTION = 8;
    static SHOW_ENTITY_REFERENCE = 16;
    static SHOW_ENTITY = 32;
    static SHOW_PROCESSING_INSTRUCTION = 64;
    static SHOW_COMMENT = 128;
    static SHOW_DOCUMENT = 256;
    static SHOW_DOCUMENT_TYPE = 512;
    static SHOW_DOCUMENT_FRAGMENT = 1024;
    static SHOW_NOTATION = 2048;
    FILTER_ACCEPT = 1;
    FILTER_REJECT = 2;
    FILTER_SKIP = 3;
    SHOW_ALL = 4294967295;
    SHOW_ELEMENT = 1;
    SHOW_ATTRIBUTE = 2;
    SHOW_TEXT = 4;
    SHOW_CDATA_SECTION = 8;
    SHOW_ENTITY_REFERENCE = 16;
    SHOW_ENTITY = 32;
    SHOW_PROCESSING_INSTRUCTION = 64;
    SHOW_COMMENT = 128;
    SHOW_DOCUMENT = 256;
    SHOW_DOCUMENT_TYPE = 512;
    SHOW_DOCUMENT_FRAGMENT = 1024;
    SHOW_NOTATION = 2048;
    constructor() {}
    acceptNode(node) {
      return interfaces_1.FilterResult.Accept;
    }
    static _create() {
      return new NodeFilterImpl;
    }
  }
  exports.NodeFilterImpl = NodeFilterImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "FILTER_ACCEPT", 1);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "FILTER_REJECT", 2);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "FILTER_SKIP", 3);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ALL", 4294967295);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ELEMENT", 1);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ATTRIBUTE", 2);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_TEXT", 4);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_CDATA_SECTION", 8);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ENTITY_REFERENCE", 16);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ENTITY", 32);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_PROCESSING_INSTRUCTION", 64);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_COMMENT", 128);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_DOCUMENT", 256);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_DOCUMENT_TYPE", 512);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_DOCUMENT_FRAGMENT", 1024);
  (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_NOTATION", 2048);
});

// node_modules/@oozcitak/dom/lib/dom/MutationRecordImpl.js
var require_MutationRecordImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MutationRecordImpl = undefined;

  class MutationRecordImpl {
    _type;
    _target;
    _addedNodes;
    _removedNodes;
    _previousSibling;
    _nextSibling;
    _attributeName;
    _attributeNamespace;
    _oldValue;
    constructor(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
      this._type = type;
      this._target = target;
      this._addedNodes = addedNodes;
      this._removedNodes = removedNodes;
      this._previousSibling = previousSibling;
      this._nextSibling = nextSibling;
      this._attributeName = attributeName;
      this._attributeNamespace = attributeNamespace;
      this._oldValue = oldValue;
    }
    get type() {
      return this._type;
    }
    get target() {
      return this._target;
    }
    get addedNodes() {
      return this._addedNodes;
    }
    get removedNodes() {
      return this._removedNodes;
    }
    get previousSibling() {
      return this._previousSibling;
    }
    get nextSibling() {
      return this._nextSibling;
    }
    get attributeName() {
      return this._attributeName;
    }
    get attributeNamespace() {
      return this._attributeNamespace;
    }
    get oldValue() {
      return this._oldValue;
    }
    static _create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
      return new MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
    }
  }
  exports.MutationRecordImpl = MutationRecordImpl;
});

// node_modules/@oozcitak/dom/lib/dom/DOMTokenListImpl.js
var require_DOMTokenListImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DOMTokenListImpl = undefined;
  var DOMImpl_1 = require_DOMImpl();
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib7();
  var algorithm_1 = require_algorithm();

  class DOMTokenListImpl {
    _element;
    _attribute;
    _tokenSet;
    constructor(element, attribute2) {
      this._element = element;
      this._attribute = attribute2;
      this._tokenSet = new Set;
      const localName = attribute2._localName;
      const value = (0, algorithm_1.element_getAnAttributeValue)(element, localName);
      const thisObj = this;
      function updateTokenSet(element2, localName2, oldValue, value2, namespace) {
        if (localName2 === thisObj._attribute._localName && namespace === null) {
          if (!value2)
            thisObj._tokenSet.clear();
          else
            thisObj._tokenSet = (0, algorithm_1.orderedSet_parse)(value2);
        }
      }
      this._element._attributeChangeSteps.push(updateTokenSet);
      if (DOMImpl_1.dom.features.steps) {
        (0, algorithm_1.dom_runAttributeChangeSteps)(element, localName, value, value, null);
      }
    }
    get length() {
      return this._tokenSet.size;
    }
    item(index) {
      let i = 0;
      for (const token of this._tokenSet) {
        if (i === index)
          return token;
        i++;
      }
      return null;
    }
    contains(token) {
      return this._tokenSet.has(token);
    }
    add(...tokens) {
      for (const token of tokens) {
        if (token === "") {
          throw new DOMException_1.SyntaxError("Cannot add an empty token.");
        } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
          throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        } else {
          this._tokenSet.add(token);
        }
      }
      (0, algorithm_1.tokenList_updateSteps)(this);
    }
    remove(...tokens) {
      for (const token of tokens) {
        if (token === "") {
          throw new DOMException_1.SyntaxError("Cannot remove an empty token.");
        } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
          throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        } else {
          this._tokenSet.delete(token);
        }
      }
      (0, algorithm_1.tokenList_updateSteps)(this);
    }
    toggle(token, force = undefined) {
      if (token === "") {
        throw new DOMException_1.SyntaxError("Cannot toggle an empty token.");
      } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
        throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
      }
      if (this._tokenSet.has(token)) {
        if (force === undefined || force === false) {
          this._tokenSet.delete(token);
          (0, algorithm_1.tokenList_updateSteps)(this);
          return false;
        }
        return true;
      }
      if (force === undefined || force === true) {
        this._tokenSet.add(token);
        (0, algorithm_1.tokenList_updateSteps)(this);
        return true;
      }
      return false;
    }
    replace(token, newToken) {
      if (token === "" || newToken === "") {
        throw new DOMException_1.SyntaxError("Cannot replace an empty token.");
      } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token) || infra_1.codePoint.ASCIIWhiteSpace.test(newToken)) {
        throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
      }
      if (!this._tokenSet.has(token))
        return false;
      infra_1.set.replace(this._tokenSet, token, newToken);
      (0, algorithm_1.tokenList_updateSteps)(this);
      return true;
    }
    supports(token) {
      return (0, algorithm_1.tokenList_validationSteps)(this, token);
    }
    get value() {
      return (0, algorithm_1.tokenList_serializeSteps)(this);
    }
    set value(value) {
      (0, algorithm_1.element_setAnAttributeValue)(this._element, this._attribute._localName, value);
    }
    [Symbol.iterator]() {
      const it = this._tokenSet[Symbol.iterator]();
      return {
        next() {
          return it.next();
        }
      };
    }
    static _create(element, attribute2) {
      return new DOMTokenListImpl(element, attribute2);
    }
  }
  exports.DOMTokenListImpl = DOMTokenListImpl;
});

// node_modules/@oozcitak/dom/lib/algorithm/CreateAlgorithm.js
var require_CreateAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.create_domImplementation = create_domImplementation;
  exports.create_window = create_window;
  exports.create_xmlDocument = create_xmlDocument;
  exports.create_document = create_document;
  exports.create_abortController = create_abortController;
  exports.create_abortSignal = create_abortSignal;
  exports.create_documentType = create_documentType;
  exports.create_element = create_element;
  exports.create_htmlElement = create_htmlElement;
  exports.create_htmlUnknownElement = create_htmlUnknownElement;
  exports.create_documentFragment = create_documentFragment;
  exports.create_shadowRoot = create_shadowRoot;
  exports.create_attr = create_attr;
  exports.create_text = create_text;
  exports.create_cdataSection = create_cdataSection;
  exports.create_comment = create_comment;
  exports.create_processingInstruction = create_processingInstruction;
  exports.create_htmlCollection = create_htmlCollection;
  exports.create_nodeList = create_nodeList;
  exports.create_nodeListStatic = create_nodeListStatic;
  exports.create_namedNodeMap = create_namedNodeMap;
  exports.create_range = create_range;
  exports.create_nodeIterator = create_nodeIterator;
  exports.create_treeWalker = create_treeWalker;
  exports.create_nodeFilter = create_nodeFilter;
  exports.create_mutationRecord = create_mutationRecord;
  exports.create_domTokenList = create_domTokenList;
  var DOMImplementationImpl_1 = require_DOMImplementationImpl();
  var WindowImpl_1 = require_WindowImpl();
  var XMLDocumentImpl_1 = require_XMLDocumentImpl();
  var DocumentImpl_1 = require_DocumentImpl();
  var AbortControllerImpl_1 = require_AbortControllerImpl();
  var AbortSignalImpl_1 = require_AbortSignalImpl();
  var DocumentTypeImpl_1 = require_DocumentTypeImpl();
  var ElementImpl_1 = require_ElementImpl();
  var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
  var ShadowRootImpl_1 = require_ShadowRootImpl();
  var AttrImpl_1 = require_AttrImpl();
  var TextImpl_1 = require_TextImpl();
  var CDATASectionImpl_1 = require_CDATASectionImpl();
  var CommentImpl_1 = require_CommentImpl();
  var ProcessingInstructionImpl_1 = require_ProcessingInstructionImpl();
  var HTMLCollectionImpl_1 = require_HTMLCollectionImpl();
  var NodeListImpl_1 = require_NodeListImpl();
  var NodeListStaticImpl_1 = require_NodeListStaticImpl();
  var NamedNodeMapImpl_1 = require_NamedNodeMapImpl();
  var RangeImpl_1 = require_RangeImpl();
  var NodeIteratorImpl_1 = require_NodeIteratorImpl();
  var TreeWalkerImpl_1 = require_TreeWalkerImpl();
  var NodeFilterImpl_1 = require_NodeFilterImpl();
  var MutationRecordImpl_1 = require_MutationRecordImpl();
  var DOMTokenListImpl_1 = require_DOMTokenListImpl();
  function create_domImplementation(document2) {
    return DOMImplementationImpl_1.DOMImplementationImpl._create(document2);
  }
  function create_window() {
    return WindowImpl_1.WindowImpl._create();
  }
  function create_xmlDocument() {
    return new XMLDocumentImpl_1.XMLDocumentImpl;
  }
  function create_document() {
    return new DocumentImpl_1.DocumentImpl;
  }
  function create_abortController() {
    return new AbortControllerImpl_1.AbortControllerImpl;
  }
  function create_abortSignal() {
    return AbortSignalImpl_1.AbortSignalImpl._create();
  }
  function create_documentType(document2, name, publicId, systemId) {
    return DocumentTypeImpl_1.DocumentTypeImpl._create(document2, name, publicId, systemId);
  }
  function create_element(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  function create_htmlElement(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  function create_htmlUnknownElement(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  function create_documentFragment(document2) {
    return DocumentFragmentImpl_1.DocumentFragmentImpl._create(document2);
  }
  function create_shadowRoot(document2, host) {
    return ShadowRootImpl_1.ShadowRootImpl._create(document2, host);
  }
  function create_attr(document2, localName) {
    return AttrImpl_1.AttrImpl._create(document2, localName);
  }
  function create_text(document2, data) {
    return TextImpl_1.TextImpl._create(document2, data);
  }
  function create_cdataSection(document2, data) {
    return CDATASectionImpl_1.CDATASectionImpl._create(document2, data);
  }
  function create_comment(document2, data) {
    return CommentImpl_1.CommentImpl._create(document2, data);
  }
  function create_processingInstruction(document2, target, data) {
    return ProcessingInstructionImpl_1.ProcessingInstructionImpl._create(document2, target, data);
  }
  function create_htmlCollection(root, filter = () => true) {
    return HTMLCollectionImpl_1.HTMLCollectionImpl._create(root, filter);
  }
  function create_nodeList(root) {
    return NodeListImpl_1.NodeListImpl._create(root);
  }
  function create_nodeListStatic(root, items) {
    return NodeListStaticImpl_1.NodeListStaticImpl._create(root, items);
  }
  function create_namedNodeMap(element) {
    return NamedNodeMapImpl_1.NamedNodeMapImpl._create(element);
  }
  function create_range(start, end) {
    return RangeImpl_1.RangeImpl._create(start, end);
  }
  function create_nodeIterator(root, reference, pointerBeforeReference) {
    return NodeIteratorImpl_1.NodeIteratorImpl._create(root, reference, pointerBeforeReference);
  }
  function create_treeWalker(root, current) {
    return TreeWalkerImpl_1.TreeWalkerImpl._create(root, current);
  }
  function create_nodeFilter() {
    return NodeFilterImpl_1.NodeFilterImpl._create();
  }
  function create_mutationRecord(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
    return MutationRecordImpl_1.MutationRecordImpl._create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
  }
  function create_domTokenList(element, attribute2) {
    return DOMTokenListImpl_1.DOMTokenListImpl._create(element, attribute2);
  }
});

// node_modules/@oozcitak/dom/lib/dom/DOMImpl.js
var require_DOMImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dom = undefined;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var CreateAlgorithm_1 = require_CreateAlgorithm();

  class DOMImpl {
    static _instance;
    _features = {
      mutationObservers: true,
      customElements: true,
      slots: true,
      steps: true
    };
    _window = null;
    _compareCache;
    _rangeList;
    constructor() {
      this._compareCache = new util_1.CompareCache;
      this._rangeList = new util_1.FixedSizeSet;
    }
    setFeatures(features) {
      if (features === undefined)
        features = true;
      if ((0, util_1.isObject)(features)) {
        for (const key in features) {
          this._features[key] = features[key] || false;
        }
      } else {
        for (const key in this._features) {
          this._features[key] = features;
        }
      }
    }
    get features() {
      return this._features;
    }
    get window() {
      if (this._window === null) {
        this._window = (0, CreateAlgorithm_1.create_window)();
      }
      return this._window;
    }
    get compareCache() {
      return this._compareCache;
    }
    get rangeList() {
      return this._rangeList;
    }
    static get instance() {
      if (!DOMImpl._instance) {
        DOMImpl._instance = new DOMImpl;
      }
      return DOMImpl._instance;
    }
  }
  exports.dom = DOMImpl.instance;
});

// node_modules/@oozcitak/dom/lib/dom/EventImpl.js
var require_EventImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();

  class EventImpl {
    static NONE = 0;
    static CAPTURING_PHASE = 1;
    static AT_TARGET = 2;
    static BUBBLING_PHASE = 3;
    NONE = 0;
    CAPTURING_PHASE = 1;
    AT_TARGET = 2;
    BUBBLING_PHASE = 3;
    _target = null;
    _relatedTarget = null;
    _touchTargetList = [];
    _path = [];
    _currentTarget = null;
    _eventPhase = interfaces_1.EventPhase.None;
    _stopPropagationFlag = false;
    _stopImmediatePropagationFlag = false;
    _canceledFlag = false;
    _inPassiveListenerFlag = false;
    _composedFlag = false;
    _initializedFlag = false;
    _dispatchFlag = false;
    _isTrusted = false;
    _type;
    _bubbles = false;
    _cancelable = false;
    _timeStamp;
    constructor(type, eventInit) {
      this._type = type;
      if (eventInit) {
        this._bubbles = eventInit.bubbles || false;
        this._cancelable = eventInit.cancelable || false;
        this._composedFlag = eventInit.composed || false;
      }
      this._initializedFlag = true;
      this._timeStamp = new Date().getTime();
    }
    get type() {
      return this._type;
    }
    get target() {
      return this._target;
    }
    get srcElement() {
      return this._target;
    }
    get currentTarget() {
      return this._currentTarget;
    }
    composedPath() {
      const composedPath = [];
      const path = this._path;
      if (path.length === 0)
        return composedPath;
      const currentTarget = this._currentTarget;
      if (currentTarget === null) {
        throw new Error("Event currentTarget is null.");
      }
      composedPath.push(currentTarget);
      let currentTargetIndex = 0;
      let currentTargetHiddenSubtreeLevel = 0;
      let index = path.length - 1;
      while (index >= 0) {
        if (path[index].rootOfClosedTree) {
          currentTargetHiddenSubtreeLevel++;
        }
        if (path[index].invocationTarget === currentTarget) {
          currentTargetIndex = index;
          break;
        }
        if (path[index].slotInClosedTree) {
          currentTargetHiddenSubtreeLevel--;
        }
        index--;
      }
      let currentHiddenLevel = currentTargetHiddenSubtreeLevel;
      let maxHiddenLevel = currentTargetHiddenSubtreeLevel;
      index = currentTargetIndex - 1;
      while (index >= 0) {
        if (path[index].rootOfClosedTree) {
          currentHiddenLevel++;
        }
        if (currentHiddenLevel <= maxHiddenLevel) {
          composedPath.unshift(path[index].invocationTarget);
        }
        if (path[index].slotInClosedTree) {
          currentHiddenLevel--;
          if (currentHiddenLevel < maxHiddenLevel) {
            maxHiddenLevel = currentHiddenLevel;
          }
        }
        index--;
      }
      currentHiddenLevel = currentTargetHiddenSubtreeLevel;
      maxHiddenLevel = currentTargetHiddenSubtreeLevel;
      index = currentTargetIndex + 1;
      while (index < path.length) {
        if (path[index].slotInClosedTree) {
          currentHiddenLevel++;
        }
        if (currentHiddenLevel <= maxHiddenLevel) {
          composedPath.push(path[index].invocationTarget);
        }
        if (path[index].rootOfClosedTree) {
          currentHiddenLevel--;
          if (currentHiddenLevel < maxHiddenLevel) {
            maxHiddenLevel = currentHiddenLevel;
          }
        }
        index++;
      }
      return composedPath;
    }
    get eventPhase() {
      return this._eventPhase;
    }
    stopPropagation() {
      this._stopPropagationFlag = true;
    }
    get cancelBubble() {
      return this._stopPropagationFlag;
    }
    set cancelBubble(value) {
      if (value)
        this.stopPropagation();
    }
    stopImmediatePropagation() {
      this._stopPropagationFlag = true;
      this._stopImmediatePropagationFlag = true;
    }
    get bubbles() {
      return this._bubbles;
    }
    get cancelable() {
      return this._cancelable;
    }
    get returnValue() {
      return !this._canceledFlag;
    }
    set returnValue(value) {
      if (!value) {
        (0, algorithm_1.event_setTheCanceledFlag)(this);
      }
    }
    preventDefault() {
      (0, algorithm_1.event_setTheCanceledFlag)(this);
    }
    get defaultPrevented() {
      return this._canceledFlag;
    }
    get composed() {
      return this._composedFlag;
    }
    get isTrusted() {
      return this._isTrusted;
    }
    get timeStamp() {
      return this._timeStamp;
    }
    initEvent(type, bubbles = false, cancelable = false) {
      if (this._dispatchFlag)
        return;
      (0, algorithm_1.event_initialize)(this, type, bubbles, cancelable);
    }
  }
  exports.EventImpl = EventImpl;
  (0, WebIDLAlgorithm_1.idl_defineConst)(EventImpl.prototype, "NONE", 0);
  (0, WebIDLAlgorithm_1.idl_defineConst)(EventImpl.prototype, "CAPTURING_PHASE", 1);
  (0, WebIDLAlgorithm_1.idl_defineConst)(EventImpl.prototype, "AT_TARGET", 2);
  (0, WebIDLAlgorithm_1.idl_defineConst)(EventImpl.prototype, "BUBBLING_PHASE", 3);
});

// node_modules/@oozcitak/dom/lib/dom/CustomEventImpl.js
var require_CustomEventImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CustomEventImpl = undefined;
  var EventImpl_1 = require_EventImpl();
  var algorithm_1 = require_algorithm();

  class CustomEventImpl extends EventImpl_1.EventImpl {
    _detail = null;
    constructor(type, eventInit) {
      super(type, eventInit);
      this._detail = eventInit && eventInit.detail || null;
    }
    get detail() {
      return this._detail;
    }
    initCustomEvent(type, bubbles = false, cancelable = false, detail = null) {
      if (this._dispatchFlag)
        return;
      (0, algorithm_1.event_initialize)(this, type, bubbles, cancelable);
      this._detail = detail;
    }
  }
  exports.CustomEventImpl = CustomEventImpl;
});

// node_modules/@oozcitak/dom/lib/algorithm/TreeAlgorithm.js
var require_TreeAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tree_getFirstDescendantNode = tree_getFirstDescendantNode;
  exports.tree_getNextDescendantNode = tree_getNextDescendantNode;
  exports.tree_getDescendantNodes = tree_getDescendantNodes;
  exports.tree_getDescendantElements = tree_getDescendantElements;
  exports.tree_getSiblingNodes = tree_getSiblingNodes;
  exports.tree_getFirstAncestorNode = tree_getFirstAncestorNode;
  exports.tree_getNextAncestorNode = tree_getNextAncestorNode;
  exports.tree_getAncestorNodes = tree_getAncestorNodes;
  exports.tree_getCommonAncestor = tree_getCommonAncestor;
  exports.tree_getFollowingNode = tree_getFollowingNode;
  exports.tree_getPrecedingNode = tree_getPrecedingNode;
  exports.tree_isConstrained = tree_isConstrained;
  exports.tree_nodeLength = tree_nodeLength;
  exports.tree_isEmpty = tree_isEmpty;
  exports.tree_rootNode = tree_rootNode;
  exports.tree_isDescendantOf = tree_isDescendantOf;
  exports.tree_isAncestorOf = tree_isAncestorOf;
  exports.tree_isHostIncludingAncestorOf = tree_isHostIncludingAncestorOf;
  exports.tree_isSiblingOf = tree_isSiblingOf;
  exports.tree_isPreceding = tree_isPreceding;
  exports.tree_isFollowing = tree_isFollowing;
  exports.tree_isParentOf = tree_isParentOf;
  exports.tree_isChildOf = tree_isChildOf;
  exports.tree_previousSibling = tree_previousSibling;
  exports.tree_nextSibling = tree_nextSibling;
  exports.tree_firstChild = tree_firstChild;
  exports.tree_lastChild = tree_lastChild;
  exports.tree_treePosition = tree_treePosition;
  exports.tree_index = tree_index;
  exports.tree_retarget = tree_retarget;
  var util_1 = require_util2();
  var interfaces_1 = require_interfaces2();
  function _getNextDescendantNode(root, node, shadow = false) {
    if (shadow && util_1.Guard.isElementNode(node) && util_1.Guard.isShadowRoot(node.shadowRoot)) {
      if (node.shadowRoot._firstChild)
        return node.shadowRoot._firstChild;
    }
    if (node._firstChild)
      return node._firstChild;
    if (node === root)
      return null;
    if (node._nextSibling)
      return node._nextSibling;
    let parent = node._parent;
    while (parent && parent !== root) {
      if (parent._nextSibling)
        return parent._nextSibling;
      parent = parent._parent;
    }
    return null;
  }
  function _emptyIterator() {
    return {
      [Symbol.iterator]: () => {
        return {
          next: () => {
            return { done: true, value: null };
          }
        };
      }
    };
  }
  function tree_getFirstDescendantNode(node, self2 = false, shadow = false, filter) {
    let firstNode = self2 ? node : _getNextDescendantNode(node, node, shadow);
    while (firstNode && filter && !filter(firstNode)) {
      firstNode = _getNextDescendantNode(node, firstNode, shadow);
    }
    return firstNode;
  }
  function tree_getNextDescendantNode(node, currentNode, self2 = false, shadow = false, filter) {
    let nextNode = _getNextDescendantNode(node, currentNode, shadow);
    while (nextNode && filter && !filter(nextNode)) {
      nextNode = _getNextDescendantNode(node, nextNode, shadow);
    }
    return nextNode;
  }
  function tree_getDescendantNodes(node, self2 = false, shadow = false, filter) {
    if (!self2 && node._children.size === 0) {
      return _emptyIterator();
    }
    return {
      [Symbol.iterator]: () => {
        let currentNode = self2 ? node : _getNextDescendantNode(node, node, shadow);
        return {
          next: () => {
            while (currentNode && filter && !filter(currentNode)) {
              currentNode = _getNextDescendantNode(node, currentNode, shadow);
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = _getNextDescendantNode(node, currentNode, shadow);
              return result;
            }
          }
        };
      }
    };
  }
  function tree_getDescendantElements(node, self2 = false, shadow = false, filter) {
    if (!self2 && node._children.size === 0) {
      return _emptyIterator();
    }
    return {
      [Symbol.iterator]: () => {
        const it = tree_getDescendantNodes(node, self2, shadow, (e) => util_1.Guard.isElementNode(e))[Symbol.iterator]();
        let currentNode = it.next().value;
        return {
          next() {
            while (currentNode && filter && !filter(currentNode)) {
              currentNode = it.next().value;
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = it.next().value;
              return result;
            }
          }
        };
      }
    };
  }
  function tree_getSiblingNodes(node, self2 = false, filter) {
    if (!node._parent || node._parent._children.size === 0) {
      return _emptyIterator();
    }
    return {
      [Symbol.iterator]() {
        let currentNode = node._parent ? node._parent._firstChild : null;
        return {
          next() {
            while (currentNode && (filter && !filter(currentNode) || !self2 && currentNode === node)) {
              currentNode = currentNode._nextSibling;
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = currentNode._nextSibling;
              return result;
            }
          }
        };
      }
    };
  }
  function tree_getFirstAncestorNode(node, self2 = false, filter) {
    let firstNode = self2 ? node : node._parent;
    while (firstNode && filter && !filter(firstNode)) {
      firstNode = firstNode._parent;
    }
    return firstNode;
  }
  function tree_getNextAncestorNode(node, currentNode, self2 = false, filter) {
    let nextNode = currentNode._parent;
    while (nextNode && filter && !filter(nextNode)) {
      nextNode = nextNode._parent;
    }
    return nextNode;
  }
  function tree_getAncestorNodes(node, self2 = false, filter) {
    if (!self2 && !node._parent) {
      return _emptyIterator();
    }
    return {
      [Symbol.iterator]() {
        let currentNode = tree_getFirstAncestorNode(node, self2, filter);
        return {
          next() {
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = tree_getNextAncestorNode(node, currentNode, self2, filter);
              return result;
            }
          }
        };
      }
    };
  }
  function tree_getCommonAncestor(nodeA, nodeB) {
    if (nodeA === nodeB) {
      return nodeA._parent;
    }
    const parentsA = [];
    const parentsB = [];
    let pA = tree_getFirstAncestorNode(nodeA, true);
    while (pA !== null) {
      parentsA.push(pA);
      pA = tree_getNextAncestorNode(nodeA, pA, true);
    }
    let pB = tree_getFirstAncestorNode(nodeB, true);
    while (pB !== null) {
      parentsB.push(pB);
      pB = tree_getNextAncestorNode(nodeB, pB, true);
    }
    let pos1 = parentsA.length;
    let pos2 = parentsB.length;
    let parent = null;
    for (let i = Math.min(pos1, pos2);i > 0; i--) {
      const parent1 = parentsA[--pos1];
      const parent2 = parentsB[--pos2];
      if (parent1 !== parent2) {
        break;
      }
      parent = parent1;
    }
    return parent;
  }
  function tree_getFollowingNode(root, node) {
    if (node._firstChild) {
      return node._firstChild;
    } else if (node._nextSibling) {
      return node._nextSibling;
    } else {
      while (true) {
        const parent = node._parent;
        if (parent === null || parent === root) {
          return null;
        } else if (parent._nextSibling) {
          return parent._nextSibling;
        } else {
          node = parent;
        }
      }
    }
  }
  function tree_getPrecedingNode(root, node) {
    if (node === root) {
      return null;
    }
    if (node._previousSibling) {
      node = node._previousSibling;
      if (node._lastChild) {
        return node._lastChild;
      } else {
        return node;
      }
    } else {
      return node._parent;
    }
  }
  function tree_isConstrained(node) {
    switch (node._nodeType) {
      case interfaces_1.NodeType.Document:
        let hasDocType = false;
        let hasElement = false;
        for (const childNode of node._children) {
          switch (childNode._nodeType) {
            case interfaces_1.NodeType.ProcessingInstruction:
            case interfaces_1.NodeType.Comment:
              break;
            case interfaces_1.NodeType.DocumentType:
              if (hasDocType || hasElement)
                return false;
              hasDocType = true;
              break;
            case interfaces_1.NodeType.Element:
              if (hasElement)
                return false;
              hasElement = true;
              break;
            default:
              return false;
          }
        }
        break;
      case interfaces_1.NodeType.DocumentFragment:
      case interfaces_1.NodeType.Element:
        for (const childNode of node._children) {
          switch (childNode._nodeType) {
            case interfaces_1.NodeType.Element:
            case interfaces_1.NodeType.Text:
            case interfaces_1.NodeType.ProcessingInstruction:
            case interfaces_1.NodeType.CData:
            case interfaces_1.NodeType.Comment:
              break;
            default:
              return false;
          }
        }
        break;
      case interfaces_1.NodeType.DocumentType:
      case interfaces_1.NodeType.Text:
      case interfaces_1.NodeType.ProcessingInstruction:
      case interfaces_1.NodeType.CData:
      case interfaces_1.NodeType.Comment:
        return !node.hasChildNodes();
    }
    for (const childNode of node._children) {
      if (!tree_isConstrained(childNode))
        return false;
    }
    return true;
  }
  function tree_nodeLength(node) {
    if (util_1.Guard.isDocumentTypeNode(node)) {
      return 0;
    } else if (util_1.Guard.isCharacterDataNode(node)) {
      return node._data.length;
    } else {
      return node._children.size;
    }
  }
  function tree_isEmpty(node) {
    return tree_nodeLength(node) === 0;
  }
  function tree_rootNode(node, shadow = false) {
    if (shadow) {
      const root = tree_rootNode(node, false);
      if (util_1.Guard.isShadowRoot(root))
        return tree_rootNode(root._host, true);
      else
        return root;
    } else {
      if (!node._parent)
        return node;
      else
        return tree_rootNode(node._parent);
    }
  }
  function tree_isDescendantOf(node, other, self2 = false, shadow = false) {
    let child = tree_getFirstDescendantNode(node, self2, shadow);
    while (child !== null) {
      if (child === other) {
        return true;
      }
      child = tree_getNextDescendantNode(node, child, self2, shadow);
    }
    return false;
  }
  function tree_isAncestorOf(node, other, self2 = false, shadow = false) {
    let ancestor = self2 ? node : shadow && util_1.Guard.isShadowRoot(node) ? node._host : node._parent;
    while (ancestor !== null) {
      if (ancestor === other)
        return true;
      ancestor = shadow && util_1.Guard.isShadowRoot(ancestor) ? ancestor._host : ancestor._parent;
    }
    return false;
  }
  function tree_isHostIncludingAncestorOf(node, other, self2 = false) {
    if (tree_isAncestorOf(node, other, self2))
      return true;
    const root = tree_rootNode(node);
    if (util_1.Guard.isDocumentFragmentNode(root) && root._host !== null && tree_isHostIncludingAncestorOf(root._host, other, self2))
      return true;
    return false;
  }
  function tree_isSiblingOf(node, other, self2 = false) {
    if (node === other) {
      if (self2)
        return true;
    } else {
      return node._parent !== null && node._parent === other._parent;
    }
    return false;
  }
  function tree_isPreceding(node, other) {
    const nodePos = tree_treePosition(node);
    const otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
      return false;
    else if (tree_rootNode(node) !== tree_rootNode(other))
      return false;
    else
      return otherPos < nodePos;
  }
  function tree_isFollowing(node, other) {
    const nodePos = tree_treePosition(node);
    const otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
      return false;
    else if (tree_rootNode(node) !== tree_rootNode(other))
      return false;
    else
      return otherPos > nodePos;
  }
  function tree_isParentOf(node, other) {
    return node._parent === other;
  }
  function tree_isChildOf(node, other) {
    return other._parent === node;
  }
  function tree_previousSibling(node) {
    return node._previousSibling;
  }
  function tree_nextSibling(node) {
    return node._nextSibling;
  }
  function tree_firstChild(node) {
    return node._firstChild;
  }
  function tree_lastChild(node) {
    return node._lastChild;
  }
  function tree_treePosition(node) {
    const root = tree_rootNode(node);
    let pos = 0;
    let childNode = tree_getFirstDescendantNode(root);
    while (childNode !== null) {
      pos++;
      if (childNode === node)
        return pos;
      childNode = tree_getNextDescendantNode(root, childNode);
    }
    return -1;
  }
  function tree_index(node) {
    let n = 0;
    while (node._previousSibling !== null) {
      n++;
      node = node._previousSibling;
    }
    return n;
  }
  function tree_retarget(a, b) {
    while (true) {
      if (!a || !util_1.Guard.isNode(a)) {
        return a;
      }
      const rootOfA = tree_rootNode(a);
      if (!util_1.Guard.isShadowRoot(rootOfA)) {
        return a;
      }
      if (b && util_1.Guard.isNode(b) && tree_isAncestorOf(rootOfA, b, true, true)) {
        return a;
      }
      a = rootOfA.host;
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/MutationObserverAlgorithm.js
var require_MutationObserverAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observer_queueAMutationObserverMicrotask = observer_queueAMutationObserverMicrotask;
  exports.observer_notifyMutationObservers = observer_notifyMutationObservers;
  exports.observer_queueMutationRecord = observer_queueMutationRecord;
  exports.observer_queueTreeMutationRecord = observer_queueTreeMutationRecord;
  exports.observer_queueAttributeMutationRecord = observer_queueAttributeMutationRecord;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var infra_1 = require_lib7();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var EventAlgorithm_1 = require_EventAlgorithm();
  function observer_queueAMutationObserverMicrotask() {
    const window2 = DOMImpl_1.dom.window;
    if (window2._mutationObserverMicrotaskQueued)
      return;
    window2._mutationObserverMicrotaskQueued = true;
    Promise.resolve().then(() => {
      observer_notifyMutationObservers();
    });
  }
  function observer_notifyMutationObservers() {
    const window2 = DOMImpl_1.dom.window;
    window2._mutationObserverMicrotaskQueued = false;
    const notifySet = infra_1.set.clone(window2._mutationObservers);
    const signalSet = infra_1.set.clone(window2._signalSlots);
    infra_1.set.empty(window2._signalSlots);
    for (const mo of notifySet) {
      const records = infra_1.list.clone(mo._recordQueue);
      infra_1.list.empty(mo._recordQueue);
      for (let i = 0;i < mo._nodeList.length; i++) {
        const node = mo._nodeList[i];
        infra_1.list.remove(node._registeredObserverList, (observer) => {
          return util_1.Guard.isTransientRegisteredObserver(observer) && observer.observer === mo;
        });
      }
      if (!infra_1.list.isEmpty(records)) {
        try {
          mo._callback.call(mo, records, mo);
        } catch (err) {}
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      for (const slot of signalSet) {
        (0, EventAlgorithm_1.event_fireAnEvent)("slotchange", slot, undefined, { bubbles: true });
      }
    }
  }
  function observer_queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {
    const interestedObservers = new Map;
    let node = (0, TreeAlgorithm_1.tree_getFirstAncestorNode)(target, true);
    while (node !== null) {
      for (let i = 0;i < node._registeredObserverList.length; i++) {
        const registered = node._registeredObserverList[i];
        const options = registered.options;
        if (node !== target && !options.subtree)
          continue;
        if (type === "attributes" && !options.attributes)
          continue;
        if (type === "attributes" && options.attributeFilter && (!options.attributeFilter.indexOf(name || "") || namespace !== null))
          continue;
        if (type === "characterData" && !options.characterData)
          continue;
        if (type === "childList" && !options.childList)
          continue;
        const mo = registered.observer;
        if (!interestedObservers.has(mo)) {
          interestedObservers.set(mo, null);
        }
        if (type === "attributes" && options.attributeOldValue || type === "characterData" && options.characterDataOldValue) {
          interestedObservers.set(mo, oldValue);
        }
      }
      node = (0, TreeAlgorithm_1.tree_getNextAncestorNode)(target, node, true);
    }
    for (const [observer, mappedOldValue] of interestedObservers) {
      const record = (0, CreateAlgorithm_1.create_mutationRecord)(type, target, (0, CreateAlgorithm_1.create_nodeListStatic)(target, addedNodes), (0, CreateAlgorithm_1.create_nodeListStatic)(target, removedNodes), previousSibling, nextSibling, name, namespace, mappedOldValue);
      const queue = observer._recordQueue;
      queue.push(record);
    }
    observer_queueAMutationObserverMicrotask();
  }
  function observer_queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {
    observer_queueMutationRecord("childList", target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);
  }
  function observer_queueAttributeMutationRecord(target, name, namespace, oldValue) {
    observer_queueMutationRecord("attributes", target, name, namespace, oldValue, [], [], null, null);
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/ShadowTreeAlgorithm.js
var require_ShadowTreeAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shadowTree_signalASlotChange = shadowTree_signalASlotChange;
  exports.shadowTree_isConnected = shadowTree_isConnected;
  exports.shadowTree_isAssigned = shadowTree_isAssigned;
  exports.shadowTree_findASlot = shadowTree_findASlot;
  exports.shadowTree_findSlotables = shadowTree_findSlotables;
  exports.shadowTree_findFlattenedSlotables = shadowTree_findFlattenedSlotables;
  exports.shadowTree_assignSlotables = shadowTree_assignSlotables;
  exports.shadowTree_assignSlotablesForATree = shadowTree_assignSlotablesForATree;
  exports.shadowTree_assignASlot = shadowTree_assignASlot;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var util_2 = (init_lib(), __toCommonJS(exports_lib));
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
  function shadowTree_signalASlotChange(slot) {
    const window2 = DOMImpl_1.dom.window;
    window2._signalSlots.add(slot);
    (0, MutationObserverAlgorithm_1.observer_queueAMutationObserverMicrotask)();
  }
  function shadowTree_isConnected(element) {
    return util_1.Guard.isDocumentNode((0, TreeAlgorithm_1.tree_rootNode)(element, true));
  }
  function shadowTree_isAssigned(slotable) {
    return slotable._assignedSlot !== null;
  }
  function shadowTree_findASlot(slotable, openFlag = false) {
    const node = util_1.Cast.asNode(slotable);
    const parent = node._parent;
    if (parent === null)
      return null;
    const shadow = parent._shadowRoot || null;
    if (shadow === null)
      return null;
    if (openFlag && shadow._mode !== "open")
      return null;
    let child = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(shadow, false, true, (e) => util_1.Guard.isSlot(e));
    while (child !== null) {
      if (child._name === slotable._name)
        return child;
      child = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(shadow, child, false, true, (e) => util_1.Guard.isSlot(e));
    }
    return null;
  }
  function shadowTree_findSlotables(slot) {
    const result = [];
    const root = (0, TreeAlgorithm_1.tree_rootNode)(slot);
    if (!util_1.Guard.isShadowRoot(root))
      return result;
    const host = root._host;
    for (const slotable of host._children) {
      if (util_1.Guard.isSlotable(slotable)) {
        const foundSlot = shadowTree_findASlot(slotable);
        if (foundSlot === slot) {
          result.push(slotable);
        }
      }
    }
    return result;
  }
  function shadowTree_findFlattenedSlotables(slot) {
    const result = [];
    const root = (0, TreeAlgorithm_1.tree_rootNode)(slot);
    if (!util_1.Guard.isShadowRoot(root))
      return result;
    const slotables = shadowTree_findSlotables(slot);
    if ((0, util_2.isEmpty)(slotables)) {
      for (const slotable of slot._children) {
        if (util_1.Guard.isSlotable(slotable)) {
          slotables.push(slotable);
        }
      }
    }
    for (const node of slotables) {
      if (util_1.Guard.isSlot(node) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(node))) {
        const temporaryResult = shadowTree_findFlattenedSlotables(node);
        result.push(...temporaryResult);
      } else {
        result.push(node);
      }
    }
    return result;
  }
  function shadowTree_assignSlotables(slot) {
    const slotables = shadowTree_findSlotables(slot);
    if (slotables.length === slot._assignedNodes.length) {
      let nodesIdentical = true;
      for (let i = 0;i < slotables.length; i++) {
        if (slotables[i] !== slot._assignedNodes[i]) {
          nodesIdentical = false;
          break;
        }
      }
      if (!nodesIdentical) {
        shadowTree_signalASlotChange(slot);
      }
    }
    slot._assignedNodes = slotables;
    for (const slotable of slotables) {
      slotable._assignedSlot = slot;
    }
  }
  function shadowTree_assignSlotablesForATree(root) {
    let descendant = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(root, true, false, (e) => util_1.Guard.isSlot(e));
    while (descendant !== null) {
      shadowTree_assignSlotables(descendant);
      descendant = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(root, descendant, true, false, (e) => util_1.Guard.isSlot(e));
    }
  }
  function shadowTree_assignASlot(slotable) {
    const slot = shadowTree_findASlot(slotable);
    if (slot !== null) {
      shadowTree_assignSlotables(slot);
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/DOMAlgorithm.js
var require_DOMAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dom_runRemovingSteps = dom_runRemovingSteps;
  exports.dom_runCloningSteps = dom_runCloningSteps;
  exports.dom_runAdoptingSteps = dom_runAdoptingSteps;
  exports.dom_runAttributeChangeSteps = dom_runAttributeChangeSteps;
  exports.dom_runInsertionSteps = dom_runInsertionSteps;
  exports.dom_runNodeIteratorPreRemovingSteps = dom_runNodeIteratorPreRemovingSteps;
  exports.dom_hasSupportedTokens = dom_hasSupportedTokens;
  exports.dom_getSupportedTokens = dom_getSupportedTokens;
  exports.dom_runEventConstructingSteps = dom_runEventConstructingSteps;
  exports.dom_runChildTextContentChangeSteps = dom_runChildTextContentChangeSteps;
  var DOMImpl_1 = require_DOMImpl();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var util_1 = require_util2();
  var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
  var supportedTokens = new Map;
  function dom_runRemovingSteps(removedNode, oldParent) {}
  function dom_runCloningSteps(copy, node, document2, cloneChildrenFlag) {}
  function dom_runAdoptingSteps(node, oldDocument) {}
  function dom_runAttributeChangeSteps(element, localName, oldValue, value, namespace) {
    if (DOMImpl_1.dom.features.slots) {
      updateASlotablesName.call(element, element, localName, oldValue, value, namespace);
      updateASlotsName.call(element, element, localName, oldValue, value, namespace);
    }
    updateAnElementID.call(element, element, localName, value, namespace);
    for (const step of element._attributeChangeSteps) {
      step.call(element, element, localName, oldValue, value, namespace);
    }
  }
  function dom_runInsertionSteps(insertedNode) {}
  function dom_runNodeIteratorPreRemovingSteps(nodeIterator, toBeRemoved) {
    removeNodeIterator.call(nodeIterator, nodeIterator, toBeRemoved);
  }
  function dom_hasSupportedTokens(attributeName) {
    return supportedTokens.has(attributeName);
  }
  function dom_getSupportedTokens(attributeName) {
    return supportedTokens.get(attributeName) || new Set;
  }
  function dom_runEventConstructingSteps(event) {}
  function dom_runChildTextContentChangeSteps(parent) {}
  function removeNodeIterator(nodeIterator, toBeRemovedNode) {
    if (toBeRemovedNode === nodeIterator._root || !(0, TreeAlgorithm_1.tree_isAncestorOf)(nodeIterator._reference, toBeRemovedNode, true)) {
      return;
    }
    if (nodeIterator._pointerBeforeReference) {
      while (true) {
        const nextNode = (0, TreeAlgorithm_1.tree_getFollowingNode)(nodeIterator._root, toBeRemovedNode);
        if (nextNode !== null && (0, TreeAlgorithm_1.tree_isDescendantOf)(nodeIterator._root, nextNode, true) && !(0, TreeAlgorithm_1.tree_isDescendantOf)(toBeRemovedNode, nextNode, true)) {
          nodeIterator._reference = nextNode;
          return;
        } else if (nextNode === null) {
          nodeIterator._pointerBeforeReference = false;
          return;
        }
      }
    }
    if (toBeRemovedNode._previousSibling === null) {
      if (toBeRemovedNode._parent !== null) {
        nodeIterator._reference = toBeRemovedNode._parent;
      }
    } else {
      let referenceNode = toBeRemovedNode._previousSibling;
      let childNode = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(toBeRemovedNode._previousSibling, true, false);
      while (childNode !== null) {
        if (childNode !== null) {
          referenceNode = childNode;
        }
        childNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(toBeRemovedNode._previousSibling, childNode, true, false);
      }
      nodeIterator._reference = referenceNode;
    }
  }
  function updateASlotsName(element, localName, oldValue, value, namespace) {
    if (util_1.Guard.isSlot(element) && localName === "name" && namespace === null) {
      if (value === oldValue)
        return;
      if (value === null && oldValue === "")
        return;
      if (value === "" && oldValue === null)
        return;
      if (value === null || value === "") {
        element._name = "";
      } else {
        element._name = value;
      }
      (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)((0, TreeAlgorithm_1.tree_rootNode)(element));
    }
  }
  function updateASlotablesName(element, localName, oldValue, value, namespace) {
    if (util_1.Guard.isSlotable(element) && localName === "slot" && namespace === null) {
      if (value === oldValue)
        return;
      if (value === null && oldValue === "")
        return;
      if (value === "" && oldValue === null)
        return;
      if (value === null || value === "") {
        element._name = "";
      } else {
        element._name = value;
      }
      if ((0, ShadowTreeAlgorithm_1.shadowTree_isAssigned)(element)) {
        (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotables)(element._assignedSlot);
      }
      (0, ShadowTreeAlgorithm_1.shadowTree_assignASlot)(element);
    }
  }
  function updateAnElementID(element, localName, value, namespace) {
    if (localName === "id" && namespace === null) {
      if (!value)
        element._uniqueIdentifier = undefined;
      else
        element._uniqueIdentifier = value;
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/EventAlgorithm.js
var require_EventAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.event_setTheCanceledFlag = event_setTheCanceledFlag;
  exports.event_initialize = event_initialize;
  exports.event_createAnEvent = event_createAnEvent;
  exports.event_innerEventCreationSteps = event_innerEventCreationSteps;
  exports.event_dispatch = event_dispatch;
  exports.event_appendToAnEventPath = event_appendToAnEventPath;
  exports.event_invoke = event_invoke;
  exports.event_innerInvoke = event_innerInvoke;
  exports.event_fireAnEvent = event_fireAnEvent;
  exports.event_createLegacyEvent = event_createLegacyEvent;
  exports.event_getterEventHandlerIDLAttribute = event_getterEventHandlerIDLAttribute;
  exports.event_setterEventHandlerIDLAttribute = event_setterEventHandlerIDLAttribute;
  exports.event_determineTheTargetOfAnEventHandler = event_determineTheTargetOfAnEventHandler;
  exports.event_getTheCurrentValueOfAnEventHandler = event_getTheCurrentValueOfAnEventHandler;
  exports.event_activateAnEventHandler = event_activateAnEventHandler;
  exports.event_deactivateAnEventHandler = event_deactivateAnEventHandler;
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var util_1 = require_util2();
  var CustomEventImpl_1 = require_CustomEventImpl();
  var EventImpl_1 = require_EventImpl();
  var DOMException_1 = require_DOMException();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  function event_setTheCanceledFlag(event) {
    if (event._cancelable && !event._inPassiveListenerFlag) {
      event._canceledFlag = true;
    }
  }
  function event_initialize(event, type, bubbles, cancelable) {
    event._initializedFlag = true;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    event._canceledFlag = false;
    event._isTrusted = false;
    event._target = null;
    event._type = type;
    event._bubbles = bubbles;
    event._cancelable = cancelable;
  }
  function event_createAnEvent(eventInterface, realm = undefined) {
    if (realm === undefined)
      realm = null;
    const dictionary = {};
    const event = event_innerEventCreationSteps(eventInterface, realm, new Date, dictionary);
    event._isTrusted = true;
    return event;
  }
  function event_innerEventCreationSteps(eventInterface, realm, time, dictionary) {
    const event = new eventInterface("");
    event._initializedFlag = true;
    event._timeStamp = time.getTime();
    Object.assign(event, dictionary);
    if (DOMImpl_1.dom.features.steps) {
      (0, DOMAlgorithm_1.dom_runEventConstructingSteps)(event);
    }
    return event;
  }
  function event_dispatch(event, target, legacyTargetOverrideFlag = false, legacyOutputDidListenersThrowFlag = { value: false }) {
    let clearTargets = false;
    event._dispatchFlag = true;
    let targetOverride = target;
    if (legacyTargetOverrideFlag) {
      const doc = target._associatedDocument;
      if (util_1.Guard.isDocumentNode(doc)) {
        targetOverride = doc;
      }
    }
    let activationTarget = null;
    let relatedTarget = (0, TreeAlgorithm_1.tree_retarget)(event._relatedTarget, target);
    if (target !== relatedTarget || target === event._relatedTarget) {
      let touchTargets = [];
      for (const touchTarget of event._touchTargetList) {
        touchTargets.push((0, TreeAlgorithm_1.tree_retarget)(touchTarget, target));
      }
      event_appendToAnEventPath(event, target, targetOverride, relatedTarget, touchTargets, false);
      const isActivationEvent = util_1.Guard.isMouseEvent(event) && event._type === "click";
      if (isActivationEvent && target._activationBehavior !== undefined) {
        activationTarget = target;
      }
      let slotable = util_1.Guard.isSlotable(target) && (0, ShadowTreeAlgorithm_1.shadowTree_isAssigned)(target) ? target : null;
      let slotInClosedTree = false;
      let parent = target._getTheParent(event);
      while (parent !== null && util_1.Guard.isNode(parent)) {
        if (slotable !== null) {
          if (!util_1.Guard.isSlot(parent)) {
            throw new Error("Parent node of a slotable should be a slot.");
          }
          slotable = null;
          const root = (0, TreeAlgorithm_1.tree_rootNode)(parent, true);
          if (util_1.Guard.isShadowRoot(root) && root._mode === "closed") {
            slotInClosedTree = true;
          }
        }
        if (util_1.Guard.isSlotable(parent) && (0, ShadowTreeAlgorithm_1.shadowTree_isAssigned)(parent)) {
          slotable = parent;
        }
        relatedTarget = (0, TreeAlgorithm_1.tree_retarget)(event._relatedTarget, parent);
        touchTargets = [];
        for (const touchTarget of event._touchTargetList) {
          touchTargets.push((0, TreeAlgorithm_1.tree_retarget)(touchTarget, parent));
        }
        if (util_1.Guard.isWindow(parent) || util_1.Guard.isNode(parent) && util_1.Guard.isNode(target) && (0, TreeAlgorithm_1.tree_isAncestorOf)((0, TreeAlgorithm_1.tree_rootNode)(target, true), parent, true, true)) {
          if (isActivationEvent && event._bubbles && activationTarget === null && parent._activationBehavior) {
            activationTarget = parent;
          }
          event_appendToAnEventPath(event, parent, null, relatedTarget, touchTargets, slotInClosedTree);
        } else if (parent === relatedTarget) {
          parent = null;
        } else {
          target = parent;
          if (isActivationEvent && activationTarget === null && target._activationBehavior) {
            activationTarget = target;
          }
          event_appendToAnEventPath(event, parent, target, relatedTarget, touchTargets, slotInClosedTree);
        }
        if (parent !== null) {
          parent = parent._getTheParent(event);
        }
        slotInClosedTree = false;
      }
      let clearTargetsStruct = null;
      const path = event._path;
      for (let i = path.length - 1;i >= 0; i--) {
        const struct = path[i];
        if (struct.shadowAdjustedTarget !== null) {
          clearTargetsStruct = struct;
          break;
        }
      }
      if (clearTargetsStruct !== null) {
        if (util_1.Guard.isNode(clearTargetsStruct.shadowAdjustedTarget) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(clearTargetsStruct.shadowAdjustedTarget, true))) {
          clearTargets = true;
        } else if (util_1.Guard.isNode(clearTargetsStruct.relatedTarget) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(clearTargetsStruct.relatedTarget, true))) {
          clearTargets = true;
        } else {
          for (let j = 0;j < clearTargetsStruct.touchTargetList.length; j++) {
            const struct = clearTargetsStruct.touchTargetList[j];
            if (util_1.Guard.isNode(struct) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(struct, true))) {
              clearTargets = true;
              break;
            }
          }
        }
      }
      if (activationTarget !== null && activationTarget._legacyPreActivationBehavior !== undefined) {
        activationTarget._legacyPreActivationBehavior(event);
      }
      for (let i = path.length - 1;i >= 0; i--) {
        const struct = path[i];
        if (struct.shadowAdjustedTarget !== null) {
          event._eventPhase = interfaces_1.EventPhase.AtTarget;
        } else {
          event._eventPhase = interfaces_1.EventPhase.Capturing;
        }
        event_invoke(struct, event, "capturing", legacyOutputDidListenersThrowFlag);
      }
      for (let i = 0;i < path.length; i++) {
        const struct = path[i];
        if (struct.shadowAdjustedTarget !== null) {
          event._eventPhase = interfaces_1.EventPhase.AtTarget;
        } else {
          if (!event._bubbles)
            continue;
          event._eventPhase = interfaces_1.EventPhase.Bubbling;
        }
        event_invoke(struct, event, "bubbling", legacyOutputDidListenersThrowFlag);
      }
    }
    event._eventPhase = interfaces_1.EventPhase.None;
    event._currentTarget = null;
    event._path = [];
    event._dispatchFlag = false;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    if (clearTargets) {
      event._target = null;
      event._relatedTarget = null;
      event._touchTargetList = [];
    }
    if (activationTarget !== null) {
      if (!event._canceledFlag && activationTarget._activationBehavior !== undefined) {
        activationTarget._activationBehavior(event);
      } else if (activationTarget._legacyCanceledActivationBehavior !== undefined) {
        activationTarget._legacyCanceledActivationBehavior(event);
      }
    }
    return !event._canceledFlag;
  }
  function event_appendToAnEventPath(event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, slotInClosedTree) {
    let invocationTargetInShadowTree = false;
    if (util_1.Guard.isNode(invocationTarget) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(invocationTarget))) {
      invocationTargetInShadowTree = true;
    }
    let rootOfClosedTree = false;
    if (util_1.Guard.isShadowRoot(invocationTarget) && invocationTarget._mode === "closed") {
      rootOfClosedTree = true;
    }
    event._path.push({
      invocationTarget,
      invocationTargetInShadowTree,
      shadowAdjustedTarget,
      relatedTarget,
      touchTargetList: touchTargets,
      rootOfClosedTree,
      slotInClosedTree
    });
  }
  function event_invoke(struct, event, phase, legacyOutputDidListenersThrowFlag = { value: false }) {
    const path = event._path;
    let index = -1;
    for (let i = 0;i < path.length; i++) {
      if (path[i] === struct) {
        index = i;
        break;
      }
    }
    if (index !== -1) {
      let item = path[index];
      if (item.shadowAdjustedTarget !== null) {
        event._target = item.shadowAdjustedTarget;
      } else if (index > 0) {
        item = path[index - 1];
        if (item.shadowAdjustedTarget !== null) {
          event._target = item.shadowAdjustedTarget;
        }
      }
    }
    event._relatedTarget = struct.relatedTarget;
    event._touchTargetList = struct.touchTargetList;
    if (event._stopPropagationFlag)
      return;
    event._currentTarget = struct.invocationTarget;
    const currentTarget = event._currentTarget;
    const targetListeners = currentTarget._eventListenerList;
    let listeners = new Array(...targetListeners);
    const found = event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
    if (!found && event._isTrusted) {
      const originalEventType = event._type;
      if (originalEventType === "animationend") {
        event._type = "webkitAnimationEnd";
      } else if (originalEventType === "animationiteration") {
        event._type = "webkitAnimationIteration";
      } else if (originalEventType === "animationstart") {
        event._type = "webkitAnimationStart";
      } else if (originalEventType === "transitionend") {
        event._type = "webkitTransitionEnd";
      }
      event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
      event._type = originalEventType;
    }
  }
  function event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag = { value: false }) {
    let found = false;
    for (let i = 0;i < listeners.length; i++) {
      const listener = listeners[i];
      if (!listener.removed) {
        if (event._type !== listener.type)
          continue;
        found = true;
        if (phase === "capturing" && !listener.capture)
          continue;
        if (phase === "bubbling" && listener.capture)
          continue;
        if (listener.once && event._currentTarget !== null) {
          const impl = event._currentTarget;
          let index = -1;
          for (let i2 = 0;i2 < impl._eventListenerList.length; i2++) {
            if (impl._eventListenerList[i2] === listener) {
              index = i2;
              break;
            }
          }
          if (index !== -1) {
            impl._eventListenerList.splice(index, 1);
          }
        }
        const globalObject = undefined;
        let currentEvent = undefined;
        if (util_1.Guard.isWindow(globalObject)) {
          currentEvent = globalObject._currentEvent;
          if (struct.invocationTargetInShadowTree === false) {
            globalObject._currentEvent = event;
          }
        }
        if (listener.passive)
          event._inPassiveListenerFlag = true;
        try {
          listener.callback.handleEvent.call(event._currentTarget, event);
        } catch (err) {
          legacyOutputDidListenersThrowFlag.value = true;
        }
        if (listener.passive)
          event._inPassiveListenerFlag = false;
        if (util_1.Guard.isWindow(globalObject)) {
          globalObject._currentEvent = currentEvent;
        }
        if (event._stopImmediatePropagationFlag)
          return found;
      }
    }
    return found;
  }
  function event_fireAnEvent(e, target, eventConstructor, idlAttributes, legacyTargetOverrideFlag) {
    if (eventConstructor === undefined) {
      eventConstructor = EventImpl_1.EventImpl;
    }
    const event = event_createAnEvent(eventConstructor);
    event._type = e;
    if (idlAttributes) {
      for (const key in idlAttributes) {
        const idlObj = event;
        idlObj[key] = idlAttributes[key];
      }
    }
    return event_dispatch(event, target, legacyTargetOverrideFlag);
  }
  function event_createLegacyEvent(eventInterface) {
    let constructor = null;
    switch (eventInterface.toLowerCase()) {
      case "beforeunloadevent":
        break;
      case "compositionevent":
        break;
      case "customevent":
        constructor = CustomEventImpl_1.CustomEventImpl;
        break;
      case "devicemotionevent":
        break;
      case "deviceorientationevent":
        break;
      case "dragevent":
        break;
      case "event":
      case "events":
        constructor = EventImpl_1.EventImpl;
        break;
      case "focusevent":
        break;
      case "hashchangeevent":
        break;
      case "htmlevents":
        break;
      case "keyboardevent":
        break;
      case "messageevent":
        break;
      case "mouseevent":
        break;
      case "mouseevents":
        break;
      case "storageevent":
        break;
      case "svgevents":
        break;
      case "textevent":
        break;
      case "touchevent":
        break;
      case "uievent":
        break;
      case "uievents":
        break;
    }
    if (constructor === null) {
      throw new DOMException_1.NotSupportedError(`Event constructor not found for interface ${eventInterface}.`);
    }
    const event = new constructor("");
    event._type = "";
    event._timeStamp = new Date().getTime();
    event._isTrusted = false;
    event._initializedFlag = false;
    return event;
  }
  function event_getterEventHandlerIDLAttribute(thisObj, name) {
    const eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null)
      return null;
    return event_getTheCurrentValueOfAnEventHandler(eventTarget, name);
  }
  function event_setterEventHandlerIDLAttribute(thisObj, name, value) {
    const eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null)
      return;
    if (value === null) {
      event_deactivateAnEventHandler(eventTarget, name);
    } else {
      const handlerMap = eventTarget._eventHandlerMap;
      const eventHandler = handlerMap["onabort"];
      if (eventHandler !== undefined) {
        eventHandler.value = value;
      }
      event_activateAnEventHandler(eventTarget, name);
    }
  }
  function event_determineTheTargetOfAnEventHandler(eventTarget, name) {
    return null;
  }
  function event_getTheCurrentValueOfAnEventHandler(eventTarget, name) {
    return null;
  }
  function event_activateAnEventHandler(eventTarget, name) {}
  function event_deactivateAnEventHandler(eventTarget, name) {}
});

// node_modules/@oozcitak/dom/lib/algorithm/AbortAlgorithm.js
var require_AbortAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.abort_add = abort_add;
  exports.abort_remove = abort_remove;
  exports.abort_signalAbort = abort_signalAbort;
  var EventAlgorithm_1 = require_EventAlgorithm();
  function abort_add(algorithm, signal) {
    if (signal._abortedFlag)
      return;
    signal._abortAlgorithms.add(algorithm);
  }
  function abort_remove(algorithm, signal) {
    signal._abortAlgorithms.delete(algorithm);
  }
  function abort_signalAbort(signal) {
    if (signal._abortedFlag)
      return;
    signal._abortedFlag = true;
    for (const algorithm of signal._abortAlgorithms) {
      algorithm.call(signal);
    }
    signal._abortAlgorithms.clear();
    (0, EventAlgorithm_1.event_fireAnEvent)("abort", signal);
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/CustomElementAlgorithm.js
var require_CustomElementAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.customElement_isValidCustomElementName = customElement_isValidCustomElementName;
  exports.customElement_isValidElementName = customElement_isValidElementName;
  exports.customElement_isVoidElementName = customElement_isVoidElementName;
  exports.customElement_isValidShadowHostName = customElement_isValidShadowHostName;
  exports.customElement_enqueueACustomElementUpgradeReaction = customElement_enqueueACustomElementUpgradeReaction;
  exports.customElement_enqueueACustomElementCallbackReaction = customElement_enqueueACustomElementCallbackReaction;
  exports.customElement_upgrade = customElement_upgrade;
  exports.customElement_tryToUpgrade = customElement_tryToUpgrade;
  exports.customElement_lookUpACustomElementDefinition = customElement_lookUpACustomElementDefinition;
  var PotentialCustomElementName = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/;
  var NamesWithHyphen = new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  var ElementNames = new Set([
    "article",
    "aside",
    "blockquote",
    "body",
    "div",
    "footer",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "main",
    "nav",
    "p",
    "section",
    "span"
  ]);
  var VoidElementNames = new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var ShadowHostNames = new Set([
    "article",
    "aside",
    "blockquote",
    "body",
    "div",
    "footer",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "main",
    "nav",
    "p",
    "section",
    "span"
  ]);
  function customElement_isValidCustomElementName(name) {
    if (!PotentialCustomElementName.test(name))
      return false;
    if (NamesWithHyphen.has(name))
      return false;
    return true;
  }
  function customElement_isValidElementName(name) {
    return ElementNames.has(name);
  }
  function customElement_isVoidElementName(name) {
    return VoidElementNames.has(name);
  }
  function customElement_isValidShadowHostName(name) {
    return ShadowHostNames.has(name);
  }
  function customElement_enqueueACustomElementUpgradeReaction(element, definition) {}
  function customElement_enqueueACustomElementCallbackReaction(element, callbackName, args) {}
  function customElement_upgrade(definition, element) {}
  function customElement_tryToUpgrade(element) {}
  function customElement_lookUpACustomElementDefinition(document2, namespace, localName, is) {
    return null;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/TraversalAlgorithm.js
var require_TraversalAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.traversal_filter = traversal_filter;
  var interfaces_1 = require_interfaces2();
  var DOMException_1 = require_DOMException();
  function traversal_filter(traverser, node) {
    if (traverser._activeFlag) {
      throw new DOMException_1.InvalidStateError;
    }
    const n = node._nodeType - 1;
    const mask = 1 << n;
    if ((traverser.whatToShow & mask) === 0) {
      return interfaces_1.FilterResult.Skip;
    }
    if (!traverser.filter) {
      return interfaces_1.FilterResult.Accept;
    }
    traverser._activeFlag = true;
    let result = interfaces_1.FilterResult.Reject;
    try {
      result = traverser.filter.acceptNode(node);
    } catch (err) {
      traverser._activeFlag = false;
      throw err;
    }
    traverser._activeFlag = false;
    return result;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/NodeIteratorAlgorithm.js
var require_NodeIteratorAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nodeIterator_traverse = nodeIterator_traverse;
  exports.nodeIterator_iteratorList = nodeIterator_iteratorList;
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var TraversalAlgorithm_1 = require_TraversalAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  function nodeIterator_traverse(iterator, forward) {
    let node = iterator._reference;
    let beforeNode = iterator._pointerBeforeReference;
    while (true) {
      if (forward) {
        if (!beforeNode) {
          const nextNode = (0, TreeAlgorithm_1.tree_getFollowingNode)(iterator._root, node);
          if (nextNode) {
            node = nextNode;
          } else {
            return null;
          }
        } else {
          beforeNode = false;
        }
      } else {
        if (beforeNode) {
          const prevNode = (0, TreeAlgorithm_1.tree_getPrecedingNode)(iterator.root, node);
          if (prevNode) {
            node = prevNode;
          } else {
            return null;
          }
        } else {
          beforeNode = true;
        }
      }
      const result = (0, TraversalAlgorithm_1.traversal_filter)(iterator, node);
      if (result === interfaces_1.FilterResult.Accept) {
        break;
      }
    }
    iterator._reference = node;
    iterator._pointerBeforeReference = beforeNode;
    return node;
  }
  function nodeIterator_iteratorList() {
    return DOMImpl_1.dom.window._iteratorList;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/XMLAlgorithm.js
var require_XMLAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.xml_isName = xml_isName;
  exports.xml_isQName = xml_isQName;
  exports.xml_isLegalChar = xml_isLegalChar;
  exports.xml_isPubidChar = xml_isPubidChar;
  function xml_isName(name) {
    for (let i = 0;i < name.length; i++) {
      let n = name.charCodeAt(i);
      if (n >= 97 && n <= 122 || n >= 65 && n <= 90 || n === 58 || n === 95 || n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) {
        continue;
      } else if (i !== 0 && (n === 45 || n === 46 || n >= 48 && n <= 57 || n === 183 || n >= 768 && n <= 879 || n >= 8255 && n <= 8256)) {
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < name.length - 1) {
        const n2 = name.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 983039) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  function xml_isQName(name) {
    let colonFound = false;
    for (let i = 0;i < name.length; i++) {
      let n = name.charCodeAt(i);
      if (n >= 97 && n <= 122 || n >= 65 && n <= 90 || n === 95 || n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) {
        continue;
      } else if (i !== 0 && (n === 45 || n === 46 || n >= 48 && n <= 57 || n === 183 || n >= 768 && n <= 879 || n >= 8255 && n <= 8256)) {
        continue;
      } else if (i !== 0 && n === 58) {
        if (colonFound)
          return false;
        if (i === name.length - 1)
          return false;
        colonFound = true;
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < name.length - 1) {
        const n2 = name.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 983039) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  function xml_isLegalChar(chars) {
    for (let i = 0;i < chars.length; i++) {
      let n = chars.charCodeAt(i);
      if (n === 9 || n === 10 || n === 13 || n >= 32 && n <= 55295 || n >= 57344 && n <= 65533) {
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < chars.length - 1) {
        const n2 = chars.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 1114111) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  function xml_isPubidChar(chars) {
    for (let i = 0;i < chars.length; i++) {
      const n = chars.charCodeAt(i);
      if (n >= 97 && n <= 122 || n >= 65 && n <= 90 || n >= 39 && n <= 59 || n === 32 || n === 13 || n === 10 || n >= 35 && n <= 37 || n === 33 || n === 61 || n === 63 || n === 64 || n === 95) {
        continue;
      } else {
        return false;
      }
    }
    return true;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/NamespaceAlgorithm.js
var require_NamespaceAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.namespace_validate = namespace_validate;
  exports.namespace_validateAndExtract = namespace_validateAndExtract;
  exports.namespace_extractQName = namespace_extractQName;
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib7();
  var XMLAlgorithm_1 = require_XMLAlgorithm();
  function namespace_validate(qualifiedName) {
    if (!(0, XMLAlgorithm_1.xml_isName)(qualifiedName))
      throw new DOMException_1.InvalidCharacterError(`Invalid XML name: ${qualifiedName}`);
    if (!(0, XMLAlgorithm_1.xml_isQName)(qualifiedName))
      throw new DOMException_1.InvalidCharacterError(`Invalid XML qualified name: ${qualifiedName}.`);
  }
  function namespace_validateAndExtract(namespace, qualifiedName) {
    if (!namespace)
      namespace = null;
    namespace_validate(qualifiedName);
    const parts = qualifiedName.split(":");
    const prefix = parts.length === 2 ? parts[0] : null;
    const localName = parts.length === 2 ? parts[1] : qualifiedName;
    if (prefix && namespace === null)
      throw new DOMException_1.NamespaceError("Qualified name includes a prefix but the namespace is null.");
    if (prefix === "xml" && namespace !== infra_1.namespace.XML)
      throw new DOMException_1.NamespaceError(`Qualified name includes the "xml" prefix but the namespace is not the XML namespace.`);
    if (namespace !== infra_1.namespace.XMLNS && (prefix === "xmlns" || qualifiedName === "xmlns"))
      throw new DOMException_1.NamespaceError(`Qualified name includes the "xmlns" prefix but the namespace is not the XMLNS namespace.`);
    if (namespace === infra_1.namespace.XMLNS && (prefix !== "xmlns" && qualifiedName !== "xmlns"))
      throw new DOMException_1.NamespaceError(`Qualified name does not include the "xmlns" prefix but the namespace is the XMLNS namespace.`);
    return [namespace, prefix, localName];
  }
  function namespace_extractQName(qualifiedName) {
    namespace_validate(qualifiedName);
    const parts = qualifiedName.split(":");
    const prefix = parts.length === 2 ? parts[0] : null;
    const localName = parts.length === 2 ? parts[1] : qualifiedName;
    return [prefix, localName];
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/DocumentAlgorithm.js
var require_DocumentAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.document_elementInterface = document_elementInterface;
  exports.document_internalCreateElementNS = document_internalCreateElementNS;
  exports.document_adopt = document_adopt;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var util_2 = (init_lib(), __toCommonJS(exports_lib));
  var ElementImpl_1 = require_ElementImpl();
  var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var NamespaceAlgorithm_1 = require_NamespaceAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var ElementAlgorithm_1 = require_ElementAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  function document_elementInterface(name, namespace) {
    return ElementImpl_1.ElementImpl;
  }
  function document_internalCreateElementNS(document2, namespace, qualifiedName, options) {
    const [ns, prefix, localName] = (0, NamespaceAlgorithm_1.namespace_validateAndExtract)(namespace, qualifiedName);
    let is = null;
    if (options !== undefined) {
      if ((0, util_2.isString)(options)) {
        is = options;
      } else {
        is = options.is;
      }
    }
    return (0, ElementAlgorithm_1.element_createAnElement)(document2, localName, ns, prefix, is, true);
  }
  function document_adopt(node, document2) {
    if (node._nodeDocument === document2 && node._parent === null) {
      return;
    }
    const oldDocument = node._nodeDocument;
    if (node._parent)
      (0, MutationAlgorithm_1.mutation_remove)(node, node._parent);
    if (document2 !== oldDocument) {
      let inclusiveDescendant = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node, true, true);
      while (inclusiveDescendant !== null) {
        inclusiveDescendant._nodeDocument = document2;
        if (util_1.Guard.isElementNode(inclusiveDescendant)) {
          for (const attr of inclusiveDescendant._attributeList._asArray()) {
            attr._nodeDocument = document2;
          }
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isElementNode(inclusiveDescendant) && inclusiveDescendant._customElementState === "custom") {
            (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(inclusiveDescendant, "adoptedCallback", [oldDocument, document2]);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runAdoptingSteps)(inclusiveDescendant, oldDocument);
        }
        inclusiveDescendant = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(node, inclusiveDescendant, true, true);
      }
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/MutationAlgorithm.js
var require_MutationAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mutation_ensurePreInsertionValidity = mutation_ensurePreInsertionValidity;
  exports.mutation_preInsert = mutation_preInsert;
  exports.mutation_insert = mutation_insert;
  exports.mutation_append = mutation_append;
  exports.mutation_replace = mutation_replace;
  exports.mutation_replaceAll = mutation_replaceAll;
  exports.mutation_preRemove = mutation_preRemove;
  exports.mutation_remove = mutation_remove;
  var DOMImpl_1 = require_DOMImpl();
  var DOMException_1 = require_DOMException();
  var interfaces_1 = require_interfaces2();
  var util_1 = require_util2();
  var util_2 = (init_lib(), __toCommonJS(exports_lib));
  var infra_1 = require_lib7();
  var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var NodeIteratorAlgorithm_1 = require_NodeIteratorAlgorithm();
  var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
  var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var DocumentAlgorithm_1 = require_DocumentAlgorithm();
  function mutation_ensurePreInsertionValidity(node, parent, child) {
    const parentNodeType = parent._nodeType;
    const nodeNodeType = node._nodeType;
    const childNodeType = child ? child._nodeType : null;
    if (parentNodeType !== interfaces_1.NodeType.Document && parentNodeType !== interfaces_1.NodeType.DocumentFragment && parentNodeType !== interfaces_1.NodeType.Element)
      throw new DOMException_1.HierarchyRequestError(`Only document, document fragment and element nodes can contain child nodes. Parent node is ${parent.nodeName}.`);
    if ((0, TreeAlgorithm_1.tree_isHostIncludingAncestorOf)(parent, node, true))
      throw new DOMException_1.HierarchyRequestError(`The node to be inserted cannot be an inclusive ancestor of parent node. Node is ${node.nodeName}, parent node is ${parent.nodeName}.`);
    if (child !== null && child._parent !== parent)
      throw new DOMException_1.NotFoundError(`The reference child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
    if (nodeNodeType !== interfaces_1.NodeType.DocumentFragment && nodeNodeType !== interfaces_1.NodeType.DocumentType && nodeNodeType !== interfaces_1.NodeType.Element && nodeNodeType !== interfaces_1.NodeType.Text && nodeNodeType !== interfaces_1.NodeType.ProcessingInstruction && nodeNodeType !== interfaces_1.NodeType.CData && nodeNodeType !== interfaces_1.NodeType.Comment)
      throw new DOMException_1.HierarchyRequestError(`Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is ${node.nodeName}.`);
    if (nodeNodeType === interfaces_1.NodeType.Text && parentNodeType === interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError(`Cannot insert a text node as a child of a document node. Node is ${node.nodeName}.`);
    if (nodeNodeType === interfaces_1.NodeType.DocumentType && parentNodeType !== interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError(`A document type node can only be inserted under a document node. Parent node is ${parent.nodeName}.`);
    if (parentNodeType === interfaces_1.NodeType.Document) {
      if (nodeNodeType === interfaces_1.NodeType.DocumentFragment) {
        let eleCount = 0;
        for (const childNode of node._children) {
          if (childNode._nodeType === interfaces_1.NodeType.Element)
            eleCount++;
          else if (childNode._nodeType === interfaces_1.NodeType.Text)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert text a node as a child of a document node. Node is ${childNode.nodeName}.`);
        }
        if (eleCount > 1) {
          throw new DOMException_1.HierarchyRequestError(`A document node can only have one document element node. Document fragment to be inserted has ${eleCount} element nodes.`);
        } else if (eleCount === 1) {
          for (const ele of parent._children) {
            if (ele._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError(`The document node already has a document element node.`);
          }
          if (child) {
            if (childNodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
            let doctypeChild = child._nextSibling;
            while (doctypeChild) {
              if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
              doctypeChild = doctypeChild._nextSibling;
            }
          }
        }
      } else if (nodeNodeType === interfaces_1.NodeType.Element) {
        for (const ele of parent._children) {
          if (ele._nodeType === interfaces_1.NodeType.Element)
            throw new DOMException_1.HierarchyRequestError(`Document already has a document element node. Node is ${node.nodeName}.`);
        }
        if (child) {
          if (childNodeType === interfaces_1.NodeType.DocumentType)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node.nodeName}.`);
          let doctypeChild = child._nextSibling;
          while (doctypeChild) {
            if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node.nodeName}.`);
            doctypeChild = doctypeChild._nextSibling;
          }
        }
      } else if (nodeNodeType === interfaces_1.NodeType.DocumentType) {
        for (const ele of parent._children) {
          if (ele._nodeType === interfaces_1.NodeType.DocumentType)
            throw new DOMException_1.HierarchyRequestError(`Document already has a document type node. Node is ${node.nodeName}.`);
        }
        if (child) {
          let elementChild = child._previousSibling;
          while (elementChild) {
            if (elementChild._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node.nodeName}.`);
            elementChild = elementChild._previousSibling;
          }
        } else {
          let elementChild = parent._firstChild;
          while (elementChild) {
            if (elementChild._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node.nodeName}.`);
            elementChild = elementChild._nextSibling;
          }
        }
      }
    }
  }
  function mutation_preInsert(node, parent, child) {
    mutation_ensurePreInsertionValidity(node, parent, child);
    let referenceChild = child;
    if (referenceChild === node)
      referenceChild = node._nextSibling;
    (0, DocumentAlgorithm_1.document_adopt)(node, parent._nodeDocument);
    mutation_insert(node, parent, referenceChild);
    return node;
  }
  function mutation_insert(node, parent, child, suppressObservers) {
    if (child === null && node._nodeType !== interfaces_1.NodeType.DocumentFragment) {
      mutation_insert_single(node, parent, suppressObservers);
      return;
    }
    const count = node._nodeType === interfaces_1.NodeType.DocumentFragment ? node._children.size : 1;
    if (child !== null) {
      if (DOMImpl_1.dom.rangeList.size !== 0) {
        const index2 = (0, TreeAlgorithm_1.tree_index)(child);
        for (const range of DOMImpl_1.dom.rangeList) {
          if (range._start[0] === parent && range._start[1] > index2) {
            range._start[1] += count;
          }
          if (range._end[0] === parent && range._end[1] > index2) {
            range._end[1] += count;
          }
        }
      }
    }
    const nodes = node._nodeType === interfaces_1.NodeType.DocumentFragment ? new Array(...node._children) : [node];
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
      while (node._firstChild) {
        mutation_remove(node._firstChild, node, true);
      }
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(node, [], nodes, null, null);
      }
    }
    const previousSibling = child ? child._previousSibling : parent._lastChild;
    let index = child === null ? -1 : (0, TreeAlgorithm_1.tree_index)(child);
    for (let i = 0;i < nodes.length; i++) {
      const node2 = nodes[i];
      if (util_1.Guard.isElementNode(node2)) {
        if (util_1.Guard.isDocumentNode(parent)) {
          parent._documentElement = node2;
        }
        if (!node2._nodeDocument._hasNamespaces && (node2._namespace !== null || node2._namespacePrefix !== null)) {
          node2._nodeDocument._hasNamespaces = true;
        }
      }
      node2._parent = parent;
      if (child === null) {
        infra_1.set.append(parent._children, node2);
      } else {
        infra_1.set.insert(parent._children, node2, index);
        index++;
      }
      if (parent._firstChild === null) {
        node2._previousSibling = null;
        node2._nextSibling = null;
        parent._firstChild = node2;
        parent._lastChild = node2;
      } else {
        const prev = child ? child._previousSibling : parent._lastChild;
        const next = child ? child : null;
        node2._previousSibling = prev;
        node2._nextSibling = next;
        if (prev)
          prev._nextSibling = node2;
        if (next)
          next._previousSibling = node2;
        if (!prev)
          parent._firstChild = node2;
        if (!next)
          parent._lastChild = node2;
      }
      if (DOMImpl_1.dom.features.slots) {
        if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node2)) {
          (0, ShadowTreeAlgorithm_1.shadowTree_assignASlot)(node2);
        }
      }
      if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node2)) {
          (0, DOMAlgorithm_1.dom_runChildTextContentChangeSteps)(parent);
        }
      }
      if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(parent)) && util_1.Guard.isSlot(parent) && (0, util_2.isEmpty)(parent._assignedNodes)) {
          (0, ShadowTreeAlgorithm_1.shadowTree_signalASlotChange)(parent);
        }
      }
      if (DOMImpl_1.dom.features.slots) {
        (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)((0, TreeAlgorithm_1.tree_rootNode)(node2));
      }
      let inclusiveDescendant = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node2, true, true);
      while (inclusiveDescendant !== null) {
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runInsertionSteps)(inclusiveDescendant);
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isElementNode(inclusiveDescendant) && (0, ShadowTreeAlgorithm_1.shadowTree_isConnected)(inclusiveDescendant)) {
            if (util_1.Guard.isCustomElementNode(inclusiveDescendant)) {
              (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(inclusiveDescendant, "connectedCallback", []);
            } else {
              (0, CustomElementAlgorithm_1.customElement_tryToUpgrade)(inclusiveDescendant);
            }
          }
        }
        inclusiveDescendant = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(node2, inclusiveDescendant, true, true);
      }
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, nodes, [], previousSibling, child);
      }
    }
  }
  function mutation_insert_single(node, parent, suppressObservers) {
    const previousSibling = parent._lastChild;
    if (util_1.Guard.isElementNode(node)) {
      if (util_1.Guard.isDocumentNode(parent)) {
        parent._documentElement = node;
      }
      if (!node._nodeDocument._hasNamespaces && (node._namespace !== null || node._namespacePrefix !== null)) {
        node._nodeDocument._hasNamespaces = true;
      }
    }
    node._parent = parent;
    parent._children.add(node);
    if (parent._firstChild === null) {
      node._previousSibling = null;
      node._nextSibling = null;
      parent._firstChild = node;
      parent._lastChild = node;
    } else {
      const prev = parent._lastChild;
      node._previousSibling = prev;
      node._nextSibling = null;
      if (prev)
        prev._nextSibling = node;
      if (!prev)
        parent._firstChild = node;
      parent._lastChild = node;
    }
    if (DOMImpl_1.dom.features.slots) {
      if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node)) {
        (0, ShadowTreeAlgorithm_1.shadowTree_assignASlot)(node);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node)) {
        (0, DOMAlgorithm_1.dom_runChildTextContentChangeSteps)(parent);
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      if (util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(parent)) && util_1.Guard.isSlot(parent) && (0, util_2.isEmpty)(parent._assignedNodes)) {
        (0, ShadowTreeAlgorithm_1.shadowTree_signalASlotChange)(parent);
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)((0, TreeAlgorithm_1.tree_rootNode)(node));
    }
    if (DOMImpl_1.dom.features.steps) {
      (0, DOMAlgorithm_1.dom_runInsertionSteps)(node);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isElementNode(node) && (0, ShadowTreeAlgorithm_1.shadowTree_isConnected)(node)) {
        if (util_1.Guard.isCustomElementNode(node)) {
          (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(node, "connectedCallback", []);
        } else {
          (0, CustomElementAlgorithm_1.customElement_tryToUpgrade)(node);
        }
      }
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, [node], [], previousSibling, null);
      }
    }
  }
  function mutation_append(node, parent) {
    return mutation_preInsert(node, parent, null);
  }
  function mutation_replace(child, node, parent) {
    if (parent._nodeType !== interfaces_1.NodeType.Document && parent._nodeType !== interfaces_1.NodeType.DocumentFragment && parent._nodeType !== interfaces_1.NodeType.Element)
      throw new DOMException_1.HierarchyRequestError(`Only document, document fragment and element nodes can contain child nodes. Parent node is ${parent.nodeName}.`);
    if ((0, TreeAlgorithm_1.tree_isHostIncludingAncestorOf)(parent, node, true))
      throw new DOMException_1.HierarchyRequestError(`The node to be inserted cannot be an ancestor of parent node. Node is ${node.nodeName}, parent node is ${parent.nodeName}.`);
    if (child._parent !== parent)
      throw new DOMException_1.NotFoundError(`The reference child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
    if (node._nodeType !== interfaces_1.NodeType.DocumentFragment && node._nodeType !== interfaces_1.NodeType.DocumentType && node._nodeType !== interfaces_1.NodeType.Element && node._nodeType !== interfaces_1.NodeType.Text && node._nodeType !== interfaces_1.NodeType.ProcessingInstruction && node._nodeType !== interfaces_1.NodeType.CData && node._nodeType !== interfaces_1.NodeType.Comment)
      throw new DOMException_1.HierarchyRequestError(`Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is ${node.nodeName}.`);
    if (node._nodeType === interfaces_1.NodeType.Text && parent._nodeType === interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError(`Cannot insert a text node as a child of a document node. Node is ${node.nodeName}.`);
    if (node._nodeType === interfaces_1.NodeType.DocumentType && parent._nodeType !== interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError(`A document type node can only be inserted under a document node. Parent node is ${parent.nodeName}.`);
    if (parent._nodeType === interfaces_1.NodeType.Document) {
      if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        let eleCount = 0;
        for (const childNode of node._children) {
          if (childNode._nodeType === interfaces_1.NodeType.Element)
            eleCount++;
          else if (childNode._nodeType === interfaces_1.NodeType.Text)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert text a node as a child of a document node. Node is ${childNode.nodeName}.`);
        }
        if (eleCount > 1) {
          throw new DOMException_1.HierarchyRequestError(`A document node can only have one document element node. Document fragment to be inserted has ${eleCount} element nodes.`);
        } else if (eleCount === 1) {
          for (const ele of parent._children) {
            if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
              throw new DOMException_1.HierarchyRequestError(`The document node already has a document element node.`);
          }
          let doctypeChild = child._nextSibling;
          while (doctypeChild) {
            if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
            doctypeChild = doctypeChild._nextSibling;
          }
        }
      } else if (node._nodeType === interfaces_1.NodeType.Element) {
        for (const ele of parent._children) {
          if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
            throw new DOMException_1.HierarchyRequestError(`Document already has a document element node. Node is ${node.nodeName}.`);
        }
        let doctypeChild = child._nextSibling;
        while (doctypeChild) {
          if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node.nodeName}.`);
          doctypeChild = doctypeChild._nextSibling;
        }
      } else if (node._nodeType === interfaces_1.NodeType.DocumentType) {
        for (const ele of parent._children) {
          if (ele._nodeType === interfaces_1.NodeType.DocumentType && ele !== child)
            throw new DOMException_1.HierarchyRequestError(`Document already has a document type node. Node is ${node.nodeName}.`);
        }
        let elementChild = child._previousSibling;
        while (elementChild) {
          if (elementChild._nodeType === interfaces_1.NodeType.Element)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node.nodeName}.`);
          elementChild = elementChild._previousSibling;
        }
      }
    }
    let referenceChild = child._nextSibling;
    if (referenceChild === node)
      referenceChild = node._nextSibling;
    let previousSibling = child._previousSibling;
    (0, DocumentAlgorithm_1.document_adopt)(node, parent._nodeDocument);
    const removedNodes = [];
    if (child._parent !== null) {
      removedNodes.push(child);
      mutation_remove(child, child._parent, true);
    }
    let nodes = [];
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
      nodes = Array.from(node._children);
    } else {
      nodes.push(node);
    }
    mutation_insert(node, parent, referenceChild, true);
    if (DOMImpl_1.dom.features.mutationObservers) {
      (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, nodes, removedNodes, previousSibling, referenceChild);
    }
    return child;
  }
  function mutation_replaceAll(node, parent) {
    if (node !== null) {
      (0, DocumentAlgorithm_1.document_adopt)(node, parent._nodeDocument);
    }
    const removedNodes = Array.from(parent._children);
    let addedNodes = [];
    if (node && node._nodeType === interfaces_1.NodeType.DocumentFragment) {
      addedNodes = Array.from(node._children);
    } else if (node !== null) {
      addedNodes.push(node);
    }
    for (const childNode of removedNodes) {
      mutation_remove(childNode, parent, true);
    }
    if (node !== null) {
      mutation_insert(node, parent, null, true);
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, addedNodes, removedNodes, null, null);
    }
  }
  function mutation_preRemove(child, parent) {
    if (child._parent !== parent)
      throw new DOMException_1.NotFoundError(`The child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
    mutation_remove(child, parent);
    return child;
  }
  function mutation_remove(node, parent, suppressObservers) {
    if (DOMImpl_1.dom.rangeList.size !== 0) {
      const index = (0, TreeAlgorithm_1.tree_index)(node);
      for (const range of DOMImpl_1.dom.rangeList) {
        if ((0, TreeAlgorithm_1.tree_isDescendantOf)(node, range._start[0], true)) {
          range._start = [parent, index];
        }
        if ((0, TreeAlgorithm_1.tree_isDescendantOf)(node, range._end[0], true)) {
          range._end = [parent, index];
        }
        if (range._start[0] === parent && range._start[1] > index) {
          range._start[1]--;
        }
        if (range._end[0] === parent && range._end[1] > index) {
          range._end[1]--;
        }
      }
      for (const range of DOMImpl_1.dom.rangeList) {
        if (range._start[0] === parent && range._start[1] > index) {
          range._start[1] -= 1;
        }
        if (range._end[0] === parent && range._end[1] > index) {
          range._end[1] -= 1;
        }
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      for (const iterator of (0, NodeIteratorAlgorithm_1.nodeIterator_iteratorList)()) {
        if (iterator._root._nodeDocument === node._nodeDocument) {
          (0, DOMAlgorithm_1.dom_runNodeIteratorPreRemovingSteps)(iterator, node);
        }
      }
    }
    const oldPreviousSibling = node._previousSibling;
    const oldNextSibling = node._nextSibling;
    if (util_1.Guard.isDocumentNode(parent) && util_1.Guard.isElementNode(node)) {
      parent._documentElement = null;
    }
    node._parent = null;
    parent._children.delete(node);
    const prev = node._previousSibling;
    const next = node._nextSibling;
    node._previousSibling = null;
    node._nextSibling = null;
    if (prev)
      prev._nextSibling = next;
    if (next)
      next._previousSibling = prev;
    if (!prev)
      parent._firstChild = next;
    if (!next)
      parent._lastChild = prev;
    if (DOMImpl_1.dom.features.slots) {
      if (util_1.Guard.isSlotable(node) && node._assignedSlot !== null && (0, ShadowTreeAlgorithm_1.shadowTree_isAssigned)(node)) {
        (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotables)(node._assignedSlot);
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      if (util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(parent)) && util_1.Guard.isSlot(parent) && (0, util_2.isEmpty)(parent._assignedNodes)) {
        (0, ShadowTreeAlgorithm_1.shadowTree_signalASlotChange)(parent);
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      const descendant2 = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node, true, false, (e) => util_1.Guard.isSlot(e));
      if (descendant2 !== null) {
        (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)((0, TreeAlgorithm_1.tree_rootNode)(parent));
        (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)(node);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      (0, DOMAlgorithm_1.dom_runRemovingSteps)(node, parent);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(node)) {
        (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(node, "disconnectedCallback", []);
      }
    }
    let descendant = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node, false, true);
    while (descendant !== null) {
      if (DOMImpl_1.dom.features.steps) {
        (0, DOMAlgorithm_1.dom_runRemovingSteps)(descendant, node);
      }
      if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(descendant)) {
          (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(descendant, "disconnectedCallback", []);
        }
      }
      descendant = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(node, descendant, false, true);
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      let inclusiveAncestor = (0, TreeAlgorithm_1.tree_getFirstAncestorNode)(parent, true);
      while (inclusiveAncestor !== null) {
        for (const registered of inclusiveAncestor._registeredObserverList) {
          if (registered.options.subtree) {
            node._registeredObserverList.push({
              observer: registered.observer,
              options: registered.options,
              source: registered
            });
          }
        }
        inclusiveAncestor = (0, TreeAlgorithm_1.tree_getNextAncestorNode)(parent, inclusiveAncestor, true);
      }
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, [], [node], oldPreviousSibling, oldNextSibling);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node)) {
        (0, DOMAlgorithm_1.dom_runChildTextContentChangeSteps)(parent);
      }
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/ElementAlgorithm.js
var require_ElementAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.element_has = element_has;
  exports.element_change = element_change;
  exports.element_append = element_append;
  exports.element_remove = element_remove;
  exports.element_replace = element_replace;
  exports.element_getAnAttributeByName = element_getAnAttributeByName;
  exports.element_getAnAttributeByNamespaceAndLocalName = element_getAnAttributeByNamespaceAndLocalName;
  exports.element_getAnAttributeValue = element_getAnAttributeValue;
  exports.element_setAnAttribute = element_setAnAttribute;
  exports.element_setAnAttributeValue = element_setAnAttributeValue;
  exports.element_removeAnAttributeByName = element_removeAnAttributeByName;
  exports.element_removeAnAttributeByNamespaceAndLocalName = element_removeAnAttributeByNamespaceAndLocalName;
  exports.element_createAnElement = element_createAnElement;
  exports.element_insertAdjacent = element_insertAdjacent;
  var DOMImpl_1 = require_DOMImpl();
  var infra_1 = require_lib7();
  var util_1 = require_util2();
  var DOMException_1 = require_DOMException();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
  var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  var DocumentAlgorithm_1 = require_DocumentAlgorithm();
  function element_has(attribute2, element) {
    return element._attributeList._asArray().indexOf(attribute2) !== -1;
  }
  function element_change(attribute2, element, value) {
    if (DOMImpl_1.dom.features.mutationObservers) {
      (0, MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord)(element, attribute2._localName, attribute2._namespace, attribute2._value);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element)) {
        (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(element, "attributeChangedCallback", [attribute2._localName, attribute2._value, value, attribute2._namespace]);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      (0, DOMAlgorithm_1.dom_runAttributeChangeSteps)(element, attribute2._localName, attribute2._value, value, attribute2._namespace);
    }
    attribute2._value = value;
  }
  function element_append(attribute2, element) {
    if (DOMImpl_1.dom.features.mutationObservers) {
      (0, MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord)(element, attribute2._localName, attribute2._namespace, null);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element)) {
        (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(element, "attributeChangedCallback", [attribute2._localName, null, attribute2._value, attribute2._namespace]);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      (0, DOMAlgorithm_1.dom_runAttributeChangeSteps)(element, attribute2._localName, null, attribute2._value, attribute2._namespace);
    }
    element._attributeList._asArray().push(attribute2);
    attribute2._element = element;
    if (!element._nodeDocument._hasNamespaces && (attribute2._namespace !== null || attribute2._namespacePrefix !== null || attribute2._localName === "xmlns")) {
      element._nodeDocument._hasNamespaces = true;
    }
  }
  function element_remove(attribute2, element) {
    if (DOMImpl_1.dom.features.mutationObservers) {
      (0, MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord)(element, attribute2._localName, attribute2._namespace, attribute2._value);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element)) {
        (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(element, "attributeChangedCallback", [attribute2._localName, attribute2._value, null, attribute2._namespace]);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      (0, DOMAlgorithm_1.dom_runAttributeChangeSteps)(element, attribute2._localName, attribute2._value, null, attribute2._namespace);
    }
    const index = element._attributeList._asArray().indexOf(attribute2);
    element._attributeList._asArray().splice(index, 1);
    attribute2._element = null;
  }
  function element_replace(oldAttr, newAttr, element) {
    if (DOMImpl_1.dom.features.mutationObservers) {
      (0, MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord)(element, oldAttr._localName, oldAttr._namespace, oldAttr._value);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element)) {
        (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(element, "attributeChangedCallback", [oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace]);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      (0, DOMAlgorithm_1.dom_runAttributeChangeSteps)(element, oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace);
    }
    const index = element._attributeList._asArray().indexOf(oldAttr);
    if (index !== -1) {
      element._attributeList._asArray()[index] = newAttr;
    }
    oldAttr._element = null;
    newAttr._element = element;
    if (!element._nodeDocument._hasNamespaces && (newAttr._namespace !== null || newAttr._namespacePrefix !== null || newAttr._localName === "xmlns")) {
      element._nodeDocument._hasNamespaces = true;
    }
  }
  function element_getAnAttributeByName(qualifiedName, element) {
    if (element._namespace === infra_1.namespace.HTML && element._nodeDocument._type === "html") {
      qualifiedName = qualifiedName.toLowerCase();
    }
    return element._attributeList._asArray().find((attr) => attr._qualifiedName === qualifiedName) || null;
  }
  function element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    const ns = namespace || null;
    return element._attributeList._asArray().find((attr) => attr._namespace === ns && attr._localName === localName) || null;
  }
  function element_getAnAttributeValue(element, localName, namespace = "") {
    const attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr === null)
      return "";
    else
      return attr._value;
  }
  function element_setAnAttribute(attr, element) {
    if (attr._element !== null && attr._element !== element)
      throw new DOMException_1.InUseAttributeError(`This attribute already exists in the document: ${attr._qualifiedName} as a child of ${attr._element._qualifiedName}.`);
    const oldAttr = element_getAnAttributeByNamespaceAndLocalName(attr._namespace || "", attr._localName, element);
    if (oldAttr === attr)
      return attr;
    if (oldAttr !== null) {
      element_replace(oldAttr, attr, element);
    } else {
      element_append(attr, element);
    }
    return oldAttr;
  }
  function element_setAnAttributeValue(element, localName, value, prefix = null, namespace = null) {
    const attribute2 = element_getAnAttributeByNamespaceAndLocalName(namespace || "", localName, element);
    if (attribute2 === null) {
      const newAttr = (0, CreateAlgorithm_1.create_attr)(element._nodeDocument, localName);
      newAttr._namespace = namespace;
      newAttr._namespacePrefix = prefix;
      newAttr._value = value;
      element_append(newAttr, element);
      return;
    }
    element_change(attribute2, element, value);
  }
  function element_removeAnAttributeByName(qualifiedName, element) {
    const attr = element_getAnAttributeByName(qualifiedName, element);
    if (attr !== null) {
      element_remove(attr, element);
    }
    return attr;
  }
  function element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    const attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr !== null) {
      element_remove(attr, element);
    }
    return attr;
  }
  function element_createAnElement(document2, localName, namespace, prefix = null, is = null, synchronousCustomElementsFlag = false) {
    let result = null;
    if (!DOMImpl_1.dom.features.customElements) {
      result = (0, CreateAlgorithm_1.create_element)(document2, localName, namespace, prefix);
      result._customElementState = "uncustomized";
      result._customElementDefinition = null;
      result._is = is;
      return result;
    }
    const definition = (0, CustomElementAlgorithm_1.customElement_lookUpACustomElementDefinition)(document2, namespace, localName, is);
    if (definition !== null && definition.name !== definition.localName) {
      const elemenInterface = (0, DocumentAlgorithm_1.document_elementInterface)(localName, infra_1.namespace.HTML);
      result = new elemenInterface;
      result._localName = localName;
      result._namespace = infra_1.namespace.HTML;
      result._namespacePrefix = prefix;
      result._customElementState = "undefined";
      result._customElementDefinition = null;
      result._is = is;
      result._nodeDocument = document2;
      if (synchronousCustomElementsFlag) {
        (0, CustomElementAlgorithm_1.customElement_upgrade)(definition, result);
      } else {
        (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction)(result, definition);
      }
    } else if (definition !== null) {
      if (synchronousCustomElementsFlag) {
        try {
          const C = definition.constructor;
          const result2 = new C;
          console.assert(result2._customElementState !== undefined);
          console.assert(result2._customElementDefinition !== undefined);
          console.assert(result2._namespace === infra_1.namespace.HTML);
          if (result2._attributeList.length !== 0)
            throw new DOMException_1.NotSupportedError("Custom element already has attributes.");
          if (result2._children.size !== 0)
            throw new DOMException_1.NotSupportedError("Custom element already has child nodes.");
          if (result2._parent !== null)
            throw new DOMException_1.NotSupportedError("Custom element already has a parent node.");
          if (result2._nodeDocument !== document2)
            throw new DOMException_1.NotSupportedError("Custom element is already in a document.");
          if (result2._localName !== localName)
            throw new DOMException_1.NotSupportedError("Custom element has a different local name.");
          result2._namespacePrefix = prefix;
          result2._is = null;
        } catch (e) {
          result = (0, CreateAlgorithm_1.create_htmlUnknownElement)(document2, localName, infra_1.namespace.HTML, prefix);
          result._customElementState = "failed";
          result._customElementDefinition = null;
          result._is = null;
        }
      } else {
        result = (0, CreateAlgorithm_1.create_htmlElement)(document2, localName, infra_1.namespace.HTML, prefix);
        result._customElementState = "undefined";
        result._customElementDefinition = null;
        result._is = null;
        (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction)(result, definition);
      }
    } else {
      const elementInterface = (0, DocumentAlgorithm_1.document_elementInterface)(localName, namespace);
      result = new elementInterface;
      result._localName = localName;
      result._namespace = namespace;
      result._namespacePrefix = prefix;
      result._customElementState = "uncustomized";
      result._customElementDefinition = null;
      result._is = is;
      result._nodeDocument = document2;
      if (namespace === infra_1.namespace.HTML && (is !== null || (0, CustomElementAlgorithm_1.customElement_isValidCustomElementName)(localName))) {
        result._customElementState = "undefined";
      }
    }
    if (result === null) {
      throw new Error("Unable to create element.");
    }
    return result;
  }
  function element_insertAdjacent(element, where, node) {
    switch (where.toLowerCase()) {
      case "beforebegin":
        if (element._parent === null)
          return null;
        return (0, MutationAlgorithm_1.mutation_preInsert)(node, element._parent, element);
      case "afterbegin":
        return (0, MutationAlgorithm_1.mutation_preInsert)(node, element, element._firstChild);
      case "beforeend":
        return (0, MutationAlgorithm_1.mutation_preInsert)(node, element, null);
      case "afterend":
        if (element._parent === null)
          return null;
        return (0, MutationAlgorithm_1.mutation_preInsert)(node, element._parent, element._nextSibling);
      default:
        throw new DOMException_1.SyntaxError(`Invalid 'where' argument. "beforebegin", "afterbegin", "beforeend" or "afterend" expected`);
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/AttrAlgorithm.js
var require_AttrAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.attr_setAnExistingAttributeValue = attr_setAnExistingAttributeValue;
  var ElementAlgorithm_1 = require_ElementAlgorithm();
  function attr_setAnExistingAttributeValue(attribute2, value) {
    if (attribute2._element === null) {
      attribute2._value = value;
    } else {
      (0, ElementAlgorithm_1.element_change)(attribute2, attribute2._element, value);
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/BoundaryPointAlgorithm.js
var require_BoundaryPointAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boundaryPoint_position = boundaryPoint_position;
  var interfaces_1 = require_interfaces2();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  function boundaryPoint_position(bp, relativeTo) {
    const nodeA = bp[0];
    const offsetA = bp[1];
    const nodeB = relativeTo[0];
    const offsetB = relativeTo[1];
    console.assert((0, TreeAlgorithm_1.tree_rootNode)(nodeA) === (0, TreeAlgorithm_1.tree_rootNode)(nodeB), "Boundary points must share the same root node.");
    if (nodeA === nodeB) {
      if (offsetA === offsetB) {
        return interfaces_1.BoundaryPosition.Equal;
      } else if (offsetA < offsetB) {
        return interfaces_1.BoundaryPosition.Before;
      } else {
        return interfaces_1.BoundaryPosition.After;
      }
    }
    if ((0, TreeAlgorithm_1.tree_isFollowing)(nodeB, nodeA)) {
      const pos = boundaryPoint_position([nodeB, offsetB], [nodeA, offsetA]);
      if (pos === interfaces_1.BoundaryPosition.Before) {
        return interfaces_1.BoundaryPosition.After;
      } else if (pos === interfaces_1.BoundaryPosition.After) {
        return interfaces_1.BoundaryPosition.Before;
      }
    }
    if ((0, TreeAlgorithm_1.tree_isAncestorOf)(nodeB, nodeA)) {
      let child = nodeB;
      while (!(0, TreeAlgorithm_1.tree_isChildOf)(nodeA, child)) {
        if (child._parent !== null) {
          child = child._parent;
        }
      }
      if ((0, TreeAlgorithm_1.tree_index)(child) < offsetA) {
        return interfaces_1.BoundaryPosition.After;
      }
    }
    return interfaces_1.BoundaryPosition.Before;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/CharacterDataAlgorithm.js
var require_CharacterDataAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.characterData_replaceData = characterData_replaceData;
  exports.characterData_substringData = characterData_substringData;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var DOMException_1 = require_DOMException();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  function characterData_replaceData(node, offset, count, data) {
    const length = (0, TreeAlgorithm_1.tree_nodeLength)(node);
    if (offset > length) {
      throw new DOMException_1.IndexSizeError(`Offset exceeds character data length. Offset: ${offset}, Length: ${length}, Node is ${node.nodeName}.`);
    }
    if (offset + count > length) {
      count = length - offset;
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      (0, MutationObserverAlgorithm_1.observer_queueMutationRecord)("characterData", node, null, null, node._data, [], [], null, null);
    }
    const newData = node._data.substring(0, offset) + data + node._data.substring(offset + count);
    node._data = newData;
    for (const range of DOMImpl_1.dom.rangeList) {
      if (range._start[0] === node && range._start[1] > offset && range._start[1] <= offset + count) {
        range._start[1] = offset;
      }
      if (range._end[0] === node && range._end[1] > offset && range._end[1] <= offset + count) {
        range._end[1] = offset;
      }
      if (range._start[0] === node && range._start[1] > offset + count) {
        range._start[1] += data.length - count;
      }
      if (range._end[0] === node && range._end[1] > offset + count) {
        range._end[1] += data.length - count;
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node) && node._parent !== null) {
        (0, DOMAlgorithm_1.dom_runChildTextContentChangeSteps)(node._parent);
      }
    }
  }
  function characterData_substringData(node, offset, count) {
    const length = (0, TreeAlgorithm_1.tree_nodeLength)(node);
    if (offset > length) {
      throw new DOMException_1.IndexSizeError(`Offset exceeds character data length. Offset: ${offset}, Length: ${length}, Node is ${node.nodeName}.`);
    }
    if (offset + count > length) {
      return node._data.substr(offset);
    } else {
      return node._data.substr(offset, count);
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/OrderedSetAlgorithm.js
var require_OrderedSetAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.orderedSet_parse = orderedSet_parse;
  exports.orderedSet_serialize = orderedSet_serialize;
  exports.orderedSet_sanitize = orderedSet_sanitize;
  exports.orderedSet_contains = orderedSet_contains;
  var infra_1 = require_lib7();
  function orderedSet_parse(value) {
    const inputTokens = infra_1.string.splitAStringOnASCIIWhitespace(value);
    return new Set(inputTokens);
  }
  function orderedSet_serialize(tokens) {
    return [...tokens].join(" ");
  }
  function orderedSet_sanitize(value) {
    return orderedSet_serialize(orderedSet_parse(value));
  }
  function orderedSet_contains(set1, set2, caseSensitive) {
    for (const val2 of set2) {
      let found = false;
      for (const val1 of set1) {
        if (caseSensitive) {
          if (val1 === val2) {
            found = true;
            break;
          }
        } else {
          if (val1.toUpperCase() === val2.toUpperCase()) {
            found = true;
            break;
          }
        }
      }
      if (!found)
        return false;
    }
    return true;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/DOMTokenListAlgorithm.js
var require_DOMTokenListAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tokenList_validationSteps = tokenList_validationSteps;
  exports.tokenList_updateSteps = tokenList_updateSteps;
  exports.tokenList_serializeSteps = tokenList_serializeSteps;
  var OrderedSetAlgorithm_1 = require_OrderedSetAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var ElementAlgorithm_1 = require_ElementAlgorithm();
  function tokenList_validationSteps(tokenList, token) {
    if (!(0, DOMAlgorithm_1.dom_hasSupportedTokens)(tokenList._attribute._localName)) {
      throw new TypeError(`There are no supported tokens defined for attribute name: '${tokenList._attribute._localName}'.`);
    }
    return (0, DOMAlgorithm_1.dom_getSupportedTokens)(tokenList._attribute._localName).has(token.toLowerCase());
  }
  function tokenList_updateSteps(tokenList) {
    if (!tokenList._element.hasAttribute(tokenList._attribute._localName) && tokenList._tokenSet.size === 0) {
      return;
    }
    (0, ElementAlgorithm_1.element_setAnAttributeValue)(tokenList._element, tokenList._attribute._localName, (0, OrderedSetAlgorithm_1.orderedSet_serialize)(tokenList._tokenSet));
  }
  function tokenList_serializeSteps(tokenList) {
    return (0, ElementAlgorithm_1.element_getAnAttributeValue)(tokenList._element, tokenList._attribute._localName);
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/EventTargetAlgorithm.js
var require_EventTargetAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.eventTarget_flatten = eventTarget_flatten;
  exports.eventTarget_flattenMore = eventTarget_flattenMore;
  exports.eventTarget_addEventListener = eventTarget_addEventListener;
  exports.eventTarget_removeEventListener = eventTarget_removeEventListener;
  exports.eventTarget_removeAllEventListeners = eventTarget_removeAllEventListeners;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  function eventTarget_flatten(options) {
    if ((0, util_1.isBoolean)(options)) {
      return options;
    } else {
      return options.capture || false;
    }
  }
  function eventTarget_flattenMore(options) {
    const capture = eventTarget_flatten(options);
    let once = false;
    let passive = false;
    if (!(0, util_1.isBoolean)(options)) {
      once = options.once || false;
      passive = options.passive || false;
    }
    return [capture, passive, once];
  }
  function eventTarget_addEventListener(eventTarget, listener) {
    if (listener.callback === null)
      return;
    for (let i = 0;i < eventTarget._eventListenerList.length; i++) {
      const entry = eventTarget._eventListenerList[i];
      if (entry.type === listener.type && entry.callback.handleEvent === listener.callback.handleEvent && entry.capture === listener.capture) {
        return;
      }
    }
    eventTarget._eventListenerList.push(listener);
  }
  function eventTarget_removeEventListener(eventTarget, listener, index) {
    listener.removed = true;
    eventTarget._eventListenerList.splice(index, 1);
  }
  function eventTarget_removeAllEventListeners(eventTarget) {
    for (const e of eventTarget._eventListenerList) {
      e.removed = true;
    }
    eventTarget._eventListenerList.length = 0;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/NodeAlgorithm.js
var require_NodeAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.node_stringReplaceAll = node_stringReplaceAll;
  exports.node_clone = node_clone;
  exports.node_equals = node_equals;
  exports.node_listOfElementsWithQualifiedName = node_listOfElementsWithQualifiedName;
  exports.node_listOfElementsWithNamespace = node_listOfElementsWithNamespace;
  exports.node_listOfElementsWithClassNames = node_listOfElementsWithClassNames;
  exports.node_locateANamespacePrefix = node_locateANamespacePrefix;
  exports.node_locateANamespace = node_locateANamespace;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var infra_1 = require_lib7();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var OrderedSetAlgorithm_1 = require_OrderedSetAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  var ElementAlgorithm_1 = require_ElementAlgorithm();
  function node_stringReplaceAll(str, parent) {
    let node = null;
    if (str !== "") {
      node = (0, CreateAlgorithm_1.create_text)(parent._nodeDocument, str);
    }
    (0, MutationAlgorithm_1.mutation_replaceAll)(node, parent);
  }
  function node_clone(node, document2 = null, cloneChildrenFlag = false) {
    if (document2 === null)
      document2 = node._nodeDocument;
    let copy;
    if (util_1.Guard.isElementNode(node)) {
      copy = (0, ElementAlgorithm_1.element_createAnElement)(document2, node._localName, node._namespace, node._namespacePrefix, node._is, false);
      for (const attribute2 of node._attributeList) {
        const copyAttribute = node_clone(attribute2, document2);
        (0, ElementAlgorithm_1.element_append)(copyAttribute, copy);
      }
    } else {
      if (util_1.Guard.isDocumentNode(node)) {
        const doc = (0, CreateAlgorithm_1.create_document)();
        doc._encoding = node._encoding;
        doc._contentType = node._contentType;
        doc._URL = node._URL;
        doc._origin = node._origin;
        doc._type = node._type;
        doc._mode = node._mode;
        copy = doc;
      } else if (util_1.Guard.isDocumentTypeNode(node)) {
        const doctype = (0, CreateAlgorithm_1.create_documentType)(document2, node._name, node._publicId, node._systemId);
        copy = doctype;
      } else if (util_1.Guard.isAttrNode(node)) {
        const attr = (0, CreateAlgorithm_1.create_attr)(document2, node.localName);
        attr._namespace = node._namespace;
        attr._namespacePrefix = node._namespacePrefix;
        attr._value = node._value;
        copy = attr;
      } else if (util_1.Guard.isExclusiveTextNode(node)) {
        copy = (0, CreateAlgorithm_1.create_text)(document2, node._data);
      } else if (util_1.Guard.isCDATASectionNode(node)) {
        copy = (0, CreateAlgorithm_1.create_cdataSection)(document2, node._data);
      } else if (util_1.Guard.isCommentNode(node)) {
        copy = (0, CreateAlgorithm_1.create_comment)(document2, node._data);
      } else if (util_1.Guard.isProcessingInstructionNode(node)) {
        copy = (0, CreateAlgorithm_1.create_processingInstruction)(document2, node._target, node._data);
      } else if (util_1.Guard.isDocumentFragmentNode(node)) {
        copy = (0, CreateAlgorithm_1.create_documentFragment)(document2);
      } else {
        copy = Object.create(node);
      }
    }
    if (util_1.Guard.isDocumentNode(copy)) {
      copy._nodeDocument = copy;
      document2 = copy;
    } else {
      copy._nodeDocument = document2;
    }
    if (DOMImpl_1.dom.features.steps) {
      (0, DOMAlgorithm_1.dom_runCloningSteps)(copy, node, document2, cloneChildrenFlag);
    }
    if (cloneChildrenFlag) {
      for (const child of node._children) {
        const childCopy = node_clone(child, document2, true);
        (0, MutationAlgorithm_1.mutation_append)(childCopy, copy);
      }
    }
    return copy;
  }
  function node_equals(a, b) {
    if (a._nodeType !== b._nodeType)
      return false;
    if (util_1.Guard.isDocumentTypeNode(a) && util_1.Guard.isDocumentTypeNode(b)) {
      if (a._name !== b._name || a._publicId !== b._publicId || a._systemId !== b._systemId)
        return false;
    } else if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
      if (a._namespace !== b._namespace || a._namespacePrefix !== b._namespacePrefix || a._localName !== b._localName || a._attributeList.length !== b._attributeList.length)
        return false;
    } else if (util_1.Guard.isAttrNode(a) && util_1.Guard.isAttrNode(b)) {
      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value)
        return false;
    } else if (util_1.Guard.isProcessingInstructionNode(a) && util_1.Guard.isProcessingInstructionNode(b)) {
      if (a._target !== b._target || a._data !== b._data)
        return false;
    } else if (util_1.Guard.isCharacterDataNode(a) && util_1.Guard.isCharacterDataNode(b)) {
      if (a._data !== b._data)
        return false;
    }
    if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
      const attrMap = {};
      for (const attrA of a._attributeList) {
        attrMap[attrA._localName] = attrA;
      }
      for (const attrB of b._attributeList) {
        const attrA = attrMap[attrB._localName];
        if (!attrA)
          return false;
        if (!node_equals(attrA, attrB))
          return false;
      }
    }
    if (a._children.size !== b._children.size)
      return false;
    const itA = a._children[Symbol.iterator]();
    const itB = b._children[Symbol.iterator]();
    let resultA = itA.next();
    let resultB = itB.next();
    while (!resultA.done && !resultB.done) {
      const child1 = resultA.value;
      const child2 = resultB.value;
      if (!node_equals(child1, child2))
        return false;
      resultA = itA.next();
      resultB = itB.next();
    }
    return true;
  }
  function node_listOfElementsWithQualifiedName(qualifiedName, root) {
    if (qualifiedName === "*") {
      return (0, CreateAlgorithm_1.create_htmlCollection)(root);
    } else if (root._nodeDocument._type === "html") {
      return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
        if (ele._namespace === infra_1.namespace.HTML && ele._qualifiedName === qualifiedName.toLowerCase()) {
          return true;
        } else if (ele._namespace !== infra_1.namespace.HTML && ele._qualifiedName === qualifiedName) {
          return true;
        } else {
          return false;
        }
      });
    } else {
      return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
        return ele._qualifiedName === qualifiedName;
      });
    }
  }
  function node_listOfElementsWithNamespace(namespace, localName, root) {
    if (namespace === "")
      namespace = null;
    if (namespace === "*" && localName === "*") {
      return (0, CreateAlgorithm_1.create_htmlCollection)(root);
    } else if (namespace === "*") {
      return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
        return ele._localName === localName;
      });
    } else if (localName === "*") {
      return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
        return ele._namespace === namespace;
      });
    } else {
      return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
        return ele._localName === localName && ele._namespace === namespace;
      });
    }
  }
  function node_listOfElementsWithClassNames(classNames, root) {
    const classes = (0, OrderedSetAlgorithm_1.orderedSet_parse)(classNames);
    if (classes.size === 0) {
      return (0, CreateAlgorithm_1.create_htmlCollection)(root, () => false);
    }
    const caseSensitive = root._nodeDocument._mode !== "quirks";
    return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
      const eleClasses = ele.classList;
      return (0, OrderedSetAlgorithm_1.orderedSet_contains)(eleClasses._tokenSet, classes, caseSensitive);
    });
  }
  function node_locateANamespacePrefix(element, namespace) {
    if (element._namespace === namespace && element._namespacePrefix !== null) {
      return element._namespacePrefix;
    }
    for (let i = 0;i < element._attributeList.length; i++) {
      const attr = element._attributeList[i];
      if (attr._namespacePrefix === "xmlns" && attr._value === namespace) {
        return attr._localName;
      }
    }
    if (element._parent && util_1.Guard.isElementNode(element._parent)) {
      return node_locateANamespacePrefix(element._parent, namespace);
    }
    return null;
  }
  function node_locateANamespace(node, prefix) {
    if (util_1.Guard.isElementNode(node)) {
      if (node._namespace !== null && node._namespacePrefix === prefix) {
        return node._namespace;
      }
      for (let i = 0;i < node._attributeList.length; i++) {
        const attr = node._attributeList[i];
        if (attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === "xmlns" && attr._localName === prefix) {
          return attr._value || null;
        }
        if (prefix === null && attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === null && attr._localName === "xmlns") {
          return attr._value || null;
        }
      }
      if (node.parentElement === null)
        return null;
      return node_locateANamespace(node.parentElement, prefix);
    } else if (util_1.Guard.isDocumentNode(node)) {
      if (node.documentElement === null)
        return null;
      return node_locateANamespace(node.documentElement, prefix);
    } else if (util_1.Guard.isDocumentTypeNode(node) || util_1.Guard.isDocumentFragmentNode(node)) {
      return null;
    } else if (util_1.Guard.isAttrNode(node)) {
      if (node._element === null)
        return null;
      return node_locateANamespace(node._element, prefix);
    } else {
      if (!node._parent || !util_1.Guard.isElementNode(node._parent))
        return null;
      return node_locateANamespace(node._parent, prefix);
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/ParentNodeAlgorithm.js
var require_ParentNodeAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parentNode_convertNodesIntoANode = parentNode_convertNodesIntoANode;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  function parentNode_convertNodesIntoANode(nodes, document2) {
    let node = null;
    for (let i = 0;i < nodes.length; i++) {
      const item = nodes[i];
      if ((0, util_1.isString)(item)) {
        const text = (0, CreateAlgorithm_1.create_text)(document2, item);
        nodes[i] = text;
      }
    }
    if (nodes.length === 1) {
      node = nodes[0];
    } else {
      node = (0, CreateAlgorithm_1.create_documentFragment)(document2);
      const ns = node;
      for (const item of nodes) {
        ns.appendChild(item);
      }
    }
    return node;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/TextAlgorithm.js
var require_TextAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.text_contiguousTextNodes = text_contiguousTextNodes;
  exports.text_contiguousExclusiveTextNodes = text_contiguousExclusiveTextNodes;
  exports.text_descendantTextContent = text_descendantTextContent;
  exports.text_split = text_split;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var DOMException_1 = require_DOMException();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var CharacterDataAlgorithm_1 = require_CharacterDataAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  function text_contiguousTextNodes(node, self2 = false) {
    return {
      [Symbol.iterator]() {
        let currentNode = node;
        while (currentNode && util_1.Guard.isTextNode(currentNode._previousSibling)) {
          currentNode = currentNode._previousSibling;
        }
        return {
          next() {
            if (currentNode && (!self2 && currentNode === node)) {
              if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                currentNode = currentNode._nextSibling;
              } else {
                currentNode = null;
              }
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                currentNode = currentNode._nextSibling;
              } else {
                currentNode = null;
              }
              return result;
            }
          }
        };
      }
    };
  }
  function text_contiguousExclusiveTextNodes(node, self2 = false) {
    return {
      [Symbol.iterator]() {
        let currentNode = node;
        while (currentNode && util_1.Guard.isExclusiveTextNode(currentNode._previousSibling)) {
          currentNode = currentNode._previousSibling;
        }
        return {
          next() {
            if (currentNode && (!self2 && currentNode === node)) {
              if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                currentNode = currentNode._nextSibling;
              } else {
                currentNode = null;
              }
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                currentNode = currentNode._nextSibling;
              } else {
                currentNode = null;
              }
              return result;
            }
          }
        };
      }
    };
  }
  function text_descendantTextContent(node) {
    let contents = "";
    let text = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node, false, false, (e) => util_1.Guard.isTextNode(e));
    while (text !== null) {
      contents += text._data;
      text = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(node, text, false, false, (e) => util_1.Guard.isTextNode(e));
    }
    return contents;
  }
  function text_split(node, offset) {
    const length = node._data.length;
    if (offset > length) {
      throw new DOMException_1.IndexSizeError;
    }
    const count = length - offset;
    const newData = (0, CharacterDataAlgorithm_1.characterData_substringData)(node, offset, count);
    const newNode = (0, CreateAlgorithm_1.create_text)(node._nodeDocument, newData);
    const parent = node._parent;
    if (parent !== null) {
      (0, MutationAlgorithm_1.mutation_insert)(newNode, parent, node._nextSibling);
      for (const range of DOMImpl_1.dom.rangeList) {
        if (range._start[0] === node && range._start[1] > offset) {
          range._start[0] = newNode;
          range._start[1] -= offset;
        }
        if (range._end[0] === node && range._end[1] > offset) {
          range._end[0] = newNode;
          range._end[1] -= offset;
        }
        const index = (0, TreeAlgorithm_1.tree_index)(node);
        if (range._start[0] === parent && range._start[1] === index + 1) {
          range._start[1]++;
        }
        if (range._end[0] === parent && range._end[1] === index + 1) {
          range._end[1]++;
        }
      }
    }
    (0, CharacterDataAlgorithm_1.characterData_replaceData)(node, offset, count, "");
    return newNode;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/RangeAlgorithm.js
var require_RangeAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.range_collapsed = range_collapsed;
  exports.range_root = range_root;
  exports.range_isContained = range_isContained;
  exports.range_isPartiallyContained = range_isPartiallyContained;
  exports.range_setTheStart = range_setTheStart;
  exports.range_setTheEnd = range_setTheEnd;
  exports.range_select = range_select;
  exports.range_extract = range_extract;
  exports.range_cloneTheContents = range_cloneTheContents;
  exports.range_insert = range_insert;
  exports.range_getContainedNodes = range_getContainedNodes;
  exports.range_getPartiallyContainedNodes = range_getPartiallyContainedNodes;
  var interfaces_1 = require_interfaces2();
  var DOMException_1 = require_DOMException();
  var util_1 = require_util2();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var BoundaryPointAlgorithm_1 = require_BoundaryPointAlgorithm();
  var CharacterDataAlgorithm_1 = require_CharacterDataAlgorithm();
  var NodeAlgorithm_1 = require_NodeAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  var TextAlgorithm_1 = require_TextAlgorithm();
  function range_collapsed(range) {
    return range._startNode === range._endNode && range._startOffset === range._endOffset;
  }
  function range_root(range) {
    return (0, TreeAlgorithm_1.tree_rootNode)(range._startNode);
  }
  function range_isContained(node, range) {
    return (0, TreeAlgorithm_1.tree_rootNode)(node) === range_root(range) && (0, BoundaryPointAlgorithm_1.boundaryPoint_position)([node, 0], range._start) === interfaces_1.BoundaryPosition.After && (0, BoundaryPointAlgorithm_1.boundaryPoint_position)([node, (0, TreeAlgorithm_1.tree_nodeLength)(node)], range._end) === interfaces_1.BoundaryPosition.Before;
  }
  function range_isPartiallyContained(node, range) {
    const startCheck = (0, TreeAlgorithm_1.tree_isAncestorOf)(range._startNode, node, true);
    const endCheck = (0, TreeAlgorithm_1.tree_isAncestorOf)(range._endNode, node, true);
    return startCheck && !endCheck || !startCheck && endCheck;
  }
  function range_setTheStart(range, node, offset) {
    if (util_1.Guard.isDocumentTypeNode(node)) {
      throw new DOMException_1.InvalidNodeTypeError;
    }
    if (offset > (0, TreeAlgorithm_1.tree_nodeLength)(node)) {
      throw new DOMException_1.IndexSizeError;
    }
    const bp = [node, offset];
    if (range_root(range) !== (0, TreeAlgorithm_1.tree_rootNode)(node) || (0, BoundaryPointAlgorithm_1.boundaryPoint_position)(bp, range._end) === interfaces_1.BoundaryPosition.After) {
      range._end = bp;
    }
    range._start = bp;
  }
  function range_setTheEnd(range, node, offset) {
    if (util_1.Guard.isDocumentTypeNode(node)) {
      throw new DOMException_1.InvalidNodeTypeError;
    }
    if (offset > (0, TreeAlgorithm_1.tree_nodeLength)(node)) {
      throw new DOMException_1.IndexSizeError;
    }
    const bp = [node, offset];
    if (range_root(range) !== (0, TreeAlgorithm_1.tree_rootNode)(node) || (0, BoundaryPointAlgorithm_1.boundaryPoint_position)(bp, range._start) === interfaces_1.BoundaryPosition.Before) {
      range._start = bp;
    }
    range._end = bp;
  }
  function range_select(node, range) {
    const parent = node._parent;
    if (parent === null)
      throw new DOMException_1.InvalidNodeTypeError;
    const index = (0, TreeAlgorithm_1.tree_index)(node);
    range._start = [parent, index];
    range._end = [parent, index + 1];
  }
  function range_extract(range) {
    const fragment = (0, CreateAlgorithm_1.create_documentFragment)(range._startNode._nodeDocument);
    if (range_collapsed(range))
      return fragment;
    const originalStartNode = range._startNode;
    const originalStartOffset = range._startOffset;
    const originalEndNode = range._endNode;
    const originalEndOffset = range._endOffset;
    if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(originalStartNode);
      clone2._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
      (0, CharacterDataAlgorithm_1.characterData_replaceData)(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
      return fragment;
    }
    let commonAncestor = originalStartNode;
    while (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, commonAncestor, true)) {
      if (commonAncestor._parent === null) {
        throw new Error("Parent node  is null.");
      }
      commonAncestor = commonAncestor._parent;
    }
    let firstPartiallyContainedChild = null;
    if (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, originalStartNode, true)) {
      for (const node of commonAncestor._children) {
        if (range_isPartiallyContained(node, range)) {
          firstPartiallyContainedChild = node;
          break;
        }
      }
    }
    let lastPartiallyContainedChild = null;
    if (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalStartNode, originalEndNode, true)) {
      const children = [...commonAncestor._children];
      for (let i = children.length - 1;i > 0; i--) {
        const node = children[i];
        if (range_isPartiallyContained(node, range)) {
          lastPartiallyContainedChild = node;
          break;
        }
      }
    }
    const containedChildren = [];
    for (const child of commonAncestor._children) {
      if (range_isContained(child, range)) {
        if (util_1.Guard.isDocumentTypeNode(child)) {
          throw new DOMException_1.HierarchyRequestError;
        }
        containedChildren.push(child);
      }
    }
    let newNode;
    let newOffset;
    if ((0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, originalStartNode, true)) {
      newNode = originalStartNode;
      newOffset = originalStartOffset;
    } else {
      let referenceNode = originalStartNode;
      while (referenceNode._parent !== null && !(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, referenceNode._parent)) {
        referenceNode = referenceNode._parent;
      }
      if (referenceNode._parent === null) {
        throw new Error("Parent node is null.");
      }
      newNode = referenceNode._parent;
      newOffset = 1 + (0, TreeAlgorithm_1.tree_index)(referenceNode);
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(originalStartNode);
      clone2._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalStartNode, originalStartOffset, (0, TreeAlgorithm_1.tree_nodeLength)(originalStartNode) - originalStartOffset);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
      (0, CharacterDataAlgorithm_1.characterData_replaceData)(originalStartNode, originalStartOffset, (0, TreeAlgorithm_1.tree_nodeLength)(originalStartNode) - originalStartOffset, "");
    } else if (firstPartiallyContainedChild !== null) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(firstPartiallyContainedChild);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
      const subrange = (0, CreateAlgorithm_1.create_range)([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, (0, TreeAlgorithm_1.tree_nodeLength)(firstPartiallyContainedChild)]);
      const subfragment = range_extract(subrange);
      (0, MutationAlgorithm_1.mutation_append)(subfragment, clone2);
    }
    for (const child of containedChildren) {
      (0, MutationAlgorithm_1.mutation_append)(child, fragment);
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(originalEndNode);
      clone2._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalEndNode, 0, originalEndOffset);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
      (0, CharacterDataAlgorithm_1.characterData_replaceData)(originalEndNode, 0, originalEndOffset, "");
    } else if (lastPartiallyContainedChild !== null) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(lastPartiallyContainedChild);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
      const subrange = (0, CreateAlgorithm_1.create_range)([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
      const subfragment = range_extract(subrange);
      (0, MutationAlgorithm_1.mutation_append)(subfragment, clone2);
    }
    range._start = [newNode, newOffset];
    range._end = [newNode, newOffset];
    return fragment;
  }
  function range_cloneTheContents(range) {
    const fragment = (0, CreateAlgorithm_1.create_documentFragment)(range._startNode._nodeDocument);
    if (range_collapsed(range))
      return fragment;
    const originalStartNode = range._startNode;
    const originalStartOffset = range._startOffset;
    const originalEndNode = range._endNode;
    const originalEndOffset = range._endOffset;
    if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(originalStartNode);
      clone2._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
    }
    let commonAncestor = originalStartNode;
    while (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, commonAncestor, true)) {
      if (commonAncestor._parent === null) {
        throw new Error("Parent node  is null.");
      }
      commonAncestor = commonAncestor._parent;
    }
    let firstPartiallyContainedChild = null;
    if (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, originalStartNode, true)) {
      for (const node of commonAncestor._children) {
        if (range_isPartiallyContained(node, range)) {
          firstPartiallyContainedChild = node;
          break;
        }
      }
    }
    let lastPartiallyContainedChild = null;
    if (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalStartNode, originalEndNode, true)) {
      const children = [...commonAncestor._children];
      for (let i = children.length - 1;i > 0; i--) {
        const node = children[i];
        if (range_isPartiallyContained(node, range)) {
          lastPartiallyContainedChild = node;
          break;
        }
      }
    }
    const containedChildren = [];
    for (const child of commonAncestor._children) {
      if (range_isContained(child, range)) {
        if (util_1.Guard.isDocumentTypeNode(child)) {
          throw new DOMException_1.HierarchyRequestError;
        }
        containedChildren.push(child);
      }
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(originalStartNode);
      clone2._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalStartNode, originalStartOffset, (0, TreeAlgorithm_1.tree_nodeLength)(originalStartNode) - originalStartOffset);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
    } else if (firstPartiallyContainedChild !== null) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(firstPartiallyContainedChild);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
      const subrange = (0, CreateAlgorithm_1.create_range)([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, (0, TreeAlgorithm_1.tree_nodeLength)(firstPartiallyContainedChild)]);
      const subfragment = range_cloneTheContents(subrange);
      (0, MutationAlgorithm_1.mutation_append)(subfragment, clone2);
    }
    for (const child of containedChildren) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(child);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(originalEndNode);
      clone2._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalEndNode, 0, originalEndOffset);
      (0, MutationAlgorithm_1.mutation_append)(clone2, fragment);
    } else if (lastPartiallyContainedChild !== null) {
      const clone2 = (0, NodeAlgorithm_1.node_clone)(lastPartiallyContainedChild);
      fragment.append(clone2);
      const subrange = (0, CreateAlgorithm_1.create_range)([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
      const subfragment = range_extract(subrange);
      (0, MutationAlgorithm_1.mutation_append)(subfragment, clone2);
    }
    return fragment;
  }
  function range_insert(node, range) {
    if (util_1.Guard.isProcessingInstructionNode(range._startNode) || util_1.Guard.isCommentNode(range._startNode) || util_1.Guard.isTextNode(range._startNode) && range._startNode._parent === null || range._startNode === node) {
      throw new DOMException_1.HierarchyRequestError;
    }
    let referenceNode = null;
    if (util_1.Guard.isTextNode(range._startNode)) {
      referenceNode = range._startNode;
    } else {
      let index = 0;
      for (const child of range._startNode._children) {
        if (index === range._startOffset) {
          referenceNode = child;
          break;
        }
        index++;
      }
    }
    let parent;
    if (referenceNode === null) {
      parent = range._startNode;
    } else {
      if (referenceNode._parent === null) {
        throw new Error("Parent node is null.");
      }
      parent = referenceNode._parent;
    }
    (0, MutationAlgorithm_1.mutation_ensurePreInsertionValidity)(node, parent, referenceNode);
    if (util_1.Guard.isTextNode(range._startNode)) {
      referenceNode = (0, TextAlgorithm_1.text_split)(range._startNode, range._startOffset);
    }
    if (node === referenceNode) {
      referenceNode = node._nextSibling;
    }
    if (node._parent !== null) {
      (0, MutationAlgorithm_1.mutation_remove)(node, node._parent);
    }
    let newOffset = referenceNode === null ? (0, TreeAlgorithm_1.tree_nodeLength)(parent) : (0, TreeAlgorithm_1.tree_index)(referenceNode);
    if (util_1.Guard.isDocumentFragmentNode(node)) {
      newOffset += (0, TreeAlgorithm_1.tree_nodeLength)(node);
    } else {
      newOffset++;
    }
    (0, MutationAlgorithm_1.mutation_preInsert)(node, parent, referenceNode);
    if (range_collapsed(range)) {
      range._end = [parent, newOffset];
    }
  }
  function range_getContainedNodes(range) {
    return {
      [Symbol.iterator]: () => {
        const container = range.commonAncestorContainer;
        let currentNode = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(container);
        return {
          next: () => {
            while (currentNode && !range_isContained(currentNode, range)) {
              currentNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(container, currentNode);
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(container, currentNode);
              return result;
            }
          }
        };
      }
    };
  }
  function range_getPartiallyContainedNodes(range) {
    return {
      [Symbol.iterator]: () => {
        const container = range.commonAncestorContainer;
        let currentNode = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(container);
        return {
          next: () => {
            while (currentNode && !range_isPartiallyContained(currentNode, range)) {
              currentNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(container, currentNode);
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(container, currentNode);
              return result;
            }
          }
        };
      }
    };
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/SelectorsAlgorithm.js
var require_SelectorsAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.selectors_scopeMatchASelectorsString = selectors_scopeMatchASelectorsString;
  var DOMException_1 = require_DOMException();
  function selectors_scopeMatchASelectorsString(selectors, node) {
    throw new DOMException_1.NotSupportedError;
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/TreeWalkerAlgorithm.js
var require_TreeWalkerAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.treeWalker_traverseChildren = treeWalker_traverseChildren;
  exports.treeWalker_traverseSiblings = treeWalker_traverseSiblings;
  var interfaces_1 = require_interfaces2();
  var TraversalAlgorithm_1 = require_TraversalAlgorithm();
  function treeWalker_traverseChildren(walker, first) {
    let node = first ? walker._current._firstChild : walker._current._lastChild;
    while (node !== null) {
      const result = (0, TraversalAlgorithm_1.traversal_filter)(walker, node);
      if (result === interfaces_1.FilterResult.Accept) {
        walker._current = node;
        return node;
      } else if (result === interfaces_1.FilterResult.Skip) {
        const child = first ? node._firstChild : node._lastChild;
        if (child !== null) {
          node = child;
          continue;
        }
      }
      while (node !== null) {
        const sibling = first ? node._nextSibling : node._previousSibling;
        if (sibling !== null) {
          node = sibling;
          break;
        }
        const parent = node._parent;
        if (parent === null || parent === walker._root || parent === walker._current) {
          return null;
        }
        node = parent;
      }
    }
    return null;
  }
  function treeWalker_traverseSiblings(walker, next) {
    let node = walker._current;
    if (node === walker._root)
      return null;
    while (true) {
      let sibling = next ? node._nextSibling : node._previousSibling;
      while (sibling !== null) {
        node = sibling;
        const result = (0, TraversalAlgorithm_1.traversal_filter)(walker, node);
        if (result === interfaces_1.FilterResult.Accept) {
          walker._current = node;
          return node;
        }
        sibling = next ? node._firstChild : node._lastChild;
        if (result === interfaces_1.FilterResult.Reject || sibling === null) {
          sibling = next ? node._nextSibling : node._previousSibling;
        }
      }
      node = node._parent;
      if (node === null || node === walker._root) {
        return null;
      }
      if ((0, TraversalAlgorithm_1.traversal_filter)(walker, node) === interfaces_1.FilterResult.Accept) {
        return null;
      }
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/index.js
var require_algorithm = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_AbortAlgorithm(), exports);
  __exportStar(require_AttrAlgorithm(), exports);
  __exportStar(require_BoundaryPointAlgorithm(), exports);
  __exportStar(require_CharacterDataAlgorithm(), exports);
  __exportStar(require_CreateAlgorithm(), exports);
  __exportStar(require_CustomElementAlgorithm(), exports);
  __exportStar(require_DocumentAlgorithm(), exports);
  __exportStar(require_DOMAlgorithm(), exports);
  __exportStar(require_DOMTokenListAlgorithm(), exports);
  __exportStar(require_ElementAlgorithm(), exports);
  __exportStar(require_EventAlgorithm(), exports);
  __exportStar(require_EventTargetAlgorithm(), exports);
  __exportStar(require_MutationAlgorithm(), exports);
  __exportStar(require_MutationObserverAlgorithm(), exports);
  __exportStar(require_NamespaceAlgorithm(), exports);
  __exportStar(require_NodeAlgorithm(), exports);
  __exportStar(require_NodeIteratorAlgorithm(), exports);
  __exportStar(require_OrderedSetAlgorithm(), exports);
  __exportStar(require_ParentNodeAlgorithm(), exports);
  __exportStar(require_RangeAlgorithm(), exports);
  __exportStar(require_SelectorsAlgorithm(), exports);
  __exportStar(require_ShadowTreeAlgorithm(), exports);
  __exportStar(require_TextAlgorithm(), exports);
  __exportStar(require_TraversalAlgorithm(), exports);
  __exportStar(require_TreeAlgorithm(), exports);
  __exportStar(require_TreeWalkerAlgorithm(), exports);
  __exportStar(require_WebIDLAlgorithm(), exports);
  __exportStar(require_XMLAlgorithm(), exports);
});

// node_modules/xmlbuilder2/lib/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nonEntityAmpersandRegex = undefined;
  exports.nonEntityAmpersandRegex = /&(?![A-Za-z]+;|#\d+;)/g;
});

// node_modules/xmlbuilder2/lib/writers/BaseWriter.js
var require_BaseWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseWriter = undefined;
  var interfaces_1 = require_interfaces2();
  var LocalNameSet_1 = require_LocalNameSet();
  var NamespacePrefixMap_1 = require_NamespacePrefixMap();
  var infra_1 = require_lib7();
  var algorithm_1 = require_algorithm();
  var constants_1 = require_constants2();

  class BaseWriter {
    static _VoidElementNames = new Set([
      "area",
      "base",
      "basefont",
      "bgsound",
      "br",
      "col",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    _builderOptions;
    _writerOptions;
    constructor(builderOptions) {
      this._builderOptions = builderOptions;
    }
    declaration(version, encoding, standalone) {}
    docType(name, publicId, systemId) {}
    comment(data) {}
    text(data) {}
    instruction(target, data) {}
    cdata(data) {}
    openTagBegin(name) {}
    openTagEnd(name, selfClosing, voidElement) {}
    closeTag(name) {}
    attributes(attributes) {
      for (const attr of attributes) {
        this.attribute(attr[1] === null ? attr[2] : attr[1] + ":" + attr[2], attr[3]);
      }
    }
    attribute(name, value) {}
    beginElement(name) {}
    endElement(name) {}
    level = 0;
    currentNode;
    serializeNode(node, requireWellFormed) {
      const hasNamespaces = node._nodeDocument !== undefined && node._nodeDocument._hasNamespaces;
      this.level = 0;
      this.currentNode = node;
      if (hasNamespaces) {
        let namespace = null;
        const prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap;
        prefixMap.set("xml", infra_1.namespace.XML);
        const prefixIndex = { value: 1 };
        this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
      } else {
        this._serializeNode(node, requireWellFormed);
      }
    }
    _serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      this.currentNode = node;
      switch (node.nodeType) {
        case interfaces_1.NodeType.Element:
          this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
          break;
        case interfaces_1.NodeType.Document:
          this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
          break;
        case interfaces_1.NodeType.Comment:
          this._serializeComment(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.Text:
          this._serializeText(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.DocumentFragment:
          this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
          break;
        case interfaces_1.NodeType.DocumentType:
          this._serializeDocumentType(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.ProcessingInstruction:
          this._serializeProcessingInstruction(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.CData:
          this._serializeCData(node, requireWellFormed);
          break;
        default:
          throw new Error(`Unknown node type: ${node.nodeType}`);
      }
    }
    _serializeNode(node, requireWellFormed) {
      this.currentNode = node;
      switch (node.nodeType) {
        case interfaces_1.NodeType.Element:
          this._serializeElement(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.Document:
          this._serializeDocument(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.Comment:
          this._serializeComment(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.Text:
          this._serializeText(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.DocumentFragment:
          this._serializeDocumentFragment(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.DocumentType:
          this._serializeDocumentType(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.ProcessingInstruction:
          this._serializeProcessingInstruction(node, requireWellFormed);
          break;
        case interfaces_1.NodeType.CData:
          this._serializeCData(node, requireWellFormed);
          break;
        default:
          throw new Error(`Unknown node type: ${node.nodeType}`);
      }
    }
    _serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      const attributes = [];
      if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let qualifiedName = "";
      let skipEndTag = false;
      let ignoreNamespaceDefinitionAttribute = false;
      let map = prefixMap.copy();
      let localPrefixesMap = {};
      let localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
      let inheritedNS = namespace;
      let ns = node.namespaceURI;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node.localName;
        } else {
          qualifiedName = node.localName;
        }
        this.beginElement(qualifiedName);
        this.openTagBegin(qualifiedName);
      } else {
        let prefix = node.prefix;
        let candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (requireWellFormed) {
            throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map, prefixIndex);
          }
          map.set(prefix, ns);
          qualifiedName += prefix + ":" + node.localName;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
          attributes.push([
            null,
            "xmlns",
            prefix,
            this._serializeAttributeValue(ns, requireWellFormed)
          ]);
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node.localName;
          inheritedNS = ns;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
          attributes.push([
            null,
            null,
            "xmlns",
            this._serializeAttributeValue(ns, requireWellFormed)
          ]);
        } else {
          qualifiedName += node.localName;
          inheritedNS = ns;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
        }
      }
      attributes.push(...this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed));
      this.attributes(attributes);
      const isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && node.childNodes.length === 0 && BaseWriter._VoidElementNames.has(node.localName)) {
        this.openTagEnd(qualifiedName, true, true);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else if (!isHTML && node.childNodes.length === 0) {
        this.openTagEnd(qualifiedName, true, false);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else {
        this.openTagEnd(qualifiedName, false, false);
      }
      if (skipEndTag)
        return;
      if (isHTML && node.localName === "template") {} else {
        for (const childNode of node.childNodes) {
          this.level++;
          this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
          this.level--;
        }
      }
      this.closeTag(qualifiedName);
      this.endElement(qualifiedName);
    }
    _serializeElement(node, requireWellFormed) {
      if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let skipEndTag = false;
      const qualifiedName = node.localName;
      this.beginElement(qualifiedName);
      this.openTagBegin(qualifiedName);
      const attributes = this._serializeAttributes(node, requireWellFormed);
      this.attributes(attributes);
      if (!node.hasChildNodes()) {
        this.openTagEnd(qualifiedName, true, false);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else {
        this.openTagEnd(qualifiedName, false, false);
      }
      if (skipEndTag)
        return;
      for (const childNode of node._children) {
        this.level++;
        this._serializeNode(childNode, requireWellFormed);
        this.level--;
      }
      this.closeTag(qualifiedName);
      this.endElement(qualifiedName);
    }
    _serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      if (requireWellFormed && node.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      for (const childNode of node.childNodes) {
        this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
      }
    }
    _serializeDocument(node, requireWellFormed) {
      if (requireWellFormed && node.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      for (const childNode of node._children) {
        this._serializeNode(childNode, requireWellFormed);
      }
    }
    _serializeComment(node, requireWellFormed) {
      if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
        throw new Error("Comment data contains invalid characters (well-formed required).");
      }
      this.comment(node.data);
    }
    _serializeText(node, requireWellFormed) {
      if (requireWellFormed && !(0, algorithm_1.xml_isLegalChar)(node.data)) {
        throw new Error("Text data contains invalid characters (well-formed required).");
      }
      const markup = node.data.replace(constants_1.nonEntityAmpersandRegex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      this.text(markup);
    }
    _serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      for (const childNode of node.childNodes) {
        this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
      }
    }
    _serializeDocumentFragment(node, requireWellFormed) {
      for (const childNode of node._children) {
        this._serializeNode(childNode, requireWellFormed);
      }
    }
    _serializeDocumentType(node, requireWellFormed) {
      if (requireWellFormed && !(0, algorithm_1.xml_isPubidChar)(node.publicId)) {
        throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
      }
      if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
        throw new Error("DocType system identifier contains invalid characters (well-formed required).");
      }
      this.docType(node.name, node.publicId, node.systemId);
    }
    _serializeProcessingInstruction(node, requireWellFormed) {
      if (requireWellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
        throw new Error("Processing instruction target contains invalid characters (well-formed required).");
      }
      if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("?>") !== -1)) {
        throw new Error("Processing instruction data contains invalid characters (well-formed required).");
      }
      this.instruction(node.target, node.data);
    }
    _serializeCData(node, requireWellFormed) {
      if (requireWellFormed && node.data.indexOf("]]>") !== -1) {
        throw new Error("CDATA contains invalid characters (well-formed required).");
      }
      this.cdata(node.data);
    }
    _serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
      const result = [];
      const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet : undefined;
      for (const attr of node.attributes) {
        if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
          result.push([
            null,
            null,
            attr.localName,
            this._serializeAttributeValue(attr.value, requireWellFormed)
          ]);
          continue;
        }
        if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet.set(attr.namespaceURI, attr.localName);
        let attributeNamespace = attr.namespaceURI;
        let candidatePrefix = null;
        if (attributeNamespace !== null) {
          candidatePrefix = map.get(attr.prefix, attributeNamespace);
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
              continue;
            if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
              throw new Error("XMLNS namespace is reserved (well-formed required).");
            }
            if (requireWellFormed && attr.value === "") {
              throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
            }
            if (attr.prefix === "xmlns")
              candidatePrefix = "xmlns";
          } else if (candidatePrefix === null) {
            if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
              candidatePrefix = attr.prefix;
            } else {
              candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
            }
            result.push([
              null,
              "xmlns",
              candidatePrefix,
              this._serializeAttributeValue(attributeNamespace, requireWellFormed)
            ]);
          }
        }
        let attrName = "";
        if (candidatePrefix !== null) {
          attrName = candidatePrefix;
        }
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result.push([
          attributeNamespace,
          candidatePrefix,
          attr.localName,
          this._serializeAttributeValue(attr.value, requireWellFormed)
        ]);
      }
      return result;
    }
    _serializeAttributes(node, requireWellFormed) {
      const result = [];
      const localNameSet = requireWellFormed ? {} : undefined;
      for (const attr of node.attributes) {
        if (!requireWellFormed) {
          result.push([
            null,
            null,
            attr.localName,
            this._serializeAttributeValue(attr.value, requireWellFormed)
          ]);
          continue;
        }
        if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet[attr.localName] = true;
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName))) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result.push([
          null,
          null,
          attr.localName,
          this._serializeAttributeValue(attr.value, requireWellFormed)
        ]);
      }
      return result;
    }
    _recordNamespaceInformation(node, map, localPrefixesMap) {
      let defaultNamespaceAttrValue = null;
      for (const attr of node.attributes) {
        let attributeNamespace = attr.namespaceURI;
        let attributePrefix = attr.prefix;
        if (attributeNamespace === infra_1.namespace.XMLNS) {
          if (attributePrefix === null) {
            defaultNamespaceAttrValue = attr.value;
            continue;
          } else {
            let prefixDefinition = attr.localName;
            let namespaceDefinition = attr.value;
            if (namespaceDefinition === infra_1.namespace.XML) {
              continue;
            }
            if (namespaceDefinition === "") {
              namespaceDefinition = null;
            }
            if (map.has(prefixDefinition, namespaceDefinition)) {
              continue;
            }
            map.set(prefixDefinition, namespaceDefinition);
            localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
          }
        }
      }
      return defaultNamespaceAttrValue;
    }
    _generatePrefix(newNamespace, prefixMap, prefixIndex) {
      const generatedPrefix = "ns" + prefixIndex.value.toString();
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    }
    _serializeAttributeValue(value, requireWellFormed) {
      if (requireWellFormed && value !== null && !(0, algorithm_1.xml_isLegalChar)(value)) {
        throw new Error("Invalid characters in attribute value.");
      }
      if (value === null)
        return "";
      return value.replace(constants_1.nonEntityAmpersandRegex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }
  }
  exports.BaseWriter = BaseWriter;
});

// node_modules/xmlbuilder2/lib/writers/ObjectWriter.js
var require_ObjectWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectWriter = undefined;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var interfaces_1 = require_interfaces2();
  var BaseWriter_1 = require_BaseWriter();

  class ObjectWriter extends BaseWriter_1.BaseWriter {
    _currentList;
    _currentIndex;
    _listRegister;
    constructor(builderOptions, writerOptions) {
      super(builderOptions);
      this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
        format: "object",
        wellFormed: false,
        group: false,
        verbose: false
      });
    }
    serialize(node) {
      this._currentList = [];
      this._currentIndex = 0;
      this._listRegister = [this._currentList];
      this.serializeNode(node, this._writerOptions.wellFormed);
      return this._process(this._currentList, this._writerOptions);
    }
    _process(items, options) {
      if (items.length === 0)
        return {};
      const namesSeen = {};
      let hasNonUniqueNames = false;
      let textCount = 0;
      let commentCount = 0;
      let instructionCount = 0;
      let cdataCount = 0;
      for (let i = 0;i < items.length; i++) {
        const item = items[i];
        const key = Object.keys(item)[0];
        switch (key) {
          case "@":
            continue;
          case "#":
            textCount++;
            break;
          case "!":
            commentCount++;
            break;
          case "?":
            instructionCount++;
            break;
          case "$":
            cdataCount++;
            break;
          default:
            if (namesSeen[key]) {
              hasNonUniqueNames = true;
            } else {
              namesSeen[key] = true;
            }
            break;
        }
      }
      const defAttrKey = this._getAttrKey();
      const defTextKey = this._getNodeKey(interfaces_1.NodeType.Text);
      const defCommentKey = this._getNodeKey(interfaces_1.NodeType.Comment);
      const defInstructionKey = this._getNodeKey(interfaces_1.NodeType.ProcessingInstruction);
      const defCdataKey = this._getNodeKey(interfaces_1.NodeType.CData);
      if (textCount === 1 && items.length === 1 && (0, util_1.isString)(items[0]["#"])) {
        return items[0]["#"];
      } else if (hasNonUniqueNames) {
        const obj = {};
        for (let i = 0;i < items.length; i++) {
          const item = items[i];
          const key = Object.keys(item)[0];
          if (key === "@") {
            const attrs = item["@"];
            const attrKeys = Object.keys(attrs);
            if (!options.group || attrKeys.length === 1) {
              for (const attrName in attrs) {
                obj[defAttrKey + attrName] = attrs[attrName];
              }
            } else {
              obj[defAttrKey] = attrs;
            }
          }
        }
        const result = [];
        for (let i = 0;i < items.length; i++) {
          const item = items[i];
          const key = Object.keys(item)[0];
          switch (key) {
            case "@":
              break;
            case "#":
              result.push({ [defTextKey]: item["#"] });
              break;
            case "!":
              result.push({ [defCommentKey]: item["!"] });
              break;
            case "?":
              result.push({ [defInstructionKey]: item["?"] });
              break;
            case "$":
              result.push({ [defCdataKey]: item["$"] });
              break;
            default:
              const ele = item;
              if (ele[key].length !== 0 && (0, util_1.isArray)(ele[key][0])) {
                const eleGroup = [];
                const listOfLists = ele[key];
                for (let i2 = 0;i2 < listOfLists.length; i2++) {
                  eleGroup.push(this._process(listOfLists[i2], options));
                }
                result.push({ [key]: eleGroup });
              } else {
                if (options.verbose) {
                  result.push({ [key]: [this._process(ele[key], options)] });
                } else {
                  result.push({ [key]: this._process(ele[key], options) });
                }
              }
              break;
          }
        }
        obj[defTextKey] = result;
        return obj;
      } else {
        let textId = 1;
        let commentId = 1;
        let instructionId = 1;
        let cdataId = 1;
        const obj = {};
        for (let i = 0;i < items.length; i++) {
          const item = items[i];
          const key = Object.keys(item)[0];
          switch (key) {
            case "@":
              const attrs = item["@"];
              const attrKeys = Object.keys(attrs);
              if (!options.group || attrKeys.length === 1) {
                for (const attrName in attrs) {
                  obj[defAttrKey + attrName] = attrs[attrName];
                }
              } else {
                obj[defAttrKey] = attrs;
              }
              break;
            case "#":
              textId = this._processSpecItem(item["#"], obj, options.group, defTextKey, textCount, textId);
              break;
            case "!":
              commentId = this._processSpecItem(item["!"], obj, options.group, defCommentKey, commentCount, commentId);
              break;
            case "?":
              instructionId = this._processSpecItem(item["?"], obj, options.group, defInstructionKey, instructionCount, instructionId);
              break;
            case "$":
              cdataId = this._processSpecItem(item["$"], obj, options.group, defCdataKey, cdataCount, cdataId);
              break;
            default:
              const ele = item;
              if (ele[key].length !== 0 && (0, util_1.isArray)(ele[key][0])) {
                const eleGroup = [];
                const listOfLists = ele[key];
                for (let i2 = 0;i2 < listOfLists.length; i2++) {
                  eleGroup.push(this._process(listOfLists[i2], options));
                }
                obj[key] = eleGroup;
              } else {
                if (options.verbose) {
                  obj[key] = [this._process(ele[key], options)];
                } else {
                  obj[key] = this._process(ele[key], options);
                }
              }
              break;
          }
        }
        return obj;
      }
    }
    _processSpecItem(item, obj, group, defKey, count, id) {
      if (!group && (0, util_1.isArray)(item) && count + item.length > 2) {
        for (const subItem of item) {
          const key = defKey + (id++).toString();
          obj[key] = subItem;
        }
      } else {
        const key = count > 1 ? defKey + (id++).toString() : defKey;
        obj[key] = item;
      }
      return id;
    }
    beginElement(name) {
      const childItems = [];
      if (this._currentList.length === 0) {
        this._currentList.push({ [name]: childItems });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isElementNode(lastItem, name)) {
          if (lastItem[name].length !== 0 && (0, util_1.isArray)(lastItem[name][0])) {
            const listOfLists = lastItem[name];
            listOfLists.push(childItems);
          } else {
            lastItem[name] = [lastItem[name], childItems];
          }
        } else {
          this._currentList.push({ [name]: childItems });
        }
      }
      this._currentIndex++;
      if (this._listRegister.length > this._currentIndex) {
        this._listRegister[this._currentIndex] = childItems;
      } else {
        this._listRegister.push(childItems);
      }
      this._currentList = childItems;
    }
    endElement() {
      this._currentList = this._listRegister[--this._currentIndex];
    }
    attribute(name, value) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "@": { [name]: value } });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isAttrNode(lastItem)) {
          lastItem["@"][name] = value;
        } else {
          this._currentList.push({ "@": { [name]: value } });
        }
      }
    }
    comment(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "!": data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isCommentNode(lastItem)) {
          if ((0, util_1.isArray)(lastItem["!"])) {
            lastItem["!"].push(data);
          } else {
            lastItem["!"] = [lastItem["!"], data];
          }
        } else {
          this._currentList.push({ "!": data });
        }
      }
    }
    text(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "#": data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isTextNode(lastItem)) {
          if ((0, util_1.isArray)(lastItem["#"])) {
            lastItem["#"].push(data);
          } else {
            lastItem["#"] = [lastItem["#"], data];
          }
        } else {
          this._currentList.push({ "#": data });
        }
      }
    }
    instruction(target, data) {
      const value = data === "" ? target : target + " " + data;
      if (this._currentList.length === 0) {
        this._currentList.push({ "?": value });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isInstructionNode(lastItem)) {
          if ((0, util_1.isArray)(lastItem["?"])) {
            lastItem["?"].push(value);
          } else {
            lastItem["?"] = [lastItem["?"], value];
          }
        } else {
          this._currentList.push({ "?": value });
        }
      }
    }
    cdata(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ $: data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isCDATANode(lastItem)) {
          if ((0, util_1.isArray)(lastItem["$"])) {
            lastItem["$"].push(data);
          } else {
            lastItem["$"] = [lastItem["$"], data];
          }
        } else {
          this._currentList.push({ $: data });
        }
      }
    }
    _isAttrNode(x) {
      return "@" in x;
    }
    _isTextNode(x) {
      return "#" in x;
    }
    _isCommentNode(x) {
      return "!" in x;
    }
    _isInstructionNode(x) {
      return "?" in x;
    }
    _isCDATANode(x) {
      return "$" in x;
    }
    _isElementNode(x, name) {
      return name in x;
    }
    _getAttrKey() {
      return this._builderOptions.convert.att;
    }
    _getNodeKey(nodeType) {
      switch (nodeType) {
        case interfaces_1.NodeType.Comment:
          return this._builderOptions.convert.comment;
        case interfaces_1.NodeType.Text:
          return this._builderOptions.convert.text;
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._builderOptions.convert.ins;
        case interfaces_1.NodeType.CData:
          return this._builderOptions.convert.cdata;
        default:
          throw new Error("Invalid node type.");
      }
    }
  }
  exports.ObjectWriter = ObjectWriter;
});

// node_modules/xmlbuilder2/lib/writers/MapWriter.js
var require_MapWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MapWriter = undefined;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var ObjectWriter_1 = require_ObjectWriter();
  var BaseWriter_1 = require_BaseWriter();

  class MapWriter extends BaseWriter_1.BaseWriter {
    constructor(builderOptions, writerOptions) {
      super(builderOptions);
      this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
        format: "map",
        wellFormed: false,
        group: false,
        verbose: false
      });
    }
    serialize(node) {
      const objectWriterOptions = (0, util_1.applyDefaults)(this._writerOptions, {
        format: "object",
        wellFormed: false,
        verbose: false
      });
      const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
      const val = objectWriter.serialize(node);
      return this._convertObject(val);
    }
    _convertObject(obj) {
      if ((0, util_1.isArray)(obj)) {
        for (let i = 0;i < obj.length; i++) {
          obj[i] = this._convertObject(obj[i]);
        }
        return obj;
      } else if ((0, util_1.isObject)(obj)) {
        const map = new Map;
        for (const key in obj) {
          map.set(key, this._convertObject(obj[key]));
        }
        return map;
      } else {
        return obj;
      }
    }
  }
  exports.MapWriter = MapWriter;
});

// node_modules/xmlbuilder2/lib/writers/XMLWriter.js
var require_XMLWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLWriter = undefined;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var interfaces_1 = require_interfaces2();
  var BaseWriter_1 = require_BaseWriter();
  var util_2 = require_util2();

  class XMLWriter extends BaseWriter_1.BaseWriter {
    _refs;
    _indentation = {};
    _lengthToLastNewline = 0;
    constructor(builderOptions, writerOptions) {
      super(builderOptions);
      this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
        wellFormed: false,
        headless: false,
        prettyPrint: false,
        indent: "  ",
        newline: `
`,
        offset: 0,
        width: 0,
        allowEmptyTags: false,
        indentTextOnlyNodes: false,
        spaceBeforeSlash: false
      });
    }
    serialize(node) {
      this._refs = { suppressPretty: false, emptyNode: false, markup: "" };
      if (node.nodeType === interfaces_1.NodeType.Document && !this._writerOptions.headless) {
        this.declaration(this._builderOptions.version, this._builderOptions.encoding, this._builderOptions.standalone);
      }
      this.serializeNode(node, this._writerOptions.wellFormed);
      if (this._writerOptions.prettyPrint && this._refs.markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
        this._refs.markup = this._refs.markup.slice(0, -this._writerOptions.newline.length);
      }
      return this._refs.markup;
    }
    declaration(version, encoding, standalone) {
      this._beginLine();
      this._refs.markup += '<?xml version="' + version + '"';
      if (encoding !== undefined) {
        this._refs.markup += ' encoding="' + encoding + '"';
      }
      if (standalone !== undefined) {
        this._refs.markup += ' standalone="' + (standalone ? "yes" : "no") + '"';
      }
      this._refs.markup += "?>";
      this._endLine();
    }
    docType(name, publicId, systemId) {
      this._beginLine();
      if (publicId && systemId) {
        this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
      } else if (publicId) {
        this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
      } else if (systemId) {
        this._refs.markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
      } else {
        this._refs.markup += "<!DOCTYPE " + name + ">";
      }
      this._endLine();
    }
    openTagBegin(name) {
      this._beginLine();
      this._refs.markup += "<" + name;
    }
    openTagEnd(name, selfClosing, voidElement) {
      this._refs.suppressPretty = false;
      this._refs.emptyNode = false;
      if (this._writerOptions.prettyPrint && !selfClosing && !voidElement) {
        let textOnlyNode = true;
        let emptyNode = true;
        let childNode = this.currentNode.firstChild;
        let cdataCount = 0;
        let textCount = 0;
        while (childNode) {
          if (util_2.Guard.isExclusiveTextNode(childNode)) {
            textCount++;
          } else if (util_2.Guard.isCDATASectionNode(childNode)) {
            cdataCount++;
          } else {
            textOnlyNode = false;
            emptyNode = false;
            break;
          }
          if (childNode.data !== "") {
            emptyNode = false;
          }
          childNode = childNode.nextSibling;
        }
        this._refs.suppressPretty = !this._writerOptions.indentTextOnlyNodes && textOnlyNode && (cdataCount <= 1 && textCount === 0 || cdataCount === 0);
        this._refs.emptyNode = emptyNode;
      }
      if ((voidElement || selfClosing || this._refs.emptyNode) && this._writerOptions.allowEmptyTags) {
        this._refs.markup += "></" + name + ">";
      } else {
        this._refs.markup += voidElement ? " />" : selfClosing || this._refs.emptyNode ? this._writerOptions.spaceBeforeSlash ? " />" : "/>" : ">";
      }
      this._endLine();
    }
    closeTag(name) {
      if (!this._refs.emptyNode) {
        this._beginLine();
        this._refs.markup += "</" + name + ">";
      }
      this._refs.suppressPretty = false;
      this._refs.emptyNode = false;
      this._endLine();
    }
    attribute(name, value) {
      const str = name + '="' + value + '"';
      if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._refs.markup.length - this._lengthToLastNewline + 1 + str.length > this._writerOptions.width) {
        this._endLine();
        this._beginLine();
        this._refs.markup += this._indent(1) + str;
      } else {
        this._refs.markup += " " + str;
      }
    }
    text(data) {
      if (data !== "") {
        this._beginLine();
        this._refs.markup += data;
        this._endLine();
      }
    }
    cdata(data) {
      if (data !== "") {
        this._beginLine();
        this._refs.markup += "<![CDATA[" + data + "]]>";
        this._endLine();
      }
    }
    comment(data) {
      this._beginLine();
      this._refs.markup += "<!--" + data + "-->";
      this._endLine();
    }
    instruction(target, data) {
      this._beginLine();
      this._refs.markup += "<?" + (data === "" ? target : target + " " + data) + "?>";
      this._endLine();
    }
    _beginLine() {
      if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
        this._refs.markup += this._indent(this._writerOptions.offset + this.level);
      }
    }
    _endLine() {
      if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
        this._refs.markup += this._writerOptions.newline;
        this._lengthToLastNewline = this._refs.markup.length;
      }
    }
    _indent(level) {
      if (level <= 0) {
        return "";
      } else if (this._indentation[level] !== undefined) {
        return this._indentation[level];
      } else {
        const str = this._writerOptions.indent.repeat(level);
        this._indentation[level] = str;
        return str;
      }
    }
  }
  exports.XMLWriter = XMLWriter;
});

// node_modules/xmlbuilder2/lib/writers/JSONWriter.js
var require_JSONWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JSONWriter = undefined;
  var ObjectWriter_1 = require_ObjectWriter();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var BaseWriter_1 = require_BaseWriter();

  class JSONWriter extends BaseWriter_1.BaseWriter {
    constructor(builderOptions, writerOptions) {
      super(builderOptions);
      this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
        wellFormed: false,
        prettyPrint: false,
        indent: "  ",
        newline: `
`,
        offset: 0,
        group: false,
        verbose: false
      });
    }
    serialize(node) {
      const objectWriterOptions = (0, util_1.applyDefaults)(this._writerOptions, {
        format: "object",
        wellFormed: false
      });
      const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
      const val = objectWriter.serialize(node);
      return this._beginLine(this._writerOptions, 0) + this._convertObject(val, this._writerOptions);
    }
    _convertObject(obj, options, level = 0) {
      let markup = "";
      const isLeaf = this._isLeafNode(obj);
      if ((0, util_1.isArray)(obj)) {
        markup += "[";
        const len = obj.length;
        let i = 0;
        for (const val of obj) {
          markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1) + this._convertObject(val, options, level + 1);
          if (i < len - 1) {
            markup += ",";
          }
          i++;
        }
        markup += this._endLine(options, level) + this._beginLine(options, level);
        markup += "]";
      } else if ((0, util_1.isObject)(obj)) {
        markup += "{";
        const len = (0, util_1.objectLength)(obj);
        let i = 0;
        (0, util_1.forEachObject)(obj, (key, val) => {
          if (isLeaf && options.prettyPrint) {
            markup += " ";
          } else {
            markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1);
          }
          markup += this._key(key);
          if (options.prettyPrint) {
            markup += " ";
          }
          markup += this._convertObject(val, options, level + 1);
          if (i < len - 1) {
            markup += ",";
          }
          i++;
        }, this);
        if (isLeaf && options.prettyPrint) {
          markup += " ";
        } else {
          markup += this._endLine(options, level) + this._beginLine(options, level);
        }
        markup += "}";
      } else {
        markup += this._val(obj);
      }
      return markup;
    }
    _beginLine(options, level) {
      if (!options.prettyPrint) {
        return "";
      } else {
        const indentLevel = options.offset + level + 1;
        if (indentLevel > 0) {
          return new Array(indentLevel).join(options.indent);
        }
      }
      return "";
    }
    _endLine(options, level) {
      if (!options.prettyPrint) {
        return "";
      } else {
        return options.newline;
      }
    }
    _key(key) {
      return '"' + key + '":';
    }
    _val(val) {
      return JSON.stringify(val);
    }
    _isLeafNode(obj) {
      return this._descendantCount(obj) <= 1;
    }
    _descendantCount(obj, count = 0) {
      if ((0, util_1.isArray)(obj)) {
        (0, util_1.forEachArray)(obj, (val) => count += this._descendantCount(val, count), this);
      } else if ((0, util_1.isObject)(obj)) {
        (0, util_1.forEachObject)(obj, (key, val) => count += this._descendantCount(val, count), this);
      } else {
        count++;
      }
      return count;
    }
  }
  exports.JSONWriter = JSONWriter;
});

// node_modules/xmlbuilder2/lib/writers/YAMLWriter.js
var require_YAMLWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.YAMLWriter = undefined;
  var ObjectWriter_1 = require_ObjectWriter();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var BaseWriter_1 = require_BaseWriter();

  class YAMLWriter extends BaseWriter_1.BaseWriter {
    constructor(builderOptions, writerOptions) {
      super(builderOptions);
      this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
        wellFormed: false,
        indent: "  ",
        newline: `
`,
        offset: 0,
        group: false,
        verbose: false
      });
      if (this._writerOptions.indent.length < 2) {
        throw new Error("YAML indententation string must be at least two characters long.");
      }
      if (this._writerOptions.offset < 0) {
        throw new Error("YAML offset should be zero or a positive number.");
      }
    }
    serialize(node) {
      const objectWriterOptions = (0, util_1.applyDefaults)(this._writerOptions, {
        format: "object",
        wellFormed: false
      });
      const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
      const val = objectWriter.serialize(node);
      let markup = this._beginLine(this._writerOptions, 0) + "---" + this._endLine(this._writerOptions) + this._convertObject(val, this._writerOptions, 0);
      if (markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
        markup = markup.slice(0, -this._writerOptions.newline.length);
      }
      return markup;
    }
    _convertObject(obj, options, level, suppressIndent = false) {
      let markup = "";
      if ((0, util_1.isArray)(obj)) {
        for (const val of obj) {
          markup += this._beginLine(options, level, true);
          if (!(0, util_1.isObject)(val)) {
            markup += this._val(val) + this._endLine(options);
          } else if ((0, util_1.isEmpty)(val)) {
            markup += '""' + this._endLine(options);
          } else {
            markup += this._convertObject(val, options, level, true);
          }
        }
      } else {
        (0, util_1.forEachObject)(obj, (key, val) => {
          if (suppressIndent) {
            markup += this._key(key);
            suppressIndent = false;
          } else {
            markup += this._beginLine(options, level) + this._key(key);
          }
          if (!(0, util_1.isObject)(val) && !(0, util_1.isArray)(val)) {
            markup += " " + this._val(val) + this._endLine(options);
          } else if ((0, util_1.isEmpty)(val)) {
            markup += ' ""' + this._endLine(options);
          } else {
            markup += this._endLine(options) + this._convertObject(val, options, level + 1);
          }
        }, this);
      }
      return markup;
    }
    _beginLine(options, level, isArray2 = false) {
      const indentLevel = options.offset + level + 1;
      const chars = new Array(indentLevel).join(options.indent);
      if (isArray2) {
        return chars.substr(0, chars.length - 2) + "-" + chars.substr(-1, 1);
      } else {
        return chars;
      }
    }
    _endLine(options) {
      return options.newline;
    }
    _key(key) {
      return '"' + key + '":';
    }
    _val(val) {
      return JSON.stringify(val);
    }
  }
  exports.YAMLWriter = YAMLWriter;
});

// node_modules/xmlbuilder2/lib/writers/index.js
var require_writers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.YAMLWriter = exports.JSONWriter = exports.ObjectWriter = exports.XMLWriter = exports.MapWriter = undefined;
  var MapWriter_1 = require_MapWriter();
  Object.defineProperty(exports, "MapWriter", { enumerable: true, get: function() {
    return MapWriter_1.MapWriter;
  } });
  var XMLWriter_1 = require_XMLWriter();
  Object.defineProperty(exports, "XMLWriter", { enumerable: true, get: function() {
    return XMLWriter_1.XMLWriter;
  } });
  var ObjectWriter_1 = require_ObjectWriter();
  Object.defineProperty(exports, "ObjectWriter", { enumerable: true, get: function() {
    return ObjectWriter_1.ObjectWriter;
  } });
  var JSONWriter_1 = require_JSONWriter();
  Object.defineProperty(exports, "JSONWriter", { enumerable: true, get: function() {
    return JSONWriter_1.JSONWriter;
  } });
  var YAMLWriter_1 = require_YAMLWriter();
  Object.defineProperty(exports, "YAMLWriter", { enumerable: true, get: function() {
    return YAMLWriter_1.YAMLWriter;
  } });
});

// node_modules/@oozcitak/dom/lib/dom/ChildNodeImpl.js
var require_ChildNodeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChildNodeImpl = undefined;
  var util_1 = require_util2();
  var algorithm_1 = require_algorithm();

  class ChildNodeImpl {
    before(...nodes) {
      const context = util_1.Cast.asNode(this);
      const parent = context._parent;
      if (parent === null)
        return;
      let viablePreviousSibling = context._previousSibling;
      let flag = true;
      while (flag && viablePreviousSibling) {
        flag = false;
        for (let i = 0;i < nodes.length; i++) {
          const child = nodes[i];
          if (child === viablePreviousSibling) {
            viablePreviousSibling = viablePreviousSibling._previousSibling;
            flag = true;
            break;
          }
        }
      }
      const node = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, context._nodeDocument);
      if (viablePreviousSibling === null)
        viablePreviousSibling = parent._firstChild;
      else
        viablePreviousSibling = viablePreviousSibling._nextSibling;
      (0, algorithm_1.mutation_preInsert)(node, parent, viablePreviousSibling);
    }
    after(...nodes) {
      const context = util_1.Cast.asNode(this);
      const parent = context._parent;
      if (!parent)
        return;
      let viableNextSibling = context._nextSibling;
      let flag = true;
      while (flag && viableNextSibling) {
        flag = false;
        for (let i = 0;i < nodes.length; i++) {
          const child = nodes[i];
          if (child === viableNextSibling) {
            viableNextSibling = viableNextSibling._nextSibling;
            flag = true;
            break;
          }
        }
      }
      const node = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, context._nodeDocument);
      (0, algorithm_1.mutation_preInsert)(node, parent, viableNextSibling);
    }
    replaceWith(...nodes) {
      const context = util_1.Cast.asNode(this);
      const parent = context._parent;
      if (!parent)
        return;
      let viableNextSibling = context._nextSibling;
      let flag = true;
      while (flag && viableNextSibling) {
        flag = false;
        for (let i = 0;i < nodes.length; i++) {
          const child = nodes[i];
          if (child === viableNextSibling) {
            viableNextSibling = viableNextSibling._nextSibling;
            flag = true;
            break;
          }
        }
      }
      const node = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, context._nodeDocument);
      if (context._parent === parent)
        (0, algorithm_1.mutation_replace)(context, node, parent);
      else
        (0, algorithm_1.mutation_preInsert)(node, parent, viableNextSibling);
    }
    remove() {
      const context = util_1.Cast.asNode(this);
      const parent = context._parent;
      if (!parent)
        return;
      (0, algorithm_1.mutation_remove)(context, parent);
    }
  }
  exports.ChildNodeImpl = ChildNodeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/DocumentOrShadowRootImpl.js
var require_DocumentOrShadowRootImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocumentOrShadowRootImpl = undefined;

  class DocumentOrShadowRootImpl {
  }
  exports.DocumentOrShadowRootImpl = DocumentOrShadowRootImpl;
});

// node_modules/@oozcitak/dom/lib/dom/MutationObserverImpl.js
var require_MutationObserverImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MutationObserverImpl = undefined;
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var infra_1 = require_lib7();

  class MutationObserverImpl {
    _callback;
    _nodeList = [];
    _recordQueue = [];
    constructor(callback) {
      this._callback = callback;
      const window2 = DOMImpl_1.dom.window;
      infra_1.set.append(window2._mutationObservers, this);
    }
    observe(target, options) {
      options = options || {
        childList: false,
        subtree: false
      };
      if ((options.attributeOldValue !== undefined || options.attributeFilter !== undefined) && options.attributes === undefined) {
        options.attributes = true;
      }
      if (options.characterDataOldValue !== undefined && options.characterData === undefined) {
        options.characterData = true;
      }
      if (!options.childList && !options.attributes && !options.characterData) {
        throw new TypeError;
      }
      if (options.attributeOldValue && !options.attributes) {
        throw new TypeError;
      }
      if (options.attributeFilter !== undefined && !options.attributes) {
        throw new TypeError;
      }
      if (options.characterDataOldValue && !options.characterData) {
        throw new TypeError;
      }
      let isRegistered = false;
      const coptions = options;
      for (const registered of target._registeredObserverList) {
        if (registered.observer === this) {
          isRegistered = true;
          for (const node of this._nodeList) {
            infra_1.list.remove(node._registeredObserverList, (ob) => util_1.Guard.isTransientRegisteredObserver(ob) && ob.source === registered);
          }
          registered.options = coptions;
        }
      }
      if (!isRegistered) {
        target._registeredObserverList.push({ observer: this, options });
        this._nodeList.push(target);
      }
    }
    disconnect() {
      for (const node of this._nodeList) {
        infra_1.list.remove(node._registeredObserverList, (ob) => ob.observer === this);
      }
      this._recordQueue = [];
    }
    takeRecords() {
      const records = this._recordQueue;
      this._recordQueue = [];
      return records;
    }
  }
  exports.MutationObserverImpl = MutationObserverImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NonDocumentTypeChildNodeImpl.js
var require_NonDocumentTypeChildNodeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonDocumentTypeChildNodeImpl = undefined;
  var util_1 = require_util2();

  class NonDocumentTypeChildNodeImpl {
    get previousElementSibling() {
      let node = util_1.Cast.asNode(this)._previousSibling;
      while (node) {
        if (util_1.Guard.isElementNode(node))
          return node;
        else
          node = node._previousSibling;
      }
      return null;
    }
    get nextElementSibling() {
      let node = util_1.Cast.asNode(this)._nextSibling;
      while (node) {
        if (util_1.Guard.isElementNode(node))
          return node;
        else
          node = node._nextSibling;
      }
      return null;
    }
  }
  exports.NonDocumentTypeChildNodeImpl = NonDocumentTypeChildNodeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NonElementParentNodeImpl.js
var require_NonElementParentNodeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonElementParentNodeImpl = undefined;
  var util_1 = require_util2();
  var algorithm_1 = require_algorithm();

  class NonElementParentNodeImpl {
    getElementById(id) {
      let ele = (0, algorithm_1.tree_getFirstDescendantNode)(util_1.Cast.asNode(this), false, false, (e) => util_1.Guard.isElementNode(e));
      while (ele !== null) {
        if (ele._uniqueIdentifier === id) {
          return ele;
        }
        ele = (0, algorithm_1.tree_getNextDescendantNode)(util_1.Cast.asNode(this), ele, false, false, (e) => util_1.Guard.isElementNode(e));
      }
      return null;
    }
  }
  exports.NonElementParentNodeImpl = NonElementParentNodeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/ParentNodeImpl.js
var require_ParentNodeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParentNodeImpl = undefined;
  var util_1 = require_util2();
  var algorithm_1 = require_algorithm();

  class ParentNodeImpl {
    get children() {
      return (0, algorithm_1.create_htmlCollection)(util_1.Cast.asNode(this));
    }
    get firstElementChild() {
      let node = util_1.Cast.asNode(this)._firstChild;
      while (node) {
        if (util_1.Guard.isElementNode(node))
          return node;
        else
          node = node._nextSibling;
      }
      return null;
    }
    get lastElementChild() {
      let node = util_1.Cast.asNode(this)._lastChild;
      while (node) {
        if (util_1.Guard.isElementNode(node))
          return node;
        else
          node = node._previousSibling;
      }
      return null;
    }
    get childElementCount() {
      let count = 0;
      for (const childNode of util_1.Cast.asNode(this)._children) {
        if (util_1.Guard.isElementNode(childNode))
          count++;
      }
      return count;
    }
    prepend(...nodes) {
      const node = util_1.Cast.asNode(this);
      const childNode = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, node._nodeDocument);
      (0, algorithm_1.mutation_preInsert)(childNode, node, node._firstChild);
    }
    append(...nodes) {
      const node = util_1.Cast.asNode(this);
      const childNode = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, node._nodeDocument);
      (0, algorithm_1.mutation_append)(childNode, node);
    }
    querySelector(selectors) {
      const node = util_1.Cast.asNode(this);
      const result = (0, algorithm_1.selectors_scopeMatchASelectorsString)(selectors, node);
      return result.length === 0 ? null : result[0];
    }
    querySelectorAll(selectors) {
      const node = util_1.Cast.asNode(this);
      const result = (0, algorithm_1.selectors_scopeMatchASelectorsString)(selectors, node);
      return (0, algorithm_1.create_nodeListStatic)(node, result);
    }
  }
  exports.ParentNodeImpl = ParentNodeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/SlotableImpl.js
var require_SlotableImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SlotableImpl = undefined;
  var algorithm_1 = require_algorithm();

  class SlotableImpl {
    __name;
    __assignedSlot;
    get _name() {
      return this.__name || "";
    }
    set _name(val) {
      this.__name = val;
    }
    get _assignedSlot() {
      return this.__assignedSlot || null;
    }
    set _assignedSlot(val) {
      this.__assignedSlot = val;
    }
    get assignedSlot() {
      return (0, algorithm_1.shadowTree_findASlot)(this, true);
    }
  }
  exports.SlotableImpl = SlotableImpl;
});

// node_modules/@oozcitak/dom/lib/dom/StaticRangeImpl.js
var require_StaticRangeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StaticRangeImpl = undefined;
  var AbstractRangeImpl_1 = require_AbstractRangeImpl();
  var DOMException_1 = require_DOMException();
  var util_1 = require_util2();

  class StaticRangeImpl extends AbstractRangeImpl_1.AbstractRangeImpl {
    _start;
    _end;
    constructor(init) {
      super();
      if (util_1.Guard.isDocumentTypeNode(init.startContainer) || util_1.Guard.isAttrNode(init.startContainer) || util_1.Guard.isDocumentTypeNode(init.endContainer) || util_1.Guard.isAttrNode(init.endContainer)) {
        throw new DOMException_1.InvalidNodeTypeError;
      }
      this._start = [init.startContainer, init.startOffset];
      this._end = [init.endContainer, init.endOffset];
    }
  }
  exports.StaticRangeImpl = StaticRangeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/index.js
var require_dom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLDocument = exports.Window = exports.TreeWalker = exports.Traverser = exports.Text = exports.StaticRange = exports.ShadowRoot = exports.Range = exports.ProcessingInstruction = exports.NodeListStatic = exports.NodeList = exports.NodeIterator = exports.Node = exports.NodeFilter = exports.NamedNodeMap = exports.MutationRecord = exports.MutationObserver = exports.HTMLCollection = exports.EventTarget = exports.Event = exports.Element = exports.DOMTokenList = exports.DOMImplementation = exports.dom = exports.DocumentType = exports.Document = exports.DocumentFragment = exports.CustomEvent = exports.Comment = exports.CharacterData = exports.CDATASection = exports.Attr = exports.AbstractRange = exports.AbortSignal = exports.AbortController = undefined;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var AbortControllerImpl_1 = require_AbortControllerImpl();
  Object.defineProperty(exports, "AbortController", { enumerable: true, get: function() {
    return AbortControllerImpl_1.AbortControllerImpl;
  } });
  var AbortSignalImpl_1 = require_AbortSignalImpl();
  Object.defineProperty(exports, "AbortSignal", { enumerable: true, get: function() {
    return AbortSignalImpl_1.AbortSignalImpl;
  } });
  var AbstractRangeImpl_1 = require_AbstractRangeImpl();
  Object.defineProperty(exports, "AbstractRange", { enumerable: true, get: function() {
    return AbstractRangeImpl_1.AbstractRangeImpl;
  } });
  var AttrImpl_1 = require_AttrImpl();
  Object.defineProperty(exports, "Attr", { enumerable: true, get: function() {
    return AttrImpl_1.AttrImpl;
  } });
  var CDATASectionImpl_1 = require_CDATASectionImpl();
  Object.defineProperty(exports, "CDATASection", { enumerable: true, get: function() {
    return CDATASectionImpl_1.CDATASectionImpl;
  } });
  var CharacterDataImpl_1 = require_CharacterDataImpl();
  Object.defineProperty(exports, "CharacterData", { enumerable: true, get: function() {
    return CharacterDataImpl_1.CharacterDataImpl;
  } });
  var ChildNodeImpl_1 = require_ChildNodeImpl();
  var CommentImpl_1 = require_CommentImpl();
  Object.defineProperty(exports, "Comment", { enumerable: true, get: function() {
    return CommentImpl_1.CommentImpl;
  } });
  var CustomEventImpl_1 = require_CustomEventImpl();
  Object.defineProperty(exports, "CustomEvent", { enumerable: true, get: function() {
    return CustomEventImpl_1.CustomEventImpl;
  } });
  var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
  Object.defineProperty(exports, "DocumentFragment", { enumerable: true, get: function() {
    return DocumentFragmentImpl_1.DocumentFragmentImpl;
  } });
  var DocumentImpl_1 = require_DocumentImpl();
  Object.defineProperty(exports, "Document", { enumerable: true, get: function() {
    return DocumentImpl_1.DocumentImpl;
  } });
  var DocumentOrShadowRootImpl_1 = require_DocumentOrShadowRootImpl();
  var DocumentTypeImpl_1 = require_DocumentTypeImpl();
  Object.defineProperty(exports, "DocumentType", { enumerable: true, get: function() {
    return DocumentTypeImpl_1.DocumentTypeImpl;
  } });
  var DOMImpl_1 = require_DOMImpl();
  Object.defineProperty(exports, "dom", { enumerable: true, get: function() {
    return DOMImpl_1.dom;
  } });
  var DOMImplementationImpl_1 = require_DOMImplementationImpl();
  Object.defineProperty(exports, "DOMImplementation", { enumerable: true, get: function() {
    return DOMImplementationImpl_1.DOMImplementationImpl;
  } });
  var DOMTokenListImpl_1 = require_DOMTokenListImpl();
  Object.defineProperty(exports, "DOMTokenList", { enumerable: true, get: function() {
    return DOMTokenListImpl_1.DOMTokenListImpl;
  } });
  var ElementImpl_1 = require_ElementImpl();
  Object.defineProperty(exports, "Element", { enumerable: true, get: function() {
    return ElementImpl_1.ElementImpl;
  } });
  var EventImpl_1 = require_EventImpl();
  Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
    return EventImpl_1.EventImpl;
  } });
  var EventTargetImpl_1 = require_EventTargetImpl();
  Object.defineProperty(exports, "EventTarget", { enumerable: true, get: function() {
    return EventTargetImpl_1.EventTargetImpl;
  } });
  var HTMLCollectionImpl_1 = require_HTMLCollectionImpl();
  Object.defineProperty(exports, "HTMLCollection", { enumerable: true, get: function() {
    return HTMLCollectionImpl_1.HTMLCollectionImpl;
  } });
  var MutationObserverImpl_1 = require_MutationObserverImpl();
  Object.defineProperty(exports, "MutationObserver", { enumerable: true, get: function() {
    return MutationObserverImpl_1.MutationObserverImpl;
  } });
  var MutationRecordImpl_1 = require_MutationRecordImpl();
  Object.defineProperty(exports, "MutationRecord", { enumerable: true, get: function() {
    return MutationRecordImpl_1.MutationRecordImpl;
  } });
  var NamedNodeMapImpl_1 = require_NamedNodeMapImpl();
  Object.defineProperty(exports, "NamedNodeMap", { enumerable: true, get: function() {
    return NamedNodeMapImpl_1.NamedNodeMapImpl;
  } });
  var NodeFilterImpl_1 = require_NodeFilterImpl();
  Object.defineProperty(exports, "NodeFilter", { enumerable: true, get: function() {
    return NodeFilterImpl_1.NodeFilterImpl;
  } });
  var NodeImpl_1 = require_NodeImpl();
  Object.defineProperty(exports, "Node", { enumerable: true, get: function() {
    return NodeImpl_1.NodeImpl;
  } });
  var NodeIteratorImpl_1 = require_NodeIteratorImpl();
  Object.defineProperty(exports, "NodeIterator", { enumerable: true, get: function() {
    return NodeIteratorImpl_1.NodeIteratorImpl;
  } });
  var NodeListImpl_1 = require_NodeListImpl();
  Object.defineProperty(exports, "NodeList", { enumerable: true, get: function() {
    return NodeListImpl_1.NodeListImpl;
  } });
  var NodeListStaticImpl_1 = require_NodeListStaticImpl();
  Object.defineProperty(exports, "NodeListStatic", { enumerable: true, get: function() {
    return NodeListStaticImpl_1.NodeListStaticImpl;
  } });
  var NonDocumentTypeChildNodeImpl_1 = require_NonDocumentTypeChildNodeImpl();
  var NonElementParentNodeImpl_1 = require_NonElementParentNodeImpl();
  var ParentNodeImpl_1 = require_ParentNodeImpl();
  var ProcessingInstructionImpl_1 = require_ProcessingInstructionImpl();
  Object.defineProperty(exports, "ProcessingInstruction", { enumerable: true, get: function() {
    return ProcessingInstructionImpl_1.ProcessingInstructionImpl;
  } });
  var RangeImpl_1 = require_RangeImpl();
  Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
    return RangeImpl_1.RangeImpl;
  } });
  var ShadowRootImpl_1 = require_ShadowRootImpl();
  Object.defineProperty(exports, "ShadowRoot", { enumerable: true, get: function() {
    return ShadowRootImpl_1.ShadowRootImpl;
  } });
  var SlotableImpl_1 = require_SlotableImpl();
  var StaticRangeImpl_1 = require_StaticRangeImpl();
  Object.defineProperty(exports, "StaticRange", { enumerable: true, get: function() {
    return StaticRangeImpl_1.StaticRangeImpl;
  } });
  var TextImpl_1 = require_TextImpl();
  Object.defineProperty(exports, "Text", { enumerable: true, get: function() {
    return TextImpl_1.TextImpl;
  } });
  var TraverserImpl_1 = require_TraverserImpl();
  Object.defineProperty(exports, "Traverser", { enumerable: true, get: function() {
    return TraverserImpl_1.TraverserImpl;
  } });
  var TreeWalkerImpl_1 = require_TreeWalkerImpl();
  Object.defineProperty(exports, "TreeWalker", { enumerable: true, get: function() {
    return TreeWalkerImpl_1.TreeWalkerImpl;
  } });
  var WindowImpl_1 = require_WindowImpl();
  Object.defineProperty(exports, "Window", { enumerable: true, get: function() {
    return WindowImpl_1.WindowImpl;
  } });
  var XMLDocumentImpl_1 = require_XMLDocumentImpl();
  Object.defineProperty(exports, "XMLDocument", { enumerable: true, get: function() {
    return XMLDocumentImpl_1.XMLDocumentImpl;
  } });
  (0, util_1.applyMixin)(ElementImpl_1.ElementImpl, ChildNodeImpl_1.ChildNodeImpl);
  (0, util_1.applyMixin)(CharacterDataImpl_1.CharacterDataImpl, ChildNodeImpl_1.ChildNodeImpl);
  (0, util_1.applyMixin)(DocumentTypeImpl_1.DocumentTypeImpl, ChildNodeImpl_1.ChildNodeImpl);
  (0, util_1.applyMixin)(DocumentImpl_1.DocumentImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
  (0, util_1.applyMixin)(ShadowRootImpl_1.ShadowRootImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
  (0, util_1.applyMixin)(ElementImpl_1.ElementImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
  (0, util_1.applyMixin)(CharacterDataImpl_1.CharacterDataImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
  (0, util_1.applyMixin)(DocumentImpl_1.DocumentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
  (0, util_1.applyMixin)(DocumentFragmentImpl_1.DocumentFragmentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
  (0, util_1.applyMixin)(DocumentImpl_1.DocumentImpl, ParentNodeImpl_1.ParentNodeImpl);
  (0, util_1.applyMixin)(DocumentFragmentImpl_1.DocumentFragmentImpl, ParentNodeImpl_1.ParentNodeImpl);
  (0, util_1.applyMixin)(ElementImpl_1.ElementImpl, ParentNodeImpl_1.ParentNodeImpl);
  (0, util_1.applyMixin)(TextImpl_1.TextImpl, SlotableImpl_1.SlotableImpl);
  (0, util_1.applyMixin)(ElementImpl_1.ElementImpl, SlotableImpl_1.SlotableImpl);
});

// node_modules/@oozcitak/dom/lib/parser/interfaces.js
var require_interfaces4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenType = undefined;
  var TokenType;
  (function(TokenType2) {
    TokenType2[TokenType2["EOF"] = 0] = "EOF";
    TokenType2[TokenType2["Declaration"] = 1] = "Declaration";
    TokenType2[TokenType2["DocType"] = 2] = "DocType";
    TokenType2[TokenType2["Element"] = 3] = "Element";
    TokenType2[TokenType2["Text"] = 4] = "Text";
    TokenType2[TokenType2["CDATA"] = 5] = "CDATA";
    TokenType2[TokenType2["PI"] = 6] = "PI";
    TokenType2[TokenType2["Comment"] = 7] = "Comment";
    TokenType2[TokenType2["ClosingTag"] = 8] = "ClosingTag";
  })(TokenType || (exports.TokenType = TokenType = {}));
});

// node_modules/@oozcitak/dom/lib/parser/XMLStringLexer.js
var require_XMLStringLexer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLStringLexer = undefined;
  var interfaces_1 = require_interfaces4();

  class XMLStringLexer {
    _str;
    _index;
    _length;
    _options = {
      skipWhitespaceOnlyText: false
    };
    err = { line: -1, col: -1, index: -1, str: "" };
    constructor(str, options) {
      this._str = str;
      this._index = 0;
      this._length = str.length;
      if (options) {
        this._options.skipWhitespaceOnlyText = options.skipWhitespaceOnlyText || false;
      }
    }
    nextToken() {
      if (this.eof()) {
        return { type: interfaces_1.TokenType.EOF };
      }
      let token = this.skipIfStartsWith("<") ? this.openBracket() : this.text();
      if (this._options.skipWhitespaceOnlyText) {
        if (token.type === interfaces_1.TokenType.Text && XMLStringLexer.isWhiteSpaceToken(token)) {
          token = this.nextToken();
        }
      }
      return token;
    }
    openBracket() {
      if (this.skipIfStartsWith("?")) {
        if (this.skipIfStartsWith("xml")) {
          if (XMLStringLexer.isSpace(this._str[this._index])) {
            return this.declaration();
          } else {
            this.seek(-3);
            return this.pi();
          }
        } else {
          return this.pi();
        }
      } else if (this.skipIfStartsWith("!")) {
        if (this.skipIfStartsWith("--")) {
          return this.comment();
        } else if (this.skipIfStartsWith("[CDATA[")) {
          return this.cdata();
        } else if (this.skipIfStartsWith("DOCTYPE")) {
          return this.doctype();
        } else {
          this.throwError("Invalid '!' in opening tag.");
        }
      } else if (this.skipIfStartsWith("/")) {
        return this.closeTag();
      } else {
        return this.openTag();
      }
    }
    declaration() {
      let version = "";
      let encoding = "";
      let standalone = "";
      while (!this.eof()) {
        this.skipSpace();
        if (this.skipIfStartsWith("?>")) {
          return { type: interfaces_1.TokenType.Declaration, version, encoding, standalone };
        } else {
          const [attName, attValue] = this.attribute();
          if (attName === "version")
            version = attValue;
          else if (attName === "encoding")
            encoding = attValue;
          else if (attName === "standalone")
            standalone = attValue;
          else
            this.throwError("Invalid attribute name: " + attName);
        }
      }
      this.throwError("Missing declaration end symbol `?>`");
    }
    doctype() {
      let pubId = "";
      let sysId = "";
      this.skipSpace();
      const name = this.takeUntil2("[", ">", true);
      this.skipSpace();
      if (this.skipIfStartsWith("PUBLIC")) {
        pubId = this.quotedString();
        sysId = this.quotedString();
      } else if (this.skipIfStartsWith("SYSTEM")) {
        sysId = this.quotedString();
      }
      this.skipSpace();
      if (this.skipIfStartsWith("[")) {
        this.skipUntil("]");
        if (!this.skipIfStartsWith("]")) {
          this.throwError("Missing end bracket of DTD internal subset");
        }
      }
      this.skipSpace();
      if (!this.skipIfStartsWith(">")) {
        this.throwError("Missing doctype end symbol `>`");
      }
      return { type: interfaces_1.TokenType.DocType, name, pubId, sysId };
    }
    pi() {
      const target = this.takeUntilStartsWith("?>", true);
      if (this.eof()) {
        this.throwError("Missing processing instruction end symbol `?>`");
      }
      this.skipSpace();
      if (this.skipIfStartsWith("?>")) {
        return { type: interfaces_1.TokenType.PI, target, data: "" };
      }
      const data = this.takeUntilStartsWith("?>");
      if (this.eof()) {
        this.throwError("Missing processing instruction end symbol `?>`");
      }
      this.seek(2);
      return { type: interfaces_1.TokenType.PI, target, data };
    }
    text() {
      const data = this.takeUntil("<");
      return { type: interfaces_1.TokenType.Text, data };
    }
    comment() {
      const data = this.takeUntilStartsWith("-->");
      if (this.eof()) {
        this.throwError("Missing comment end symbol `-->`");
      }
      this.seek(3);
      return { type: interfaces_1.TokenType.Comment, data };
    }
    cdata() {
      const data = this.takeUntilStartsWith("]]>");
      if (this.eof()) {
        this.throwError("Missing CDATA end symbol `]>`");
      }
      this.seek(3);
      return { type: interfaces_1.TokenType.CDATA, data };
    }
    openTag() {
      this.skipSpace();
      const name = this.takeUntil2(">", "/", true);
      this.skipSpace();
      if (this.skipIfStartsWith(">")) {
        return { type: interfaces_1.TokenType.Element, name, attributes: [], selfClosing: false };
      } else if (this.skipIfStartsWith("/>")) {
        return { type: interfaces_1.TokenType.Element, name, attributes: [], selfClosing: true };
      }
      const attributes = [];
      while (!this.eof()) {
        this.skipSpace();
        if (this.skipIfStartsWith(">")) {
          return { type: interfaces_1.TokenType.Element, name, attributes, selfClosing: false };
        } else if (this.skipIfStartsWith("/>")) {
          return { type: interfaces_1.TokenType.Element, name, attributes, selfClosing: true };
        }
        const attr = this.attribute();
        attributes.push(attr);
      }
      this.throwError("Missing opening element tag end symbol `>`");
    }
    closeTag() {
      this.skipSpace();
      const name = this.takeUntil(">", true);
      this.skipSpace();
      if (!this.skipIfStartsWith(">")) {
        this.throwError("Missing closing element tag end symbol `>`");
      }
      return { type: interfaces_1.TokenType.ClosingTag, name };
    }
    attribute() {
      this.skipSpace();
      const name = this.takeUntil("=", true);
      this.skipSpace();
      if (!this.skipIfStartsWith("=")) {
        this.throwError("Missing equals sign before attribute value");
      }
      const value = this.quotedString();
      return [name, value];
    }
    quotedString() {
      this.skipSpace();
      const startQuote = this.take(1);
      if (!XMLStringLexer.isQuote(startQuote)) {
        this.throwError("Missing start quote character before quoted value");
      }
      const value = this.takeUntil(startQuote);
      if (!this.skipIfStartsWith(startQuote)) {
        this.throwError("Missing end quote character after quoted value");
      }
      return value;
    }
    eof() {
      return this._index >= this._length;
    }
    skipIfStartsWith(str) {
      const strLength = str.length;
      if (strLength === 1) {
        if (this._str[this._index] === str) {
          this._index++;
          return true;
        } else {
          return false;
        }
      }
      for (let i = 0;i < strLength; i++) {
        if (this._str[this._index + i] !== str[i])
          return false;
      }
      this._index += strLength;
      return true;
    }
    seek(count) {
      this._index += count;
      if (this._index < 0)
        this._index = 0;
      if (this._index > this._length)
        this._index = this._length;
    }
    skipSpace() {
      while (!this.eof() && XMLStringLexer.isSpace(this._str[this._index])) {
        this._index++;
      }
    }
    take(count) {
      if (count === 1) {
        return this._str[this._index++];
      }
      const startIndex = this._index;
      this.seek(count);
      return this._str.slice(startIndex, this._index);
    }
    takeUntil(char, space = false) {
      const startIndex = this._index;
      while (this._index < this._length) {
        const c = this._str[this._index];
        if (c !== char && (!space || !XMLStringLexer.isSpace(c))) {
          this._index++;
        } else {
          break;
        }
      }
      return this._str.slice(startIndex, this._index);
    }
    takeUntil2(char1, char2, space = false) {
      const startIndex = this._index;
      while (this._index < this._length) {
        const c = this._str[this._index];
        if (c !== char1 && c !== char2 && (!space || !XMLStringLexer.isSpace(c))) {
          this._index++;
        } else {
          break;
        }
      }
      return this._str.slice(startIndex, this._index);
    }
    takeUntilStartsWith(str, space = false) {
      const startIndex = this._index;
      const strLength = str.length;
      while (this._index < this._length) {
        let match = true;
        for (let i = 0;i < strLength; i++) {
          const c = this._str[this._index + i];
          const char = str[i];
          if (space && XMLStringLexer.isSpace(c)) {
            return this._str.slice(startIndex, this._index);
          } else if (c !== char) {
            this._index++;
            match = false;
            break;
          }
        }
        if (match)
          return this._str.slice(startIndex, this._index);
      }
      this._index = this._length;
      return this._str.slice(startIndex);
    }
    skipUntil(char) {
      while (this._index < this._length) {
        const c = this._str[this._index];
        if (c !== char) {
          this._index++;
        } else {
          break;
        }
      }
    }
    static isWhiteSpaceToken(token) {
      const str = token.data;
      for (let i = 0;i < str.length; i++) {
        const c = str[i];
        if (c !== " " && c !== `
` && c !== "\r" && c !== "\t" && c !== "\f")
          return false;
      }
      return true;
    }
    static isSpace(char) {
      return char === " " || char === `
` || char === "\r" || char === "\t";
    }
    static isQuote(char) {
      return char === '"' || char === "'";
    }
    throwError(msg) {
      const regexp = /\r\n|\r|\n/g;
      let match = null;
      let line = 0;
      let firstNewLineIndex = 0;
      let lastNewlineIndex = this._str.length;
      while ((match = regexp.exec(this._str)) !== null) {
        if (match === null)
          break;
        line++;
        if (match.index < this._index)
          firstNewLineIndex = regexp.lastIndex;
        if (match.index > this._index) {
          lastNewlineIndex = match.index;
          break;
        }
      }
      this.err = {
        line,
        col: this._index - firstNewLineIndex,
        index: this._index,
        str: this._str.substring(firstNewLineIndex, lastNewlineIndex)
      };
      throw new Error(msg + `
Index: ` + this.err.index + `
Ln: ` + this.err.line + ", Col: " + this.err.col + `
Input: ` + this.err.str);
    }
    [Symbol.iterator]() {
      this._index = 0;
      return {
        next: function() {
          const token = this.nextToken();
          if (token.type === interfaces_1.TokenType.EOF) {
            return { done: true, value: null };
          } else {
            return { done: false, value: token };
          }
        }.bind(this)
      };
    }
  }
  exports.XMLStringLexer = XMLStringLexer;
});

// node_modules/@oozcitak/dom/lib/parser/XMLParserImpl.js
var require_XMLParserImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLParserImpl = undefined;
  var XMLStringLexer_1 = require_XMLStringLexer();
  var interfaces_1 = require_interfaces4();
  var infra_1 = require_lib7();
  var algorithm_1 = require_algorithm();
  var LocalNameSet_1 = require_LocalNameSet();

  class XMLParserImpl {
    parse(source) {
      const lexer = new XMLStringLexer_1.XMLStringLexer(source, { skipWhitespaceOnlyText: true });
      const doc = (0, algorithm_1.create_document)();
      let context = doc;
      let token = lexer.nextToken();
      while (token.type !== interfaces_1.TokenType.EOF) {
        switch (token.type) {
          case interfaces_1.TokenType.Declaration:
            const declaration = token;
            if (declaration.version !== "1.0") {
              throw new Error("Invalid xml version: " + declaration.version);
            }
            break;
          case interfaces_1.TokenType.DocType:
            const doctype = token;
            if (!(0, algorithm_1.xml_isPubidChar)(doctype.pubId)) {
              throw new Error("DocType public identifier does not match PubidChar construct.");
            }
            if (!(0, algorithm_1.xml_isLegalChar)(doctype.sysId) || doctype.sysId.indexOf('"') !== -1 && doctype.sysId.indexOf("'") !== -1) {
              throw new Error("DocType system identifier contains invalid characters.");
            }
            context.appendChild(doc.implementation.createDocumentType(doctype.name, doctype.pubId, doctype.sysId));
            break;
          case interfaces_1.TokenType.CDATA:
            const cdata = token;
            if (!(0, algorithm_1.xml_isLegalChar)(cdata.data) || cdata.data.indexOf("]]>") !== -1) {
              throw new Error("CDATA contains invalid characters.");
            }
            context.appendChild(doc.createCDATASection(cdata.data));
            break;
          case interfaces_1.TokenType.Comment:
            const comment = token;
            if (!(0, algorithm_1.xml_isLegalChar)(comment.data) || comment.data.indexOf("--") !== -1 || comment.data.endsWith("-")) {
              throw new Error("Comment data contains invalid characters.");
            }
            context.appendChild(doc.createComment(comment.data));
            break;
          case interfaces_1.TokenType.PI:
            const pi = token;
            if (pi.target.indexOf(":") !== -1 || /^xml$/i.test(pi.target)) {
              throw new Error("Processing instruction target contains invalid characters.");
            }
            if (!(0, algorithm_1.xml_isLegalChar)(pi.data) || pi.data.indexOf("?>") !== -1) {
              throw new Error("Processing instruction data contains invalid characters.");
            }
            context.appendChild(doc.createProcessingInstruction(pi.target, pi.data));
            break;
          case interfaces_1.TokenType.Text:
            const text = token;
            if (!(0, algorithm_1.xml_isLegalChar)(text.data)) {
              throw new Error("Text data contains invalid characters.");
            }
            context.appendChild(doc.createTextNode(this._decodeText(text.data)));
            break;
          case interfaces_1.TokenType.Element:
            const element = token;
            const [prefix, localName] = (0, algorithm_1.namespace_extractQName)(element.name);
            if (localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(localName)) {
              throw new Error("Node local name contains invalid characters.");
            }
            if (prefix === "xmlns") {
              throw new Error("An element cannot have the 'xmlns' prefix.");
            }
            let namespace = context.lookupNamespaceURI(prefix);
            const nsDeclarations = {};
            for (const [attName, attValue] of element.attributes) {
              if (attName === "xmlns") {
                namespace = attValue;
              } else {
                const [attPrefix, attLocalName] = (0, algorithm_1.namespace_extractQName)(attName);
                if (attPrefix === "xmlns") {
                  if (attLocalName === prefix) {
                    namespace = attValue;
                  }
                  nsDeclarations[attLocalName] = attValue;
                }
              }
            }
            const elementNode = namespace !== null ? doc.createElementNS(namespace, element.name) : doc.createElement(element.name);
            context.appendChild(elementNode);
            const localNameSet = new LocalNameSet_1.LocalNameSet;
            for (const [attName, attValue] of element.attributes) {
              const [attPrefix, attLocalName] = (0, algorithm_1.namespace_extractQName)(attName);
              let attNamespace = null;
              if (attPrefix === "xmlns" || attPrefix === null && attLocalName === "xmlns") {
                attNamespace = infra_1.namespace.XMLNS;
              } else {
                attNamespace = elementNode.lookupNamespaceURI(attPrefix);
                if (attNamespace !== null && elementNode.isDefaultNamespace(attNamespace)) {
                  attNamespace = null;
                } else if (attNamespace === null && attPrefix !== null) {
                  attNamespace = nsDeclarations[attPrefix] || null;
                }
              }
              if (localNameSet.has(attNamespace, attLocalName)) {
                throw new Error("Element contains duplicate attributes.");
              }
              localNameSet.set(attNamespace, attLocalName);
              if (attNamespace === infra_1.namespace.XMLNS) {
                if (attValue === infra_1.namespace.XMLNS) {
                  throw new Error("XMLNS namespace is reserved.");
                }
              }
              if (attLocalName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attLocalName)) {
                throw new Error("Attribute local name contains invalid characters.");
              }
              if (attPrefix === "xmlns" && attValue === "") {
                throw new Error("Empty XML namespace is not allowed.");
              }
              if (attNamespace !== null)
                elementNode.setAttributeNS(attNamespace, attName, this._decodeAttributeValue(attValue));
              else
                elementNode.setAttribute(attName, this._decodeAttributeValue(attValue));
            }
            if (!element.selfClosing) {
              context = elementNode;
            }
            break;
          case interfaces_1.TokenType.ClosingTag:
            const closingTag = token;
            if (closingTag.name !== context.nodeName) {
              throw new Error("Closing tag name does not match opening tag name.");
            }
            if (context._parent) {
              context = context._parent;
            }
            break;
        }
        token = lexer.nextToken();
      }
      return doc;
    }
    _decodeText(text) {
      return text == null ? text : text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
    }
    _decodeAttributeValue(text) {
      return text == null ? text : text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
    }
  }
  exports.XMLParserImpl = XMLParserImpl;
});

// node_modules/@oozcitak/dom/lib/parser/DOMParserImpl.js
var require_DOMParserImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DOMParserImpl = undefined;
  var algorithm_1 = require_algorithm();
  var XMLParserImpl_1 = require_XMLParserImpl();

  class DOMParserImpl {
    parseFromString(source, mimeType) {
      if (mimeType === "text/html")
        throw new Error("HTML parser not implemented.");
      try {
        const parser = new XMLParserImpl_1.XMLParserImpl;
        const doc = parser.parse(source);
        doc._contentType = mimeType;
        return doc;
      } catch (e) {
        const errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
        const doc = (0, algorithm_1.create_xmlDocument)();
        const root = doc.createElementNS(errorNS, "parsererror");
        const ele = doc.createElementNS(errorNS, "error");
        ele.setAttribute("message", e.message);
        root.appendChild(ele);
        doc.appendChild(root);
        return doc;
      }
    }
  }
  exports.DOMParserImpl = DOMParserImpl;
});

// node_modules/@oozcitak/dom/lib/parser/index.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DOMParser = undefined;
  var DOMParserImpl_1 = require_DOMParserImpl();
  Object.defineProperty(exports, "DOMParser", { enumerable: true, get: function() {
    return DOMParserImpl_1.DOMParserImpl;
  } });
});

// node_modules/@oozcitak/dom/lib/serializer/XMLSerializerImpl.js
var require_XMLSerializerImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLSerializerImpl = undefined;
  var interfaces_1 = require_interfaces2();
  var LocalNameSet_1 = require_LocalNameSet();
  var NamespacePrefixMap_1 = require_NamespacePrefixMap();
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib7();
  var algorithm_1 = require_algorithm();

  class XMLSerializerImpl {
    static _VoidElementNames = new Set([
      "area",
      "base",
      "basefont",
      "bgsound",
      "br",
      "col",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    serializeToString(root) {
      return this._xmlSerialization(root, false);
    }
    _xmlSerialization(node, requireWellFormed) {
      if (node._nodeDocument === undefined || node._nodeDocument._hasNamespaces) {
        const namespace = null;
        const prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap;
        prefixMap.set("xml", infra_1.namespace.XML);
        const prefixIndex = { value: 1 };
        try {
          return this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        } catch {
          throw new DOMException_1.InvalidStateError;
        }
      } else {
        try {
          return this._serializeNode(node, requireWellFormed);
        } catch {
          throw new DOMException_1.InvalidStateError;
        }
      }
    }
    _serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      switch (node.nodeType) {
        case interfaces_1.NodeType.Element:
          return this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.Document:
          return this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.Comment:
          return this._serializeComment(node, requireWellFormed);
        case interfaces_1.NodeType.Text:
          return this._serializeText(node, requireWellFormed);
        case interfaces_1.NodeType.DocumentFragment:
          return this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.DocumentType:
          return this._serializeDocumentType(node, requireWellFormed);
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._serializeProcessingInstruction(node, requireWellFormed);
        case interfaces_1.NodeType.CData:
          return this._serializeCData(node, requireWellFormed);
        default:
          throw new Error(`Unknown node type: ${node.nodeType}`);
      }
    }
    _serializeNode(node, requireWellFormed) {
      switch (node.nodeType) {
        case interfaces_1.NodeType.Element:
          return this._serializeElement(node, requireWellFormed);
        case interfaces_1.NodeType.Document:
          return this._serializeDocument(node, requireWellFormed);
        case interfaces_1.NodeType.Comment:
          return this._serializeComment(node, requireWellFormed);
        case interfaces_1.NodeType.Text:
          return this._serializeText(node, requireWellFormed);
        case interfaces_1.NodeType.DocumentFragment:
          return this._serializeDocumentFragment(node, requireWellFormed);
        case interfaces_1.NodeType.DocumentType:
          return this._serializeDocumentType(node, requireWellFormed);
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._serializeProcessingInstruction(node, requireWellFormed);
        case interfaces_1.NodeType.CData:
          return this._serializeCData(node, requireWellFormed);
        default:
          throw new Error(`Unknown node type: ${node.nodeType}`);
      }
    }
    _serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let markup = "<";
      let qualifiedName = "";
      let skipEndTag = false;
      let ignoreNamespaceDefinitionAttribute = false;
      let map = prefixMap.copy();
      let localPrefixesMap = {};
      let localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
      let inheritedNS = namespace;
      let ns = node.namespaceURI;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node.localName;
        } else {
          qualifiedName = node.localName;
        }
        markup += qualifiedName;
      } else {
        let prefix = node.prefix;
        let candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (requireWellFormed) {
            throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          markup += qualifiedName;
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map, prefixIndex);
          }
          map.set(prefix, ns);
          qualifiedName += prefix + ":" + node.localName;
          markup += qualifiedName;
          markup += " xmlns:" + prefix + '="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node.localName;
          inheritedNS = ns;
          markup += qualifiedName;
          markup += " xmlns" + '="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
        } else {
          qualifiedName += node.localName;
          inheritedNS = ns;
          markup += qualifiedName;
        }
      }
      markup += this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed);
      const isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && node.childNodes.length === 0 && XMLSerializerImpl._VoidElementNames.has(node.localName)) {
        markup += " /";
        skipEndTag = true;
      } else if (!isHTML && node.childNodes.length === 0) {
        markup += "/";
        skipEndTag = true;
      }
      markup += ">";
      if (skipEndTag)
        return markup;
      if (isHTML && node.localName === "template") {} else {
        for (const childNode of node._children || node.childNodes) {
          markup += this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
        }
      }
      markup += "</" + qualifiedName + ">";
      return markup;
    }
    _serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      if (requireWellFormed && node.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      let serializedDocument = "";
      for (const childNode of node._children || node.childNodes) {
        serializedDocument += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
      }
      return serializedDocument;
    }
    _serializeComment(node, requireWellFormed) {
      if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
        throw new Error("Comment data contains invalid characters (well-formed required).");
      }
      return "<!--" + node.data + "-->";
    }
    _serializeText(node, requireWellFormed) {
      if (requireWellFormed && !(0, algorithm_1.xml_isLegalChar)(node.data)) {
        throw new Error("Text data contains invalid characters (well-formed required).");
      }
      let result = "";
      for (let i = 0;i < node.data.length; i++) {
        const c = node.data[i];
        if (c === "&")
          result += "&amp;";
        else if (c === "<")
          result += "&lt;";
        else if (c === ">")
          result += "&gt;";
        else
          result += c;
      }
      return result;
    }
    _serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      let markup = "";
      for (const childNode of node._children || node.childNodes) {
        markup += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
      }
      return markup;
    }
    _serializeDocumentType(node, requireWellFormed) {
      if (requireWellFormed && !(0, algorithm_1.xml_isPubidChar)(node.publicId)) {
        throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
      }
      if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
        throw new Error("DocType system identifier contains invalid characters (well-formed required).");
      }
      return node.publicId && node.systemId ? "<!DOCTYPE " + node.name + ' PUBLIC "' + node.publicId + '" "' + node.systemId + '">' : node.publicId ? "<!DOCTYPE " + node.name + ' PUBLIC "' + node.publicId + '">' : node.systemId ? "<!DOCTYPE " + node.name + ' SYSTEM "' + node.systemId + '">' : "<!DOCTYPE " + node.name + ">";
    }
    _serializeProcessingInstruction(node, requireWellFormed) {
      if (requireWellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
        throw new Error("Processing instruction target contains invalid characters (well-formed required).");
      }
      if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("?>") !== -1)) {
        throw new Error("Processing instruction data contains invalid characters (well-formed required).");
      }
      return "<?" + (node.data === "" ? node.target : node.target + " " + node.data) + "?>";
    }
    _serializeCData(node, requireWellFormed) {
      if (requireWellFormed && node.data.indexOf("]]>") !== -1) {
        throw new Error("CDATA contains invalid characters (well-formed required).");
      }
      return "<![CDATA[" + node.data + "]]>";
    }
    _serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
      let result = "";
      const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet : undefined;
      for (const attr of node.attributes) {
        if (!ignoreNamespaceDefinitionAttribute && !requireWellFormed && attr.namespaceURI === null) {
          result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
          continue;
        }
        if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet.set(attr.namespaceURI, attr.localName);
        let attributeNamespace = attr.namespaceURI;
        let candidatePrefix = null;
        if (attributeNamespace !== null) {
          candidatePrefix = map.get(attr.prefix, attributeNamespace);
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
              continue;
            if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
              throw new Error("XMLNS namespace is reserved (well-formed required).");
            }
            if (requireWellFormed && attr.value === "") {
              throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
            }
            if (attr.prefix === "xmlns")
              candidatePrefix = "xmlns";
          } else if (candidatePrefix === null) {
            if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
              candidatePrefix = attr.prefix;
            } else {
              candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
            }
            result += " xmlns:" + candidatePrefix + '="' + this._serializeAttributeValue(attributeNamespace, requireWellFormed) + '"';
          }
        }
        result += " ";
        if (candidatePrefix !== null) {
          result += candidatePrefix + ":";
        }
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result += attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
      }
      return result;
    }
    _recordNamespaceInformation(node, map, localPrefixesMap) {
      let defaultNamespaceAttrValue = null;
      for (const attr of node.attributes) {
        let attributeNamespace = attr.namespaceURI;
        let attributePrefix = attr.prefix;
        if (attributeNamespace === infra_1.namespace.XMLNS) {
          if (attributePrefix === null) {
            defaultNamespaceAttrValue = attr.value;
            continue;
          } else {
            let prefixDefinition = attr.localName;
            let namespaceDefinition = attr.value;
            if (namespaceDefinition === infra_1.namespace.XML) {
              continue;
            }
            if (namespaceDefinition === "") {
              namespaceDefinition = null;
            }
            if (map.has(prefixDefinition, namespaceDefinition)) {
              continue;
            }
            map.set(prefixDefinition, namespaceDefinition);
            localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
          }
        }
      }
      return defaultNamespaceAttrValue;
    }
    _generatePrefix(newNamespace, prefixMap, prefixIndex) {
      let generatedPrefix = "ns" + prefixIndex.value;
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    }
    _serializeAttributeValue(value, requireWellFormed) {
      if (requireWellFormed && value !== null && !(0, algorithm_1.xml_isLegalChar)(value)) {
        throw new Error("Invalid characters in attribute value.");
      }
      if (value === null)
        return "";
      let result = "";
      for (let i = 0;i < value.length; i++) {
        const c = value[i];
        if (c === '"')
          result += "&quot;";
        else if (c === "&")
          result += "&amp;";
        else if (c === "<")
          result += "&lt;";
        else if (c === ">")
          result += "&gt;";
        else
          result += c;
      }
      return result;
    }
    _serializeElement(node, requireWellFormed) {
      if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let skipEndTag = false;
      const qualifiedName = node.localName;
      let markup = "<" + qualifiedName;
      markup += this._serializeAttributes(node, requireWellFormed);
      if (node._children.size === 0) {
        markup += "/";
        skipEndTag = true;
      }
      markup += ">";
      if (skipEndTag)
        return markup;
      for (const childNode of node._children) {
        markup += this._serializeNode(childNode, requireWellFormed);
      }
      markup += "</" + qualifiedName + ">";
      return markup;
    }
    _serializeDocument(node, requireWellFormed) {
      if (requireWellFormed && node.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      let serializedDocument = "";
      for (const childNode of node._children) {
        serializedDocument += this._serializeNode(childNode, requireWellFormed);
      }
      return serializedDocument;
    }
    _serializeDocumentFragment(node, requireWellFormed) {
      let markup = "";
      for (const childNode of node._children) {
        markup += this._serializeNode(childNode, requireWellFormed);
      }
      return markup;
    }
    _serializeAttributes(node, requireWellFormed) {
      let result = "";
      const localNameSet = requireWellFormed ? {} : undefined;
      for (const attr of node.attributes) {
        if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet[attr.localName] = true;
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName))) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
      }
      return result;
    }
  }
  exports.XMLSerializerImpl = XMLSerializerImpl;
});

// node_modules/@oozcitak/dom/lib/serializer/index.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLSerializer = undefined;
  var XMLSerializerImpl_1 = require_XMLSerializerImpl();
  Object.defineProperty(exports, "XMLSerializer", { enumerable: true, get: function() {
    return XMLSerializerImpl_1.XMLSerializerImpl;
  } });
});

// node_modules/@oozcitak/dom/lib/index.js
var require_lib8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLSerializer = exports.DOMParser = exports.DOMImplementation = undefined;
  var dom_1 = require_dom();
  dom_1.dom.setFeatures(true);
  var dom_2 = require_dom();
  Object.defineProperty(exports, "DOMImplementation", { enumerable: true, get: function() {
    return dom_2.DOMImplementation;
  } });
  var parser_1 = require_parser();
  Object.defineProperty(exports, "DOMParser", { enumerable: true, get: function() {
    return parser_1.DOMParser;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "XMLSerializer", { enumerable: true, get: function() {
    return serializer_1.XMLSerializer;
  } });
});

// node_modules/xmlbuilder2/lib/builder/dom.js
var require_dom2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDocument = createDocument;
  exports.sanitizeInput = sanitizeInput;
  var dom_1 = require_lib8();
  var dom_2 = require_dom();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  dom_2.dom.setFeatures(false);
  function createDocument() {
    const impl = new dom_1.DOMImplementation;
    const doc = impl.createDocument(null, "root", null);
    if (doc.documentElement) {
      doc.removeChild(doc.documentElement);
    }
    return doc;
  }
  function sanitizeInput(str, replacement) {
    if (str == null) {
      return str;
    } else if (replacement === undefined) {
      return str + "";
    } else {
      let result = "";
      str = str + "";
      for (let i = 0;i < str.length; i++) {
        let n = str.charCodeAt(i);
        if (n === 9 || n === 10 || n === 13 || n >= 32 && n <= 55295 || n >= 57344 && n <= 65533) {
          result += str.charAt(i);
        } else if (n >= 55296 && n <= 56319 && i < str.length - 1) {
          const n2 = str.charCodeAt(i + 1);
          if (n2 >= 56320 && n2 <= 57343) {
            n = (n - 55296) * 1024 + n2 - 56320 + 65536;
            result += String.fromCodePoint(n);
            i++;
          } else {
            result += (0, util_1.isString)(replacement) ? replacement : replacement(str.charAt(i), i, str);
          }
        } else {
          result += (0, util_1.isString)(replacement) ? replacement : replacement(str.charAt(i), i, str);
        }
      }
      return result;
    }
  }
});

// node_modules/xmlbuilder2/lib/readers/BaseReader.js
var require_BaseReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseReader = undefined;
  var dom_1 = require_dom2();

  class BaseReader {
    _builderOptions;
    static _entityTable = {
      lt: "<",
      gt: ">",
      amp: "&",
      quot: '"',
      apos: "'"
    };
    constructor(builderOptions) {
      this._builderOptions = builderOptions;
      if (builderOptions.parser) {
        Object.assign(this, builderOptions.parser);
      }
    }
    _docType(parent, name, publicId, systemId) {
      return parent.dtd({ name, pubID: publicId, sysID: systemId });
    }
    _comment(parent, data) {
      return parent.com(data);
    }
    _text(parent, data) {
      return parent.txt(data);
    }
    _instruction(parent, target, data) {
      return parent.ins(target, data);
    }
    _cdata(parent, data) {
      return parent.dat(data);
    }
    _element(parent, namespace, name) {
      return namespace === undefined ? parent.ele(name) : parent.ele(namespace, name);
    }
    _attribute(parent, namespace, name, value) {
      return namespace === undefined ? parent.att(name, value) : parent.att(namespace, name, value);
    }
    _sanitize(str) {
      return (0, dom_1.sanitizeInput)(str, this._builderOptions.invalidCharReplacement);
    }
    _decodeText(text) {
      if (text == null)
        return text;
      return text.replace(/&(quot|amp|apos|lt|gt);/g, (_match, tag) => BaseReader._entityTable[tag]).replace(/&#(?:x([a-fA-F0-9]+)|([0-9]+));/g, (_match, hexStr, numStr) => String.fromCodePoint(parseInt(hexStr || numStr, hexStr ? 16 : 10)));
    }
    _decodeAttributeValue(text) {
      return this._decodeText(text);
    }
    parse(node, obj) {
      return this._parse(node, obj);
    }
    docType(parent, name, publicId, systemId) {
      return this._docType(parent, name, publicId, systemId);
    }
    comment(parent, data) {
      return this._comment(parent, data);
    }
    text(parent, data) {
      return this._text(parent, data);
    }
    instruction(parent, target, data) {
      return this._instruction(parent, target, data);
    }
    cdata(parent, data) {
      return this._cdata(parent, data);
    }
    element(parent, namespace, name) {
      return this._element(parent, namespace, name);
    }
    attribute(parent, namespace, name, value) {
      return this._attribute(parent, namespace, name, value);
    }
    sanitize(str) {
      return this._sanitize(str);
    }
  }
  exports.BaseReader = BaseReader;
});

// node_modules/xmlbuilder2/lib/readers/XMLReader.js
var require_XMLReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLReader = undefined;
  var XMLStringLexer_1 = require_XMLStringLexer();
  var interfaces_1 = require_interfaces4();
  var interfaces_2 = require_interfaces2();
  var infra_1 = require_lib7();
  var algorithm_1 = require_algorithm();
  var BaseReader_1 = require_BaseReader();

  class XMLReader extends BaseReader_1.BaseReader {
    _parse(node, str) {
      const lexer = new XMLStringLexer_1.XMLStringLexer(str, { skipWhitespaceOnlyText: this._builderOptions.skipWhitespaceOnlyText });
      let lastChild = node;
      let context = node;
      let token = lexer.nextToken();
      while (token.type !== interfaces_1.TokenType.EOF) {
        switch (token.type) {
          case interfaces_1.TokenType.Declaration:
            const declaration = token;
            const version = this.sanitize(declaration.version);
            if (version !== "1.0") {
              throw new Error("Invalid xml version: " + version);
            }
            const builderOptions = {
              version
            };
            if (declaration.encoding) {
              builderOptions.encoding = this.sanitize(declaration.encoding);
            }
            if (declaration.standalone) {
              builderOptions.standalone = this.sanitize(declaration.standalone) === "yes";
            }
            context.set(builderOptions);
            break;
          case interfaces_1.TokenType.DocType:
            const doctype = token;
            context = this.docType(context, this.sanitize(doctype.name), this.sanitize(doctype.pubId), this.sanitize(doctype.sysId)) || context;
            break;
          case interfaces_1.TokenType.CDATA:
            const cdata = token;
            context = this.cdata(context, this.sanitize(cdata.data)) || context;
            break;
          case interfaces_1.TokenType.Comment:
            const comment = token;
            context = this.comment(context, this.sanitize(comment.data)) || context;
            break;
          case interfaces_1.TokenType.PI:
            const pi = token;
            context = this.instruction(context, this.sanitize(pi.target), this.sanitize(pi.data)) || context;
            break;
          case interfaces_1.TokenType.Text:
            if (context.node.nodeType === interfaces_2.NodeType.Document)
              break;
            const text = token;
            context = this.text(context, this._decodeText(this.sanitize(text.data))) || context;
            break;
          case interfaces_1.TokenType.Element:
            const element = token;
            const elementName = this.sanitize(element.name);
            const [prefix] = (0, algorithm_1.namespace_extractQName)(elementName);
            let namespace = context.node.lookupNamespaceURI(prefix);
            const nsDeclarations = {};
            for (let [attName, attValue] of element.attributes) {
              attName = this.sanitize(attName);
              attValue = this.sanitize(attValue);
              if (attName === "xmlns") {
                namespace = attValue;
              } else {
                const [attPrefix, attLocalName] = (0, algorithm_1.namespace_extractQName)(attName);
                if (attPrefix === "xmlns") {
                  if (attLocalName === prefix) {
                    namespace = attValue;
                  }
                  nsDeclarations[attLocalName] = attValue;
                }
              }
            }
            const elementNode = namespace !== null ? this.element(context, namespace, elementName) : this.element(context, undefined, elementName);
            if (elementNode === undefined)
              break;
            if (context.node === node.node)
              lastChild = elementNode;
            for (let [attName, attValue] of element.attributes) {
              attName = this.sanitize(attName);
              attValue = this.sanitize(attValue);
              const [attPrefix, attLocalName] = (0, algorithm_1.namespace_extractQName)(attName);
              let attNamespace = null;
              if (attPrefix === "xmlns" || attPrefix === null && attLocalName === "xmlns") {
                attNamespace = infra_1.namespace.XMLNS;
              } else {
                attNamespace = elementNode.node.lookupNamespaceURI(attPrefix);
                if (attNamespace !== null && elementNode.node.isDefaultNamespace(attNamespace)) {
                  attNamespace = null;
                } else if (attNamespace === null && attPrefix !== null) {
                  attNamespace = nsDeclarations[attPrefix] || null;
                }
              }
              if (attNamespace !== null)
                this.attribute(elementNode, attNamespace, attName, this._decodeAttributeValue(attValue));
              else
                this.attribute(elementNode, undefined, attName, this._decodeAttributeValue(attValue));
            }
            if (!element.selfClosing) {
              context = elementNode;
            }
            break;
          case interfaces_1.TokenType.ClosingTag:
            if (context.node.parentNode) {
              context = context.up();
            }
            break;
        }
        token = lexer.nextToken();
      }
      return lastChild;
    }
  }
  exports.XMLReader = XMLReader;
});

// node_modules/xmlbuilder2/lib/readers/ObjectReader.js
var require_ObjectReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectReader = undefined;
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var BaseReader_1 = require_BaseReader();

  class ObjectReader extends BaseReader_1.BaseReader {
    _parse(node, obj) {
      const options = this._builderOptions;
      let lastChild = null;
      if ((0, util_1.isFunction)(obj)) {
        lastChild = this.parse(node, obj.call(this));
      } else if ((0, util_1.isArray)(obj) || (0, util_1.isSet)(obj)) {
        (0, util_1.forEachArray)(obj, (item) => lastChild = this.parse(node, item), this);
      } else if ((0, util_1.isMap)(obj) || (0, util_1.isObject)(obj)) {
        (0, util_1.forEachObject)(obj, (key, val) => {
          if ((0, util_1.isFunction)(val)) {
            val = val.call(this);
          }
          if (!options.ignoreConverters && key.indexOf(options.convert.att) === 0) {
            if (key === options.convert.att) {
              if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
                throw new Error("Invalid attribute: " + val.toString() + ". " + node._debugInfo());
              } else {
                (0, util_1.forEachObject)(val, (attrKey, attrVal) => {
                  lastChild = this.attribute(node, undefined, this.sanitize(attrKey), this._decodeAttributeValue(this.sanitize(attrVal))) || lastChild;
                });
              }
            } else {
              lastChild = this.attribute(node, undefined, this.sanitize(key.substring(options.convert.att.length)), this._decodeAttributeValue(this.sanitize(val?.toString()))) || lastChild;
            }
          } else if (!options.ignoreConverters && key.indexOf(options.convert.text) === 0) {
            if ((0, util_1.isMap)(val) || (0, util_1.isObject)(val)) {
              lastChild = this.parse(node, val);
            } else {
              lastChild = this.text(node, this._decodeText(this.sanitize(val?.toString()))) || lastChild;
            }
          } else if (!options.ignoreConverters && key.indexOf(options.convert.cdata) === 0) {
            if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
              (0, util_1.forEachArray)(val, (item) => lastChild = this.cdata(node, this.sanitize(item)) || lastChild, this);
            } else {
              lastChild = this.cdata(node, this.sanitize(val?.toString())) || lastChild;
            }
          } else if (!options.ignoreConverters && key.indexOf(options.convert.comment) === 0) {
            if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
              (0, util_1.forEachArray)(val, (item) => lastChild = this.comment(node, this.sanitize(item)) || lastChild, this);
            } else {
              lastChild = this.comment(node, this.sanitize(val?.toString())) || lastChild;
            }
          } else if (!options.ignoreConverters && key.indexOf(options.convert.ins) === 0) {
            if ((0, util_1.isString)(val)) {
              const insIndex = val.indexOf(" ");
              const insTarget = insIndex === -1 ? val : val.substr(0, insIndex);
              const insValue = insIndex === -1 ? "" : val.substr(insIndex + 1);
              lastChild = this.instruction(node, this.sanitize(insTarget), this.sanitize(insValue)) || lastChild;
            } else if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
              (0, util_1.forEachArray)(val, (item) => {
                const insIndex = item.indexOf(" ");
                const insTarget = insIndex === -1 ? item : item.substr(0, insIndex);
                const insValue = insIndex === -1 ? "" : item.substr(insIndex + 1);
                lastChild = this.instruction(node, this.sanitize(insTarget), this.sanitize(insValue)) || lastChild;
              }, this);
            } else {
              (0, util_1.forEachObject)(val, (insTarget, insValue) => lastChild = this.instruction(node, this.sanitize(insTarget), this.sanitize(insValue)) || lastChild, this);
            }
          } else if (((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) && (0, util_1.isEmpty)(val)) {} else if (((0, util_1.isMap)(val) || (0, util_1.isObject)(val)) && (0, util_1.isEmpty)(val)) {
            lastChild = this.element(node, undefined, this.sanitize(key)) || lastChild;
          } else if (!options.keepNullNodes && val == null) {} else if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
            (0, util_1.forEachArray)(val, (item) => {
              const childNode = {};
              childNode[key] = item;
              lastChild = this.parse(node, childNode);
            }, this);
          } else if ((0, util_1.isMap)(val) || (0, util_1.isObject)(val)) {
            const parent = this.element(node, undefined, this.sanitize(key));
            if (parent) {
              lastChild = parent;
              this.parse(parent, val);
            }
          } else if (val != null && (!(0, util_1.isString)(val) || val !== "")) {
            const parent = this.element(node, undefined, this.sanitize(key));
            if (parent) {
              lastChild = parent;
              this.text(parent, this._decodeText(this.sanitize(val?.toString())));
            }
          } else {
            lastChild = this.element(node, undefined, this.sanitize(key)) || lastChild;
          }
        }, this);
      } else if (!options.keepNullNodes && obj == null) {} else {
        lastChild = this.text(node, this._decodeText(this.sanitize(obj?.toString()))) || lastChild;
      }
      return lastChild || node;
    }
  }
  exports.ObjectReader = ObjectReader;
});

// node_modules/xmlbuilder2/lib/readers/JSONReader.js
var require_JSONReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JSONReader = undefined;
  var ObjectReader_1 = require_ObjectReader();
  var BaseReader_1 = require_BaseReader();

  class JSONReader extends BaseReader_1.BaseReader {
    _parse(node, str) {
      return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, JSON.parse(str));
    }
  }
  exports.JSONReader = JSONReader;
});

// node_modules/js-yaml/lib/common.js
var require_common2 = __commonJS((exports, module) => {
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject2(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length;index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0;cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  exports.isNothing = isNothing;
  exports.isObject = isObject2;
  exports.toArray = toArray;
  exports.repeat = repeat;
  exports.isNegativeZero = isNegativeZero;
  exports.extend = extend;
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS((exports, module) => {
  function formatError(exception, compact) {
    var where = "", message = exception.reason || "(unknown reason)";
    if (!exception.mark)
      return message;
    if (exception.mark.name) {
      where += 'in "' + exception.mark.name + '" ';
    }
    where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
    if (!compact && exception.mark.snippet) {
      where += `

` + exception.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  module.exports = YAMLException;
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS((exports, module) => {
  var common = require_common2();
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
      pos: position - lineStart + head.length
    };
  }
  function padStart(string, max) {
    return common.repeat(" ", max - string.length) + string;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer)
      return null;
    if (!options.maxLength)
      options.maxLength = 79;
    if (typeof options.indent !== "number")
      options.indent = 1;
    if (typeof options.linesBefore !== "number")
      options.linesBefore = 3;
    if (typeof options.linesAfter !== "number")
      options.linesAfter = 2;
    var re = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0)
      foundLineNo = lineStarts.length - 1;
    var result = "", i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i = 1;i <= options.linesBefore; i++) {
      if (foundLineNo - i < 0)
        break;
      line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
      result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + `
` + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + `
`;
    result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^" + `
`;
    for (i = 1;i <= options.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length)
        break;
      line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + `
`;
    }
    return result.replace(/\n$/, "");
  }
  module.exports = makeSnippet;
});

// node_modules/js-yaml/lib/type.js
var require_type2 = __commonJS((exports, module) => {
  var YAMLException = require_exception();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map) {
    var result = {};
    if (map !== null) {
      Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  module.exports = Type;
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS((exports, module) => {
  var YAMLException = require_exception();
  var Type = require_type2();
  function compileList(schema, name) {
    var result = [];
    schema[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type) {
      if (type.multi) {
        result.multi[type.kind].push(type);
        result.multi["fallback"].push(type);
      } else {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
    }
    for (index = 0, length = arguments.length;index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema(definition) {
    return this.extend(definition);
  }
  Schema.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof Type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit)
        implicit = implicit.concat(definition.implicit);
      if (definition.explicit)
        explicit = explicit.concat(definition.explicit);
    } else {
      throw new YAMLException("Schema.extend argument should be a Type, [ Type ], " + "or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type) {
      if (!(type instanceof Type)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type.loadKind && type.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type.multi) {
        throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type) {
      if (!(type instanceof Type)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  module.exports = Schema;
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS((exports, module) => {
  var Type = require_type2();
  module.exports = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS((exports, module) => {
  var Type = require_type2();
  module.exports = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
});

// node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS((exports, module) => {
  var Type = require_type2();
  module.exports = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS((exports, module) => {
  var Schema = require_schema();
  module.exports = new Schema({
    explicit: [
      require_str(),
      require_seq(),
      require_map()
    ]
  });
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS((exports, module) => {
  var Type = require_type2();
  function resolveYamlNull(data) {
    if (data === null)
      return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  module.exports = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS((exports, module) => {
  var Type = require_type2();
  function resolveYamlBoolean(data) {
    if (data === null)
      return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean2(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  module.exports = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean2,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS((exports, module) => {
  var common = require_common2();
  var Type = require_type2();
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null)
      return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max)
      return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max)
        return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (;index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (ch !== "0" && ch !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (;index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isHexCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index++;
        for (;index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_")
      return false;
    for (;index < max; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_")
      return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-")
        sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0")
      return 0;
    if (ch === "0") {
      if (value[1] === "b")
        return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x")
        return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o")
        return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  module.exports = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS((exports, module) => {
  var common = require_common2();
  var Type = require_type2();
  var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + "|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + "|[-+]?\\.(?:inf|Inf|INF)" + "|\\.(?:nan|NaN|NAN))$");
  function resolveYamlFloat(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  module.exports = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS((exports, module) => {
  module.exports = require_failsafe().extend({
    implicit: [
      require_null(),
      require_bool(),
      require_int(),
      require_float()
    ]
  });
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS((exports, module) => {
  var Type = require_type2();
  var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9])" + "-([0-9][0-9])$");
  var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9]?)" + "-([0-9][0-9]?)" + "(?:[Tt]|[ \\t]+)" + "([0-9][0-9]?)" + ":([0-9][0-9])" + ":([0-9][0-9])" + "(?:\\.([0-9]*))?" + "(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + "(?::([0-9][0-9]))?))?$");
  function resolveYamlTimestamp(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null)
      match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null)
      throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000;
      if (match[9] === "-")
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  module.exports = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS((exports, module) => {
  var Type = require_type2();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  module.exports = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS((exports, module) => {
  var Type = require_type2();
  var BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function resolveYamlBinary(data) {
    if (data === null)
      return false;
    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
    for (idx = 0;idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));
      if (code > 64)
        continue;
      if (code < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
    for (idx = 0;idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    for (idx = 0;idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map[bits >> 18 & 63];
      result += map[bits >> 12 & 63];
      result += map[bits >> 6 & 63];
      result += map[bits & 63];
    } else if (tail === 2) {
      result += map[bits >> 10 & 63];
      result += map[bits >> 4 & 63];
      result += map[bits << 2 & 63];
      result += map[64];
    } else if (tail === 1) {
      result += map[bits >> 2 & 63];
      result += map[bits << 4 & 63];
      result += map[64];
      result += map[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  module.exports = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS((exports, module) => {
  var Type = require_type2();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null)
      return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length;index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys.indexOf(pairKey) === -1)
        objectKeys.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  module.exports = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS((exports, module) => {
  var Type = require_type2();
  var _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null)
      return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length;index < length; index += 1) {
      pair = object[index];
      if (_toString.call(pair) !== "[object Object]")
        return false;
      keys = Object.keys(pair);
      if (keys.length !== 1)
        return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null)
      return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length;index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  module.exports = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS((exports, module) => {
  var Type = require_type2();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null)
      return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty.call(object, key)) {
        if (object[key] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  module.exports = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS((exports, module) => {
  module.exports = require_json().extend({
    implicit: [
      require_timestamp(),
      require_merge()
    ],
    explicit: [
      require_binary(),
      require_omap(),
      require_pairs(),
      require_set()
    ]
  });
});

// node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS((exports, module) => {
  var common = require_common2();
  var YAMLException = require_exception();
  var makeSnippet = require_snippet();
  var DEFAULT_SCHEMA = require_default();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\x00" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "\t" : c === 9 ? "\t" : c === 110 ? `
` : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? " " : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (i = 0;i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  var i;
  function State(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || DEFAULT_SCHEMA;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = makeSnippet(mark);
    return new YAMLException(message, mark);
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length;_position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length;index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length;index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length;index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat(`
`, count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (;hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += `
`;
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat(`
`, emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat(`
`, emptyLines);
        }
      } else {
        state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.firstTabInLine !== -1)
      return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.firstTabInLine !== -1)
      return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33)
      return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38)
      return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42)
      return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];
        if (type.resolve(state.result)) {
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length;typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }
      if (!type.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch))
          break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0)
        readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += `
`;
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options);
    var nullpos = input.indexOf("\x00");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\x00";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length;index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  }
  exports.loadAll = loadAll;
  exports.load = load;
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS((exports, module) => {
  var common = require_common2();
  var YAMLException = require_exception();
  var DEFAULT_SCHEMA = require_default();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = "\\\"";
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null)
      return {};
    result = {};
    keys = Object.keys(map);
    for (index = 0, length = keys.length;index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type = schema.compiledTypeMap["fallback"][tag];
      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1;
  var QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || DEFAULT_SCHEMA;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf(`
`, position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== `
`)
        result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return `
` + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str) {
    var index, length, type;
    for (index = 0, length = state.implicitTypes.length;index < length; index += 1) {
      type = state.implicitTypes[index];
      if (type.resolve(str)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
  }
  function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c) {
    return !isWhitespace(c) && c !== CHAR_COLON;
  }
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i = 0;i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i = 0;i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function() {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string, lineWidth) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === `
`;
    var keep = clip && (string[string.length - 2] === `
` || string === `
`);
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + `
`;
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf(`
`);
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === `
` || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? `
` : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ")
      return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += `
` + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += `
`;
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + `
` + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i = 0;i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string[i];
        if (char >= 65536)
          result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length;index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "")
          _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length;index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length;index < length; index += 1) {
      pairBuffer = "";
      if (_result !== "")
        pairBuffer += ", ";
      if (state.condenseFlow)
        pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length;index < length; index += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length;index < length; index += 1) {
      type = typeList[index];
      if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
        if (explicit) {
          if (type.multi && type.representName) {
            state.tag = type.representName(object);
          } else {
            state.tag = type.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;
          if (_toString.call(type.represent) === "[object Function]") {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid)
          return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length;index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length;index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length;index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs)
      getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true))
      return state.dump + `
`;
    return "";
  }
  exports.dump = dump;
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS((exports, module) => {
  var loader = require_loader();
  var dumper = require_dumper();
  function renamed(from, to) {
    return function() {
      throw new Error("Function yaml." + from + " is removed in js-yaml 4. " + "Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  exports.Type = require_type2();
  exports.Schema = require_schema();
  exports.FAILSAFE_SCHEMA = require_failsafe();
  exports.JSON_SCHEMA = require_json();
  exports.CORE_SCHEMA = require_json();
  exports.DEFAULT_SCHEMA = require_default();
  exports.load = loader.load;
  exports.loadAll = loader.loadAll;
  exports.dump = dumper.dump;
  exports.YAMLException = require_exception();
  exports.types = {
    binary: require_binary(),
    float: require_float(),
    map: require_map(),
    null: require_null(),
    pairs: require_pairs(),
    set: require_set(),
    timestamp: require_timestamp(),
    bool: require_bool(),
    int: require_int(),
    merge: require_merge(),
    omap: require_omap(),
    seq: require_seq(),
    str: require_str()
  };
  exports.safeLoad = renamed("safeLoad", "load");
  exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
  exports.safeDump = renamed("safeDump", "dump");
});

// node_modules/xmlbuilder2/lib/readers/YAMLReader.js
var require_YAMLReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.YAMLReader = undefined;
  var ObjectReader_1 = require_ObjectReader();
  var BaseReader_1 = require_BaseReader();
  var js_yaml_1 = require_js_yaml();

  class YAMLReader extends BaseReader_1.BaseReader {
    _parse(node, str) {
      const result = (0, js_yaml_1.load)(str);
      if (result === undefined) {
        throw new Error("Unable to parse YAML document.");
      }
      return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, result);
    }
  }
  exports.YAMLReader = YAMLReader;
});

// node_modules/xmlbuilder2/lib/readers/index.js
var require_readers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.YAMLReader = exports.JSONReader = exports.ObjectReader = exports.XMLReader = undefined;
  var XMLReader_1 = require_XMLReader();
  Object.defineProperty(exports, "XMLReader", { enumerable: true, get: function() {
    return XMLReader_1.XMLReader;
  } });
  var ObjectReader_1 = require_ObjectReader();
  Object.defineProperty(exports, "ObjectReader", { enumerable: true, get: function() {
    return ObjectReader_1.ObjectReader;
  } });
  var JSONReader_1 = require_JSONReader();
  Object.defineProperty(exports, "JSONReader", { enumerable: true, get: function() {
    return JSONReader_1.JSONReader;
  } });
  var YAMLReader_1 = require_YAMLReader();
  Object.defineProperty(exports, "YAMLReader", { enumerable: true, get: function() {
    return YAMLReader_1.YAMLReader;
  } });
});

// node_modules/xmlbuilder2/lib/builder/XMLBuilderImpl.js
var require_XMLBuilderImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLBuilderImpl = undefined;
  var interfaces_1 = require_interfaces();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var writers_1 = require_writers();
  var interfaces_2 = require_interfaces2();
  var util_2 = require_util2();
  var algorithm_1 = require_algorithm();
  var dom_1 = require_dom2();
  var infra_1 = require_lib7();
  var readers_1 = require_readers();

  class XMLBuilderImpl {
    _domNode;
    constructor(domNode) {
      this._domNode = domNode;
    }
    get node() {
      return this._domNode;
    }
    get options() {
      return this._options;
    }
    set(options) {
      this._options = (0, util_1.applyDefaults)((0, util_1.applyDefaults)(this._options, options, true), interfaces_1.DefaultBuilderOptions);
      return this;
    }
    ele(p1, p2, p3) {
      let namespace;
      let name;
      let attributes;
      if ((0, util_1.isObject)(p1)) {
        return new readers_1.ObjectReader(this._options).parse(this, p1);
      } else if ((0, util_1.isString)(p1) && p1 !== null && /^\s*</.test(p1)) {
        return new readers_1.XMLReader(this._options).parse(this, p1);
      } else if ((0, util_1.isString)(p1) && p1 !== null && /^\s*[\{\[]/.test(p1)) {
        return new readers_1.JSONReader(this._options).parse(this, p1);
      } else if ((0, util_1.isString)(p1) && p1 !== null && /^(\s*|(#.*)|(%.*))*---/.test(p1)) {
        return new readers_1.YAMLReader(this._options).parse(this, p1);
      }
      if ((p1 === null || (0, util_1.isString)(p1)) && (0, util_1.isString)(p2)) {
        [namespace, name, attributes] = [p1, p2, p3];
      } else if (p1 !== null) {
        [namespace, name, attributes] = [undefined, p1, (0, util_1.isObject)(p2) ? p2 : undefined];
      } else {
        throw new Error("Element name cannot be null. " + this._debugInfo());
      }
      if (attributes) {
        attributes = (0, util_1.getValue)(attributes);
      }
      [namespace, name] = this._extractNamespace((0, dom_1.sanitizeInput)(namespace, this._options.invalidCharReplacement), (0, dom_1.sanitizeInput)(name, this._options.invalidCharReplacement), true);
      if (namespace === undefined) {
        const [prefix] = (0, algorithm_1.namespace_extractQName)(name);
        namespace = this.node.lookupNamespaceURI(prefix);
      }
      const childNode = namespace !== undefined && namespace !== null ? this._doc.createElementNS(namespace, name) : this._doc.createElement(name);
      this.node.appendChild(childNode);
      const builder = new XMLBuilderImpl(childNode);
      const oldDocType = this._doc.doctype;
      if (childNode === this._doc.documentElement && oldDocType !== null) {
        const docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);
        this._doc.replaceChild(docType, oldDocType);
      }
      if (attributes && !(0, util_1.isEmpty)(attributes)) {
        builder.att(attributes);
      }
      return builder;
    }
    remove() {
      const parent = this.up();
      parent.node.removeChild(this.node);
      return parent;
    }
    att(p1, p2, p3) {
      if ((0, util_1.isMap)(p1) || (0, util_1.isObject)(p1)) {
        (0, util_1.forEachObject)(p1, (attName, attValue) => this.att(attName, attValue), this);
        return this;
      }
      if (p1 !== undefined && p1 !== null)
        p1 = (0, util_1.getValue)(p1 + "");
      if (p2 !== undefined && p2 !== null)
        p2 = (0, util_1.getValue)(p2 + "");
      if (p3 !== undefined && p3 !== null)
        p3 = (0, util_1.getValue)(p3 + "");
      let namespace;
      let name;
      let value;
      if ((p1 === null || (0, util_1.isString)(p1)) && (0, util_1.isString)(p2) && (p3 === null || (0, util_1.isString)(p3))) {
        [namespace, name, value] = [p1, p2, p3];
      } else if ((0, util_1.isString)(p1) && (p2 == null || (0, util_1.isString)(p2))) {
        [namespace, name, value] = [undefined, p1, p2];
      } else {
        throw new Error("Attribute name and value not specified. " + this._debugInfo());
      }
      if (this._options.keepNullAttributes && value == null) {
        value = "";
      } else if (value == null) {
        return this;
      }
      if (!util_2.Guard.isElementNode(this.node)) {
        throw new Error("An attribute can only be assigned to an element node.");
      }
      let ele = this.node;
      [namespace, name] = this._extractNamespace(namespace, name, false);
      name = (0, dom_1.sanitizeInput)(name, this._options.invalidCharReplacement);
      namespace = (0, dom_1.sanitizeInput)(namespace, this._options.invalidCharReplacement);
      value = (0, dom_1.sanitizeInput)(value, this._options.invalidCharReplacement);
      const [prefix, localName] = (0, algorithm_1.namespace_extractQName)(name);
      const [elePrefix] = (0, algorithm_1.namespace_extractQName)(ele.prefix ? ele.prefix + ":" + ele.localName : ele.localName);
      let eleNamespace = null;
      if (prefix === "xmlns") {
        namespace = infra_1.namespace.XMLNS;
        if (ele.namespaceURI === null && elePrefix === localName) {
          eleNamespace = value;
        }
      } else if (prefix === null && localName === "xmlns" && elePrefix === null) {
        namespace = infra_1.namespace.XMLNS;
        eleNamespace = value;
      }
      if (eleNamespace !== null) {
        this._updateNamespace(eleNamespace);
        ele = this.node;
      }
      if (namespace !== undefined) {
        ele.setAttributeNS(namespace, name, value);
      } else {
        ele.setAttribute(name, value);
      }
      return this;
    }
    removeAtt(p1, p2) {
      if (!util_2.Guard.isElementNode(this.node)) {
        throw new Error("An attribute can only be removed from an element node.");
      }
      p1 = (0, util_1.getValue)(p1);
      if (p2 !== undefined) {
        p2 = (0, util_1.getValue)(p2);
      }
      let namespace;
      let name;
      if (p1 !== null && p2 === undefined) {
        name = p1;
      } else if ((p1 === null || (0, util_1.isString)(p1)) && p2 !== undefined) {
        namespace = p1;
        name = p2;
      } else {
        throw new Error("Attribute namespace must be a string. " + this._debugInfo());
      }
      if ((0, util_1.isArray)(name) || (0, util_1.isSet)(name)) {
        (0, util_1.forEachArray)(name, (attName) => namespace === undefined ? this.removeAtt(attName) : this.removeAtt(namespace, attName), this);
      } else if (namespace !== undefined) {
        name = (0, dom_1.sanitizeInput)(name, this._options.invalidCharReplacement);
        namespace = (0, dom_1.sanitizeInput)(namespace, this._options.invalidCharReplacement);
        this.node.removeAttributeNS(namespace, name);
      } else {
        name = (0, dom_1.sanitizeInput)(name, this._options.invalidCharReplacement);
        this.node.removeAttribute(name);
      }
      return this;
    }
    txt(content) {
      if (content === null || content === undefined) {
        if (this._options.keepNullNodes) {
          content = "";
        } else {
          return this;
        }
      }
      const child = this._doc.createTextNode((0, dom_1.sanitizeInput)(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    com(content) {
      if (content === null || content === undefined) {
        if (this._options.keepNullNodes) {
          content = "";
        } else {
          return this;
        }
      }
      const child = this._doc.createComment((0, dom_1.sanitizeInput)(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    dat(content) {
      if (content === null || content === undefined) {
        if (this._options.keepNullNodes) {
          content = "";
        } else {
          return this;
        }
      }
      const child = this._doc.createCDATASection((0, dom_1.sanitizeInput)(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    ins(target, content = "") {
      if (content === null || content === undefined) {
        if (this._options.keepNullNodes) {
          content = "";
        } else {
          return this;
        }
      }
      if ((0, util_1.isArray)(target) || (0, util_1.isSet)(target)) {
        (0, util_1.forEachArray)(target, (item) => {
          item += "";
          const insIndex = item.indexOf(" ");
          const insTarget = insIndex === -1 ? item : item.substr(0, insIndex);
          const insValue = insIndex === -1 ? "" : item.substr(insIndex + 1);
          this.ins(insTarget, insValue);
        }, this);
      } else if ((0, util_1.isMap)(target) || (0, util_1.isObject)(target)) {
        (0, util_1.forEachObject)(target, (insTarget, insValue) => this.ins(insTarget, insValue), this);
      } else {
        const child = this._doc.createProcessingInstruction((0, dom_1.sanitizeInput)(target, this._options.invalidCharReplacement), (0, dom_1.sanitizeInput)(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
      }
      return this;
    }
    dec(options) {
      this._options.version = options.version || "1.0";
      this._options.encoding = options.encoding;
      this._options.standalone = options.standalone;
      return this;
    }
    dtd(options) {
      const name = (0, dom_1.sanitizeInput)(options && options.name || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement);
      const pubID = (0, dom_1.sanitizeInput)(options && options.pubID || "", this._options.invalidCharReplacement);
      const sysID = (0, dom_1.sanitizeInput)(options && options.sysID || "", this._options.invalidCharReplacement);
      if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {
        throw new Error("DocType name does not match document element name.");
      }
      const docType = this._doc.implementation.createDocumentType(name, pubID, sysID);
      if (this._doc.doctype !== null) {
        this._doc.replaceChild(docType, this._doc.doctype);
      } else {
        this._doc.insertBefore(docType, this._doc.documentElement);
      }
      return this;
    }
    import(node) {
      const hostNode = this._domNode;
      const hostDoc = this._doc;
      const importedNode = node.node;
      const updateImportedNodeNs = (clone2) => {
        if (!clone2._namespace) {
          const [prefix] = (0, algorithm_1.namespace_extractQName)(clone2.prefix ? clone2.prefix + ":" + clone2.localName : clone2.localName);
          const namespace = hostNode.lookupNamespaceURI(prefix);
          new XMLBuilderImpl(clone2)._updateNamespace(namespace);
        }
      };
      if (util_2.Guard.isDocumentNode(importedNode)) {
        const elementNode = importedNode.documentElement;
        if (elementNode === null) {
          throw new Error("Imported document has no document element node. " + this._debugInfo());
        }
        const clone2 = hostDoc.importNode(elementNode, true);
        hostNode.appendChild(clone2);
        updateImportedNodeNs(clone2);
      } else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {
        for (const childNode of importedNode.childNodes) {
          const clone2 = hostDoc.importNode(childNode, true);
          hostNode.appendChild(clone2);
          if (util_2.Guard.isElementNode(clone2)) {
            updateImportedNodeNs(clone2);
          }
        }
      } else {
        const clone2 = hostDoc.importNode(importedNode, true);
        hostNode.appendChild(clone2);
        if (util_2.Guard.isElementNode(clone2)) {
          updateImportedNodeNs(clone2);
        }
      }
      return this;
    }
    doc() {
      if (this._doc._isFragment) {
        let node = this.node;
        while (node && node.nodeType !== interfaces_2.NodeType.DocumentFragment) {
          node = node.parentNode;
        }
        if (node === null) {
          throw new Error("Node has no parent node while searching for document fragment ancestor. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
      } else {
        return new XMLBuilderImpl(this._doc);
      }
    }
    root() {
      const ele = this._doc.documentElement;
      if (!ele) {
        throw new Error("Document root element is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(ele);
    }
    up() {
      const parent = this._domNode.parentNode;
      if (!parent) {
        throw new Error("Parent node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(parent);
    }
    prev() {
      const node = this._domNode.previousSibling;
      if (!node) {
        throw new Error("Previous sibling node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(node);
    }
    next() {
      const node = this._domNode.nextSibling;
      if (!node) {
        throw new Error("Next sibling node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(node);
    }
    first() {
      const node = this._domNode.firstChild;
      if (!node) {
        throw new Error("First child node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(node);
    }
    last() {
      const node = this._domNode.lastChild;
      if (!node) {
        throw new Error("Last child node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(node);
    }
    each(callback, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const nextResult = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        callback.call(thisArg, new XMLBuilderImpl(result[0]), result[1], result[2]);
        result = nextResult;
      }
      return this;
    }
    map(callback, self2 = false, recursive = false, thisArg) {
      let result = [];
      this.each((node, index, level) => result.push(callback.call(thisArg, node, index, level)), self2, recursive);
      return result;
    }
    reduce(callback, initialValue, self2 = false, recursive = false, thisArg) {
      let value = initialValue;
      this.each((node, index, level) => value = callback.call(thisArg, value, node, index, level), self2, recursive);
      return value;
    }
    find(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder = new XMLBuilderImpl(result[0]);
        if (predicate.call(thisArg, builder, result[1], result[2])) {
          return builder;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return;
    }
    filter(predicate, self2 = false, recursive = false, thisArg) {
      let result = [];
      this.each((node, index, level) => {
        if (predicate.call(thisArg, node, index, level)) {
          result.push(node);
        }
      }, self2, recursive);
      return result;
    }
    every(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder = new XMLBuilderImpl(result[0]);
        if (!predicate.call(thisArg, builder, result[1], result[2])) {
          return false;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return true;
    }
    some(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder = new XMLBuilderImpl(result[0]);
        if (predicate.call(thisArg, builder, result[1], result[2])) {
          return true;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return false;
    }
    toArray(self2 = false, recursive = false) {
      let result = [];
      this.each((node) => result.push(node), self2, recursive);
      return result;
    }
    toString(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === undefined) {
        writerOptions.format = "xml";
      }
      return this._serialize(writerOptions);
    }
    toObject(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === undefined) {
        writerOptions.format = "object";
      }
      return this._serialize(writerOptions);
    }
    end(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === undefined) {
        writerOptions.format = "xml";
      }
      return this.doc()._serialize(writerOptions);
    }
    _getFirstDescendantNode(root, self2, recursive) {
      if (self2)
        return [this._domNode, 0, 0];
      else if (recursive)
        return this._getNextDescendantNode(root, root, recursive, 0, 0);
      else
        return [this._domNode.firstChild, 0, 1];
    }
    _getNextDescendantNode(root, node, recursive, index, level) {
      if (recursive) {
        if (node.firstChild)
          return [node.firstChild, 0, level + 1];
        if (node === root)
          return [null, -1, -1];
        if (node.nextSibling)
          return [node.nextSibling, index + 1, level];
        let parent = node.parentNode;
        while (parent && parent !== root) {
          if (parent.nextSibling)
            return [parent.nextSibling, (0, algorithm_1.tree_index)(parent.nextSibling), level - 1];
          parent = parent.parentNode;
          level--;
        }
      } else {
        if (root === node)
          return [node.firstChild, 0, level + 1];
        else
          return [node.nextSibling, index + 1, level];
      }
      return [null, -1, -1];
    }
    _serialize(writerOptions) {
      if (writerOptions.format === "xml") {
        const writer = new writers_1.XMLWriter(this._options, writerOptions);
        return writer.serialize(this.node);
      } else if (writerOptions.format === "map") {
        const writer = new writers_1.MapWriter(this._options, writerOptions);
        return writer.serialize(this.node);
      } else if (writerOptions.format === "object") {
        const writer = new writers_1.ObjectWriter(this._options, writerOptions);
        return writer.serialize(this.node);
      } else if (writerOptions.format === "json") {
        const writer = new writers_1.JSONWriter(this._options, writerOptions);
        return writer.serialize(this.node);
      } else if (writerOptions.format === "yaml") {
        const writer = new writers_1.YAMLWriter(this._options, writerOptions);
        return writer.serialize(this.node);
      } else {
        throw new Error("Invalid writer format: " + writerOptions.format + ". " + this._debugInfo());
      }
    }
    _extractNamespace(namespace, name, ele) {
      const atIndex = name.indexOf("@");
      if (atIndex > 0) {
        if (namespace === undefined)
          namespace = name.slice(atIndex + 1);
        name = name.slice(0, atIndex);
      }
      if (namespace === undefined) {
        namespace = ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att;
      } else if (namespace !== null && namespace[0] === "@") {
        const alias = namespace.slice(1);
        namespace = this._options.namespaceAlias[alias];
        if (namespace === undefined) {
          throw new Error("Namespace alias `" + alias + "` is not defined. " + this._debugInfo());
        }
      }
      return [namespace, name];
    }
    _updateNamespace(ns) {
      const ele = this._domNode;
      if (util_2.Guard.isElementNode(ele) && ns !== null && ele.namespaceURI !== ns) {
        const [elePrefix, eleLocalName] = (0, algorithm_1.namespace_extractQName)(ele.prefix ? ele.prefix + ":" + ele.localName : ele.localName);
        const newEle = (0, algorithm_1.create_element)(this._doc, eleLocalName, ns, elePrefix);
        for (const attr of ele.attributes) {
          const attrQName = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
          const [attrPrefix] = (0, algorithm_1.namespace_extractQName)(attrQName);
          let newAttrNS = attr.namespaceURI;
          if (newAttrNS === null && attrPrefix !== null) {
            newAttrNS = ele.lookupNamespaceURI(attrPrefix);
          }
          if (newAttrNS === null) {
            newEle.setAttribute(attrQName, attr.value);
          } else {
            newEle.setAttributeNS(newAttrNS, attrQName, attr.value);
          }
        }
        const parent = ele.parentNode;
        if (parent === null) {
          throw new Error("Parent node is null." + this._debugInfo());
        }
        parent.replaceChild(newEle, ele);
        this._domNode = newEle;
        for (const childNode of ele.childNodes) {
          const newChildNode = childNode.cloneNode(true);
          newEle.appendChild(newChildNode);
          if (util_2.Guard.isElementNode(newChildNode) && !newChildNode._namespace) {
            const [newChildNodePrefix] = (0, algorithm_1.namespace_extractQName)(newChildNode.prefix ? newChildNode.prefix + ":" + newChildNode.localName : newChildNode.localName);
            const newChildNodeNS = newEle.lookupNamespaceURI(newChildNodePrefix);
            new XMLBuilderImpl(newChildNode)._updateNamespace(newChildNodeNS);
          }
        }
      }
    }
    get _doc() {
      const node = this.node;
      if (util_2.Guard.isDocumentNode(node)) {
        return node;
      } else {
        const docNode = node.ownerDocument;
        if (!docNode)
          throw new Error("Owner document is null. " + this._debugInfo());
        return docNode;
      }
    }
    _debugInfo(name) {
      const node = this.node;
      const parentNode = node.parentNode;
      name = name || node.nodeName;
      const parentName = parentNode ? parentNode.nodeName : "";
      if (!parentName) {
        return "node: <" + name + ">";
      } else {
        return "node: <" + name + ">, parent: <" + parentName + ">";
      }
    }
    get _options() {
      const doc = this._doc;
      if (doc._xmlBuilderOptions === undefined) {
        throw new Error("Builder options is not set.");
      }
      return doc._xmlBuilderOptions;
    }
    set _options(value) {
      const doc = this._doc;
      doc._xmlBuilderOptions = value;
    }
  }
  exports.XMLBuilderImpl = XMLBuilderImpl;
});

// node_modules/xmlbuilder2/lib/builder/BuilderFunctions.js
var require_BuilderFunctions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.builder = builder;
  exports.create = create;
  exports.fragment = fragment;
  exports.convert = convert;
  var interfaces_1 = require_interfaces();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var util_2 = require_util2();
  var _1 = require_builder();
  var dom_1 = require_dom2();
  function builder(p1, p2) {
    const options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const nodes = util_2.Guard.isNode(p1) || (0, util_1.isArray)(p1) ? p1 : p2;
    if (nodes === undefined) {
      throw new Error("Invalid arguments.");
    }
    if ((0, util_1.isArray)(nodes)) {
      const builders = [];
      for (let i = 0;i < nodes.length; i++) {
        const builder2 = new _1.XMLBuilderImpl(nodes[i]);
        builder2.set(options);
        builders.push(builder2);
      }
      return builders;
    } else {
      const builder2 = new _1.XMLBuilderImpl(nodes);
      builder2.set(options);
      return builder2;
    }
  }
  function create(p1, p2) {
    const options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    const doc = (0, dom_1.createDocument)();
    setOptions(doc, options);
    const builder2 = new _1.XMLBuilderImpl(doc);
    if (contents !== undefined) {
      builder2.ele(contents);
    }
    return builder2;
  }
  function fragment(p1, p2) {
    const options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    const doc = (0, dom_1.createDocument)();
    setOptions(doc, options, true);
    const builder2 = new _1.XMLBuilderImpl(doc.createDocumentFragment());
    if (contents !== undefined) {
      builder2.ele(contents);
    }
    return builder2;
  }
  function convert(p1, p2, p3) {
    let builderOptions;
    let contents;
    let convertOptions;
    if (isXMLBuilderCreateOptions(p1) && p2 !== undefined) {
      builderOptions = p1;
      contents = p2;
      convertOptions = p3;
    } else {
      builderOptions = interfaces_1.DefaultBuilderOptions;
      contents = p1;
      convertOptions = p2 || undefined;
    }
    return create(builderOptions, contents).end(convertOptions);
  }
  function isXMLBuilderCreateOptions(obj) {
    if (!(0, util_1.isPlainObject)(obj))
      return false;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (!interfaces_1.XMLBuilderOptionKeys.has(key))
          return false;
      }
    }
    return true;
  }
  function formatBuilderOptions(createOptions = {}) {
    const options = (0, util_1.applyDefaults)(createOptions, interfaces_1.DefaultBuilderOptions);
    if (options.convert.att.length === 0 || options.convert.ins.length === 0 || options.convert.text.length === 0 || options.convert.cdata.length === 0 || options.convert.comment.length === 0) {
      throw new Error("JS object converter strings cannot be zero length.");
    }
    return options;
  }
  function setOptions(doc, options, isFragment) {
    const docWithSettings = doc;
    docWithSettings._xmlBuilderOptions = options;
    docWithSettings._isFragment = isFragment;
  }
});

// node_modules/xmlbuilder2/lib/writers/BaseCBWriter.js
var require_BaseCBWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseCBWriter = undefined;

  class BaseCBWriter {
    _builderOptions;
    _writerOptions;
    level = 0;
    hasData;
    constructor(builderOptions) {
      this._builderOptions = builderOptions;
      this._writerOptions = builderOptions;
    }
  }
  exports.BaseCBWriter = BaseCBWriter;
});

// node_modules/xmlbuilder2/lib/writers/XMLCBWriter.js
var require_XMLCBWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLCBWriter = undefined;
  var BaseCBWriter_1 = require_BaseCBWriter();

  class XMLCBWriter extends BaseCBWriter_1.BaseCBWriter {
    _lineLength = 0;
    constructor(builderOptions) {
      super(builderOptions);
    }
    frontMatter() {
      return "";
    }
    declaration(version, encoding, standalone) {
      let markup = this._beginLine() + "<?xml";
      markup += ' version="' + version + '"';
      if (encoding !== undefined) {
        markup += ' encoding="' + encoding + '"';
      }
      if (standalone !== undefined) {
        markup += ' standalone="' + (standalone ? "yes" : "no") + '"';
      }
      markup += "?>";
      return markup;
    }
    docType(name, publicId, systemId) {
      let markup = this._beginLine();
      if (publicId && systemId) {
        markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
      } else if (publicId) {
        markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
      } else if (systemId) {
        markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
      } else {
        markup += "<!DOCTYPE " + name + ">";
      }
      return markup;
    }
    comment(data) {
      return this._beginLine() + "<!--" + data + "-->";
    }
    text(data) {
      return this._beginLine() + data;
    }
    instruction(target, data) {
      if (data) {
        return this._beginLine() + "<?" + target + " " + data + "?>";
      } else {
        return this._beginLine() + "<?" + target + "?>";
      }
    }
    cdata(data) {
      return this._beginLine() + "<![CDATA[" + data + "]]>";
    }
    openTagBegin(name) {
      this._lineLength += 1 + name.length;
      return this._beginLine() + "<" + name;
    }
    openTagEnd(name, selfClosing, voidElement) {
      if (voidElement) {
        return " />";
      } else if (selfClosing) {
        if (this._writerOptions.allowEmptyTags) {
          return "></" + name + ">";
        } else if (this._writerOptions.spaceBeforeSlash) {
          return " />";
        } else {
          return "/>";
        }
      } else {
        return ">";
      }
    }
    closeTag(name) {
      return this._beginLine() + "</" + name + ">";
    }
    attribute(name, value) {
      let str = name + '="' + value + '"';
      if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._lineLength + 1 + str.length > this._writerOptions.width) {
        str = this._beginLine() + this._indent(1) + str;
        this._lineLength = str.length;
        return str;
      } else {
        this._lineLength += 1 + str.length;
        return " " + str;
      }
    }
    beginElement(name) {}
    endElement(name) {}
    _beginLine() {
      if (this._writerOptions.prettyPrint) {
        const str = (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level);
        this._lineLength = str.length;
        return str;
      } else {
        return "";
      }
    }
    _indent(level) {
      if (level <= 0) {
        return "";
      } else {
        return this._writerOptions.indent.repeat(level);
      }
    }
  }
  exports.XMLCBWriter = XMLCBWriter;
});

// node_modules/xmlbuilder2/lib/writers/JSONCBWriter.js
var require_JSONCBWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JSONCBWriter = undefined;
  var BaseCBWriter_1 = require_BaseCBWriter();

  class JSONCBWriter extends BaseCBWriter_1.BaseCBWriter {
    _hasChildren = [];
    _additionalLevel = 0;
    constructor(builderOptions) {
      super(builderOptions);
    }
    frontMatter() {
      return "";
    }
    declaration(version, encoding, standalone) {
      return "";
    }
    docType(name, publicId, systemId) {
      return "";
    }
    comment(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.comment) + this._sep() + this._val(data) + this._sep() + "}";
    }
    text(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.text) + this._sep() + this._val(data) + this._sep() + "}";
    }
    instruction(target, data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.ins) + this._sep() + this._val(data ? target + " " + data : target) + this._sep() + "}";
    }
    cdata(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.cdata) + this._sep() + this._val(data) + this._sep() + "}";
    }
    attribute(name, value) {
      return this._comma() + this._beginLine(1) + "{" + this._sep() + this._key(this._builderOptions.convert.att + name) + this._sep() + this._val(value) + this._sep() + "}";
    }
    openTagBegin(name) {
      let str = this._comma() + this._beginLine() + "{" + this._sep() + this._key(name) + this._sep() + "{";
      this._additionalLevel++;
      this.hasData = true;
      str += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[";
      this._hasChildren.push(false);
      return str;
    }
    openTagEnd(name, selfClosing, voidElement) {
      if (selfClosing) {
        let str = this._sep() + "]";
        this._additionalLevel--;
        str += this._beginLine() + "}" + this._sep() + "}";
        return str;
      } else {
        return "";
      }
    }
    closeTag(name) {
      let str = this._beginLine() + "]";
      this._additionalLevel--;
      str += this._beginLine() + "}" + this._sep() + "}";
      return str;
    }
    beginElement(name) {}
    endElement(name) {
      this._hasChildren.pop();
    }
    _beginLine(additionalOffset = 0) {
      if (this._writerOptions.prettyPrint) {
        return (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level + additionalOffset);
      } else {
        return "";
      }
    }
    _indent(level) {
      if (level + this._additionalLevel <= 0) {
        return "";
      } else {
        return this._writerOptions.indent.repeat(level + this._additionalLevel);
      }
    }
    _comma() {
      const str = this._hasChildren[this._hasChildren.length - 1] ? "," : "";
      if (this._hasChildren.length > 0) {
        this._hasChildren[this._hasChildren.length - 1] = true;
      }
      return str;
    }
    _sep() {
      return this._writerOptions.prettyPrint ? " " : "";
    }
    _key(key) {
      return '"' + key + '":';
    }
    _val(val) {
      return JSON.stringify(val);
    }
  }
  exports.JSONCBWriter = JSONCBWriter;
});

// node_modules/xmlbuilder2/lib/writers/YAMLCBWriter.js
var require_YAMLCBWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.YAMLCBWriter = undefined;
  var BaseCBWriter_1 = require_BaseCBWriter();

  class YAMLCBWriter extends BaseCBWriter_1.BaseCBWriter {
    _rootWritten = false;
    _additionalLevel = 0;
    constructor(builderOptions) {
      super(builderOptions);
      if (builderOptions.indent.length < 2) {
        throw new Error("YAML indententation string must be at least two characters long.");
      }
      if (builderOptions.offset < 0) {
        throw new Error("YAML offset should be zero or a positive number.");
      }
    }
    frontMatter() {
      return this._beginLine() + "---";
    }
    declaration(version, encoding, standalone) {
      return "";
    }
    docType(name, publicId, systemId) {
      return "";
    }
    comment(data) {
      return this._beginLine() + this._key(this._builderOptions.convert.comment) + " " + this._val(data);
    }
    text(data) {
      return this._beginLine() + this._key(this._builderOptions.convert.text) + " " + this._val(data);
    }
    instruction(target, data) {
      return this._beginLine() + this._key(this._builderOptions.convert.ins) + " " + this._val(data ? target + " " + data : target);
    }
    cdata(data) {
      return this._beginLine() + this._key(this._builderOptions.convert.cdata) + " " + this._val(data);
    }
    attribute(name, value) {
      this._additionalLevel++;
      const str = this._beginLine() + this._key(this._builderOptions.convert.att + name) + " " + this._val(value);
      this._additionalLevel--;
      return str;
    }
    openTagBegin(name) {
      let str = this._beginLine() + this._key(name);
      if (!this._rootWritten) {
        this._rootWritten = true;
      }
      this.hasData = true;
      this._additionalLevel++;
      str += this._beginLine(true) + this._key(this._builderOptions.convert.text);
      return str;
    }
    openTagEnd(name, selfClosing, voidElement) {
      if (selfClosing) {
        return " " + this._val("");
      }
      return "";
    }
    closeTag(name) {
      this._additionalLevel--;
      return "";
    }
    beginElement(name) {}
    endElement(name) {}
    _beginLine(suppressArray = false) {
      return (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level, suppressArray);
    }
    _indent(level, suppressArray) {
      if (level + this._additionalLevel <= 0) {
        return "";
      } else {
        const chars = this._writerOptions.indent.repeat(level + this._additionalLevel);
        if (!suppressArray && this._rootWritten) {
          return chars.substr(0, chars.length - 2) + "-" + chars.substr(-1, 1);
        }
        return chars;
      }
    }
    _key(key) {
      return '"' + key + '":';
    }
    _val(val) {
      return JSON.stringify(val);
    }
  }
  exports.YAMLCBWriter = YAMLCBWriter;
});

// node_modules/xmlbuilder2/lib/builder/XMLBuilderCBImpl.js
var require_XMLBuilderCBImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XMLBuilderCBImpl = undefined;
  var interfaces_1 = require_interfaces();
  var util_1 = (init_lib(), __toCommonJS(exports_lib));
  var BuilderFunctions_1 = require_BuilderFunctions();
  var algorithm_1 = require_algorithm();
  var infra_1 = require_lib7();
  var NamespacePrefixMap_1 = require_NamespacePrefixMap();
  var LocalNameSet_1 = require_LocalNameSet();
  var util_2 = require_util2();
  var XMLCBWriter_1 = require_XMLCBWriter();
  var JSONCBWriter_1 = require_JSONCBWriter();
  var YAMLCBWriter_1 = require_YAMLCBWriter();
  var events_1 = __require("events");

  class XMLBuilderCBImpl extends events_1.EventEmitter {
    static _VoidElementNames = new Set([
      "area",
      "base",
      "basefont",
      "bgsound",
      "br",
      "col",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    _options;
    _builderOptions;
    _writer;
    _fragment;
    _hasDeclaration = false;
    _docTypeName = "";
    _hasDocumentElement = false;
    _currentElement;
    _currentElementSerialized = false;
    _openTags = [];
    _prefixMap;
    _prefixIndex;
    _ended = false;
    constructor(options, fragment = false) {
      super();
      this._fragment = fragment;
      this._options = (0, util_1.applyDefaults)(options || {}, interfaces_1.DefaultXMLBuilderCBOptions);
      this._builderOptions = {
        defaultNamespace: this._options.defaultNamespace,
        namespaceAlias: this._options.namespaceAlias
      };
      if (this._options.format === "json") {
        this._writer = new JSONCBWriter_1.JSONCBWriter(this._options);
      } else if (this._options.format === "yaml") {
        this._writer = new YAMLCBWriter_1.YAMLCBWriter(this._options);
      } else {
        this._writer = new XMLCBWriter_1.XMLCBWriter(this._options);
      }
      if (this._options.data !== undefined) {
        this.on("data", this._options.data);
      }
      if (this._options.end !== undefined) {
        this.on("end", this._options.end);
      }
      if (this._options.error !== undefined) {
        this.on("error", this._options.error);
      }
      this._prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap;
      this._prefixMap.set("xml", infra_1.namespace.XML);
      this._prefixIndex = { value: 1 };
      this._push(this._writer.frontMatter());
    }
    ele(p1, p2, p3) {
      if ((0, util_1.isObject)(p1) || (0, util_1.isString)(p1) && (/^\s*</.test(p1) || /^\s*[\{\[]/.test(p1) || /^(\s*|(#.*)|(%.*))*---/.test(p1))) {
        const frag = (0, BuilderFunctions_1.fragment)().set(this._options);
        try {
          frag.ele(p1);
        } catch (err) {
          this.emit("error", err);
          return this;
        }
        for (const node of frag.node.childNodes) {
          this._fromNode(node);
        }
        return this;
      }
      this._serializeOpenTag(true);
      if (!this._fragment && this._hasDocumentElement && this._writer.level === 0) {
        this.emit("error", new Error("Document cannot have multiple document element nodes."));
        return this;
      }
      try {
        this._currentElement = (0, BuilderFunctions_1.fragment)(this._builderOptions).ele(p1, p2, p3);
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (!this._fragment && !this._hasDocumentElement && this._docTypeName !== "" && this._currentElement.node._qualifiedName !== this._docTypeName) {
        this.emit("error", new Error("Document element name does not match DocType declaration name."));
        return this;
      }
      this._currentElementSerialized = false;
      if (!this._fragment) {
        this._hasDocumentElement = true;
      }
      return this;
    }
    att(p1, p2, p3) {
      if (this._currentElement === undefined) {
        this.emit("error", new Error("Cannot insert an attribute node as child of a document node."));
        return this;
      }
      try {
        this._currentElement.att(p1, p2, p3);
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      return this;
    }
    com(content) {
      this._serializeOpenTag(true);
      let node;
      try {
        node = (0, BuilderFunctions_1.fragment)(this._builderOptions).com(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
        this.emit("error", new Error("Comment data contains invalid characters (well-formed required)."));
        return this;
      }
      this._push(this._writer.comment(node.data));
      return this;
    }
    txt(content) {
      if (!this._fragment && this._currentElement === undefined) {
        this.emit("error", new Error("Cannot insert a text node as child of a document node."));
        return this;
      }
      this._serializeOpenTag(true);
      let node;
      try {
        node = (0, BuilderFunctions_1.fragment)(this._builderOptions).txt(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && !(0, algorithm_1.xml_isLegalChar)(node.data)) {
        this.emit("error", new Error("Text data contains invalid characters (well-formed required)."));
        return this;
      }
      const markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      this._push(this._writer.text(markup));
      return this;
    }
    ins(target, content = "") {
      this._serializeOpenTag(true);
      let node;
      try {
        node = (0, BuilderFunctions_1.fragment)(this._builderOptions).ins(target, content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
        this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required)."));
        return this;
      }
      if (this._options.wellFormed && !(0, algorithm_1.xml_isLegalChar)(node.data)) {
        this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required)."));
        return this;
      }
      this._push(this._writer.instruction(node.target, node.data));
      return this;
    }
    dat(content) {
      this._serializeOpenTag(true);
      let node;
      try {
        node = (0, BuilderFunctions_1.fragment)(this._builderOptions).dat(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      this._push(this._writer.cdata(node.data));
      return this;
    }
    dec(options = { version: "1.0" }) {
      if (this._fragment) {
        this.emit("error", Error("Cannot insert an XML declaration into a document fragment."));
        return this;
      }
      if (this._hasDeclaration) {
        this.emit("error", Error("XML declaration is already inserted."));
        return this;
      }
      this._push(this._writer.declaration(options.version || "1.0", options.encoding, options.standalone));
      this._hasDeclaration = true;
      return this;
    }
    dtd(options) {
      if (this._fragment) {
        this.emit("error", Error("Cannot insert a DocType declaration into a document fragment."));
        return this;
      }
      if (this._docTypeName !== "") {
        this.emit("error", new Error("DocType declaration is already inserted."));
        return this;
      }
      if (this._hasDocumentElement) {
        this.emit("error", new Error("Cannot insert DocType declaration after document element."));
        return this;
      }
      let node;
      try {
        node = (0, BuilderFunctions_1.create)().dtd(options).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && !(0, algorithm_1.xml_isPubidChar)(node.publicId)) {
        this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required)."));
        return this;
      }
      if (this._options.wellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
        this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required)."));
        return this;
      }
      this._docTypeName = options.name;
      this._push(this._writer.docType(options.name, node.publicId, node.systemId));
      return this;
    }
    import(node) {
      const frag = (0, BuilderFunctions_1.fragment)().set(this._options);
      try {
        frag.import(node);
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      for (const node2 of frag.node.childNodes) {
        this._fromNode(node2);
      }
      return this;
    }
    up() {
      this._serializeOpenTag(false);
      this._serializeCloseTag();
      return this;
    }
    end() {
      this._serializeOpenTag(false);
      while (this._openTags.length > 0) {
        this._serializeCloseTag();
      }
      this._push(null);
      return this;
    }
    _serializeOpenTag(hasChildren) {
      if (this._currentElementSerialized)
        return;
      if (this._currentElement === undefined)
        return;
      const node = this._currentElement.node;
      if (this._options.wellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
        this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
        return;
      }
      let qualifiedName = "";
      let ignoreNamespaceDefinitionAttribute = false;
      let map = this._prefixMap.copy();
      let localPrefixesMap = {};
      let localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
      let inheritedNS = this._openTags.length === 0 ? null : this._openTags[this._openTags.length - 1][1];
      let ns = node.namespaceURI;
      if (ns === null)
        ns = inheritedNS;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node.localName;
        } else {
          qualifiedName = node.localName;
        }
        this._writer.beginElement(qualifiedName);
        this._push(this._writer.openTagBegin(qualifiedName));
      } else {
        let prefix = node.prefix;
        let candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (this._options.wellFormed) {
            this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
            return;
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map, this._prefixIndex);
          }
          map.set(prefix, ns);
          qualifiedName += prefix + ":" + node.localName;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
          this._push(this._writer.attribute("xmlns:" + prefix, this._serializeAttributeValue(ns, this._options.wellFormed)));
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node.localName;
          inheritedNS = ns;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
          this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(ns, this._options.wellFormed)));
        } else {
          qualifiedName += node.localName;
          inheritedNS = ns;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
        }
      }
      this._serializeAttributes(node, map, this._prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, this._options.wellFormed);
      const isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && !hasChildren && XMLBuilderCBImpl._VoidElementNames.has(node.localName)) {
        this._push(this._writer.openTagEnd(qualifiedName, true, true));
        this._writer.endElement(qualifiedName);
      } else if (!isHTML && !hasChildren) {
        this._push(this._writer.openTagEnd(qualifiedName, true, false));
        this._writer.endElement(qualifiedName);
      } else {
        this._push(this._writer.openTagEnd(qualifiedName, false, false));
      }
      this._currentElementSerialized = true;
      this._openTags.push([qualifiedName, inheritedNS, this._prefixMap, hasChildren]);
      if (this._isPrefixMapModified(this._prefixMap, map)) {
        this._prefixMap = map;
      }
      this._writer.level++;
    }
    _serializeCloseTag() {
      this._writer.level--;
      const lastEle = this._openTags.pop();
      if (lastEle === undefined) {
        this.emit("error", new Error("Last element is undefined."));
        return;
      }
      const [qualifiedName, ns, map, hasChildren] = lastEle;
      this._prefixMap = map;
      if (!hasChildren)
        return;
      this._push(this._writer.closeTag(qualifiedName));
      this._writer.endElement(qualifiedName);
    }
    _push(data) {
      if (data === null) {
        this._ended = true;
        this.emit("end");
      } else if (this._ended) {
        this.emit("error", new Error("Cannot push to ended stream."));
      } else if (data.length !== 0) {
        this._writer.hasData = true;
        this.emit("data", data, this._writer.level);
      }
    }
    _fromNode(node) {
      if (util_2.Guard.isElementNode(node)) {
        const name = node.prefix ? node.prefix + ":" + node.localName : node.localName;
        if (node.namespaceURI !== null) {
          this.ele(node.namespaceURI, name);
        } else {
          this.ele(name);
        }
        for (const attr of node.attributes) {
          const name2 = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
          if (attr.namespaceURI !== null) {
            this.att(attr.namespaceURI, name2, attr.value);
          } else {
            this.att(name2, attr.value);
          }
        }
        for (const child of node.childNodes) {
          this._fromNode(child);
        }
        this.up();
      } else if (util_2.Guard.isExclusiveTextNode(node) && node.data) {
        this.txt(node.data);
      } else if (util_2.Guard.isCommentNode(node)) {
        this.com(node.data);
      } else if (util_2.Guard.isCDATASectionNode(node)) {
        this.dat(node.data);
      } else if (util_2.Guard.isProcessingInstructionNode(node)) {
        this.ins(node.target, node.data);
      }
    }
    _serializeAttributes(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
      const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet : undefined;
      for (const attr of node.attributes) {
        if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
          this._push(this._writer.attribute(attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
          continue;
        }
        if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
          this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
          return;
        }
        if (requireWellFormed && localNameSet)
          localNameSet.set(attr.namespaceURI, attr.localName);
        let attributeNamespace = attr.namespaceURI;
        let candidatePrefix = null;
        if (attributeNamespace !== null) {
          candidatePrefix = map.get(attr.prefix, attributeNamespace);
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
              continue;
            if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
              this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
              return;
            }
            if (requireWellFormed && attr.value === "") {
              this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
              return;
            }
            if (attr.prefix === "xmlns")
              candidatePrefix = "xmlns";
          } else if (candidatePrefix === null) {
            if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
              candidatePrefix = attr.prefix;
            } else {
              candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
            }
            this._push(this._writer.attribute("xmlns:" + candidatePrefix, this._serializeAttributeValue(attributeNamespace, this._options.wellFormed)));
          }
        }
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
          this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
          return;
        }
        this._push(this._writer.attribute((candidatePrefix !== null ? candidatePrefix + ":" : "") + attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
      }
    }
    _serializeAttributeValue(value, requireWellFormed) {
      if (requireWellFormed && value !== null && !(0, algorithm_1.xml_isLegalChar)(value)) {
        this.emit("error", new Error("Invalid characters in attribute value."));
        return "";
      }
      if (value === null)
        return "";
      return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }
    _recordNamespaceInformation(node, map, localPrefixesMap) {
      let defaultNamespaceAttrValue = null;
      for (const attr of node.attributes) {
        let attributeNamespace = attr.namespaceURI;
        let attributePrefix = attr.prefix;
        if (attributeNamespace === infra_1.namespace.XMLNS) {
          if (attributePrefix === null) {
            defaultNamespaceAttrValue = attr.value;
            continue;
          } else {
            let prefixDefinition = attr.localName;
            let namespaceDefinition = attr.value;
            if (namespaceDefinition === infra_1.namespace.XML) {
              continue;
            }
            if (namespaceDefinition === "") {
              namespaceDefinition = null;
            }
            if (map.has(prefixDefinition, namespaceDefinition)) {
              continue;
            }
            map.set(prefixDefinition, namespaceDefinition);
            localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
          }
        }
      }
      return defaultNamespaceAttrValue;
    }
    _generatePrefix(newNamespace, prefixMap, prefixIndex) {
      let generatedPrefix = "ns" + prefixIndex.value;
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    }
    _isPrefixMapModified(originalMap, newMap) {
      const items1 = originalMap._items;
      const items2 = newMap._items;
      const nullItems1 = originalMap._nullItems;
      const nullItems2 = newMap._nullItems;
      for (const key in items2) {
        const arr1 = items1[key];
        if (arr1 === undefined)
          return true;
        const arr2 = items2[key];
        if (arr1.length !== arr2.length)
          return true;
        for (let i = 0;i < arr1.length; i++) {
          if (arr1[i] !== arr2[i])
            return true;
        }
      }
      if (nullItems1.length !== nullItems2.length)
        return true;
      for (let i = 0;i < nullItems1.length; i++) {
        if (nullItems1[i] !== nullItems2[i])
          return true;
      }
      return false;
    }
  }
  exports.XMLBuilderCBImpl = XMLBuilderCBImpl;
});

// node_modules/xmlbuilder2/lib/builder/BuilderFunctionsCB.js
var require_BuilderFunctionsCB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCB = createCB;
  exports.fragmentCB = fragmentCB;
  var _1 = require_builder();
  function createCB(options) {
    return new _1.XMLBuilderCBImpl(options);
  }
  function fragmentCB(options) {
    return new _1.XMLBuilderCBImpl(options, true);
  }
});

// node_modules/xmlbuilder2/lib/builder/index.js
var require_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fragmentCB = exports.createCB = exports.convert = exports.fragment = exports.create = exports.builder = exports.XMLBuilderCBImpl = exports.XMLBuilderImpl = undefined;
  var XMLBuilderImpl_1 = require_XMLBuilderImpl();
  Object.defineProperty(exports, "XMLBuilderImpl", { enumerable: true, get: function() {
    return XMLBuilderImpl_1.XMLBuilderImpl;
  } });
  var XMLBuilderCBImpl_1 = require_XMLBuilderCBImpl();
  Object.defineProperty(exports, "XMLBuilderCBImpl", { enumerable: true, get: function() {
    return XMLBuilderCBImpl_1.XMLBuilderCBImpl;
  } });
  var BuilderFunctions_1 = require_BuilderFunctions();
  Object.defineProperty(exports, "builder", { enumerable: true, get: function() {
    return BuilderFunctions_1.builder;
  } });
  Object.defineProperty(exports, "create", { enumerable: true, get: function() {
    return BuilderFunctions_1.create;
  } });
  Object.defineProperty(exports, "fragment", { enumerable: true, get: function() {
    return BuilderFunctions_1.fragment;
  } });
  Object.defineProperty(exports, "convert", { enumerable: true, get: function() {
    return BuilderFunctions_1.convert;
  } });
  var BuilderFunctionsCB_1 = require_BuilderFunctionsCB();
  Object.defineProperty(exports, "createCB", { enumerable: true, get: function() {
    return BuilderFunctionsCB_1.createCB;
  } });
  Object.defineProperty(exports, "fragmentCB", { enumerable: true, get: function() {
    return BuilderFunctionsCB_1.fragmentCB;
  } });
});

// node_modules/xmlbuilder2/lib/index.js
var require_lib9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fragmentCB = exports.createCB = exports.convert = exports.fragment = exports.create = exports.builder = undefined;
  var builder_1 = require_builder();
  Object.defineProperty(exports, "builder", { enumerable: true, get: function() {
    return builder_1.builder;
  } });
  Object.defineProperty(exports, "create", { enumerable: true, get: function() {
    return builder_1.create;
  } });
  Object.defineProperty(exports, "fragment", { enumerable: true, get: function() {
    return builder_1.fragment;
  } });
  Object.defineProperty(exports, "convert", { enumerable: true, get: function() {
    return builder_1.convert;
  } });
  Object.defineProperty(exports, "createCB", { enumerable: true, get: function() {
    return builder_1.createCB;
  } });
  Object.defineProperty(exports, "fragmentCB", { enumerable: true, get: function() {
    return builder_1.fragmentCB;
  } });
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports, module) => {
  (function() {
    var undefined2;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {}
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var { Array: Array2, Date: Date2, Error: Error2, Function: Function2, Math: Math2, Object: Object2, RegExp: RegExp2, String: String2, TypeError: TypeError2 } = context;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {}
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {}
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object;
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {}
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash,
          map: new (Map2 || ListCache),
          string: new Hash
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index, value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue2(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {}
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, `{
/* [wrapped with ` + details + `] */
`);
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || (key in Object2(object)));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}
          try {
            return func + "";
          } catch (e) {}
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return { done, value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + `
`;
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += `' +
__e(` + escapeValue + `) +
'`;
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += `';
` + evaluateValue + `;
__p += '`;
          }
          if (interpolateValue) {
            source += `' +
((__t = (` + interpolateValue + `)) == null ? '' : __t) +
'`;
          }
          index = offset + match.length;
          return match;
        });
        source += `';
`;
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = `with (obj) {
` + source + `
}
`;
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + `) {
` + (variable ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? `, __j = Array.prototype.join;
` + `function print() { __p += __j.call(arguments, '') }
` : `;
`) + source + `return __p
}`;
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject2(options) && ("chain" in options)) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {}
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined2 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone2;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray2;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean2;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty2;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction2;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap2;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber2;
      lodash.isObject = isObject2;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject2;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet2;
      lodash.isString = isString2;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined2 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports);
});

// node_modules/virtual-dom/vnode/is-vtext.js
var require_is_vtext = __commonJS((exports, module) => {
  var version = require_version();
  module.exports = isVirtualText;
  function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common3 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i2 = 0;i2 < namespace.length; i2++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces2) {
      createDebug.save(namespaces2);
      createDebug.namespaces = namespaces2;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces2 === "string" ? namespaces2 : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces2 = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces2;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces2) {
    try {
      if (namespaces2) {
        exports.storage.setItem("debug", namespaces2);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common3()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces2) {
    if (namespaces2) {
      process.env.DEBUG = namespaces2;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common3()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node3();
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/ace+json": {
      source: "iana",
      compressible: true
    },
    "application/ace-groupcomm+cbor": {
      source: "iana"
    },
    "application/ace-trl+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/aif+cbor": {
      source: "iana"
    },
    "application/aif+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-cdni+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-cdnifilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-propmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-propmapparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-tips+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-tipsparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/appinstaller": {
      compressible: false,
      extensions: ["appinstaller"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/appx": {
      compressible: false,
      extensions: ["appx"]
    },
    "application/appxbundle": {
      compressible: false,
      extensions: ["appxbundle"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/automationml-aml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["aml"]
    },
    "application/automationml-amlx+zip": {
      source: "iana",
      compressible: false,
      extensions: ["amlx"]
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/bufr": {
      source: "iana"
    },
    "application/c2pa": {
      source: "iana"
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/ce+cbor": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/cid-edhoc+cbor-seq": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/city+json-seq": {
      source: "iana"
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-eap": {
      source: "iana"
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/concise-problem-details+cbor": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cose-x509": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwl": {
      source: "iana",
      extensions: ["cwl"]
    },
    "application/cwl+json": {
      source: "iana",
      compressible: true
    },
    "application/cwl+yaml": {
      source: "iana"
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana",
      extensions: ["dcm"]
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dpop+jwt": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/eat+cwt": {
      source: "iana"
    },
    "application/eat+jwt": {
      source: "iana"
    },
    "application/eat-bun+cbor": {
      source: "iana"
    },
    "application/eat-bun+json": {
      source: "iana",
      compressible: true
    },
    "application/eat-ucs+cbor": {
      source: "iana"
    },
    "application/eat-ucs+json": {
      source: "iana",
      compressible: true
    },
    "application/ecmascript": {
      source: "apache",
      compressible: true,
      extensions: ["ecma"]
    },
    "application/edhoc+cbor-seq": {
      source: "iana"
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.legacyesn+json": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/entity-statement+jwt": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geopose+json": {
      source: "iana",
      compressible: true
    },
    "application/geoxacml+json": {
      source: "iana",
      compressible: true
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gnap-binding-jws": {
      source: "iana"
    },
    "application/gnap-binding-jwsd": {
      source: "iana"
    },
    "application/gnap-binding-rotation-jws": {
      source: "iana"
    },
    "application/gnap-binding-rotation-jwsd": {
      source: "iana"
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/grib": {
      source: "iana"
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "iana",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "apache",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/jscontact+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jsonpath": {
      source: "iana"
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+jwt": {
      source: "iana"
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/linkset": {
      source: "iana"
    },
    "application/linkset+json": {
      source: "iana",
      compressible: true
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/logout+jwt": {
      source: "iana"
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4", "mpg4", "mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msix": {
      compressible: false,
      extensions: ["msix"]
    },
    "application/msixbundle": {
      compressible: false,
      extensions: ["msixbundle"]
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: true,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/ohttp-keys": {
      source: "iana"
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["sig", "asc"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/private-token-issuer-directory": {
      source: "iana"
    },
    "application/private-token-request": {
      source: "iana"
    },
    "application/private-token-response": {
      source: "iana"
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/provided-claims+jwt": {
      source: "iana"
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.implied-document+xml": {
      source: "iana",
      compressible: true
    },
    "application/prs.implied-executable": {
      source: "iana"
    },
    "application/prs.implied-object+json": {
      source: "iana",
      compressible: true
    },
    "application/prs.implied-object+json-seq": {
      source: "iana"
    },
    "application/prs.implied-object+yaml": {
      source: "iana"
    },
    "application/prs.implied-structure": {
      source: "iana"
    },
    "application/prs.mayfile": {
      source: "iana"
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.vcfbzip2": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsf"]
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "apache"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resolve-response+jwt": {
      source: "iana"
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-checklist": {
      source: "iana"
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-signed-tal": {
      source: "iana"
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "apache"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana",
      extensions: ["sql"]
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/sslkeylogfile": {
      source: "iana"
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/st2110-41": {
      source: "iana"
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/stratum": {
      source: "iana"
    },
    "application/swid+cbor": {
      source: "iana"
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tm+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/toc+cbor": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      source: "iana",
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/trust-chain+json": {
      source: "iana",
      compressible: true
    },
    "application/trust-mark+jwt": {
      source: "iana"
    },
    "application/trust-mark-delegation+jwt": {
      source: "iana"
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/uccs+cbor": {
      source: "iana"
    },
    "application/ujcs+json": {
      source: "iana",
      compressible: true
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vc": {
      source: "iana"
    },
    "application/vc+cose": {
      source: "iana"
    },
    "application/vc+jwt": {
      source: "iana"
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.1ob": {
      source: "iana"
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3a+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ach+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc8+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.5gsa2x": {
      source: "iana"
    },
    "application/vnd.3gpp.5gsa2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gsv2x": {
      source: "iana"
    },
    "application/vnd.3gpp.5gsv2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.crs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.current-location-discovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-regroup+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-regroup+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-regroup+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.pinapp-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.seal-group-doc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-network-qos-management-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-ue-config-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-unicast-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-user-profile-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.v2x": {
      source: "iana"
    },
    "application/vnd.3gpp.vae-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acm.addressxfer+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.acm.chatbot+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "apache",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "apache"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.parquet": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.apexlang": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "apache"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autodesk.fbx": {
      extensions: ["fbx"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.belightsoft.lhzd+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.belightsoft.lhzl+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bzip3": {
      source: "iana"
    },
    "application/vnd.c3voc.schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.cncf.helm.chart.content.v1.tar+gzip": {
      source: "iana"
    },
    "application/vnd.cncf.helm.chart.provenance.v1.prov": {
      source: "iana"
    },
    "application/vnd.cncf.helm.config.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datalog": {
      source: "iana"
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.dcmp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dcmp"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.eln+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.erofs": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "apache",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.fdsn.stationxml+xml": {
      source: "iana",
      charset: "XML-BASED",
      compressible: true
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.freelog.comic": {
      source: "iana"
    },
    "application/vnd.frogans.fnc": {
      source: "apache",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "apache",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.ga4gh.passport+jwt": {
      source: "iana"
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.genozip": {
      source: "iana"
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gentoo.catmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gentoo.ebuild": {
      source: "iana"
    },
    "application/vnd.gentoo.eclass": {
      source: "iana"
    },
    "application/vnd.gentoo.gpkg": {
      source: "iana"
    },
    "application/vnd.gentoo.manifest": {
      source: "iana"
    },
    "application/vnd.gentoo.pkgmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gentoo.xpak": {
      source: "iana"
    },
    "application/vnd.geo+json": {
      source: "apache",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.pinboard": {
      source: "iana"
    },
    "application/vnd.geogebra.slides": {
      source: "iana",
      extensions: ["ggs"]
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.gnu.taler.exchange+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gnu.taler.merchant+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.google-apps.audio": {},
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.drawing": {
      compressible: false,
      extensions: ["gdraw"]
    },
    "application/vnd.google-apps.drive-sdk": {
      compressible: false
    },
    "application/vnd.google-apps.file": {},
    "application/vnd.google-apps.folder": {
      compressible: false
    },
    "application/vnd.google-apps.form": {
      compressible: false,
      extensions: ["gform"]
    },
    "application/vnd.google-apps.fusiontable": {},
    "application/vnd.google-apps.jam": {
      compressible: false,
      extensions: ["gjam"]
    },
    "application/vnd.google-apps.mail-layout": {},
    "application/vnd.google-apps.map": {
      compressible: false,
      extensions: ["gmap"]
    },
    "application/vnd.google-apps.photo": {},
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.script": {
      compressible: false,
      extensions: ["gscript"]
    },
    "application/vnd.google-apps.shortcut": {},
    "application/vnd.google-apps.site": {
      compressible: false,
      extensions: ["gsite"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-apps.unknown": {},
    "application/vnd.google-apps.video": {},
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdcf"]
    },
    "application/vnd.gpxsee.map+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.hsl": {
      source: "iana"
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "apache"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "apache",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "apache"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.ipfs.ipns-record": {
      source: "iana"
    },
    "application/vnd.ipld.car": {
      source: "iana"
    },
    "application/vnd.ipld.dag-cbor": {
      source: "iana"
    },
    "application/vnd.ipld.dag-json": {
      source: "iana"
    },
    "application/vnd.ipld.raw": {
      source: "iana"
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kdl": {
      source: "iana"
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.keyman.kmp+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.keyman.kmx": {
      source: "iana"
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.ldev.productlicensing": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.mdl": {
      source: "iana"
    },
    "application/vnd.mdl-mbsdf": {
      source: "iana"
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.medicalholodeck.recordxr": {
      source: "iana"
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mermaid": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.modl": {
      source: "iana"
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-visio.viewer": {
      extensions: ["vdx"]
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msgpack": {
      source: "iana"
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nato.bindingdataobject+cbor": {
      source: "iana"
    },
    "application/vnd.nato.bindingdataobject+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nato.bindingdataobject+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bdo"]
    },
    "application/vnd.nato.openxmlformats-package.iepd+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "apache",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oai.workflows": {
      source: "iana"
    },
    "application/vnd.oai.workflows+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oai.workflows+yaml": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.base": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "apache",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-master-template": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.onvif.metadata": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openvpi.dspx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.procrate.brushset": {
      extensions: ["brushset"]
    },
    "application/vnd.procreate.brush": {
      extensions: ["brush"]
    },
    "application/vnd.procreate.dream": {
      extensions: ["drm"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.pt.mundusmundi": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtm"]
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.relpipe": {
      source: "iana"
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sketchometry": {
      source: "iana"
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.smintio.portals.archive": {
      source: "iana"
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sybyl.mol2": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uic.osdm+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml", "uo"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veraison.tsm-report+cbor": {
      source: "iana"
    },
    "application/vnd.veraison.tsm-report+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vocalshaper.vsp4": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.wasmflow.wafl": {
      source: "iana"
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordlift": {
      source: "iana"
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xarin.cpj": {
      source: "iana"
    },
    "application/vnd.xecrets-encrypted": {
      source: "iana"
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/voucher-jws+json": {
      source: "iana",
      compressible: true
    },
    "application/vp": {
      source: "iana"
    },
    "application/vp+cose": {
      source: "iana"
    },
    "application/vp+jwt": {
      source: "iana"
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blender": {
      extensions: ["blend"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-compressed": {
      extensions: ["rar"]
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-ipynb+json": {
      compressible: true,
      extensions: ["ipynb"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zip-compressed": {
      extensions: ["zip"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yaml": {
      source: "iana"
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+cbor": {
      source: "iana"
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-sid+json": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zip+dotlottie": {
      extensions: ["lottie"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana",
      extensions: ["adts", "aac"]
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flac": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/matroska": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/midi-clip": {
      source: "iana"
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a", "m4b"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "apache"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      source: "iana",
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp", "dib"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/dpx": {
      source: "iana",
      extensions: ["dpx"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/j2c": {
      source: "iana"
    },
    "image/jaii": {
      source: "iana",
      extensions: ["jaii"]
    },
    "image/jais": {
      source: "iana",
      extensions: ["jais"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpg", "jpeg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm", "jpgm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxl": {
      source: "iana",
      extensions: ["jxl"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false,
      extensions: ["jfif"]
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif", "btf"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.clip": {
      source: "iana"
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "iana",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-adobe-dng": {
      extensions: ["dng"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-emf": {
      source: "iana"
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-wmf": {
      source: "iana"
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/bhttp": {
      source: "iana"
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/mls": {
      source: "iana"
    },
    "message/news": {
      source: "apache"
    },
    "message/ohttp-req": {
      source: "iana"
    },
    "message/ohttp-res": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime", "mht", "mhtml"]
    },
    "message/s-http": {
      source: "apache"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "apache"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/jt": {
      source: "iana",
      extensions: ["jt"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/prc": {
      source: "iana",
      extensions: ["prc"]
    },
    "model/step": {
      source: "iana",
      extensions: ["step", "stp", "stpnc", "p21", "210"]
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/u3d": {
      source: "iana",
      extensions: ["u3d"]
    },
    "model/vnd.bary": {
      source: "iana",
      extensions: ["bary"]
    },
    "model/vnd.cld": {
      source: "iana",
      extensions: ["cld"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana",
      extensions: ["pyo", "pyox"]
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usda": {
      source: "iana",
      extensions: ["usda"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "apache"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/hl7v2": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["md", "markdown"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/prs.texi": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.exchangeable": {
      source: "iana"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "apache"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.vcf": {
      source: "iana"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vnd.zoo.kcl": {
      source: "iana"
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/wgsl": {
      source: "iana",
      extensions: ["wgsl"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/evc": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/h266": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/lottie+json": {
      source: "iana",
      compressible: true
    },
    "video/matroska": {
      source: "iana"
    },
    "video/matroska-3d": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts", "m2t", "m2ts", "mts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.planar": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "apache"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/mime-types/mimeScore.js
var require_mimeScore = __commonJS((exports, module) => {
  var FACET_SCORES = {
    "prs.": 100,
    "x-": 200,
    "x.": 300,
    "vnd.": 400,
    default: 900
  };
  var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30
  };
  var TYPE_SCORES = {
    application: 1,
    font: 2,
    default: 0
  };
  module.exports = function mimeScore(mimeType, source = "default") {
    if (mimeType === "application/octet-stream") {
      return 0;
    }
    const [type, subtype] = mimeType.split("/");
    const facet = subtype.replace(/(\.|x-).*/, "$1");
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
  };
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var mimeScore = require_mimeScore();
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  exports._extensionConflicts = [];
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().slice(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions2, types2) {
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions2[type] = exts;
      for (var i2 = 0;i2 < exts.length; i2++) {
        var extension2 = exts[i2];
        types2[extension2] = _preferredType(extension2, types2[extension2], type);
        const legacyType = _preferredTypeLegacy(extension2, types2[extension2], type);
        if (legacyType !== types2[extension2]) {
          exports._extensionConflicts.push([extension2, legacyType, types2[extension2]]);
        }
      }
    });
  }
  function _preferredType(ext, type0, type1) {
    var score0 = type0 ? mimeScore(type0, db[type0].source) : 0;
    var score1 = type1 ? mimeScore(type1, db[type1].source) : 0;
    return score0 > score1 ? type0 : type1;
  }
  function _preferredTypeLegacy(ext, type0, type1) {
    var SOURCE_RANK = ["nginx", "apache", undefined, "iana"];
    var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
    var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
    if (exports.types[extension] !== "application/octet-stream" && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === "application/")) {
      return type0;
    }
    return score0 > score1 ? type0 : type1;
  }
});

// index.ts
var import_jszip = __toESM(require_lib3(), 1);

// node_modules/html-entities/dist/esm/named-references.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var pairDivider = "~";
var blockDivider = "~~";
function generateNamedReferences(input, prev) {
  var entities = {};
  var characters = {};
  var blocks = input.split(blockDivider);
  var isOptionalBlock = false;
  for (var i = 0;blocks.length > i; i++) {
    var entries = blocks[i].split(pairDivider);
    for (var j = 0;j < entries.length; j += 2) {
      var entity = entries[j];
      var character = entries[j + 1];
      var fullEntity = "&" + entity + ";";
      entities[fullEntity] = character;
      if (isOptionalBlock) {
        entities["&" + entity] = character;
      }
      characters[character] = fullEntity;
    }
    isOptionalBlock = true;
  }
  return prev ? { entities: __assign(__assign({}, entities), prev.entities), characters: __assign(__assign({}, characters), prev.characters) } : { entities, characters };
}
var bodyRegExps = {
  xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g
};
var namedReferences = {};
namedReferences["xml"] = generateNamedReferences(`lt~<~gt~>~quot~"~apos~'~amp~&`);
namedReferences["html4"] = generateNamedReferences("apos~'~OElig~Œ~oelig~œ~Scaron~Š~scaron~š~Yuml~Ÿ~circ~ˆ~tilde~˜~ensp~ ~emsp~ ~thinsp~ ~zwnj~‌~zwj~‍~lrm~‎~rlm~‏~ndash~–~mdash~—~lsquo~‘~rsquo~’~sbquo~‚~ldquo~“~rdquo~”~bdquo~„~dagger~†~Dagger~‡~permil~‰~lsaquo~‹~rsaquo~›~euro~€~fnof~ƒ~Alpha~Α~Beta~Β~Gamma~Γ~Delta~Δ~Epsilon~Ε~Zeta~Ζ~Eta~Η~Theta~Θ~Iota~Ι~Kappa~Κ~Lambda~Λ~Mu~Μ~Nu~Ν~Xi~Ξ~Omicron~Ο~Pi~Π~Rho~Ρ~Sigma~Σ~Tau~Τ~Upsilon~Υ~Phi~Φ~Chi~Χ~Psi~Ψ~Omega~Ω~alpha~α~beta~β~gamma~γ~delta~δ~epsilon~ε~zeta~ζ~eta~η~theta~θ~iota~ι~kappa~κ~lambda~λ~mu~μ~nu~ν~xi~ξ~omicron~ο~pi~π~rho~ρ~sigmaf~ς~sigma~σ~tau~τ~upsilon~υ~phi~φ~chi~χ~psi~ψ~omega~ω~thetasym~ϑ~upsih~ϒ~piv~ϖ~bull~•~hellip~…~prime~′~Prime~″~oline~‾~frasl~⁄~weierp~℘~image~ℑ~real~ℜ~trade~™~alefsym~ℵ~larr~←~uarr~↑~rarr~→~darr~↓~harr~↔~crarr~↵~lArr~⇐~uArr~⇑~rArr~⇒~dArr~⇓~hArr~⇔~forall~∀~part~∂~exist~∃~empty~∅~nabla~∇~isin~∈~notin~∉~ni~∋~prod~∏~sum~∑~minus~−~lowast~∗~radic~√~prop~∝~infin~∞~ang~∠~and~∧~or~∨~cap~∩~cup~∪~int~∫~there4~∴~sim~∼~cong~≅~asymp~≈~ne~≠~equiv~≡~le~≤~ge~≥~sub~⊂~sup~⊃~nsub~⊄~sube~⊆~supe~⊇~oplus~⊕~otimes~⊗~perp~⊥~sdot~⋅~lceil~⌈~rceil~⌉~lfloor~⌊~rfloor~⌋~lang~〈~rang~〉~loz~◊~spades~♠~clubs~♣~hearts~♥~diams~♦~~nbsp~ ~iexcl~¡~cent~¢~pound~£~curren~¤~yen~¥~brvbar~¦~sect~§~uml~¨~copy~©~ordf~ª~laquo~«~not~¬~shy~­~reg~®~macr~¯~deg~°~plusmn~±~sup2~²~sup3~³~acute~´~micro~µ~para~¶~middot~·~cedil~¸~sup1~¹~ordm~º~raquo~»~frac14~¼~frac12~½~frac34~¾~iquest~¿~Agrave~À~Aacute~Á~Acirc~Â~Atilde~Ã~Auml~Ä~Aring~Å~AElig~Æ~Ccedil~Ç~Egrave~È~Eacute~É~Ecirc~Ê~Euml~Ë~Igrave~Ì~Iacute~Í~Icirc~Î~Iuml~Ï~ETH~Ð~Ntilde~Ñ~Ograve~Ò~Oacute~Ó~Ocirc~Ô~Otilde~Õ~Ouml~Ö~times~×~Oslash~Ø~Ugrave~Ù~Uacute~Ú~Ucirc~Û~Uuml~Ü~Yacute~Ý~THORN~Þ~szlig~ß~agrave~à~aacute~á~acirc~â~atilde~ã~auml~ä~aring~å~aelig~æ~ccedil~ç~egrave~è~eacute~é~ecirc~ê~euml~ë~igrave~ì~iacute~í~icirc~î~iuml~ï~eth~ð~ntilde~ñ~ograve~ò~oacute~ó~ocirc~ô~otilde~õ~ouml~ö~divide~÷~oslash~ø~ugrave~ù~uacute~ú~ucirc~û~uuml~ü~yacute~ý~thorn~þ~yuml~ÿ~quot~\"~amp~&~lt~<~gt~>");
namedReferences["html5"] = generateNamedReferences("Abreve~Ă~Acy~А~Afr~\uD835\uDD04~Amacr~Ā~And~⩓~Aogon~Ą~Aopf~\uD835\uDD38~ApplyFunction~⁡~Ascr~\uD835\uDC9C~Assign~≔~Backslash~∖~Barv~⫧~Barwed~⌆~Bcy~Б~Because~∵~Bernoullis~ℬ~Bfr~\uD835\uDD05~Bopf~\uD835\uDD39~Breve~˘~Bscr~ℬ~Bumpeq~≎~CHcy~Ч~Cacute~Ć~Cap~⋒~CapitalDifferentialD~ⅅ~Cayleys~ℭ~Ccaron~Č~Ccirc~Ĉ~Cconint~∰~Cdot~Ċ~Cedilla~¸~CenterDot~·~Cfr~ℭ~CircleDot~⊙~CircleMinus~⊖~CirclePlus~⊕~CircleTimes~⊗~ClockwiseContourIntegral~∲~CloseCurlyDoubleQuote~”~CloseCurlyQuote~’~Colon~∷~Colone~⩴~Congruent~≡~Conint~∯~ContourIntegral~∮~Copf~ℂ~Coproduct~∐~CounterClockwiseContourIntegral~∳~Cross~⨯~Cscr~\uD835\uDC9E~Cup~⋓~CupCap~≍~DD~ⅅ~DDotrahd~⤑~DJcy~Ђ~DScy~Ѕ~DZcy~Џ~Darr~↡~Dashv~⫤~Dcaron~Ď~Dcy~Д~Del~∇~Dfr~\uD835\uDD07~DiacriticalAcute~´~DiacriticalDot~˙~DiacriticalDoubleAcute~˝~DiacriticalGrave~`~DiacriticalTilde~˜~Diamond~⋄~DifferentialD~ⅆ~Dopf~\uD835\uDD3B~Dot~¨~DotDot~⃜~DotEqual~≐~DoubleContourIntegral~∯~DoubleDot~¨~DoubleDownArrow~⇓~DoubleLeftArrow~⇐~DoubleLeftRightArrow~⇔~DoubleLeftTee~⫤~DoubleLongLeftArrow~⟸~DoubleLongLeftRightArrow~⟺~DoubleLongRightArrow~⟹~DoubleRightArrow~⇒~DoubleRightTee~⊨~DoubleUpArrow~⇑~DoubleUpDownArrow~⇕~DoubleVerticalBar~∥~DownArrow~↓~DownArrowBar~⤓~DownArrowUpArrow~⇵~DownBreve~̑~DownLeftRightVector~⥐~DownLeftTeeVector~⥞~DownLeftVector~↽~DownLeftVectorBar~⥖~DownRightTeeVector~⥟~DownRightVector~⇁~DownRightVectorBar~⥗~DownTee~⊤~DownTeeArrow~↧~Downarrow~⇓~Dscr~\uD835\uDC9F~Dstrok~Đ~ENG~Ŋ~Ecaron~Ě~Ecy~Э~Edot~Ė~Efr~\uD835\uDD08~Element~∈~Emacr~Ē~EmptySmallSquare~◻~EmptyVerySmallSquare~▫~Eogon~Ę~Eopf~\uD835\uDD3C~Equal~⩵~EqualTilde~≂~Equilibrium~⇌~Escr~ℰ~Esim~⩳~Exists~∃~ExponentialE~ⅇ~Fcy~Ф~Ffr~\uD835\uDD09~FilledSmallSquare~◼~FilledVerySmallSquare~▪~Fopf~\uD835\uDD3D~ForAll~∀~Fouriertrf~ℱ~Fscr~ℱ~GJcy~Ѓ~Gammad~Ϝ~Gbreve~Ğ~Gcedil~Ģ~Gcirc~Ĝ~Gcy~Г~Gdot~Ġ~Gfr~\uD835\uDD0A~Gg~⋙~Gopf~\uD835\uDD3E~GreaterEqual~≥~GreaterEqualLess~⋛~GreaterFullEqual~≧~GreaterGreater~⪢~GreaterLess~≷~GreaterSlantEqual~⩾~GreaterTilde~≳~Gscr~\uD835\uDCA2~Gt~≫~HARDcy~Ъ~Hacek~ˇ~Hat~^~Hcirc~Ĥ~Hfr~ℌ~HilbertSpace~ℋ~Hopf~ℍ~HorizontalLine~─~Hscr~ℋ~Hstrok~Ħ~HumpDownHump~≎~HumpEqual~≏~IEcy~Е~IJlig~Ĳ~IOcy~Ё~Icy~И~Idot~İ~Ifr~ℑ~Im~ℑ~Imacr~Ī~ImaginaryI~ⅈ~Implies~⇒~Int~∬~Integral~∫~Intersection~⋂~InvisibleComma~⁣~InvisibleTimes~⁢~Iogon~Į~Iopf~\uD835\uDD40~Iscr~ℐ~Itilde~Ĩ~Iukcy~І~Jcirc~Ĵ~Jcy~Й~Jfr~\uD835\uDD0D~Jopf~\uD835\uDD41~Jscr~\uD835\uDCA5~Jsercy~Ј~Jukcy~Є~KHcy~Х~KJcy~Ќ~Kcedil~Ķ~Kcy~К~Kfr~\uD835\uDD0E~Kopf~\uD835\uDD42~Kscr~\uD835\uDCA6~LJcy~Љ~Lacute~Ĺ~Lang~⟪~Laplacetrf~ℒ~Larr~↞~Lcaron~Ľ~Lcedil~Ļ~Lcy~Л~LeftAngleBracket~⟨~LeftArrow~←~LeftArrowBar~⇤~LeftArrowRightArrow~⇆~LeftCeiling~⌈~LeftDoubleBracket~⟦~LeftDownTeeVector~⥡~LeftDownVector~⇃~LeftDownVectorBar~⥙~LeftFloor~⌊~LeftRightArrow~↔~LeftRightVector~⥎~LeftTee~⊣~LeftTeeArrow~↤~LeftTeeVector~⥚~LeftTriangle~⊲~LeftTriangleBar~⧏~LeftTriangleEqual~⊴~LeftUpDownVector~⥑~LeftUpTeeVector~⥠~LeftUpVector~↿~LeftUpVectorBar~⥘~LeftVector~↼~LeftVectorBar~⥒~Leftarrow~⇐~Leftrightarrow~⇔~LessEqualGreater~⋚~LessFullEqual~≦~LessGreater~≶~LessLess~⪡~LessSlantEqual~⩽~LessTilde~≲~Lfr~\uD835\uDD0F~Ll~⋘~Lleftarrow~⇚~Lmidot~Ŀ~LongLeftArrow~⟵~LongLeftRightArrow~⟷~LongRightArrow~⟶~Longleftarrow~⟸~Longleftrightarrow~⟺~Longrightarrow~⟹~Lopf~\uD835\uDD43~LowerLeftArrow~↙~LowerRightArrow~↘~Lscr~ℒ~Lsh~↰~Lstrok~Ł~Lt~≪~Map~⤅~Mcy~М~MediumSpace~ ~Mellintrf~ℳ~Mfr~\uD835\uDD10~MinusPlus~∓~Mopf~\uD835\uDD44~Mscr~ℳ~NJcy~Њ~Nacute~Ń~Ncaron~Ň~Ncedil~Ņ~Ncy~Н~NegativeMediumSpace~​~NegativeThickSpace~​~NegativeThinSpace~​~NegativeVeryThinSpace~​~NestedGreaterGreater~≫~NestedLessLess~≪~NewLine~\n~Nfr~\uD835\uDD11~NoBreak~⁠~NonBreakingSpace~ ~Nopf~ℕ~Not~⫬~NotCongruent~≢~NotCupCap~≭~NotDoubleVerticalBar~∦~NotElement~∉~NotEqual~≠~NotEqualTilde~≂̸~NotExists~∄~NotGreater~≯~NotGreaterEqual~≱~NotGreaterFullEqual~≧̸~NotGreaterGreater~≫̸~NotGreaterLess~≹~NotGreaterSlantEqual~⩾̸~NotGreaterTilde~≵~NotHumpDownHump~≎̸~NotHumpEqual~≏̸~NotLeftTriangle~⋪~NotLeftTriangleBar~⧏̸~NotLeftTriangleEqual~⋬~NotLess~≮~NotLessEqual~≰~NotLessGreater~≸~NotLessLess~≪̸~NotLessSlantEqual~⩽̸~NotLessTilde~≴~NotNestedGreaterGreater~⪢̸~NotNestedLessLess~⪡̸~NotPrecedes~⊀~NotPrecedesEqual~⪯̸~NotPrecedesSlantEqual~⋠~NotReverseElement~∌~NotRightTriangle~⋫~NotRightTriangleBar~⧐̸~NotRightTriangleEqual~⋭~NotSquareSubset~⊏̸~NotSquareSubsetEqual~⋢~NotSquareSuperset~⊐̸~NotSquareSupersetEqual~⋣~NotSubset~⊂⃒~NotSubsetEqual~⊈~NotSucceeds~⊁~NotSucceedsEqual~⪰̸~NotSucceedsSlantEqual~⋡~NotSucceedsTilde~≿̸~NotSuperset~⊃⃒~NotSupersetEqual~⊉~NotTilde~≁~NotTildeEqual~≄~NotTildeFullEqual~≇~NotTildeTilde~≉~NotVerticalBar~∤~Nscr~\uD835\uDCA9~Ocy~О~Odblac~Ő~Ofr~\uD835\uDD12~Omacr~Ō~Oopf~\uD835\uDD46~OpenCurlyDoubleQuote~“~OpenCurlyQuote~‘~Or~⩔~Oscr~\uD835\uDCAA~Otimes~⨷~OverBar~‾~OverBrace~⏞~OverBracket~⎴~OverParenthesis~⏜~PartialD~∂~Pcy~П~Pfr~\uD835\uDD13~PlusMinus~±~Poincareplane~ℌ~Popf~ℙ~Pr~⪻~Precedes~≺~PrecedesEqual~⪯~PrecedesSlantEqual~≼~PrecedesTilde~≾~Product~∏~Proportion~∷~Proportional~∝~Pscr~\uD835\uDCAB~Qfr~\uD835\uDD14~Qopf~ℚ~Qscr~\uD835\uDCAC~RBarr~⤐~Racute~Ŕ~Rang~⟫~Rarr~↠~Rarrtl~⤖~Rcaron~Ř~Rcedil~Ŗ~Rcy~Р~Re~ℜ~ReverseElement~∋~ReverseEquilibrium~⇋~ReverseUpEquilibrium~⥯~Rfr~ℜ~RightAngleBracket~⟩~RightArrow~→~RightArrowBar~⇥~RightArrowLeftArrow~⇄~RightCeiling~⌉~RightDoubleBracket~⟧~RightDownTeeVector~⥝~RightDownVector~⇂~RightDownVectorBar~⥕~RightFloor~⌋~RightTee~⊢~RightTeeArrow~↦~RightTeeVector~⥛~RightTriangle~⊳~RightTriangleBar~⧐~RightTriangleEqual~⊵~RightUpDownVector~⥏~RightUpTeeVector~⥜~RightUpVector~↾~RightUpVectorBar~⥔~RightVector~⇀~RightVectorBar~⥓~Rightarrow~⇒~Ropf~ℝ~RoundImplies~⥰~Rrightarrow~⇛~Rscr~ℛ~Rsh~↱~RuleDelayed~⧴~SHCHcy~Щ~SHcy~Ш~SOFTcy~Ь~Sacute~Ś~Sc~⪼~Scedil~Ş~Scirc~Ŝ~Scy~С~Sfr~\uD835\uDD16~ShortDownArrow~↓~ShortLeftArrow~←~ShortRightArrow~→~ShortUpArrow~↑~SmallCircle~∘~Sopf~\uD835\uDD4A~Sqrt~√~Square~□~SquareIntersection~⊓~SquareSubset~⊏~SquareSubsetEqual~⊑~SquareSuperset~⊐~SquareSupersetEqual~⊒~SquareUnion~⊔~Sscr~\uD835\uDCAE~Star~⋆~Sub~⋐~Subset~⋐~SubsetEqual~⊆~Succeeds~≻~SucceedsEqual~⪰~SucceedsSlantEqual~≽~SucceedsTilde~≿~SuchThat~∋~Sum~∑~Sup~⋑~Superset~⊃~SupersetEqual~⊇~Supset~⋑~TRADE~™~TSHcy~Ћ~TScy~Ц~Tab~\t~Tcaron~Ť~Tcedil~Ţ~Tcy~Т~Tfr~\uD835\uDD17~Therefore~∴~ThickSpace~  ~ThinSpace~ ~Tilde~∼~TildeEqual~≃~TildeFullEqual~≅~TildeTilde~≈~Topf~\uD835\uDD4B~TripleDot~⃛~Tscr~\uD835\uDCAF~Tstrok~Ŧ~Uarr~↟~Uarrocir~⥉~Ubrcy~Ў~Ubreve~Ŭ~Ucy~У~Udblac~Ű~Ufr~\uD835\uDD18~Umacr~Ū~UnderBar~_~UnderBrace~⏟~UnderBracket~⎵~UnderParenthesis~⏝~Union~⋃~UnionPlus~⊎~Uogon~Ų~Uopf~\uD835\uDD4C~UpArrow~↑~UpArrowBar~⤒~UpArrowDownArrow~⇅~UpDownArrow~↕~UpEquilibrium~⥮~UpTee~⊥~UpTeeArrow~↥~Uparrow~⇑~Updownarrow~⇕~UpperLeftArrow~↖~UpperRightArrow~↗~Upsi~ϒ~Uring~Ů~Uscr~\uD835\uDCB0~Utilde~Ũ~VDash~⊫~Vbar~⫫~Vcy~В~Vdash~⊩~Vdashl~⫦~Vee~⋁~Verbar~‖~Vert~‖~VerticalBar~∣~VerticalLine~|~VerticalSeparator~❘~VerticalTilde~≀~VeryThinSpace~ ~Vfr~\uD835\uDD19~Vopf~\uD835\uDD4D~Vscr~\uD835\uDCB1~Vvdash~⊪~Wcirc~Ŵ~Wedge~⋀~Wfr~\uD835\uDD1A~Wopf~\uD835\uDD4E~Wscr~\uD835\uDCB2~Xfr~\uD835\uDD1B~Xopf~\uD835\uDD4F~Xscr~\uD835\uDCB3~YAcy~Я~YIcy~Ї~YUcy~Ю~Ycirc~Ŷ~Ycy~Ы~Yfr~\uD835\uDD1C~Yopf~\uD835\uDD50~Yscr~\uD835\uDCB4~ZHcy~Ж~Zacute~Ź~Zcaron~Ž~Zcy~З~Zdot~Ż~ZeroWidthSpace~​~Zfr~ℨ~Zopf~ℤ~Zscr~\uD835\uDCB5~abreve~ă~ac~∾~acE~∾̳~acd~∿~acy~а~af~⁡~afr~\uD835\uDD1E~aleph~ℵ~amacr~ā~amalg~⨿~andand~⩕~andd~⩜~andslope~⩘~andv~⩚~ange~⦤~angle~∠~angmsd~∡~angmsdaa~⦨~angmsdab~⦩~angmsdac~⦪~angmsdad~⦫~angmsdae~⦬~angmsdaf~⦭~angmsdag~⦮~angmsdah~⦯~angrt~∟~angrtvb~⊾~angrtvbd~⦝~angsph~∢~angst~Å~angzarr~⍼~aogon~ą~aopf~\uD835\uDD52~ap~≈~apE~⩰~apacir~⩯~ape~≊~apid~≋~approx~≈~approxeq~≊~ascr~\uD835\uDCB6~ast~*~asympeq~≍~awconint~∳~awint~⨑~bNot~⫭~backcong~≌~backepsilon~϶~backprime~‵~backsim~∽~backsimeq~⋍~barvee~⊽~barwed~⌅~barwedge~⌅~bbrk~⎵~bbrktbrk~⎶~bcong~≌~bcy~б~becaus~∵~because~∵~bemptyv~⦰~bepsi~϶~bernou~ℬ~beth~ℶ~between~≬~bfr~\uD835\uDD1F~bigcap~⋂~bigcirc~◯~bigcup~⋃~bigodot~⨀~bigoplus~⨁~bigotimes~⨂~bigsqcup~⨆~bigstar~★~bigtriangledown~▽~bigtriangleup~△~biguplus~⨄~bigvee~⋁~bigwedge~⋀~bkarow~⤍~blacklozenge~⧫~blacksquare~▪~blacktriangle~▴~blacktriangledown~▾~blacktriangleleft~◂~blacktriangleright~▸~blank~␣~blk12~▒~blk14~░~blk34~▓~block~█~bne~=⃥~bnequiv~≡⃥~bnot~⌐~bopf~\uD835\uDD53~bot~⊥~bottom~⊥~bowtie~⋈~boxDL~╗~boxDR~╔~boxDl~╖~boxDr~╓~boxH~═~boxHD~╦~boxHU~╩~boxHd~╤~boxHu~╧~boxUL~╝~boxUR~╚~boxUl~╜~boxUr~╙~boxV~║~boxVH~╬~boxVL~╣~boxVR~╠~boxVh~╫~boxVl~╢~boxVr~╟~boxbox~⧉~boxdL~╕~boxdR~╒~boxdl~┐~boxdr~┌~boxh~─~boxhD~╥~boxhU~╨~boxhd~┬~boxhu~┴~boxminus~⊟~boxplus~⊞~boxtimes~⊠~boxuL~╛~boxuR~╘~boxul~┘~boxur~└~boxv~│~boxvH~╪~boxvL~╡~boxvR~╞~boxvh~┼~boxvl~┤~boxvr~├~bprime~‵~breve~˘~bscr~\uD835\uDCB7~bsemi~⁏~bsim~∽~bsime~⋍~bsol~\\~bsolb~⧅~bsolhsub~⟈~bullet~•~bump~≎~bumpE~⪮~bumpe~≏~bumpeq~≏~cacute~ć~capand~⩄~capbrcup~⩉~capcap~⩋~capcup~⩇~capdot~⩀~caps~∩︀~caret~⁁~caron~ˇ~ccaps~⩍~ccaron~č~ccirc~ĉ~ccups~⩌~ccupssm~⩐~cdot~ċ~cemptyv~⦲~centerdot~·~cfr~\uD835\uDD20~chcy~ч~check~✓~checkmark~✓~cir~○~cirE~⧃~circeq~≗~circlearrowleft~↺~circlearrowright~↻~circledR~®~circledS~Ⓢ~circledast~⊛~circledcirc~⊚~circleddash~⊝~cire~≗~cirfnint~⨐~cirmid~⫯~cirscir~⧂~clubsuit~♣~colon~:~colone~≔~coloneq~≔~comma~,~commat~@~comp~∁~compfn~∘~complement~∁~complexes~ℂ~congdot~⩭~conint~∮~copf~\uD835\uDD54~coprod~∐~copysr~℗~cross~✗~cscr~\uD835\uDCB8~csub~⫏~csube~⫑~csup~⫐~csupe~⫒~ctdot~⋯~cudarrl~⤸~cudarrr~⤵~cuepr~⋞~cuesc~⋟~cularr~↶~cularrp~⤽~cupbrcap~⩈~cupcap~⩆~cupcup~⩊~cupdot~⊍~cupor~⩅~cups~∪︀~curarr~↷~curarrm~⤼~curlyeqprec~⋞~curlyeqsucc~⋟~curlyvee~⋎~curlywedge~⋏~curvearrowleft~↶~curvearrowright~↷~cuvee~⋎~cuwed~⋏~cwconint~∲~cwint~∱~cylcty~⌭~dHar~⥥~daleth~ℸ~dash~‐~dashv~⊣~dbkarow~⤏~dblac~˝~dcaron~ď~dcy~д~dd~ⅆ~ddagger~‡~ddarr~⇊~ddotseq~⩷~demptyv~⦱~dfisht~⥿~dfr~\uD835\uDD21~dharl~⇃~dharr~⇂~diam~⋄~diamond~⋄~diamondsuit~♦~die~¨~digamma~ϝ~disin~⋲~div~÷~divideontimes~⋇~divonx~⋇~djcy~ђ~dlcorn~⌞~dlcrop~⌍~dollar~$~dopf~\uD835\uDD55~dot~˙~doteq~≐~doteqdot~≑~dotminus~∸~dotplus~∔~dotsquare~⊡~doublebarwedge~⌆~downarrow~↓~downdownarrows~⇊~downharpoonleft~⇃~downharpoonright~⇂~drbkarow~⤐~drcorn~⌟~drcrop~⌌~dscr~\uD835\uDCB9~dscy~ѕ~dsol~⧶~dstrok~đ~dtdot~⋱~dtri~▿~dtrif~▾~duarr~⇵~duhar~⥯~dwangle~⦦~dzcy~џ~dzigrarr~⟿~eDDot~⩷~eDot~≑~easter~⩮~ecaron~ě~ecir~≖~ecolon~≕~ecy~э~edot~ė~ee~ⅇ~efDot~≒~efr~\uD835\uDD22~eg~⪚~egs~⪖~egsdot~⪘~el~⪙~elinters~⏧~ell~ℓ~els~⪕~elsdot~⪗~emacr~ē~emptyset~∅~emptyv~∅~emsp13~ ~emsp14~ ~eng~ŋ~eogon~ę~eopf~\uD835\uDD56~epar~⋕~eparsl~⧣~eplus~⩱~epsi~ε~epsiv~ϵ~eqcirc~≖~eqcolon~≕~eqsim~≂~eqslantgtr~⪖~eqslantless~⪕~equals~=~equest~≟~equivDD~⩸~eqvparsl~⧥~erDot~≓~erarr~⥱~escr~ℯ~esdot~≐~esim~≂~excl~!~expectation~ℰ~exponentiale~ⅇ~fallingdotseq~≒~fcy~ф~female~♀~ffilig~ﬃ~fflig~ﬀ~ffllig~ﬄ~ffr~\uD835\uDD23~filig~ﬁ~fjlig~fj~flat~♭~fllig~ﬂ~fltns~▱~fopf~\uD835\uDD57~fork~⋔~forkv~⫙~fpartint~⨍~frac13~⅓~frac15~⅕~frac16~⅙~frac18~⅛~frac23~⅔~frac25~⅖~frac35~⅗~frac38~⅜~frac45~⅘~frac56~⅚~frac58~⅝~frac78~⅞~frown~⌢~fscr~\uD835\uDCBB~gE~≧~gEl~⪌~gacute~ǵ~gammad~ϝ~gap~⪆~gbreve~ğ~gcirc~ĝ~gcy~г~gdot~ġ~gel~⋛~geq~≥~geqq~≧~geqslant~⩾~ges~⩾~gescc~⪩~gesdot~⪀~gesdoto~⪂~gesdotol~⪄~gesl~⋛︀~gesles~⪔~gfr~\uD835\uDD24~gg~≫~ggg~⋙~gimel~ℷ~gjcy~ѓ~gl~≷~glE~⪒~gla~⪥~glj~⪤~gnE~≩~gnap~⪊~gnapprox~⪊~gne~⪈~gneq~⪈~gneqq~≩~gnsim~⋧~gopf~\uD835\uDD58~grave~`~gscr~ℊ~gsim~≳~gsime~⪎~gsiml~⪐~gtcc~⪧~gtcir~⩺~gtdot~⋗~gtlPar~⦕~gtquest~⩼~gtrapprox~⪆~gtrarr~⥸~gtrdot~⋗~gtreqless~⋛~gtreqqless~⪌~gtrless~≷~gtrsim~≳~gvertneqq~≩︀~gvnE~≩︀~hairsp~ ~half~½~hamilt~ℋ~hardcy~ъ~harrcir~⥈~harrw~↭~hbar~ℏ~hcirc~ĥ~heartsuit~♥~hercon~⊹~hfr~\uD835\uDD25~hksearow~⤥~hkswarow~⤦~hoarr~⇿~homtht~∻~hookleftarrow~↩~hookrightarrow~↪~hopf~\uD835\uDD59~horbar~―~hscr~\uD835\uDCBD~hslash~ℏ~hstrok~ħ~hybull~⁃~hyphen~‐~ic~⁣~icy~и~iecy~е~iff~⇔~ifr~\uD835\uDD26~ii~ⅈ~iiiint~⨌~iiint~∭~iinfin~⧜~iiota~℩~ijlig~ĳ~imacr~ī~imagline~ℐ~imagpart~ℑ~imath~ı~imof~⊷~imped~Ƶ~in~∈~incare~℅~infintie~⧝~inodot~ı~intcal~⊺~integers~ℤ~intercal~⊺~intlarhk~⨗~intprod~⨼~iocy~ё~iogon~į~iopf~\uD835\uDD5A~iprod~⨼~iscr~\uD835\uDCBE~isinE~⋹~isindot~⋵~isins~⋴~isinsv~⋳~isinv~∈~it~⁢~itilde~ĩ~iukcy~і~jcirc~ĵ~jcy~й~jfr~\uD835\uDD27~jmath~ȷ~jopf~\uD835\uDD5B~jscr~\uD835\uDCBF~jsercy~ј~jukcy~є~kappav~ϰ~kcedil~ķ~kcy~к~kfr~\uD835\uDD28~kgreen~ĸ~khcy~х~kjcy~ќ~kopf~\uD835\uDD5C~kscr~\uD835\uDCC0~lAarr~⇚~lAtail~⤛~lBarr~⤎~lE~≦~lEg~⪋~lHar~⥢~lacute~ĺ~laemptyv~⦴~lagran~ℒ~langd~⦑~langle~⟨~lap~⪅~larrb~⇤~larrbfs~⤟~larrfs~⤝~larrhk~↩~larrlp~↫~larrpl~⤹~larrsim~⥳~larrtl~↢~lat~⪫~latail~⤙~late~⪭~lates~⪭︀~lbarr~⤌~lbbrk~❲~lbrace~{~lbrack~[~lbrke~⦋~lbrksld~⦏~lbrkslu~⦍~lcaron~ľ~lcedil~ļ~lcub~{~lcy~л~ldca~⤶~ldquor~„~ldrdhar~⥧~ldrushar~⥋~ldsh~↲~leftarrow~←~leftarrowtail~↢~leftharpoondown~↽~leftharpoonup~↼~leftleftarrows~⇇~leftrightarrow~↔~leftrightarrows~⇆~leftrightharpoons~⇋~leftrightsquigarrow~↭~leftthreetimes~⋋~leg~⋚~leq~≤~leqq~≦~leqslant~⩽~les~⩽~lescc~⪨~lesdot~⩿~lesdoto~⪁~lesdotor~⪃~lesg~⋚︀~lesges~⪓~lessapprox~⪅~lessdot~⋖~lesseqgtr~⋚~lesseqqgtr~⪋~lessgtr~≶~lesssim~≲~lfisht~⥼~lfr~\uD835\uDD29~lg~≶~lgE~⪑~lhard~↽~lharu~↼~lharul~⥪~lhblk~▄~ljcy~љ~ll~≪~llarr~⇇~llcorner~⌞~llhard~⥫~lltri~◺~lmidot~ŀ~lmoust~⎰~lmoustache~⎰~lnE~≨~lnap~⪉~lnapprox~⪉~lne~⪇~lneq~⪇~lneqq~≨~lnsim~⋦~loang~⟬~loarr~⇽~lobrk~⟦~longleftarrow~⟵~longleftrightarrow~⟷~longmapsto~⟼~longrightarrow~⟶~looparrowleft~↫~looparrowright~↬~lopar~⦅~lopf~\uD835\uDD5D~loplus~⨭~lotimes~⨴~lowbar~_~lozenge~◊~lozf~⧫~lpar~(~lparlt~⦓~lrarr~⇆~lrcorner~⌟~lrhar~⇋~lrhard~⥭~lrtri~⊿~lscr~\uD835\uDCC1~lsh~↰~lsim~≲~lsime~⪍~lsimg~⪏~lsqb~[~lsquor~‚~lstrok~ł~ltcc~⪦~ltcir~⩹~ltdot~⋖~lthree~⋋~ltimes~⋉~ltlarr~⥶~ltquest~⩻~ltrPar~⦖~ltri~◃~ltrie~⊴~ltrif~◂~lurdshar~⥊~luruhar~⥦~lvertneqq~≨︀~lvnE~≨︀~mDDot~∺~male~♂~malt~✠~maltese~✠~map~↦~mapsto~↦~mapstodown~↧~mapstoleft~↤~mapstoup~↥~marker~▮~mcomma~⨩~mcy~м~measuredangle~∡~mfr~\uD835\uDD2A~mho~℧~mid~∣~midast~*~midcir~⫰~minusb~⊟~minusd~∸~minusdu~⨪~mlcp~⫛~mldr~…~mnplus~∓~models~⊧~mopf~\uD835\uDD5E~mp~∓~mscr~\uD835\uDCC2~mstpos~∾~multimap~⊸~mumap~⊸~nGg~⋙̸~nGt~≫⃒~nGtv~≫̸~nLeftarrow~⇍~nLeftrightarrow~⇎~nLl~⋘̸~nLt~≪⃒~nLtv~≪̸~nRightarrow~⇏~nVDash~⊯~nVdash~⊮~nacute~ń~nang~∠⃒~nap~≉~napE~⩰̸~napid~≋̸~napos~ŉ~napprox~≉~natur~♮~natural~♮~naturals~ℕ~nbump~≎̸~nbumpe~≏̸~ncap~⩃~ncaron~ň~ncedil~ņ~ncong~≇~ncongdot~⩭̸~ncup~⩂~ncy~н~neArr~⇗~nearhk~⤤~nearr~↗~nearrow~↗~nedot~≐̸~nequiv~≢~nesear~⤨~nesim~≂̸~nexist~∄~nexists~∄~nfr~\uD835\uDD2B~ngE~≧̸~nge~≱~ngeq~≱~ngeqq~≧̸~ngeqslant~⩾̸~nges~⩾̸~ngsim~≵~ngt~≯~ngtr~≯~nhArr~⇎~nharr~↮~nhpar~⫲~nis~⋼~nisd~⋺~niv~∋~njcy~њ~nlArr~⇍~nlE~≦̸~nlarr~↚~nldr~‥~nle~≰~nleftarrow~↚~nleftrightarrow~↮~nleq~≰~nleqq~≦̸~nleqslant~⩽̸~nles~⩽̸~nless~≮~nlsim~≴~nlt~≮~nltri~⋪~nltrie~⋬~nmid~∤~nopf~\uD835\uDD5F~notinE~⋹̸~notindot~⋵̸~notinva~∉~notinvb~⋷~notinvc~⋶~notni~∌~notniva~∌~notnivb~⋾~notnivc~⋽~npar~∦~nparallel~∦~nparsl~⫽⃥~npart~∂̸~npolint~⨔~npr~⊀~nprcue~⋠~npre~⪯̸~nprec~⊀~npreceq~⪯̸~nrArr~⇏~nrarr~↛~nrarrc~⤳̸~nrarrw~↝̸~nrightarrow~↛~nrtri~⋫~nrtrie~⋭~nsc~⊁~nsccue~⋡~nsce~⪰̸~nscr~\uD835\uDCC3~nshortmid~∤~nshortparallel~∦~nsim~≁~nsime~≄~nsimeq~≄~nsmid~∤~nspar~∦~nsqsube~⋢~nsqsupe~⋣~nsubE~⫅̸~nsube~⊈~nsubset~⊂⃒~nsubseteq~⊈~nsubseteqq~⫅̸~nsucc~⊁~nsucceq~⪰̸~nsup~⊅~nsupE~⫆̸~nsupe~⊉~nsupset~⊃⃒~nsupseteq~⊉~nsupseteqq~⫆̸~ntgl~≹~ntlg~≸~ntriangleleft~⋪~ntrianglelefteq~⋬~ntriangleright~⋫~ntrianglerighteq~⋭~num~#~numero~№~numsp~ ~nvDash~⊭~nvHarr~⤄~nvap~≍⃒~nvdash~⊬~nvge~≥⃒~nvgt~>⃒~nvinfin~⧞~nvlArr~⤂~nvle~≤⃒~nvlt~<⃒~nvltrie~⊴⃒~nvrArr~⤃~nvrtrie~⊵⃒~nvsim~∼⃒~nwArr~⇖~nwarhk~⤣~nwarr~↖~nwarrow~↖~nwnear~⤧~oS~Ⓢ~oast~⊛~ocir~⊚~ocy~о~odash~⊝~odblac~ő~odiv~⨸~odot~⊙~odsold~⦼~ofcir~⦿~ofr~\uD835\uDD2C~ogon~˛~ogt~⧁~ohbar~⦵~ohm~Ω~oint~∮~olarr~↺~olcir~⦾~olcross~⦻~olt~⧀~omacr~ō~omid~⦶~ominus~⊖~oopf~\uD835\uDD60~opar~⦷~operp~⦹~orarr~↻~ord~⩝~order~ℴ~orderof~ℴ~origof~⊶~oror~⩖~orslope~⩗~orv~⩛~oscr~ℴ~osol~⊘~otimesas~⨶~ovbar~⌽~par~∥~parallel~∥~parsim~⫳~parsl~⫽~pcy~п~percnt~%~period~.~pertenk~‱~pfr~\uD835\uDD2D~phiv~ϕ~phmmat~ℳ~phone~☎~pitchfork~⋔~planck~ℏ~planckh~ℎ~plankv~ℏ~plus~+~plusacir~⨣~plusb~⊞~pluscir~⨢~plusdo~∔~plusdu~⨥~pluse~⩲~plussim~⨦~plustwo~⨧~pm~±~pointint~⨕~popf~\uD835\uDD61~pr~≺~prE~⪳~prap~⪷~prcue~≼~pre~⪯~prec~≺~precapprox~⪷~preccurlyeq~≼~preceq~⪯~precnapprox~⪹~precneqq~⪵~precnsim~⋨~precsim~≾~primes~ℙ~prnE~⪵~prnap~⪹~prnsim~⋨~profalar~⌮~profline~⌒~profsurf~⌓~propto~∝~prsim~≾~prurel~⊰~pscr~\uD835\uDCC5~puncsp~ ~qfr~\uD835\uDD2E~qint~⨌~qopf~\uD835\uDD62~qprime~⁗~qscr~\uD835\uDCC6~quaternions~ℍ~quatint~⨖~quest~?~questeq~≟~rAarr~⇛~rAtail~⤜~rBarr~⤏~rHar~⥤~race~∽̱~racute~ŕ~raemptyv~⦳~rangd~⦒~range~⦥~rangle~⟩~rarrap~⥵~rarrb~⇥~rarrbfs~⤠~rarrc~⤳~rarrfs~⤞~rarrhk~↪~rarrlp~↬~rarrpl~⥅~rarrsim~⥴~rarrtl~↣~rarrw~↝~ratail~⤚~ratio~∶~rationals~ℚ~rbarr~⤍~rbbrk~❳~rbrace~}~rbrack~]~rbrke~⦌~rbrksld~⦎~rbrkslu~⦐~rcaron~ř~rcedil~ŗ~rcub~}~rcy~р~rdca~⤷~rdldhar~⥩~rdquor~”~rdsh~↳~realine~ℛ~realpart~ℜ~reals~ℝ~rect~▭~rfisht~⥽~rfr~\uD835\uDD2F~rhard~⇁~rharu~⇀~rharul~⥬~rhov~ϱ~rightarrow~→~rightarrowtail~↣~rightharpoondown~⇁~rightharpoonup~⇀~rightleftarrows~⇄~rightleftharpoons~⇌~rightrightarrows~⇉~rightsquigarrow~↝~rightthreetimes~⋌~ring~˚~risingdotseq~≓~rlarr~⇄~rlhar~⇌~rmoust~⎱~rmoustache~⎱~rnmid~⫮~roang~⟭~roarr~⇾~robrk~⟧~ropar~⦆~ropf~\uD835\uDD63~roplus~⨮~rotimes~⨵~rpar~)~rpargt~⦔~rppolint~⨒~rrarr~⇉~rscr~\uD835\uDCC7~rsh~↱~rsqb~]~rsquor~’~rthree~⋌~rtimes~⋊~rtri~▹~rtrie~⊵~rtrif~▸~rtriltri~⧎~ruluhar~⥨~rx~℞~sacute~ś~sc~≻~scE~⪴~scap~⪸~sccue~≽~sce~⪰~scedil~ş~scirc~ŝ~scnE~⪶~scnap~⪺~scnsim~⋩~scpolint~⨓~scsim~≿~scy~с~sdotb~⊡~sdote~⩦~seArr~⇘~searhk~⤥~searr~↘~searrow~↘~semi~;~seswar~⤩~setminus~∖~setmn~∖~sext~✶~sfr~\uD835\uDD30~sfrown~⌢~sharp~♯~shchcy~щ~shcy~ш~shortmid~∣~shortparallel~∥~sigmav~ς~simdot~⩪~sime~≃~simeq~≃~simg~⪞~simgE~⪠~siml~⪝~simlE~⪟~simne~≆~simplus~⨤~simrarr~⥲~slarr~←~smallsetminus~∖~smashp~⨳~smeparsl~⧤~smid~∣~smile~⌣~smt~⪪~smte~⪬~smtes~⪬︀~softcy~ь~sol~/~solb~⧄~solbar~⌿~sopf~\uD835\uDD64~spadesuit~♠~spar~∥~sqcap~⊓~sqcaps~⊓︀~sqcup~⊔~sqcups~⊔︀~sqsub~⊏~sqsube~⊑~sqsubset~⊏~sqsubseteq~⊑~sqsup~⊐~sqsupe~⊒~sqsupset~⊐~sqsupseteq~⊒~squ~□~square~□~squarf~▪~squf~▪~srarr~→~sscr~\uD835\uDCC8~ssetmn~∖~ssmile~⌣~sstarf~⋆~star~☆~starf~★~straightepsilon~ϵ~straightphi~ϕ~strns~¯~subE~⫅~subdot~⪽~subedot~⫃~submult~⫁~subnE~⫋~subne~⊊~subplus~⪿~subrarr~⥹~subset~⊂~subseteq~⊆~subseteqq~⫅~subsetneq~⊊~subsetneqq~⫋~subsim~⫇~subsub~⫕~subsup~⫓~succ~≻~succapprox~⪸~succcurlyeq~≽~succeq~⪰~succnapprox~⪺~succneqq~⪶~succnsim~⋩~succsim~≿~sung~♪~supE~⫆~supdot~⪾~supdsub~⫘~supedot~⫄~suphsol~⟉~suphsub~⫗~suplarr~⥻~supmult~⫂~supnE~⫌~supne~⊋~supplus~⫀~supset~⊃~supseteq~⊇~supseteqq~⫆~supsetneq~⊋~supsetneqq~⫌~supsim~⫈~supsub~⫔~supsup~⫖~swArr~⇙~swarhk~⤦~swarr~↙~swarrow~↙~swnwar~⤪~target~⌖~tbrk~⎴~tcaron~ť~tcedil~ţ~tcy~т~tdot~⃛~telrec~⌕~tfr~\uD835\uDD31~therefore~∴~thetav~ϑ~thickapprox~≈~thicksim~∼~thkap~≈~thksim~∼~timesb~⊠~timesbar~⨱~timesd~⨰~tint~∭~toea~⤨~top~⊤~topbot~⌶~topcir~⫱~topf~\uD835\uDD65~topfork~⫚~tosa~⤩~tprime~‴~triangle~▵~triangledown~▿~triangleleft~◃~trianglelefteq~⊴~triangleq~≜~triangleright~▹~trianglerighteq~⊵~tridot~◬~trie~≜~triminus~⨺~triplus~⨹~trisb~⧍~tritime~⨻~trpezium~⏢~tscr~\uD835\uDCC9~tscy~ц~tshcy~ћ~tstrok~ŧ~twixt~≬~twoheadleftarrow~↞~twoheadrightarrow~↠~uHar~⥣~ubrcy~ў~ubreve~ŭ~ucy~у~udarr~⇅~udblac~ű~udhar~⥮~ufisht~⥾~ufr~\uD835\uDD32~uharl~↿~uharr~↾~uhblk~▀~ulcorn~⌜~ulcorner~⌜~ulcrop~⌏~ultri~◸~umacr~ū~uogon~ų~uopf~\uD835\uDD66~uparrow~↑~updownarrow~↕~upharpoonleft~↿~upharpoonright~↾~uplus~⊎~upsi~υ~upuparrows~⇈~urcorn~⌝~urcorner~⌝~urcrop~⌎~uring~ů~urtri~◹~uscr~\uD835\uDCCA~utdot~⋰~utilde~ũ~utri~▵~utrif~▴~uuarr~⇈~uwangle~⦧~vArr~⇕~vBar~⫨~vBarv~⫩~vDash~⊨~vangrt~⦜~varepsilon~ϵ~varkappa~ϰ~varnothing~∅~varphi~ϕ~varpi~ϖ~varpropto~∝~varr~↕~varrho~ϱ~varsigma~ς~varsubsetneq~⊊︀~varsubsetneqq~⫋︀~varsupsetneq~⊋︀~varsupsetneqq~⫌︀~vartheta~ϑ~vartriangleleft~⊲~vartriangleright~⊳~vcy~в~vdash~⊢~vee~∨~veebar~⊻~veeeq~≚~vellip~⋮~verbar~|~vert~|~vfr~\uD835\uDD33~vltri~⊲~vnsub~⊂⃒~vnsup~⊃⃒~vopf~\uD835\uDD67~vprop~∝~vrtri~⊳~vscr~\uD835\uDCCB~vsubnE~⫋︀~vsubne~⊊︀~vsupnE~⫌︀~vsupne~⊋︀~vzigzag~⦚~wcirc~ŵ~wedbar~⩟~wedge~∧~wedgeq~≙~wfr~\uD835\uDD34~wopf~\uD835\uDD68~wp~℘~wr~≀~wreath~≀~wscr~\uD835\uDCCC~xcap~⋂~xcirc~◯~xcup~⋃~xdtri~▽~xfr~\uD835\uDD35~xhArr~⟺~xharr~⟷~xlArr~⟸~xlarr~⟵~xmap~⟼~xnis~⋻~xodot~⨀~xopf~\uD835\uDD69~xoplus~⨁~xotime~⨂~xrArr~⟹~xrarr~⟶~xscr~\uD835\uDCCD~xsqcup~⨆~xuplus~⨄~xutri~△~xvee~⋁~xwedge~⋀~yacy~я~ycirc~ŷ~ycy~ы~yfr~\uD835\uDD36~yicy~ї~yopf~\uD835\uDD6A~yscr~\uD835\uDCCE~yucy~ю~zacute~ź~zcaron~ž~zcy~з~zdot~ż~zeetrf~ℨ~zfr~\uD835\uDD37~zhcy~ж~zigrarr~⇝~zopf~\uD835\uDD6B~zscr~\uD835\uDCCF~~AMP~&~COPY~©~GT~>~LT~<~QUOT~\"~REG~®", namedReferences["html4"]);

// node_modules/html-entities/dist/esm/numeric-unicode-map.js
var numericUnicodeMap = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
};

// node_modules/html-entities/dist/esm/surrogate-pairs.js
var fromCodePoint = String.fromCodePoint || function(astralCodePoint) {
  return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
};
var getCodePoint = String.prototype.codePointAt ? function(input, position) {
  return input.codePointAt(position);
} : function(input, position) {
  return (input.charCodeAt(position) - 55296) * 1024 + input.charCodeAt(position + 1) - 56320 + 65536;
};

// node_modules/html-entities/dist/esm/index.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var allNamedReferences = __assign2(__assign2({}, namedReferences), { all: namedReferences.html5 });
var defaultDecodeOptions = {
  scope: "body",
  level: "all"
};
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = {
  xml: {
    strict,
    attribute,
    body: bodyRegExps.xml
  },
  html4: {
    strict,
    attribute,
    body: bodyRegExps.html4
  },
  html5: {
    strict,
    attribute,
    body: bodyRegExps.html5
  }
};
var decodeRegExps = __assign2(__assign2({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
function getDecodedEntity(entity, references, isAttribute, isStrict) {
  var decodeResult = entity;
  var decodeEntityLastChar = entity[entity.length - 1];
  if (isAttribute && decodeEntityLastChar === "=") {
    decodeResult = entity;
  } else if (isStrict && decodeEntityLastChar !== ";") {
    decodeResult = entity;
  } else {
    var decodeResultByReference = references[entity];
    if (decodeResultByReference) {
      decodeResult = decodeResultByReference;
    } else if (entity[0] === "&" && entity[1] === "#") {
      var decodeSecondChar = entity[2];
      var decodeCode = decodeSecondChar == "x" || decodeSecondChar == "X" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
      decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? fromCodePoint(decodeCode) : fromCharCode(numericUnicodeMap[decodeCode] || decodeCode);
    }
  }
  return decodeResult;
}
function decode(text, _a) {
  var _b = _a === undefined ? defaultDecodeOptions : _a, _c = _b.level, level = _c === undefined ? "all" : _c, _d = _b.scope, scope = _d === undefined ? level === "xml" ? "strict" : "body" : _d;
  if (!text) {
    return "";
  }
  var decodeRegExp = decodeRegExps[level][scope];
  var references = allNamedReferences[level].entities;
  var isAttribute = scope === "attribute";
  var isStrict = scope === "strict";
  return text.replace(decodeRegExp, function(entity) {
    return getDecodedEntity(entity, references, isAttribute, isStrict);
  });
}

// src/html-to-docx.ts
var import_html_to_vdom2 = __toESM(require_html_to_vdom2(), 1);
var import_vnode5 = __toESM(require_vnode(), 1);
var import_vtext3 = __toESM(require_vtext(), 1);
var import_xmlbuilder24 = __toESM(require_lib9(), 1);

// src/constants.ts
var import_lodash = __toESM(require_lodash(), 1);
var applicationName = "@oxfordabstracts/html-to-docx";
var defaultOrientation = "portrait";
var landscapeWidth = 15840;
var landscapeHeight = 12240;
var landscapeMargins = {
  top: 1800,
  right: 1440,
  bottom: 1800,
  left: 1440,
  header: 720,
  footer: 720,
  gutter: 0
};
var portraitMargins = {
  top: 1440,
  right: 1800,
  bottom: 1440,
  left: 1800,
  header: 720,
  footer: 720,
  gutter: 0
};
var defaultFont = "Times New Roman";
var defaultFontSize = 22;
var defaultLang = "en-US";
var defaultDocumentOptions = {
  orientation: defaultOrientation,
  margins: import_lodash.default.cloneDeep(portraitMargins),
  creator: applicationName,
  keywords: [applicationName],
  lastModifiedBy: applicationName,
  font: defaultFont,
  fontSize: defaultFontSize,
  complexScriptFontSize: defaultFontSize,
  pageSize: {
    width: landscapeHeight,
    height: landscapeWidth
  },
  defaultLang,
  embedImages: true
};
var defaultHTMLString = "<p></p>";
var relsFolderName = "_rels";
var headerFileName = "header1";
var footerFileName = "footer1";
var themeFileName = "theme1";
var documentFileName = "document";
var headerType = "header";
var footerType = "footer";
var themeType = "theme";
var hyperlinkType = "hyperlink";
var imageType = "image";
var internalRelationship = "Internal";
var wordFolder = "word";
var themeFolder = "theme";
var paragraphBordersObject = {
  top: {
    size: 0,
    spacing: 3,
    color: "FFFFFF"
  },
  left: {
    size: 0,
    spacing: 3,
    color: "FFFFFF"
  },
  bottom: {
    size: 0,
    spacing: 3,
    color: "FFFFFF"
  },
  right: {
    size: 0,
    spacing: 3,
    color: "FFFFFF"
  }
};
var colorlessColors = ["transparent", "auto"];
var verticalAlignValues = ["top", "middle", "bottom"];
var htmlInlineElements = [
  "a",
  "abbr",
  "acronym",
  "b",
  "bdo",
  "big",
  "br",
  "button",
  "cite",
  "code",
  "del",
  "dfn",
  "em",
  "i",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "map",
  "mark",
  "output",
  "q",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strike",
  "strong",
  "sub",
  "sup",
  "textarea",
  "time",
  "tt",
  "u",
  "var"
];
var htmlHeadings = ["h1", "h2", "h3", "h4", "h5", "h6"];

// src/docx-document.ts
var import_xmlbuilder23 = __toESM(require_lib9(), 1);
import { createHash } from "node:crypto";

// node_modules/color-name/index.js
var color_name_default = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

// src/helpers/render-document-file.ts
var import_html_to_vdom = __toESM(require_html_to_vdom2(), 1);
var import_is_vnode2 = __toESM(require_is_vnode(), 1);
var import_is_vtext2 = __toESM(require_is_vtext(), 1);
var import_vnode3 = __toESM(require_vnode(), 1);
var import_vtext2 = __toESM(require_vtext(), 1);
var import_xmlbuilder22 = __toESM(require_lib9(), 1);

// src/namespaces.ts
var namespaces = {
  a: "http://schemas.openxmlformats.org/drawingml/2006/main",
  b: "http://schemas.openxmlformats.org/officeDocument/2006/bibliography",
  cdr: "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing",
  dc: "http://purl.org/dc/elements/1.1/",
  dcmitype: "http://purl.org/dc/dcmitype/",
  dcterms: "http://purl.org/dc/terms/",
  o: "urn:schemas-microsoft-com:office:office",
  pic: "http://schemas.openxmlformats.org/drawingml/2006/picture",
  r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  v: "urn:schemas-microsoft-com:vml",
  ve: "http://schemas.openxmlformats.org/markup-compatibility/2006",
  vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
  w10: "urn:schemas-microsoft-com:office:word",
  wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
  wne: "http://schemas.microsoft.com/office/word/2006/wordml",
  xsd: "http://www.w3.org/2001/XMLSchema",
  xsi: "http://www.w3.org/2001/XMLSchema-instance",
  numbering: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
  fontTable: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
  hyperlinks: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  images: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  headers: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
  footers: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
  themes: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  coreProperties: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  officeDocumentRelation: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  corePropertiesRelation: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  settingsRelation: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
  webSettingsRelation: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
  sl: "http://schemas.openxmlformats.org/schemaLibrary/2006/main",
  contentTypes: "http://schemas.openxmlformats.org/package/2006/content-types",
  relationship: "http://schemas.openxmlformats.org/package/2006/relationships"
};
var namespaces_default = namespaces;

// node_modules/strtok3/lib/stream/Errors.js
var defaultMessages = "End-Of-Stream";

class EndOfStreamError extends Error {
  constructor() {
    super(defaultMessages);
    this.name = "EndOfStreamError";
  }
}

class AbortError extends Error {
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
  }
}
// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0 && !mayBeLess) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
}
// node_modules/strtok3/lib/stream/WebStreamReader.js
class WebStreamReader extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
  }
  async abort() {
    return this.close();
  }
  async close() {
    this.reader.releaseLock();
  }
}

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
class WebStreamByobReader extends WebStreamReader {
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });
    if (result.done) {
      this.endOfStream = result.done;
    }
    if (result.value) {
      buffer.set(result.value);
      return result.value.length;
    }
    return 0;
  }
}
// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
class WebStreamDefaultReader extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
    this.buffer = null;
  }
  writeChunk(target, chunk) {
    const written = Math.min(chunk.length, target.length);
    target.set(chunk.subarray(0, written));
    if (written < chunk.length) {
      this.buffer = chunk.subarray(written);
    } else {
      this.buffer = null;
    }
    return written;
  }
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    let totalBytesRead = 0;
    if (this.buffer) {
      totalBytesRead += this.writeChunk(buffer, this.buffer);
    }
    while (totalBytesRead < buffer.length && !this.endOfStream) {
      const result = await this.reader.read();
      if (result.done) {
        this.endOfStream = true;
        break;
      }
      if (result.value) {
        totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
      }
    }
    if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
      throw new EndOfStreamError;
    }
    return totalBytesRead;
  }
  abort() {
    this.interrupted = true;
    return this.reader.cancel();
  }
  async close() {
    await this.abort();
    this.reader.releaseLock();
  }
}
// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error) {
    if (error instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error;
  }
}
// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000;

class ReadStreamTokenizer extends AbstractTokenizer {
  constructor(streamReader, options) {
    super(options);
    this.streamReader = streamReader;
    this.fileInfo = options?.fileInfo ?? {};
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const skipBytes = normOptions.position - this.position;
    if (skipBytes > 0) {
      await this.ignore(skipBytes);
      return this.readBuffer(uint8Array, options);
    }
    if (skipBytes < 0) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    if (normOptions.length === 0) {
      return 0;
    }
    const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
    this.position += bytesRead;
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    let bytesRead = 0;
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
        bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
        uint8Array.set(skipBuffer.subarray(skipBytes));
        return bytesRead - skipBytes;
      }
      if (skipBytes < 0) {
        throw new Error("Cannot peek from a negative offset in a stream");
      }
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      } catch (err) {
        if (options?.mayBeLess && err instanceof EndOfStreamError) {
          return 0;
        }
        throw err;
      }
      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
    }
    return bytesRead;
  }
  async ignore(length) {
    const bufSize = Math.min(maxBufferSize, length);
    const buf = new Uint8Array(bufSize);
    let totBytesRead = 0;
    while (totBytesRead < length) {
      const remaining = length - totBytesRead;
      const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
      if (bytesRead < 0) {
        return bytesRead;
      }
      totBytesRead += bytesRead;
    }
    return totBytesRead;
  }
  abort() {
    return this.streamReader.abort();
  }
  async close() {
    return this.streamReader.close();
  }
  supportsRandomAccess() {
    return false;
  }
}

// node_modules/strtok3/lib/BufferTokenizer.js
class BufferTokenizer extends AbstractTokenizer {
  constructor(uint8Array, options) {
    super(options);
    this.uint8Array = uint8Array;
    this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
  }
  async readBuffer(uint8Array, options) {
    if (options?.position) {
      this.position = options.position;
    }
    const bytesRead = await this.peekBuffer(uint8Array, options);
    this.position += bytesRead;
    return bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
    if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
      throw new EndOfStreamError;
    }
    uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
    return bytes2read;
  }
  close() {
    return super.close();
  }
  supportsRandomAccess() {
    return true;
  }
  setPosition(position) {
    this.position = position;
  }
}
// node_modules/strtok3/lib/core.js
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}

// node_modules/strtok3/lib/FileTokenizer.js
import { open as fsOpen } from "node:fs/promises";

class FileTokenizer extends AbstractTokenizer {
  static async fromFile(sourceFilePath) {
    const fileHandle = await fsOpen(sourceFilePath, "r");
    const stat = await fileHandle.stat();
    return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
  }
  constructor(fileHandle, options) {
    super(options);
    this.fileHandle = fileHandle;
    this.fileInfo = options.fileInfo;
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    this.position = normOptions.position;
    if (normOptions.length === 0)
      return 0;
    const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
    this.position += res.bytesRead;
    if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
      throw new EndOfStreamError;
    }
    return res.bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
    if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
      throw new EndOfStreamError;
    }
    return res.bytesRead;
  }
  async close() {
    await this.fileHandle.close();
    return super.close();
  }
  setPosition(position) {
    this.position = position;
  }
  supportsRandomAccess() {
    return true;
  }
}
// node_modules/strtok3/lib/index.js
var fromFile = FileTokenizer.fromFile;

// node_modules/ieee754/index.js
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

// node_modules/@borewit/text-codec/lib/index.js
var WINDOWS_1252_EXTRA = {
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
var WINDOWS_1252_REVERSE = {};
for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {
  WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
}
function textDecode(bytes, encoding = "utf-8") {
  switch (encoding.toLowerCase()) {
    case "utf-8":
    case "utf8":
      if (typeof globalThis.TextDecoder !== "undefined") {
        return new globalThis.TextDecoder("utf-8").decode(bytes);
      }
      return decodeUTF8(bytes);
    case "utf-16le":
      return decodeUTF16LE(bytes);
    case "ascii":
      return decodeASCII(bytes);
    case "latin1":
    case "iso-8859-1":
      return decodeLatin1(bytes);
    case "windows-1252":
      return decodeWindows1252(bytes);
    default:
      throw new RangeError(`Encoding '${encoding}' not supported`);
  }
}
function decodeUTF8(bytes) {
  let out = "";
  let i = 0;
  while (i < bytes.length) {
    const b1 = bytes[i++];
    if (b1 < 128) {
      out += String.fromCharCode(b1);
    } else if (b1 < 224) {
      const b2 = bytes[i++] & 63;
      out += String.fromCharCode((b1 & 31) << 6 | b2);
    } else if (b1 < 240) {
      const b2 = bytes[i++] & 63;
      const b3 = bytes[i++] & 63;
      out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
    } else {
      const b2 = bytes[i++] & 63;
      const b3 = bytes[i++] & 63;
      const b4 = bytes[i++] & 63;
      let cp = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
      cp -= 65536;
      out += String.fromCharCode(55296 + (cp >> 10 & 1023), 56320 + (cp & 1023));
    }
  }
  return out;
}
function decodeUTF16LE(bytes) {
  let out = "";
  for (let i = 0;i < bytes.length; i += 2) {
    out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
  }
  return out;
}
function decodeASCII(bytes) {
  return String.fromCharCode(...bytes.map((b) => b & 127));
}
function decodeLatin1(bytes) {
  return String.fromCharCode(...bytes);
}
function decodeWindows1252(bytes) {
  let out = "";
  for (const b of bytes) {
    if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
      out += WINDOWS_1252_EXTRA[b];
    } else {
      out += String.fromCharCode(b);
    }
  }
  return out;
}

// node_modules/token-types/lib/index.js
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}
var UINT8 = {
  len: 1,
  get(array, offset) {
    return dv(array).getUint8(offset);
  },
  put(array, offset, value) {
    dv(array).setUint8(offset, value);
    return offset + 1;
  }
};
var UINT16_LE = {
  len: 2,
  get(array, offset) {
    return dv(array).getUint16(offset, true);
  },
  put(array, offset, value) {
    dv(array).setUint16(offset, value, true);
    return offset + 2;
  }
};
var UINT16_BE = {
  len: 2,
  get(array, offset) {
    return dv(array).getUint16(offset);
  },
  put(array, offset, value) {
    dv(array).setUint16(offset, value);
    return offset + 2;
  }
};
var UINT32_LE = {
  len: 4,
  get(array, offset) {
    return dv(array).getUint32(offset, true);
  },
  put(array, offset, value) {
    dv(array).setUint32(offset, value, true);
    return offset + 4;
  }
};
var UINT32_BE = {
  len: 4,
  get(array, offset) {
    return dv(array).getUint32(offset);
  },
  put(array, offset, value) {
    dv(array).setUint32(offset, value);
    return offset + 4;
  }
};
var INT32_BE = {
  len: 4,
  get(array, offset) {
    return dv(array).getInt32(offset);
  },
  put(array, offset, value) {
    dv(array).setInt32(offset, value);
    return offset + 4;
  }
};
var UINT64_LE = {
  len: 8,
  get(array, offset) {
    return dv(array).getBigUint64(offset, true);
  },
  put(array, offset, value) {
    dv(array).setBigUint64(offset, value, true);
    return offset + 8;
  }
};
class StringType {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
  }
  get(data, offset = 0) {
    const bytes = data.subarray(offset, offset + this.len);
    return textDecode(bytes, this.encoding);
  }
}

// node_modules/fflate/esm/index.mjs
import { createRequire as createRequire2 } from "module";
var require2 = createRequire2("/");
var Worker;
try {
  Worker = require2("worker_threads").Worker;
} catch (e) {}
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0;i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (;i2 < s; ++i2) {
    if (cd[i2])
      ++l[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1;i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0;i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144;i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256;i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280;i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0;i < 32; ++i)
  fdt[i] = 5;
var i;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i2 = 1;i2 < a.length; ++i2) {
    if (a[i2] > m)
      m = a[i2];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0;i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0;i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i2++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i2++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {}

// node_modules/@tokenizer/inflate/lib/index.js
var import_debug = __toESM(require_src(), 1);

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature = {
  LocalFileHeader: 67324752,
  DataDescriptor: 134695760,
  CentralFileHeader: 33639248,
  EndOfCentralDirectory: 101010256
};
var DataDescriptor = {
  get(array) {
    const flags = UINT16_LE.get(array, 6);
    return {
      signature: UINT32_LE.get(array, 0),
      compressedSize: UINT32_LE.get(array, 8),
      uncompressedSize: UINT32_LE.get(array, 12)
    };
  },
  len: 16
};
var LocalFileHeaderToken = {
  get(array) {
    const flags = UINT16_LE.get(array, 6);
    return {
      signature: UINT32_LE.get(array, 0),
      minVersion: UINT16_LE.get(array, 4),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array, 8),
      compressedSize: UINT32_LE.get(array, 18),
      uncompressedSize: UINT32_LE.get(array, 22),
      filenameLength: UINT16_LE.get(array, 26),
      extraFieldLength: UINT16_LE.get(array, 28),
      filename: null
    };
  },
  len: 30
};
var EndOfCentralDirectoryRecordToken = {
  get(array) {
    return {
      signature: UINT32_LE.get(array, 0),
      nrOfThisDisk: UINT16_LE.get(array, 4),
      nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
      nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
      nrOfEntriesOfSize: UINT16_LE.get(array, 10),
      sizeOfCd: UINT32_LE.get(array, 12),
      offsetOfStartOfCd: UINT32_LE.get(array, 16),
      zipFileCommentLength: UINT16_LE.get(array, 20)
    };
  },
  len: 22
};
var FileHeader = {
  get(array) {
    const flags = UINT16_LE.get(array, 8);
    return {
      signature: UINT32_LE.get(array, 0),
      minVersion: UINT16_LE.get(array, 6),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array, 10),
      compressedSize: UINT32_LE.get(array, 20),
      uncompressedSize: UINT32_LE.get(array, 24),
      filenameLength: UINT16_LE.get(array, 28),
      extraFieldLength: UINT16_LE.get(array, 30),
      fileCommentLength: UINT16_LE.get(array, 32),
      relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
      filename: null
    };
  },
  len: 46
};

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}
var debug = import_debug.default("tokenizer:inflate");
var syncBufferSize = 256 * 1024;
var ddSignatureArray = signatureToArray(Signature.DataDescriptor);
var eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i2 = buffer.length - 4;i2 >= 0; i2--) {
      if (buffer[i2] === eocdSignatureBytes[0] && buffer[i2 + 1] === eocdSignatureBytes[1] && buffer[i2 + 2] === eocdSignatureBytes[2] && buffer[i2 + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i2;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i2 = 0;i2 <= bufferLength - portionLength; i2++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer[i2 + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i2;
    }
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}

// node_modules/uint8array-extras/index.js
var cachedDecoders = {
  utf8: new globalThis.TextDecoder("utf8")
};
var cachedEncoder = new globalThis.TextEncoder;
var byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}

// node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken = {
  get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
  len: 4
};

// node_modules/file-type/supported.js
var extensions = [
  "jpg",
  "png",
  "apng",
  "gif",
  "webp",
  "flif",
  "xcf",
  "cr2",
  "cr3",
  "orf",
  "arw",
  "dng",
  "nef",
  "rw2",
  "raf",
  "tif",
  "bmp",
  "icns",
  "jxr",
  "psd",
  "indd",
  "zip",
  "tar",
  "rar",
  "gz",
  "bz2",
  "7z",
  "dmg",
  "mp4",
  "mid",
  "mkv",
  "webm",
  "mov",
  "avi",
  "mpg",
  "mp2",
  "mp3",
  "m4a",
  "oga",
  "ogg",
  "ogv",
  "opus",
  "flac",
  "wav",
  "spx",
  "amr",
  "pdf",
  "epub",
  "elf",
  "macho",
  "exe",
  "swf",
  "rtf",
  "wasm",
  "woff",
  "woff2",
  "eot",
  "ttf",
  "otf",
  "ttc",
  "ico",
  "flv",
  "ps",
  "xz",
  "sqlite",
  "nes",
  "crx",
  "xpi",
  "cab",
  "deb",
  "ar",
  "rpm",
  "Z",
  "lz",
  "cfb",
  "mxf",
  "mts",
  "blend",
  "bpg",
  "docx",
  "pptx",
  "xlsx",
  "3gp",
  "3g2",
  "j2c",
  "jp2",
  "jpm",
  "jpx",
  "mj2",
  "aif",
  "qcp",
  "odt",
  "ods",
  "odp",
  "xml",
  "mobi",
  "heic",
  "cur",
  "ktx",
  "ape",
  "wv",
  "dcm",
  "ics",
  "glb",
  "pcap",
  "dsf",
  "lnk",
  "alias",
  "voc",
  "ac3",
  "m4v",
  "m4p",
  "m4b",
  "f4v",
  "f4p",
  "f4b",
  "f4a",
  "mie",
  "asf",
  "ogm",
  "ogx",
  "mpc",
  "arrow",
  "shp",
  "aac",
  "mp1",
  "it",
  "s3m",
  "xm",
  "skp",
  "avif",
  "eps",
  "lzh",
  "pgp",
  "asar",
  "stl",
  "chm",
  "3mf",
  "zst",
  "jxl",
  "vcf",
  "jls",
  "pst",
  "dwg",
  "parquet",
  "class",
  "arj",
  "cpio",
  "ace",
  "avro",
  "icc",
  "fbx",
  "vsdx",
  "vtt",
  "apk",
  "drc",
  "lz4",
  "potx",
  "xltx",
  "dotx",
  "xltm",
  "ott",
  "ots",
  "otp",
  "odg",
  "otg",
  "xlsm",
  "docm",
  "dotm",
  "potm",
  "pptm",
  "jar",
  "rm",
  "ppsm",
  "ppsx"
];
var mimeTypes = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/flif",
  "image/x-xcf",
  "image/x-canon-cr2",
  "image/x-canon-cr3",
  "image/tiff",
  "image/bmp",
  "image/vnd.ms-photo",
  "image/vnd.adobe.photoshop",
  "application/x-indesign",
  "application/epub+zip",
  "application/x-xpinstall",
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
  "application/vnd.oasis.opendocument.text",
  "application/vnd.oasis.opendocument.spreadsheet",
  "application/vnd.oasis.opendocument.presentation",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
  "application/zip",
  "application/x-tar",
  "application/x-rar-compressed",
  "application/gzip",
  "application/x-bzip2",
  "application/x-7z-compressed",
  "application/x-apple-diskimage",
  "application/vnd.apache.arrow.file",
  "video/mp4",
  "audio/midi",
  "video/matroska",
  "video/webm",
  "video/quicktime",
  "video/vnd.avi",
  "audio/wav",
  "audio/qcelp",
  "audio/x-ms-asf",
  "video/x-ms-asf",
  "application/vnd.ms-asf",
  "video/mpeg",
  "video/3gpp",
  "audio/mpeg",
  "audio/mp4",
  "video/ogg",
  "audio/ogg",
  "audio/ogg; codecs=opus",
  "application/ogg",
  "audio/flac",
  "audio/ape",
  "audio/wavpack",
  "audio/amr",
  "application/pdf",
  "application/x-elf",
  "application/x-mach-binary",
  "application/x-msdownload",
  "application/x-shockwave-flash",
  "application/rtf",
  "application/wasm",
  "font/woff",
  "font/woff2",
  "application/vnd.ms-fontobject",
  "font/ttf",
  "font/otf",
  "font/collection",
  "image/x-icon",
  "video/x-flv",
  "application/postscript",
  "application/eps",
  "application/x-xz",
  "application/x-sqlite3",
  "application/x-nintendo-nes-rom",
  "application/x-google-chrome-extension",
  "application/vnd.ms-cab-compressed",
  "application/x-deb",
  "application/x-unix-archive",
  "application/x-rpm",
  "application/x-compress",
  "application/x-lzip",
  "application/x-cfb",
  "application/x-mie",
  "application/mxf",
  "video/mp2t",
  "application/x-blender",
  "image/bpg",
  "image/j2c",
  "image/jp2",
  "image/jpx",
  "image/jpm",
  "image/mj2",
  "audio/aiff",
  "application/xml",
  "application/x-mobipocket-ebook",
  "image/heif",
  "image/heif-sequence",
  "image/heic",
  "image/heic-sequence",
  "image/icns",
  "image/ktx",
  "application/dicom",
  "audio/x-musepack",
  "text/calendar",
  "text/vcard",
  "text/vtt",
  "model/gltf-binary",
  "application/vnd.tcpdump.pcap",
  "audio/x-dsf",
  "application/x.ms.shortcut",
  "application/x.apple.alias",
  "audio/x-voc",
  "audio/vnd.dolby.dd-raw",
  "audio/x-m4a",
  "image/apng",
  "image/x-olympus-orf",
  "image/x-sony-arw",
  "image/x-adobe-dng",
  "image/x-nikon-nef",
  "image/x-panasonic-rw2",
  "image/x-fujifilm-raf",
  "video/x-m4v",
  "video/3gpp2",
  "application/x-esri-shape",
  "audio/aac",
  "audio/x-it",
  "audio/x-s3m",
  "audio/x-xm",
  "video/MP1S",
  "video/MP2P",
  "application/vnd.sketchup.skp",
  "image/avif",
  "application/x-lzh-compressed",
  "application/pgp-encrypted",
  "application/x-asar",
  "model/stl",
  "application/vnd.ms-htmlhelp",
  "model/3mf",
  "image/jxl",
  "application/zstd",
  "image/jls",
  "application/vnd.ms-outlook",
  "image/vnd.dwg",
  "application/vnd.apache.parquet",
  "application/java-vm",
  "application/x-arj",
  "application/x-cpio",
  "application/x-ace-compressed",
  "application/avro",
  "application/vnd.iccprofile",
  "application/x.autodesk.fbx",
  "application/vnd.visio",
  "application/vnd.android.package-archive",
  "application/vnd.google.draco",
  "application/x-lz4",
  "application/vnd.openxmlformats-officedocument.presentationml.template",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  "application/vnd.ms-excel.template.macroenabled.12",
  "application/vnd.oasis.opendocument.text-template",
  "application/vnd.oasis.opendocument.spreadsheet-template",
  "application/vnd.oasis.opendocument.presentation-template",
  "application/vnd.oasis.opendocument.graphics",
  "application/vnd.oasis.opendocument.graphics-template",
  "application/vnd.ms-excel.sheet.macroenabled.12",
  "application/vnd.ms-word.document.macroenabled.12",
  "application/vnd.ms-word.template.macroenabled.12",
  "application/vnd.ms-powerpoint.template.macroenabled.12",
  "application/vnd.ms-powerpoint.presentation.macroenabled.12",
  "application/java-archive",
  "application/vnd.rn-realmedia"
];

// node_modules/file-type/core.js
var reasonableDetectionSizeInBytes = 4100;
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
class FileTypeParser {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
        } catch (error) {
          if (!(error instanceof EndOfStreamError)) {
            throw error;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = new Uint8Array(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1") || this.checkString("PARE")) {
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet"
      };
    }
    if (this.checkString("ttcf")) {
      return {
        ext: "ttc",
        mime: "font/collection"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString(".RMF")) {
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string = await tokenizer.readToken(new StringType(13, "ascii"));
      if (string === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && [`
`, "\r", "\t", " ", "\x00"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\x00", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new StringType(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {}
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \x00")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\x00", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
      for (let depth = 0;depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type = this.scanMpeg(depth);
        if (type) {
          return type;
        }
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
}
var supportedExtensions = new Set(extensions);
var supportedMimeTypes = new Set(mimeTypes);
// node_modules/image-size/dist/index.mjs
var decoder = new TextDecoder;
var toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));
var toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i2) => memo + `0${i2.toString(16)}`.slice(-2), "");
var getView = (input, offset) => new DataView(input.buffer, input.byteOffset + offset);
var readInt16LE = (input, offset = 0) => getView(input, offset).getInt16(0, true);
var readUInt16BE = (input, offset = 0) => getView(input, offset).getUint16(0, false);
var readUInt16LE = (input, offset = 0) => getView(input, offset).getUint16(0, true);
var readUInt24LE = (input, offset = 0) => {
  const view = getView(input, offset);
  return view.getUint16(0, true) + (view.getUint8(2) << 16);
};
var readInt32LE = (input, offset = 0) => getView(input, offset).getInt32(0, true);
var readUInt32BE = (input, offset = 0) => getView(input, offset).getUint32(0, false);
var readUInt32LE = (input, offset = 0) => getView(input, offset).getUint32(0, true);
var readUInt64 = (input, offset, isBigEndian) => getView(input, offset).getBigUint64(0, !isBigEndian);
var methods = {
  readUInt16BE,
  readUInt16LE,
  readUInt32BE,
  readUInt32LE
};
function readUInt(input, bits2, offset = 0, isBigEndian = false) {
  const endian = isBigEndian ? "BE" : "LE";
  const methodName = `readUInt${bits2}${endian}`;
  return methods[methodName](input, offset);
}
function readBox(input, offset) {
  if (input.length - offset < 4)
    return;
  const boxSize = readUInt32BE(input, offset);
  if (input.length - offset < boxSize)
    return;
  return {
    name: toUTF8String(input, 4 + offset, 8 + offset),
    offset,
    size: boxSize
  };
}
function findBox(input, boxName, currentOffset) {
  while (currentOffset < input.length) {
    const box = readBox(input, currentOffset);
    if (!box)
      break;
    if (box.name === boxName)
      return box;
    currentOffset += box.size > 0 ? box.size : 8;
  }
}
var BMP = {
  validate: (input) => toUTF8String(input, 0, 2) === "BM",
  calculate: (input) => ({
    height: Math.abs(readInt32LE(input, 22)),
    width: readUInt32LE(input, 18)
  })
};
var TYPE_ICON = 1;
var SIZE_HEADER = 2 + 2 + 2;
var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
function getSizeFromOffset(input, offset) {
  const value = input[offset];
  return value === 0 ? 256 : value;
}
function getImageSize(input, imageIndex) {
  const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
  return {
    height: getSizeFromOffset(input, offset + 1),
    width: getSizeFromOffset(input, offset)
  };
}
var ICO = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0)
      return false;
    const imageType2 = readUInt16LE(input, 2);
    return imageType2 === TYPE_ICON;
  },
  calculate(input) {
    const nbImages = readUInt16LE(input, 4);
    const imageSize2 = getImageSize(input, 0);
    if (nbImages === 1)
      return imageSize2;
    const images = [];
    for (let imageIndex = 0;imageIndex < nbImages; imageIndex += 1) {
      images.push(getImageSize(input, imageIndex));
    }
    return {
      width: imageSize2.width,
      height: imageSize2.height,
      images
    };
  }
};
var TYPE_CURSOR = 2;
var CUR = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0)
      return false;
    const imageType2 = readUInt16LE(input, 2);
    return imageType2 === TYPE_CURSOR;
  },
  calculate: (input) => ICO.calculate(input)
};
var DDS = {
  validate: (input) => readUInt32LE(input, 0) === 542327876,
  calculate: (input) => ({
    height: readUInt32LE(input, 12),
    width: readUInt32LE(input, 16)
  })
};
var gifRegexp = /^GIF8[79]a/;
var GIF = {
  validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),
  calculate: (input) => ({
    height: readUInt16LE(input, 8),
    width: readUInt16LE(input, 6)
  })
};
var brandMap = {
  avif: "avif",
  mif1: "heif",
  msf1: "heif",
  heic: "heic",
  heix: "heic",
  hevc: "heic",
  hevx: "heic"
};
var HEIF = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "ftyp")
      return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox)
      return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand in brandMap;
  },
  calculate(input) {
    const metaBox = findBox(input, "meta", 0);
    const iprpBox = metaBox && findBox(input, "iprp", metaBox.offset + 12);
    const ipcoBox = iprpBox && findBox(input, "ipco", iprpBox.offset + 8);
    if (!ipcoBox) {
      throw new TypeError("Invalid HEIF, no ipco box found");
    }
    const type = toUTF8String(input, 8, 12);
    const images = [];
    let currentOffset = ipcoBox.offset + 8;
    while (currentOffset < ipcoBox.offset + ipcoBox.size) {
      const ispeBox = findBox(input, "ispe", currentOffset);
      if (!ispeBox)
        break;
      const rawWidth = readUInt32BE(input, ispeBox.offset + 12);
      const rawHeight = readUInt32BE(input, ispeBox.offset + 16);
      const clapBox = findBox(input, "clap", currentOffset);
      let width = rawWidth;
      let height = rawHeight;
      if (clapBox && clapBox.offset < ipcoBox.offset + ipcoBox.size) {
        const cropRight = readUInt32BE(input, clapBox.offset + 12);
        width = rawWidth - cropRight;
      }
      images.push({ height, width });
      currentOffset = ispeBox.offset + ispeBox.size;
    }
    if (images.length === 0) {
      throw new TypeError("Invalid HEIF, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      type,
      ...images.length > 1 ? { images } : {}
    };
  }
};
var SIZE_HEADER2 = 4 + 4;
var FILE_LENGTH_OFFSET = 4;
var ENTRY_LENGTH_OFFSET = 4;
var ICON_TYPE_SIZE = {
  ICON: 32,
  "ICN#": 32,
  "icm#": 16,
  icm4: 16,
  icm8: 16,
  "ics#": 16,
  ics4: 16,
  ics8: 16,
  is32: 16,
  s8mk: 16,
  icp4: 16,
  icl4: 32,
  icl8: 32,
  il32: 32,
  l8mk: 32,
  icp5: 32,
  ic11: 32,
  ich4: 48,
  ich8: 48,
  ih32: 48,
  h8mk: 48,
  icp6: 64,
  ic12: 32,
  it32: 128,
  t8mk: 128,
  ic07: 128,
  ic08: 256,
  ic13: 256,
  ic09: 512,
  ic14: 512,
  ic10: 1024
};
function readImageHeader(input, imageOffset) {
  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
  return [
    toUTF8String(input, imageOffset, imageLengthOffset),
    readUInt32BE(input, imageLengthOffset)
  ];
}
function getImageSize2(type) {
  const size = ICON_TYPE_SIZE[type];
  return { width: size, height: size, type };
}
var ICNS = {
  validate: (input) => toUTF8String(input, 0, 4) === "icns",
  calculate(input) {
    const inputLength = input.length;
    const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
    let imageOffset = SIZE_HEADER2;
    const images = [];
    while (imageOffset < fileLength && imageOffset < inputLength) {
      const imageHeader = readImageHeader(input, imageOffset);
      const imageSize2 = getImageSize2(imageHeader[0]);
      images.push(imageSize2);
      imageOffset += imageHeader[1];
    }
    if (images.length === 0) {
      throw new TypeError("Invalid ICNS, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      ...images.length > 1 ? { images } : {}
    };
  }
};
var J2C = {
  validate: (input) => readUInt32BE(input, 0) === 4283432785,
  calculate: (input) => ({
    height: readUInt32BE(input, 12),
    width: readUInt32BE(input, 8)
  })
};
var JP2 = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "jP  ")
      return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox)
      return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand === "jp2 ";
  },
  calculate(input) {
    const jp2hBox = findBox(input, "jp2h", 0);
    const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
    if (ihdrBox) {
      return {
        height: readUInt32BE(input, ihdrBox.offset + 8),
        width: readUInt32BE(input, ihdrBox.offset + 12)
      };
    }
    throw new TypeError("Unsupported JPEG 2000 format");
  }
};
var EXIF_MARKER = "45786966";
var APP1_DATA_SIZE_BYTES = 2;
var EXIF_HEADER_BYTES = 6;
var TIFF_BYTE_ALIGN_BYTES = 2;
var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
var IDF_ENTRY_BYTES = 12;
var NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
  return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index) {
  return {
    height: readUInt16BE(input, index),
    width: readUInt16BE(input, index + 2)
  };
}
function extractOrientation(exifBlock, isBigEndian) {
  const idfOffset = 8;
  const offset = EXIF_HEADER_BYTES + idfOffset;
  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
  for (let directoryEntryNumber = 0;directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
    const end = start + IDF_ENTRY_BYTES;
    if (start > exifBlock.length) {
      return;
    }
    const block = exifBlock.slice(start, end);
    const tagNumber = readUInt(block, 16, 0, isBigEndian);
    if (tagNumber === 274) {
      const dataFormat = readUInt(block, 16, 2, isBigEndian);
      if (dataFormat !== 3) {
        return;
      }
      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
      if (numberOfComponents !== 1) {
        return;
      }
      return readUInt(block, 16, 8, isBigEndian);
    }
  }
}
function validateExifBlock(input, index) {
  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
  const byteAlign = toHexString(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
  if (isBigEndian || isLittleEndian) {
    return extractOrientation(exifBlock, isBigEndian);
  }
}
function validateInput(input, index) {
  if (index > input.length) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
}
var JPG = {
  validate: (input) => toHexString(input, 0, 2) === "ffd8",
  calculate(_input) {
    let input = _input.slice(4);
    let orientation;
    let next;
    while (input.length) {
      const i2 = readUInt16BE(input, 0);
      validateInput(input, i2);
      if (input[i2] !== 255) {
        input = input.slice(1);
        continue;
      }
      if (isEXIF(input)) {
        orientation = validateExifBlock(input, i2);
      }
      next = input[i2 + 1];
      if (next === 192 || next === 193 || next === 194) {
        const size = extractSize(input, i2 + 5);
        if (!orientation) {
          return size;
        }
        return {
          height: size.height,
          orientation,
          width: size.width
        };
      }
      input = input.slice(i2 + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  }
};
var BitReader = class {
  constructor(input, endianness) {
    this.input = input;
    this.endianness = endianness;
    this.byteOffset = 2;
    this.bitOffset = 0;
  }
  getBits(length = 1) {
    let result = 0;
    let bitsRead = 0;
    while (bitsRead < length) {
      if (this.byteOffset >= this.input.length) {
        throw new Error("Reached end of input");
      }
      const currentByte = this.input[this.byteOffset];
      const bitsLeft = 8 - this.bitOffset;
      const bitsToRead = Math.min(length - bitsRead, bitsLeft);
      if (this.endianness === "little-endian") {
        const mask = (1 << bitsToRead) - 1;
        const bits2 = currentByte >> this.bitOffset & mask;
        result |= bits2 << bitsRead;
      } else {
        const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;
        const bits2 = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;
        result = result << bitsToRead | bits2;
      }
      bitsRead += bitsToRead;
      this.bitOffset += bitsToRead;
      if (this.bitOffset === 8) {
        this.byteOffset++;
        this.bitOffset = 0;
      }
    }
    return result;
  }
};
function calculateImageDimension(reader, isSmallImage) {
  if (isSmallImage) {
    return 8 * (1 + reader.getBits(5));
  }
  const sizeClass = reader.getBits(2);
  const extraBits = [9, 13, 18, 30][sizeClass];
  return 1 + reader.getBits(extraBits);
}
function calculateImageWidth(reader, isSmallImage, widthMode, height) {
  if (isSmallImage && widthMode === 0) {
    return 8 * (1 + reader.getBits(5));
  }
  if (widthMode === 0) {
    return calculateImageDimension(reader, false);
  }
  const aspectRatios = [1, 1.2, 4 / 3, 1.5, 16 / 9, 5 / 4, 2];
  return Math.floor(height * aspectRatios[widthMode - 1]);
}
var JXLStream = {
  validate: (input) => {
    return toHexString(input, 0, 2) === "ff0a";
  },
  calculate(input) {
    const reader = new BitReader(input, "little-endian");
    const isSmallImage = reader.getBits(1) === 1;
    const height = calculateImageDimension(reader, isSmallImage);
    const widthMode = reader.getBits(3);
    const width = calculateImageWidth(reader, isSmallImage, widthMode, height);
    return { width, height };
  }
};
function extractCodestream(input) {
  const jxlcBox = findBox(input, "jxlc", 0);
  if (jxlcBox) {
    return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);
  }
  const partialStreams = extractPartialStreams(input);
  if (partialStreams.length > 0) {
    return concatenateCodestreams(partialStreams);
  }
  return;
}
function extractPartialStreams(input) {
  const partialStreams = [];
  let offset = 0;
  while (offset < input.length) {
    const jxlpBox = findBox(input, "jxlp", offset);
    if (!jxlpBox)
      break;
    partialStreams.push(input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size));
    offset = jxlpBox.offset + jxlpBox.size;
  }
  return partialStreams;
}
function concatenateCodestreams(partialCodestreams) {
  const totalLength = partialCodestreams.reduce((acc, curr) => acc + curr.length, 0);
  const codestream = new Uint8Array(totalLength);
  let position = 0;
  for (const partial of partialCodestreams) {
    codestream.set(partial, position);
    position += partial.length;
  }
  return codestream;
}
var JXL = {
  validate: (input) => {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "JXL ")
      return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox)
      return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand === "jxl ";
  },
  calculate(input) {
    const codestream = extractCodestream(input);
    if (codestream)
      return JXLStream.calculate(codestream);
    throw new Error("No codestream found in JXL container");
  }
};
var KTX = {
  validate: (input) => {
    const signature = toUTF8String(input, 1, 7);
    return ["KTX 11", "KTX 20"].includes(signature);
  },
  calculate: (input) => {
    const type = input[5] === 49 ? "ktx" : "ktx2";
    const offset = type === "ktx" ? 36 : 20;
    return {
      height: readUInt32LE(input, offset + 4),
      width: readUInt32LE(input, offset),
      type
    };
  }
};
var pngSignature = `PNG\r
\x1A
`;
var pngImageHeaderChunkName = "IHDR";
var pngFriedChunkName = "CgBI";
var PNG = {
  validate(input) {
    if (pngSignature === toUTF8String(input, 1, 8)) {
      let chunkName = toUTF8String(input, 12, 16);
      if (chunkName === pngFriedChunkName) {
        chunkName = toUTF8String(input, 28, 32);
      }
      if (chunkName !== pngImageHeaderChunkName) {
        throw new TypeError("Invalid PNG");
      }
      return true;
    }
    return false;
  },
  calculate(input) {
    if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
      return {
        height: readUInt32BE(input, 36),
        width: readUInt32BE(input, 32)
      };
    }
    return {
      height: readUInt32BE(input, 20),
      width: readUInt32BE(input, 16)
    };
  }
};
var PNMTypes = {
  P1: "pbm/ascii",
  P2: "pgm/ascii",
  P3: "ppm/ascii",
  P4: "pbm",
  P5: "pgm",
  P6: "ppm",
  P7: "pam",
  PF: "pfm"
};
var handlers = {
  default: (lines) => {
    let dimensions = [];
    while (lines.length > 0) {
      const line = lines.shift();
      if (line[0] === "#") {
        continue;
      }
      dimensions = line.split(" ");
      break;
    }
    if (dimensions.length === 2) {
      return {
        height: Number.parseInt(dimensions[1], 10),
        width: Number.parseInt(dimensions[0], 10)
      };
    }
    throw new TypeError("Invalid PNM");
  },
  pam: (lines) => {
    const size = {};
    while (lines.length > 0) {
      const line = lines.shift();
      if (line.length > 16 || line.charCodeAt(0) > 128) {
        continue;
      }
      const [key, value] = line.split(" ");
      if (key && value) {
        size[key.toLowerCase()] = Number.parseInt(value, 10);
      }
      if (size.height && size.width) {
        break;
      }
    }
    if (size.height && size.width) {
      return {
        height: size.height,
        width: size.width
      };
    }
    throw new TypeError("Invalid PAM");
  }
};
var PNM = {
  validate: (input) => (toUTF8String(input, 0, 2) in PNMTypes),
  calculate(input) {
    const signature = toUTF8String(input, 0, 2);
    const type = PNMTypes[signature];
    const lines = toUTF8String(input, 3).split(/[\r\n]+/);
    const handler = handlers[type] || handlers.default;
    return handler(lines);
  }
};
var PSD = {
  validate: (input) => toUTF8String(input, 0, 4) === "8BPS",
  calculate: (input) => ({
    height: readUInt32BE(input, 14),
    width: readUInt32BE(input, 18)
  })
};
var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
var extractorRegExps = {
  height: /\sheight=(['"])([^%]+?)\1/,
  root: svgReg,
  viewbox: /\sviewBox=(['"])(.+?)\1/i,
  width: /\swidth=(['"])([^%]+?)\1/
};
var INCH_CM = 2.54;
var units = {
  in: 96,
  cm: 96 / INCH_CM,
  em: 16,
  ex: 8,
  m: 96 / INCH_CM * 100,
  mm: 96 / INCH_CM / 10,
  pc: 96 / 72 / 12,
  pt: 96 / 72,
  px: 1
};
var unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`);
function parseLength(len) {
  const m = unitsReg.exec(len);
  if (!m) {
    return;
  }
  return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
  const bounds = viewbox.split(" ");
  return {
    height: parseLength(bounds[3]),
    width: parseLength(bounds[2])
  };
}
function parseAttributes(root) {
  const width = root.match(extractorRegExps.width);
  const height = root.match(extractorRegExps.height);
  const viewbox = root.match(extractorRegExps.viewbox);
  return {
    height: height && parseLength(height[2]),
    viewbox: viewbox && parseViewbox(viewbox[2]),
    width: width && parseLength(width[2])
  };
}
function calculateByDimensions(attrs) {
  return {
    height: attrs.height,
    width: attrs.width
  };
}
function calculateByViewbox(attrs, viewbox) {
  const ratio = viewbox.width / viewbox.height;
  if (attrs.width) {
    return {
      height: Math.floor(attrs.width / ratio),
      width: attrs.width
    };
  }
  if (attrs.height) {
    return {
      height: attrs.height,
      width: Math.floor(attrs.height * ratio)
    };
  }
  return {
    height: viewbox.height,
    width: viewbox.width
  };
}
var SVG = {
  validate: (input) => svgReg.test(toUTF8String(input, 0, 1000)),
  calculate(input) {
    const root = toUTF8String(input).match(extractorRegExps.root);
    if (root) {
      const attrs = parseAttributes(root[0]);
      if (attrs.width && attrs.height) {
        return calculateByDimensions(attrs);
      }
      if (attrs.viewbox) {
        return calculateByViewbox(attrs, attrs.viewbox);
      }
    }
    throw new TypeError("Invalid SVG");
  }
};
var TGA = {
  validate(input) {
    return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
  },
  calculate(input) {
    return {
      height: readUInt16LE(input, 14),
      width: readUInt16LE(input, 12)
    };
  }
};
var CONSTANTS = {
  TAG: {
    WIDTH: 256,
    HEIGHT: 257,
    COMPRESSION: 259
  },
  TYPE: {
    SHORT: 3,
    LONG: 4,
    LONG8: 16
  },
  ENTRY_SIZE: {
    STANDARD: 12,
    BIG: 20
  },
  COUNT_SIZE: {
    STANDARD: 2,
    BIG: 8
  }
};
function readIFD(input, { isBigEndian, isBigTiff }) {
  const ifdOffset = isBigTiff ? Number(readUInt64(input, 8, isBigEndian)) : readUInt(input, 32, 4, isBigEndian);
  const entryCountSize = isBigTiff ? CONSTANTS.COUNT_SIZE.BIG : CONSTANTS.COUNT_SIZE.STANDARD;
  return input.slice(ifdOffset + entryCountSize);
}
function readTagValue(input, type, offset, isBigEndian) {
  switch (type) {
    case CONSTANTS.TYPE.SHORT:
      return readUInt(input, 16, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG:
      return readUInt(input, 32, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG8: {
      const value = Number(readUInt64(input, offset, isBigEndian));
      if (value > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("Value too large");
      }
      return value;
    }
    default:
      return 0;
  }
}
function nextTag(input, isBigTiff) {
  const entrySize = isBigTiff ? CONSTANTS.ENTRY_SIZE.BIG : CONSTANTS.ENTRY_SIZE.STANDARD;
  if (input.length > entrySize) {
    return input.slice(entrySize);
  }
}
function extractTags(input, { isBigEndian, isBigTiff }) {
  const tags = {};
  let temp = input;
  while (temp?.length) {
    const code = readUInt(temp, 16, 0, isBigEndian);
    const type = readUInt(temp, 16, 2, isBigEndian);
    const length = isBigTiff ? Number(readUInt64(temp, 4, isBigEndian)) : readUInt(temp, 32, 4, isBigEndian);
    if (code === 0)
      break;
    if (length === 1 && (type === CONSTANTS.TYPE.SHORT || type === CONSTANTS.TYPE.LONG || isBigTiff && type === CONSTANTS.TYPE.LONG8)) {
      const valueOffset = isBigTiff ? 12 : 8;
      tags[code] = readTagValue(temp, type, valueOffset, isBigEndian);
    }
    temp = nextTag(temp, isBigTiff);
  }
  return tags;
}
function determineFormat(input) {
  const signature = toUTF8String(input, 0, 2);
  const version = readUInt(input, 16, 2, signature === "MM");
  return {
    isBigEndian: signature === "MM",
    isBigTiff: version === 43
  };
}
function validateBigTIFFHeader(input, isBigEndian) {
  const byteSize = readUInt(input, 16, 4, isBigEndian);
  const reserved = readUInt(input, 16, 6, isBigEndian);
  if (byteSize !== 8 || reserved !== 0) {
    throw new TypeError("Invalid BigTIFF header");
  }
}
var signatures = /* @__PURE__ */ new Set([
  "49492a00",
  "4d4d002a",
  "49492b00",
  "4d4d002b"
]);
var TIFF = {
  validate: (input) => {
    const signature = toHexString(input, 0, 4);
    return signatures.has(signature);
  },
  calculate(input) {
    const format = determineFormat(input);
    if (format.isBigTiff) {
      validateBigTIFFHeader(input, format.isBigEndian);
    }
    const ifdBuffer = readIFD(input, format);
    const tags = extractTags(ifdBuffer, format);
    const info = {
      height: tags[CONSTANTS.TAG.HEIGHT],
      width: tags[CONSTANTS.TAG.WIDTH],
      type: format.isBigTiff ? "bigtiff" : "tiff"
    };
    if (tags[CONSTANTS.TAG.COMPRESSION]) {
      info.compression = tags[CONSTANTS.TAG.COMPRESSION];
    }
    if (!info.width || !info.height) {
      throw new TypeError("Invalid Tiff. Missing tags");
    }
    return info;
  }
};
function calculateExtended(input) {
  return {
    height: 1 + readUInt24LE(input, 7),
    width: 1 + readUInt24LE(input, 4)
  };
}
function calculateLossless(input) {
  return {
    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
    width: 1 + ((input[2] & 63) << 8 | input[1])
  };
}
function calculateLossy(input) {
  return {
    height: readInt16LE(input, 8) & 16383,
    width: readInt16LE(input, 6) & 16383
  };
}
var WEBP = {
  validate(input) {
    const riffHeader = toUTF8String(input, 0, 4) === "RIFF";
    const webpHeader = toUTF8String(input, 8, 12) === "WEBP";
    const vp8Header = toUTF8String(input, 12, 15) === "VP8";
    return riffHeader && webpHeader && vp8Header;
  },
  calculate(_input) {
    const chunkHeader = toUTF8String(_input, 12, 16);
    const input = _input.slice(20, 30);
    if (chunkHeader === "VP8X") {
      const extendedHeader = input[0];
      const validStart = (extendedHeader & 192) === 0;
      const validEnd = (extendedHeader & 1) === 0;
      if (validStart && validEnd) {
        return calculateExtended(input);
      }
      throw new TypeError("Invalid WebP");
    }
    if (chunkHeader === "VP8 " && input[0] !== 47) {
      return calculateLossy(input);
    }
    const signature = toHexString(input, 3, 6);
    if (chunkHeader === "VP8L" && signature !== "9d012a") {
      return calculateLossless(input);
    }
    throw new TypeError("Invalid WebP");
  }
};
var typeHandlers = /* @__PURE__ */ new Map([
  ["bmp", BMP],
  ["cur", CUR],
  ["dds", DDS],
  ["gif", GIF],
  ["heif", HEIF],
  ["icns", ICNS],
  ["ico", ICO],
  ["j2c", J2C],
  ["jp2", JP2],
  ["jpg", JPG],
  ["jxl", JXL],
  ["jxl-stream", JXLStream],
  ["ktx", KTX],
  ["png", PNG],
  ["pnm", PNM],
  ["psd", PSD],
  ["svg", SVG],
  ["tga", TGA],
  ["tiff", TIFF],
  ["webp", WEBP]
]);
var types = Array.from(typeHandlers.keys());
var firstBytes = /* @__PURE__ */ new Map([
  [0, "heif"],
  [56, "psd"],
  [66, "bmp"],
  [68, "dds"],
  [71, "gif"],
  [73, "tiff"],
  [77, "tiff"],
  [82, "webp"],
  [105, "icns"],
  [137, "png"],
  [255, "jpg"]
]);
function detector(input) {
  const byte = input[0];
  const type = firstBytes.get(byte);
  if (type && typeHandlers.get(type).validate(input)) {
    return type;
  }
  return types.find((type2) => typeHandlers.get(type2).validate(input));
}
var globalOptions = {
  disabledTypes: []
};
function imageSize(input) {
  const type = detector(input);
  if (typeof type !== "undefined") {
    if (globalOptions.disabledTypes.indexOf(type) > -1) {
      throw new TypeError(`disabled file type: ${type}`);
    }
    const size = typeHandlers.get(type).calculate(input);
    if (size !== undefined) {
      size.type = size.type ?? type;
      if (size.images && size.images.length > 1) {
        const largestImage = size.images.reduce((largest, current) => {
          return current.width * current.height > largest.width * largest.height ? current : largest;
        }, size.images[0]);
        size.width = largestImage.width;
        size.height = largestImage.height;
      }
      return size;
    }
  }
  throw new TypeError(`unsupported file type: ${type}`);
}

// src/utils/base64.ts
var import_mime_types = __toESM(require_mime_types(), 1);
async function fetchImageDimensionsFromUrl(imageUrlStr) {
  const MAX_BYTES = 256 * 1024;
  try {
    const imageUrl = new URL(imageUrlStr);
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      console.warn(`WARNING: Skip image dimension fetch of "${imageUrl}" ` + `due to HTTP error ${imageResponse.status}`);
      return null;
    }
    if (!imageResponse.body) {
      console.warn(`WARNING: No response body for image dimension fetch of "${imageUrl}"`);
      return null;
    }
    const chunks = [];
    let totalBytes = 0;
    const reader = imageResponse.body.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (value) {
          chunks.push(value);
          totalBytes += value.length;
          try {
            const buffer = Buffer.concat(chunks);
            const dimensions2 = imageSize(buffer);
            if (dimensions2 && dimensions2.width && dimensions2.height) {
              await reader.cancel();
              return dimensions2;
            }
          } catch (error) {}
          if (totalBytes > MAX_BYTES) {
            console.warn(`WARNING: Could not determine dimensions for "${imageUrl}" ` + `after downloading ${totalBytes} bytes. Using default dimensions.`);
            await reader.cancel();
            return null;
          }
        }
        if (done) {
          break;
        }
      }
      const finalBuffer = Buffer.concat(chunks);
      const dimensions = imageSize(finalBuffer);
      if (dimensions && dimensions.width && dimensions.height) {
        return dimensions;
      }
      console.warn(`WARNING: Could not determine dimensions from image data for "${imageUrl}"`);
      return null;
    } catch (sizeError) {
      console.warn(`WARNING: image-size failed for "${imageUrl}": ${sizeError.message}`);
      return null;
    } finally {
      await reader.cancel().catch(() => {});
    }
  } catch (error) {
    const errorObj = error;
    console.warn("WARNING: " + `Image dimension fetch failed for "${imageUrlStr}" with following error:`, (errorObj.cause ?? errorObj).message);
    return null;
  }
}
async function fetchImageToDataUrl(imageUrlStr) {
  try {
    const imageUrl = new URL(imageUrlStr);
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      console.warn(`WARNING: Skip download of "${imageUrl}" ` + `due to HTTP error ${imageResponse.status}`);
      return emptyPngDataURL;
    }
    const imgArrayBuff = await imageResponse.arrayBuffer();
    const base64String = Buffer.from(imgArrayBuff).toString("base64");
    if (!base64String) {
      console.warn("WARNING: Image response could not be converted to base64");
      return emptyPngDataURL;
    } else {
      let mimeType = import_mime_types.default.lookup(imageUrl.pathname);
      if (!mimeType) {
        const fileType = await fileTypeFromBuffer(imgArrayBuff);
        mimeType = fileType?.mime || "png";
      }
      return `data:${mimeType};base64,${base64String}`;
    }
  } catch (error) {
    const errorObj = error;
    console.warn("WARNING: " + `Image download failed for "${imageUrlStr}" with following error:`, (errorObj.cause ?? errorObj).message);
    return emptyPngDataURL;
  }
}
function extractBase64Data(src) {
  if (!src) {
    console.warn("WARNING: Empty base64 data URL");
    return null;
  }
  const idxComma = src.indexOf(",");
  const idxSlash = src.indexOf("/");
  if (idxComma === -1 || idxSlash === -1 || !src.startsWith("data:")) {
    console.warn(`WARNING: Invalid base64 data URL:
`, src);
    return null;
  }
  const idxSemi = src.indexOf(";");
  const extEnd = idxSemi === -1 ? idxComma : Math.min(idxSemi, idxComma);
  const base64Content = src.substring(idxComma + 1).trim();
  if (!base64Content) {
    console.warn("WARNING: Empty base64 data URL");
    return null;
  }
  return {
    type: src.substring("data:".length, idxSlash),
    extension: src.substring(idxSlash + 1, extEnd),
    base64Content
  };
}
var emptyPngBase64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAA" + "AAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=";
var emptyPngDataURL = "data:image/png;base64," + emptyPngBase64;

// src/utils/image-dimensions.ts
import fs from "fs/promises";
import os from "os";
import path from "path";
async function getImageDimensions(imageBuffer) {
  try {
    return imageSize(imageBuffer);
  } catch (error) {
    const errorMessage = error.message;
    if (errorMessage.includes("Tiff doesn't support buffer")) {
      try {
        const tmpDir = os.tmpdir();
        const tmpFile = path.join(tmpDir, `temp-image-${Date.now()}.tiff`);
        await fs.writeFile(tmpFile, imageBuffer);
        const fileBuffer = new Uint8Array(await fs.readFile(tmpFile));
        const dimensions = imageSize(fileBuffer);
        await fs.unlink(tmpFile);
        return dimensions;
      } catch (tempError) {
        const tempErrorMessage = tempError.message;
        console.warn("WARNING: Unable to determine TIFF image dimensions " + `even with temp file: ${tempErrorMessage}. ` + "Using default dimensions.");
        return { width: 400, height: 300 };
      }
    } else {
      console.warn("WARNING: Unable to determine image dimensions: " + `${errorMessage}. Using default dimensions.`);
      return { width: 400, height: 300 };
    }
  }
}

// src/utils/unit-conversion.ts
var pixelRegex = /([\d.]+)px/i;
var emRegex = /([\d.]+)em/i;
var remRegex = /([\d.]+)rem/i;
var percentageRegex = /([\d.]+)%/i;
var pointRegex = /([\d.]+)pt/i;
var cmRegex = /([\d.]+)cm/i;
var inchRegex = /([\d.]+)in/i;
function pixelToEMU(pixelValue) {
  return Math.round(pixelValue * 9525);
}
function emToEmu(emValue) {
  return pixelToEMU(emValue * 16);
}
function remToEmu(remValue) {
  return pixelToEMU(remValue * 16);
}
function TWIPToEMU(TWIPValue) {
  return Math.round(TWIPValue * 635);
}
function EMUToTWIP(EMUValue) {
  return Math.round(EMUValue / 635);
}
function pointToTWIP(pointValue) {
  return Math.round(pointValue * 20);
}
function pointToHIP(pointValue) {
  return Math.round(pointValue * 2);
}
function HIPToPoint(HIPValue) {
  return Math.round(HIPValue / 2);
}
function HIPToTWIP(HIPValue) {
  return Math.round(HIPValue * 10);
}
function TWIPToHIP(TWIPValue) {
  return Math.round(TWIPValue / 10);
}
function pixelToTWIP(pixelValue) {
  return EMUToTWIP(pixelToEMU(pixelValue));
}
function pixelToHIP(pixelValue) {
  return TWIPToHIP(EMUToTWIP(pixelToEMU(pixelValue)));
}
function inchToPoint(inchValue) {
  return Math.round(inchValue * 72);
}
function inchToTWIP(inchValue) {
  return pointToTWIP(inchToPoint(inchValue));
}
function cmToInch(cmValue) {
  return cmValue * 0.3937008;
}
function cmToTWIP(cmValue) {
  return inchToTWIP(cmToInch(cmValue));
}
function pixelToPoint(pixelValue) {
  return HIPToPoint(pixelToHIP(pixelValue));
}
function pointToEIP(PointValue) {
  return Math.round(PointValue * 8);
}
function pixelToEIP(pixelValue) {
  return pointToEIP(pixelToPoint(pixelValue));
}

// src/utils/url.ts
function isValidUrl(urlString) {
  const urlRegex = /http(s)?:\/\/(\w+:?\w*@)?(\S+)(:\d+)?((?<=\.)\w+)+(\/([\w#!:.?+=&%@!\-/])*)?/gi;
  return Boolean(urlRegex.test(urlString));
}

// src/utils/vnode.ts
function vNodeHasChildren(vNode) {
  return vNode && vNode.children && Array.isArray(vNode.children) && vNode.children.length;
}

// src/helpers/xml-builder.ts
var import_lodash2 = __toESM(require_lodash(), 1);
var import_is_vnode = __toESM(require_is_vnode(), 1);
var import_is_vtext = __toESM(require_is_vtext(), 1);
var import_vtext = __toESM(require_vtext(), 1);
var import_vnode = __toESM(require_vnode(), 1);
var import_xmlbuilder2 = __toESM(require_lib9(), 1);

// src/utils/color-conversion.ts
var rgbRegex = /rgb\((\d+),\s*([\d.]+),\s*([\d.]+)\)/i;
var hslRegex = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/i;
var hexRegex = /#([0-9A-F]{6})/i;
var hex3Regex = /#([0-9A-F])([0-9A-F])([0-9A-F])/i;
function rgbToHex(red, green, blue) {
  const hexColorCode = [red, green, blue].map((x2) => {
    x2 = (typeof x2 === "string" ? parseInt(x2) : x2 || 0).toString(16);
    return x2.length === 1 ? `0${x2}` : x2;
  }).join("");
  return hexColorCode;
}
function hslToHex(hue, saturation, luminosity) {
  hue = (hue || 0) / 360;
  saturation = (saturation || 0) / 100;
  luminosity = (luminosity || 0) / 100;
  let red;
  let green;
  let blue;
  if (saturation === 0) {
    red = green = blue = luminosity;
  } else {
    let hue2rgb = function(p2, q2, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2)
        return q2;
      if (t < 2 / 3)
        return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = luminosity < 0.5 ? luminosity * (1 + saturation) : luminosity + saturation - luminosity * saturation;
    const p = 2 * luminosity - q;
    red = hue2rgb(p, q, hue + 1 / 3);
    green = hue2rgb(p, q, hue);
    blue = hue2rgb(p, q, hue - 1 / 3);
  }
  return [red, green, blue].map((x2) => {
    const hex = Math.round(x2 * 255).toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }).join("");
}
function hex3ToHex(red, green, blue) {
  const hexColorCode = [red, green, blue].map((color) => `${color}${color}`).join("");
  return hexColorCode;
}

// src/utils/font-size.ts
function fixupFontSize(fontSizeString) {
  const input = String(fontSizeString || "").trim();
  if (pointRegex.test(input)) {
    const m = input.match(pointRegex);
    return pointToHIP(Number(m?.[1]));
  }
  if (pixelRegex.test(input)) {
    const m = input.match(pixelRegex);
    return pixelToHIP(Number(m?.[1]));
  }
  if (remRegex.test(input)) {
    const m = input.match(remRegex);
    const remVal = Number(m?.[1]) || 0;
    return pixelToHIP(remVal * 16);
  }
  if (emRegex.test(input)) {
    const m = input.match(emRegex);
    const emVal = Number(m?.[1]) || 0;
    return pixelToHIP(emVal * 16);
  }
  if (/^\d+(?:\.\d+)?$/.test(input)) {
    return pointToHIP(Number(input));
  }
  return 24;
}
var font_size_default = fixupFontSize;

// src/utils/xml-sanitizer.ts
function sanitizeXmlString(str) {
  if (!str)
    return str;
  let escaped = str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return escaped.replace(/[^\x09\x0A\x0D\x20-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]/gu, "");
}
function sanitizeHtml(html) {
  if (!html)
    return html;
  return html.replace(/[^\x09\x0A\x0D\x20-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]/gu, "");
}

// src/helpers/xml-builder.ts
function fixupColorCode(colorCodeString) {
  if (Object.prototype.hasOwnProperty.call(color_name_default, colorCodeString.toLowerCase())) {
    const [red, green, blue] = Object.prototype.hasOwnProperty.call(color_name_default, colorCodeString.toLowerCase()) ? color_name_default[colorCodeString.toLowerCase()] : [0, 0, 0];
    return rgbToHex(red, green, blue);
  } else if (rgbRegex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(rgbRegex);
    const red = matchedParts?.[1];
    const green = matchedParts?.[2];
    const blue = matchedParts?.[3];
    return rgbToHex(red, green, blue);
  } else if (hslRegex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(hslRegex);
    const hue = Number(matchedParts?.[1]);
    const saturation = Number(matchedParts?.[2]);
    const luminosity = Number(matchedParts?.[3]);
    return hslToHex(hue, saturation, luminosity);
  } else if (hexRegex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(hexRegex);
    return matchedParts?.[1] || "";
  } else if (hex3Regex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(hex3Regex);
    const red = Number(matchedParts?.[1]);
    const green = Number(matchedParts?.[2]);
    const blue = Number(matchedParts?.[3]);
    return hex3ToHex(red, green, blue);
  } else {
    return "000000";
  }
}
function buildRunFontFragment(fontName = defaultFont) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "rFonts").att("@w", "ascii", fontName).att("@w", "hAnsi", fontName).att("@w", "eastAsia", fontName).att("@w", "cs", fontName).up();
}
function buildRunStyleFragment(type = "Hyperlink") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "rStyle").att("@w", "val", type).up();
}
function buildTableRowHeight(tableRowHeight) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "trHeight").att("@w", "val", String(tableRowHeight)).att("@w", "hRule", "atLeast").up();
}
function buildVerticalAlignment(verticalAlignment) {
  const vertAlign = verticalAlignment.toLowerCase() === "middle" ? "center" : verticalAlignment;
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "vAlign").att("@w", "val", vertAlign).up();
}
function buildVerticalMerge(verticalMerge = "continue") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "vMerge").att("@w", "val", verticalMerge).up();
}
function buildColor(colorCode) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "color").att("@w", "val", colorCode).up();
}
function buildShading(colorCode) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "shd").att("@w", "val", "clear").att("@w", "fill", colorCode).up();
}
function buildHighlight(color = "yellow") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "highlight").att("@w", "val", color).up();
}
function buildVertAlign(type = "baseline") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "vertAlign").att("@w", "val", type).up();
}
function buildStrike() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "strike").att("@w", "val", "true").up();
}
function buildBold() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "b").up();
}
function buildItalics() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "i").up();
}
function buildUnderline(type = "single") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "u").att("@w", "val", type).up();
}
function buildLineBreak(type = "textWrapping") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "br").att("@w", "type", type).up();
}
function buildBorder(borderSide = "top", borderSize = 0, borderSpacing = 0, borderColor = fixupColorCode("black"), borderStroke = "single") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", borderSide).att("@w", "val", borderStroke).att("@w", "sz", String(borderSize)).att("@w", "space", String(borderSpacing)).att("@w", "color", borderColor).up();
}
function buildTextElement(text, preserveWhitespace = false) {
  const normalizedText = preserveWhitespace ? text : (() => {
    let t = text.replace(/\r\n?/g, `
`);
    t = t.replace(/[ \t]+\n/g, `
`);
    t = t.replace(/\n[ \t]+/g, `
`);
    t = t.replace(/\n/g, " ");
    t = t.replace(/ {2,}/g, " ");
    if (/^ {2,}/.test(text)) {
      t = t.replace(/^ +/, "");
      t = t.replace(/ +$/, "");
    }
    if (text.includes(`
`)) {
      if (/^\n\s+/.test(text)) {
        t = t.replace(/^ /, "");
      }
      if (/\s+\n$/.test(text)) {
        t = t.replace(/ $/, "");
      }
    }
    return t;
  })();
  const sanitizedText = sanitizeXmlString(normalizedText);
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "t").att("@xml", "space", "preserve").txt(sanitizedText).up();
}
function buildTextElementsWithSpaceSeparation(text, preserveWhitespace = false, attributes = {}) {
  if (preserveWhitespace) {
    const runFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
    const runPropertiesFragment = buildRunProperties(attributes);
    if (runPropertiesFragment) {
      runFragment.import(runPropertiesFragment);
    }
    const textFragment = buildTextElement(text, preserveWhitespace);
    runFragment.import(textFragment);
    return [runFragment];
  }
  const normalizedText = (() => {
    let t = text.replace(/\r\n?/g, `
`);
    t = t.replace(/[ \t]+\n/g, `
`);
    t = t.replace(/\n[ \t]+/g, `
`);
    const startsWithNewlineAndContent = /^\n\S/.test(t);
    t = t.replace(/\n/g, " ");
    t = t.replace(/ {2,}/g, " ");
    if (/^ {2,}/.test(text)) {
      t = t.replace(/^ +/, "");
      t = t.replace(/ +$/, "");
    }
    if (text.includes(`
`)) {
      if (/^\n/.test(text)) {
        t = t.replace(/^ +/, "");
      }
      if (/\s+\n$/.test(text)) {
        t = t.replace(/ +$/, "");
      }
    }
    if (/^ [A-Z]/.test(t) && !startsWithNewlineAndContent) {
      if (!/^ {2}/.test(t)) {
        t = t.replace(/^ /, "");
      }
    }
    if (startsWithNewlineAndContent) {
      t = t.replace(/^ /, "");
    }
    return t;
  })();
  const leadingSpace = normalizedText.match(/^(\s+)/);
  const trailingSpace = normalizedText.match(/(\s+)$/);
  const trimmedText = normalizedText.trim();
  const runs = [];
  if (leadingSpace) {
    const spaceRunFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
    const runPropertiesFragment = buildRunProperties(attributes);
    if (runPropertiesFragment) {
      spaceRunFragment.import(runPropertiesFragment);
    }
    const spaceTextFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "t").att("@xml", "space", "preserve").txt(sanitizeXmlString(leadingSpace[1])).up();
    spaceRunFragment.import(spaceTextFragment);
    runs.push(spaceRunFragment);
  }
  if (trimmedText) {
    const mainRunFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
    const runPropertiesFragment = buildRunProperties(attributes);
    if (runPropertiesFragment) {
      mainRunFragment.import(runPropertiesFragment);
    }
    const mainTextFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "t").att("@xml", "space", "preserve").txt(sanitizeXmlString(trimmedText)).up();
    mainRunFragment.import(mainTextFragment);
    runs.push(mainRunFragment);
  }
  if (trailingSpace && (!leadingSpace || trailingSpace[1] !== leadingSpace[1] || trimmedText)) {
    const spaceRunFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
    const runPropertiesFragment = buildRunProperties(attributes);
    if (runPropertiesFragment) {
      spaceRunFragment.import(runPropertiesFragment);
    }
    const spaceTextFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "t").att("@xml", "space", "preserve").txt(sanitizeXmlString(trailingSpace[1])).up();
    spaceRunFragment.import(spaceTextFragment);
    runs.push(spaceRunFragment);
  }
  if (runs.length === 0) {
    const emptyRunFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
    const runPropertiesFragment = buildRunProperties(attributes);
    if (runPropertiesFragment) {
      emptyRunFragment.import(runPropertiesFragment);
    }
    const textFragment = buildTextElement(normalizedText, preserveWhitespace);
    emptyRunFragment.import(textFragment);
    runs.push(emptyRunFragment);
  }
  return runs;
}
function fixupLineHeight(lineHeight, fontSize) {
  if (Number.isFinite(lineHeight)) {
    if (Number.isFinite(fontSize)) {
      const actualLineHeight = Number(lineHeight) * Number(fontSize);
      return HIPToTWIP(actualLineHeight);
    } else {
      return Number(lineHeight) * 240;
    }
  } else {
    return 240;
  }
}
function fixupRowHeight(rowHeightString) {
  if (pointRegex.test(rowHeightString)) {
    const matchedParts = rowHeightString.match(pointRegex);
    return pointToTWIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(rowHeightString)) {
    const matchedParts = rowHeightString.match(pixelRegex);
    return pixelToTWIP(Number(matchedParts?.[1]));
  } else if (cmRegex.test(rowHeightString)) {
    const matchedParts = rowHeightString.match(cmRegex);
    return cmToTWIP(Number(matchedParts?.[1]));
  } else if (inchRegex.test(rowHeightString)) {
    const matchedParts = rowHeightString.match(inchRegex);
    return inchToTWIP(Number(matchedParts?.[1]));
  }
}
function fixupColumnWidth(columnWidth) {
  if (typeof columnWidth === "number") {
    return columnWidth;
  }
  if (pointRegex.test(columnWidth)) {
    const matchedParts = columnWidth.match(pointRegex);
    return pointToTWIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(columnWidth)) {
    const matchedParts = columnWidth.match(pixelRegex);
    return pixelToTWIP(Number(matchedParts?.[1]));
  } else if (cmRegex.test(columnWidth)) {
    const matchedParts = columnWidth.match(cmRegex);
    return cmToTWIP(Number(matchedParts?.[1]));
  } else if (inchRegex.test(columnWidth)) {
    const matchedParts = columnWidth.match(inchRegex);
    return inchToTWIP(Number(matchedParts?.[1]));
  } else {
    return columnWidth;
  }
}
function fixupMargin(marginString) {
  if (pointRegex.test(marginString)) {
    const matchedParts = marginString.match(pointRegex);
    return pointToTWIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(marginString)) {
    const matchedParts = marginString.match(pixelRegex);
    return pixelToTWIP(Number(matchedParts?.[1]));
  }
}
function modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes, options = { isParagraph: false }) {
  const modifiedAttributes = { ...attributes };
  if (vNode && import_is_vnode.default(vNode)) {
    const properties = vNode.properties;
    if (properties && properties.style) {
      if (properties.style.color && !colorlessColors.includes(properties.style.color)) {
        modifiedAttributes.color = fixupColorCode(properties.style.color);
      }
      if (properties.style["text-decoration"] && properties.style["text-decoration"].includes("underline")) {
        modifiedAttributes.u = true;
      }
      if (properties.style["background-color"] && !colorlessColors.includes(properties.style["background-color"])) {
        modifiedAttributes.backgroundColor = fixupColorCode(properties.style["background-color"]);
      }
      if (properties.style["vertical-align"] && verticalAlignValues.includes(properties.style["vertical-align"])) {
        modifiedAttributes.verticalAlign = properties.style["vertical-align"];
      }
      if (properties.style["text-align"] && ["left", "right", "center", "justify"].includes(properties.style["text-align"])) {
        modifiedAttributes.textAlign = properties.style["text-align"];
      }
      if (properties.style["font-weight"] && properties.style["font-weight"] === "bold") {
        modifiedAttributes.strong = true;
      }
      if (properties.style["font-style"] && properties.style["font-style"] === "italic") {
        modifiedAttributes.i = true;
      }
      if (properties.style["font-family"] || properties.style.fontFamily) {
        modifiedAttributes.font = docxDocumentInstance.createFont(properties.style.fontFamily || properties.style["font-family"]);
      }
      const fontSizeValue = properties.style.fontSize || properties.style["font-size"];
      if (fontSizeValue) {
        modifiedAttributes.fontSize = fixupFontSize(String(fontSizeValue));
      }
      if (properties.style["line-height"]) {
        modifiedAttributes.lineHeight = fixupLineHeight(properties.style["line-height"], properties.style["font-size"] ? fixupFontSize(properties.style["font-size"]) : undefined);
      }
      if (properties.style["margin-left"] || properties.style["margin-right"]) {
        const leftMargin = fixupMargin(properties.style["margin-left"]);
        const rightMargin = fixupMargin(properties.style["margin-right"]);
        if (leftMargin || rightMargin) {
          modifiedAttributes.indentation = {
            left: leftMargin,
            right: rightMargin
          };
        }
      }
      if (properties.style.display) {
        modifiedAttributes.display = properties.style.display;
      }
      if (properties.style.width) {
        modifiedAttributes.width = properties.style.width;
      }
    }
    const props = vNode.properties || {};
    const classAttr = props.className || props.class || props.attributes && props.attributes.class || "";
    if (classAttr && docxDocumentInstance.cssClassStyles) {
      classAttr.toString().split(/\s+/).filter(Boolean).forEach((cls) => {
        const clsStyles = docxDocumentInstance.cssClassStyles[cls];
        if (clsStyles) {
          if (clsStyles.color && !modifiedAttributes.color) {
            modifiedAttributes.color = fixupColorCode(String(clsStyles.color));
          }
          if (clsStyles["background-color"] && !modifiedAttributes.backgroundColor) {
            modifiedAttributes.backgroundColor = fixupColorCode(String(clsStyles["background-color"]));
          }
          if (clsStyles["font-size"] && !modifiedAttributes.fontSize) {
            modifiedAttributes.fontSize = fixupFontSize(clsStyles["font-size"]);
          }
          if (clsStyles["font-weight"] && clsStyles["font-weight"] === "bold" && !modifiedAttributes.strong) {
            modifiedAttributes.strong = true;
          }
          if (clsStyles["font-style"] && clsStyles["font-style"] === "italic" && !modifiedAttributes.i) {
            modifiedAttributes.i = true;
          }
          if (clsStyles["font-family"] && !modifiedAttributes.font) {
            modifiedAttributes.font = docxDocumentInstance.createFont(clsStyles["font-family"]);
          }
        }
      });
    }
    if (!modifiedAttributes.font && docxDocumentInstance.cssClassStyles && docxDocumentInstance.cssClassStyles.__element_body) {
      const bodyStyles = docxDocumentInstance.cssClassStyles.__element_body;
      if (bodyStyles["font-family"]) {
        modifiedAttributes.font = docxDocumentInstance.createFont(bodyStyles["font-family"]);
      }
    }
    if (!modifiedAttributes.font && docxDocumentInstance.cssClassStyles && docxDocumentInstance.cssClassStyles["__element_*"]) {
      const universalStyles = docxDocumentInstance.cssClassStyles["__element_*"];
      if (universalStyles["font-family"]) {
        modifiedAttributes.font = docxDocumentInstance.createFont(universalStyles["font-family"]);
      }
    }
  }
  if (options?.isParagraph) {
    if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "blockquote") {
      modifiedAttributes.indentation = { left: 284, right: 0 };
      modifiedAttributes.textAlign = "justify";
    } else if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "code") {
      modifiedAttributes.highlightColor = "lightGray";
    } else if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "pre") {
      modifiedAttributes.font = "Courier";
    }
  }
  return modifiedAttributes;
}
function buildFormatting(htmlTag, options) {
  switch (htmlTag) {
    case "strong":
    case "b":
      return buildBold();
    case "em":
    case "i":
      return buildItalics();
    case "ins":
    case "u":
      return buildUnderline();
    case "strike":
    case "del":
    case "s":
      return buildStrike();
    case "sub":
      return buildVertAlign("subscript");
    case "sup":
      return buildVertAlign("superscript");
    case "mark":
      return buildHighlight();
    case "code":
      return buildHighlight("lightGray");
    case "highlightColor":
      if (options.color) {
        return buildHighlight(options.color);
      }
      break;
    case "font":
      if (options.font) {
        return buildRunFontFragment(options.font);
      }
      break;
    case "pre":
      return buildRunFontFragment("Courier");
    case "color":
      if (options.color) {
        return buildColor(options.color);
      }
      break;
    case "backgroundColor":
      if (options.color) {
        return buildShading(options.color);
      }
      break;
    case "fontSize": {
      if (typeof options.fontSize === "undefined") {
        return null;
      }
      const fsValue = options.fontSize;
      const szFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("w:sz", { "w:val": String(fsValue) }).up();
      const szCsFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("w:szCs", { "w:val": String(fsValue) }).up();
      return import_xmlbuilder2.fragment().import(szFragment).import(szCsFragment);
    }
    case "hyperlink":
      return buildRunStyleFragment("Hyperlink");
    default:
      break;
  }
  return null;
}
function buildRunProperties(attributes) {
  const keys = Object.keys(attributes);
  if (keys.length && (keys[0] !== "textAlign" || keys.length > 1)) {
    const runPropertiesFragment = import_xmlbuilder2.fragment({
      namespaceAlias: { w: namespaces_default.w }
    }).ele("@w", "rPr");
    keys.forEach((key) => {
      const options = {
        color: key === "color" || key === "backgroundColor" || key === "highlightColor" ? attributes[key] || undefined : undefined,
        fontSize: key === "fontSize" ? attributes.fontSize : undefined,
        font: key === "font" ? attributes.font : undefined
      };
      const formattingFragment = buildFormatting(key, options);
      if (formattingFragment) {
        runPropertiesFragment.import(formattingFragment);
      }
    });
    const attrs = Object.keys(runPropertiesFragment.toObject()?.rPr);
    if (attrs?.[0] === "@xmlns" && attrs.length === 1) {
      return null;
    }
    return runPropertiesFragment;
  }
}
async function buildRun(vNode, attributes, docxDocumentInstance, preserveWhitespace = false) {
  attributes = modifiedStyleAttributesBuilder(docxDocumentInstance, import_is_vnode.default(vNode) ? vNode : null, { ...attributes });
  const runFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
  const runPropertiesFragment = buildRunProperties(import_lodash2.default.cloneDeep(attributes));
  if (import_is_vnode.default(vNode) && vNode.tagName === "span") {
    return buildRunOrRuns(vNode, attributes, docxDocumentInstance, preserveWhitespace);
  }
  if (vNode && import_is_vnode.default(vNode) && [
    "strong",
    "b",
    "em",
    "i",
    "u",
    "ins",
    "strike",
    "del",
    "s",
    "sub",
    "sup",
    "mark",
    "code",
    "pre"
  ].includes(vNode.tagName)) {
    const runFragmentsArray = [];
    let vNodes = [vNode];
    let tempAttributes = import_lodash2.default.cloneDeep(attributes);
    while (vNodes.length) {
      const tempVNode = vNodes.shift();
      if (import_is_vtext.default(tempVNode)) {
        const textRuns = buildTextElementsWithSpaceSeparation(tempVNode.text, preserveWhitespace, {
          ...attributes,
          ...tempAttributes
        });
        runFragmentsArray.push(...textRuns);
        tempAttributes = import_lodash2.default.cloneDeep(attributes);
      } else if (import_is_vnode.default(tempVNode)) {
        if ([
          "strong",
          "b",
          "em",
          "i",
          "u",
          "ins",
          "strike",
          "del",
          "s",
          "sub",
          "sup",
          "mark",
          "code",
          "pre"
        ].includes(tempVNode.tagName)) {
          switch (tempVNode.tagName) {
            case "strong":
            case "b":
              tempAttributes.strong = true;
              break;
            case "i":
            case "em":
              tempAttributes.i = true;
              break;
            case "u":
              tempAttributes.u = true;
              break;
            case "sub":
              tempAttributes.sub = true;
              break;
            case "sup":
              tempAttributes.sup = true;
              break;
            default:
              break;
          }
          const formattingFragment = buildFormatting(tempVNode.tagName, {});
          if (runPropertiesFragment && formattingFragment) {
            runPropertiesFragment.import(formattingFragment);
          }
        } else if (tempVNode.tagName === "span") {
          const spanFragment = await buildRunOrRuns(tempVNode, { ...attributes, ...tempAttributes }, docxDocumentInstance, preserveWhitespace);
          if (Array.isArray(spanFragment)) {
            spanFragment.flat(Infinity);
            runFragmentsArray.push(...spanFragment);
          } else {
            runFragmentsArray.push(spanFragment);
          }
          continue;
        }
      }
      if (tempVNode.children?.length) {
        if (tempVNode.children.length > 1) {
          attributes = { ...attributes, ...tempAttributes };
        }
        vNodes = tempVNode.children.slice().concat(vNodes);
      }
    }
    if (runFragmentsArray.length) {
      return runFragmentsArray;
    }
  }
  if (runPropertiesFragment) {
    runFragment.import(runPropertiesFragment);
  }
  if (import_is_vtext.default(vNode)) {
    const textRuns = buildTextElementsWithSpaceSeparation(vNode.text, preserveWhitespace, attributes);
    if (textRuns.length > 1) {
      return textRuns;
    } else if (textRuns.length === 1) {
      return textRuns[0];
    }
    const textFragment = buildTextElement(vNode.text, preserveWhitespace);
    runFragment.import(textFragment);
  } else if (attributes && attributes.type === "picture") {
    let response = null;
    const originalSrc = vNode.properties.src;
    const isUrl = isValidUrl(originalSrc);
    if (isUrl && docxDocumentInstance.embedImages) {
      vNode.properties.src = await fetchImageToDataUrl(vNode.properties.src);
    }
    if (isUrl && !docxDocumentInstance.embedImages) {
      const documentRelsId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, imageType, originalSrc, "External");
      attributes.inlineOrAnchored = true;
      attributes.relationshipId = documentRelsId;
      attributes.fileNameWithExtension = originalSrc;
      attributes.isExternalLink = true;
      if (!attributes.width)
        attributes.width = pixelToEMU(600);
      if (!attributes.height)
        attributes.height = pixelToEMU(400);
    } else {
      const base64Uri = decodeURIComponent(vNode.properties.src);
      if (base64Uri) {
        response = docxDocumentInstance.createMediaFile(base64Uri);
      }
      if (response) {
        docxDocumentInstance.zip.folder("word")?.folder("media")?.file(response.fileNameWithExtension, Buffer.from(response.fileContent, "base64"), {
          createFolders: false
        });
        const documentRelsId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, imageType, `media/${response.fileNameWithExtension}`, internalRelationship);
        attributes.inlineOrAnchored = true;
        attributes.relationshipId = documentRelsId;
        attributes.id = response.id;
        attributes.fileContent = response.fileContent;
        attributes.fileNameWithExtension = response.fileNameWithExtension;
      }
    }
    const imageFragment = buildDrawing(attributes);
    runFragment.import(imageFragment);
  } else if (import_is_vnode.default(vNode) && vNode.tagName === "br") {
    const lineBreakFragment = buildLineBreak();
    runFragment.import(lineBreakFragment);
  } else if (import_is_vnode.default(vNode) && vNodeHasChildren(vNode)) {
    let extractTextFromChildren = function(children) {
      return children.map((child) => {
        if (import_is_vtext.default(child)) {
          return child.text;
        } else if (import_is_vnode.default(child) && child.children) {
          return extractTextFromChildren(child.children);
        }
        return "";
      }).join("");
    };
    const textContent = extractTextFromChildren(vNode.children);
    if (textContent.trim()) {
      const textFragment = buildTextElement(textContent, preserveWhitespace);
      runFragment.import(textFragment);
    }
  } else if (import_is_vnode.default(vNode) && vNode.tagName === "img") {
    return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } });
  }
  runFragment.up();
  return runFragment;
}
async function buildRunOrRuns(vNode, attributes, docxDocumentInstance, preserveWhitespace = false) {
  if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "span") {
    let runFragments = [];
    for (let index = 0;index < vNode.children.length; index++) {
      const childVNode = vNode.children[index];
      const modifiedAttributes = modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes);
      if (import_is_vnode.default(childVNode) && childVNode.tagName === "img") {
        const isUrl = isValidUrl(childVNode.properties.src);
        if (isUrl && docxDocumentInstance.embedImages) {
          childVNode.properties.src = await fetchImageToDataUrl(childVNode.properties.src);
        }
        if (!isUrl || docxDocumentInstance.embedImages) {
          const base64String = extractBase64Data(childVNode.properties.src)?.base64Content;
          const imageBuffer = Buffer.from(decodeURIComponent(base64String || ""), "base64");
          const imageProperties = await getImageDimensions(imageBuffer);
          modifiedAttributes.maximumWidth = modifiedAttributes.maximumWidth || docxDocumentInstance.availableDocumentSpace;
          modifiedAttributes.originalWidth = imageProperties.width;
          modifiedAttributes.originalHeight = imageProperties.height;
          computeImageDimensions(childVNode, modifiedAttributes);
        }
      }
      const tempRunFragments = await buildRun(childVNode, modifiedAttributes, docxDocumentInstance, preserveWhitespace);
      runFragments = runFragments.concat(Array.isArray(tempRunFragments) ? tempRunFragments : [tempRunFragments]);
    }
    return runFragments;
  } else {
    const tempRunFragments = await buildRun(vNode, attributes, docxDocumentInstance, preserveWhitespace);
    return tempRunFragments;
  }
}
async function buildRunOrHyperLink(vNode, attributes, docxDocumentInstance, preserveWhitespace = false) {
  if (import_is_vnode.default(vNode) && vNode.tagName === "input") {
    return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } });
  }
  if (import_is_vnode.default(vNode) && vNode.tagName === "a") {
    const relationshipId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, hyperlinkType, vNode.properties && vNode.properties.href ? vNode.properties.href : "");
    const hyperlinkFragment = import_xmlbuilder2.fragment({
      namespaceAlias: { w: namespaces_default.w, r: namespaces_default.r }
    }).ele("@w", "hyperlink").att("@r", "id", `rId${relationshipId}`);
    const modifiedAttributes = { ...attributes };
    modifiedAttributes.hyperlink = true;
    const runFragments2 = await buildRunOrRuns(vNode.children[0], modifiedAttributes, docxDocumentInstance, preserveWhitespace);
    if (Array.isArray(runFragments2)) {
      for (let index = 0;index < runFragments2.length; index++) {
        const runFragment = runFragments2[index];
        hyperlinkFragment.import(runFragment);
      }
    } else {
      hyperlinkFragment.import(runFragments2);
    }
    hyperlinkFragment.up();
    return hyperlinkFragment;
  }
  const runFragments = await buildRunOrRuns(vNode, attributes, docxDocumentInstance, preserveWhitespace);
  return runFragments;
}
function buildNumberingProperties(levelId, numberingId) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "numPr").ele("@w", "ilvl").att("@w", "val", String(levelId)).up().ele("@w", "numId").att("@w", "val", String(numberingId)).up();
}
function buildSpacing(lineSpacing, beforeSpacing, afterSpacing) {
  if (!Number.isFinite(lineSpacing) && !Number.isFinite(beforeSpacing) && !Number.isFinite(afterSpacing)) {
    return;
  }
  const spacingFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "spacing");
  if (Number.isFinite(lineSpacing)) {
    spacingFragment.att("@w", "line", String(lineSpacing));
  }
  if (Number.isFinite(beforeSpacing)) {
    spacingFragment.att("@w", "before", String(beforeSpacing));
  }
  if (Number.isFinite(afterSpacing)) {
    spacingFragment.att("@w", "after", String(afterSpacing));
  }
  spacingFragment.att("@w", "lineRule", "auto").up();
  return spacingFragment;
}
function buildIndentation({ left, right }) {
  if (!left && !right) {
    return;
  }
  const indentationFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "ind");
  if (left) {
    indentationFragment.att("@w", "left", String(left));
  }
  if (right) {
    indentationFragment.att("@w", "right", String(right));
  }
  indentationFragment.up();
  return indentationFragment;
}
function buildPStyle(style = "Normal") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "pStyle").att("@w", "val", style).up();
}
function buildHorizontalAlignment(horizontalAlignment) {
  const horAlign = horizontalAlignment === "justify" ? "both" : horizontalAlignment;
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "jc").att("@w", "val", horAlign).up();
}
function buildParagraphBorder() {
  const paragraphBorderFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "pBdr");
  const bordersObject = import_lodash2.default.cloneDeep(paragraphBordersObject);
  Object.keys(bordersObject).forEach((borderName) => {
    const bName = borderName;
    if (bordersObject[bName]) {
      const { size, spacing, color } = bordersObject[bName];
      const borderFragment = buildBorder(bName, size, spacing, color);
      paragraphBorderFragment.import(borderFragment);
    }
  });
  paragraphBorderFragment.up();
  return paragraphBorderFragment;
}
function buildParagraphProperties(attributes, forceEmpty = false) {
  const keys = Object.keys(attributes);
  let hasProperties = false;
  const paragraphPropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "pPr");
  if (keys.length) {
    keys.forEach((key) => {
      switch (key) {
        case "numbering": {
          if (attributes.numbering?.levelId !== undefined && attributes.numbering?.numberingId !== undefined) {
            const numberingPropertiesFragment = buildNumberingProperties(attributes.numbering.levelId, attributes.numbering.numberingId);
            paragraphPropertiesFragment.import(numberingPropertiesFragment);
            hasProperties = true;
            delete attributes.numbering;
          }
          break;
        }
        case "textAlign": {
          if (attributes.textAlign) {
            const horizontalAlignmentFragment = buildHorizontalAlignment(attributes.textAlign);
            paragraphPropertiesFragment.import(horizontalAlignmentFragment);
            hasProperties = true;
            delete attributes.textAlign;
          }
          break;
        }
        case "backgroundColor":
          if (attributes.backgroundColor && attributes.display === "block") {
            const shadingFragment = buildShading(attributes.backgroundColor);
            paragraphPropertiesFragment.import(shadingFragment);
            const paragraphBorderFragment = buildParagraphBorder();
            paragraphPropertiesFragment.import(paragraphBorderFragment);
            hasProperties = true;
            delete attributes.backgroundColor;
          }
          break;
        case "paragraphStyle": {
          if (attributes.paragraphStyle) {
            const pStyleFragment = buildPStyle(attributes.paragraphStyle);
            paragraphPropertiesFragment.import(pStyleFragment);
            hasProperties = true;
            delete attributes.paragraphStyle;
          }
          break;
        }
        case "indentation": {
          if (attributes.indentation) {
            const indentationFragment = buildIndentation(attributes.indentation);
            if (indentationFragment) {
              paragraphPropertiesFragment.import(indentationFragment);
              hasProperties = true;
            }
            delete attributes.indentation;
          }
          break;
        }
        default:
          break;
      }
    });
  }
  const spacingFragment = buildSpacing(attributes.lineHeight, attributes.beforeSpacing, attributes.afterSpacing);
  delete attributes.lineHeight;
  delete attributes.beforeSpacing;
  delete attributes.afterSpacing;
  if (spacingFragment) {
    paragraphPropertiesFragment.import(spacingFragment);
    hasProperties = true;
  }
  if (hasProperties || forceEmpty) {
    paragraphPropertiesFragment.up();
    return paragraphPropertiesFragment;
  } else {
    return null;
  }
}
function computeImageDimensions(vNode, attributes) {
  const { maximumWidth, originalWidth, originalHeight } = attributes;
  const aspectRatio = (originalWidth || 0) / (originalHeight || 1);
  const maximumWidthInEMU = TWIPToEMU(maximumWidth || 0);
  let originalWidthInEMU = pixelToEMU(originalWidth || 0);
  let originalHeightInEMU = pixelToEMU(originalHeight || 0);
  if (originalWidthInEMU > maximumWidthInEMU) {
    originalWidthInEMU = maximumWidthInEMU;
    originalHeightInEMU = Math.round(originalWidthInEMU / aspectRatio);
  }
  let modifiedHeight;
  let modifiedWidth;
  if (vNode.properties && vNode.properties.style) {
    const styleWidth = vNode.properties.style.width;
    const styleHeight = vNode.properties.style.height;
    if (styleWidth) {
      if (styleWidth !== "auto") {
        if (pixelRegex.test(styleWidth)) {
          modifiedWidth = pixelToEMU(styleWidth.match(pixelRegex)[1]);
        } else if (emRegex.test(styleWidth)) {
          modifiedWidth = emToEmu(styleWidth.match(emRegex)[1]);
        } else if (remRegex.test(styleWidth)) {
          modifiedWidth = remToEmu(styleWidth.match(remRegex)[1]);
        } else if (percentageRegex.test(styleWidth)) {
          const percentageValue = styleWidth.match(percentageRegex)[1];
          modifiedWidth = Math.round(percentageValue / 100 * originalWidthInEMU);
        } else {
          modifiedWidth = originalWidthInEMU;
          modifiedHeight = originalHeightInEMU;
        }
      } else {
        if (styleHeight && styleHeight === "auto") {
          modifiedWidth = originalWidthInEMU;
          modifiedHeight = originalHeightInEMU;
        }
      }
    }
    if (styleHeight) {
      if (styleHeight !== "auto") {
        if (pixelRegex.test(styleHeight)) {
          modifiedHeight = pixelToEMU(styleHeight.match(pixelRegex)[1]);
        } else if (emRegex.test(styleHeight)) {
          modifiedHeight = emToEmu(styleHeight.match(emRegex)[1]);
        } else if (remRegex.test(styleHeight)) {
          modifiedHeight = remToEmu(styleHeight.match(remRegex)[1]);
        } else if (percentageRegex.test(styleHeight)) {
          const percentageValue = styleHeight.match(percentageRegex)[1];
          modifiedHeight = Math.round(percentageValue / 100 * originalHeightInEMU);
          if (!modifiedWidth) {
            modifiedWidth = Math.round(modifiedHeight * aspectRatio);
          }
        }
      } else {
        if (modifiedWidth) {
          if (!modifiedHeight) {
            modifiedHeight = Math.round(modifiedWidth / aspectRatio);
          }
        } else {
          modifiedHeight = originalHeightInEMU;
          modifiedWidth = originalWidthInEMU;
        }
      }
    }
    if (modifiedWidth && !modifiedHeight) {
      modifiedHeight = Math.round(modifiedWidth / aspectRatio);
    } else if (modifiedHeight && !modifiedWidth) {
      modifiedWidth = Math.round(modifiedHeight * aspectRatio);
    } else {
      modifiedWidth = originalWidthInEMU;
      modifiedHeight = originalHeightInEMU;
    }
  } else {
    modifiedWidth = originalWidthInEMU;
    modifiedHeight = originalHeightInEMU;
  }
  attributes.width = modifiedWidth;
  attributes.height = modifiedHeight;
}
function preprocessParagraphChildren(children) {
  if (children.length === 0)
    return children;
  const processedChildren = [];
  for (let i2 = 0;i2 < children.length; i2++) {
    const current = children[i2];
    const next = i2 < children.length - 1 ? children[i2 + 1] : null;
    if (import_is_vtext.default(current)) {
      const text = current.text;
      const trimmedText = text.trim();
      if (trimmedText) {
        const leadingSpaces = text.match(/^(\s+)/)?.[1] || "";
        const trailingSpaces = text.match(/(\s+)$/)?.[1] || "";
        if (leadingSpaces && i2 > 0) {
          const prevInProcessed = processedChildren[processedChildren.length - 1];
          const prevEndsWithSpace = prevInProcessed && import_is_vtext.default(prevInProcessed) && prevInProcessed.text.endsWith(" ");
          if (!prevEndsWithSpace) {
            processedChildren.push(new import_vtext.default(" "));
          }
        }
        processedChildren.push(new import_vtext.default(trimmedText));
        if (trailingSpaces && i2 < children.length - 1) {
          processedChildren.push(new import_vtext.default(" "));
        }
      } else if (text.match(/^\s+$/)) {
        const prevInProcessed = processedChildren[processedChildren.length - 1];
        const shouldAddSpace = i2 > 0 && i2 < children.length - 1 && !(prevInProcessed && import_is_vtext.default(prevInProcessed) && prevInProcessed.text === " ");
        if (shouldAddSpace) {
          processedChildren.push(new import_vtext.default(" "));
        }
      }
    } else if (import_is_vnode.default(current)) {
      const vNodeCurrent = current;
      if (vNodeCurrent.children && vNodeCurrent.children.length === 1 && import_is_vtext.default(vNodeCurrent.children[0])) {
        const childText = vNodeCurrent.children[0].text;
        const trimmedChildText = childText.trim();
        if (trimmedChildText) {
          const leadingSpaces = childText.match(/^(\s+)/)?.[1] || "";
          const trailingSpaces = childText.match(/(\s+)$/)?.[1] || "";
          if (leadingSpaces && i2 > 0) {
            const prevInProcessed = processedChildren[processedChildren.length - 1];
            const prevEndsWithSpace = prevInProcessed && import_is_vtext.default(prevInProcessed) && prevInProcessed.text.endsWith(" ");
            if (!prevEndsWithSpace) {
              processedChildren.push(new import_vtext.default(" "));
            }
          }
          const modifiedElement = new import_vnode.default(vNodeCurrent.tagName, vNodeCurrent.properties, [new import_vtext.default(trimmedChildText)]);
          processedChildren.push(modifiedElement);
          const nextIsWhitespaceOnly = next && import_is_vtext.default(next) && next.text.match(/^\s+$/);
          if (trailingSpaces && i2 < children.length - 1 && !nextIsWhitespaceOnly) {
            processedChildren.push(new import_vtext.default(" "));
          }
        } else {
          processedChildren.push(new import_vtext.default(" "));
        }
      } else {
        processedChildren.push(current);
      }
    } else {
      processedChildren.push(current);
    }
  }
  return processedChildren;
}
async function buildParagraph(vNode, attributes, docxDocumentInstance, preserveWhitespace = false) {
  const paragraphFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "p");
  const modifiedAttributes = modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes, {
    isParagraph: true
  });
  const paragraphPropertiesFragment = buildParagraphProperties(modifiedAttributes, false);
  if (paragraphPropertiesFragment) {
    paragraphFragment.import(paragraphPropertiesFragment);
  }
  if (vNode && import_is_vnode.default(vNode) && vNodeHasChildren(vNode)) {
    if ([
      "span",
      "strong",
      "b",
      "em",
      "i",
      "u",
      "ins",
      "strike",
      "del",
      "s",
      "sub",
      "sup",
      "mark",
      "a",
      "code",
      "pre"
    ].includes(vNode.tagName)) {
      const isPreTag = vNode.tagName === "pre";
      const runOrHyperlinkFragments = await buildRunOrHyperLink(vNode, modifiedAttributes, docxDocumentInstance, isPreTag);
      if (Array.isArray(runOrHyperlinkFragments)) {
        for (let iteratorIndex = 0;iteratorIndex < runOrHyperlinkFragments.length; iteratorIndex++) {
          const runOrHyperlinkFragment = runOrHyperlinkFragments[iteratorIndex];
          paragraphFragment.import(runOrHyperlinkFragment);
        }
      } else {
        paragraphFragment.import(runOrHyperlinkFragments);
      }
    } else {
      const processedChildren = preserveWhitespace ? vNode.children : preprocessParagraphChildren(vNode.children);
      for (let index = 0;index < processedChildren.length; index++) {
        const childVNode = processedChildren[index];
        if (import_is_vnode.default(childVNode) && childVNode.tagName === "img") {
          const isUrl = isValidUrl(childVNode.properties.src);
          if (isUrl && docxDocumentInstance.embedImages) {
            childVNode.properties.src = await fetchImageToDataUrl(childVNode.properties.src);
          }
          if (!isUrl || docxDocumentInstance.embedImages) {
            const base64String = extractBase64Data(childVNode.properties.src)?.base64Content;
            const imageBuffer = Buffer.from(decodeURIComponent(base64String || ""), "base64");
            const imageProperties = await getImageDimensions(imageBuffer);
            modifiedAttributes.maximumWidth = modifiedAttributes.maximumWidth || docxDocumentInstance.availableDocumentSpace;
            modifiedAttributes.originalWidth = imageProperties.width;
            modifiedAttributes.originalHeight = imageProperties.height;
            computeImageDimensions(childVNode, modifiedAttributes);
          }
        }
        const runOrHyperlinkFragments = await buildRunOrHyperLink(childVNode, import_is_vnode.default(childVNode) && childVNode.tagName === "img" ? {
          ...modifiedAttributes,
          type: "picture",
          description: childVNode.properties.alt
        } : modifiedAttributes, docxDocumentInstance, preserveWhitespace);
        if (Array.isArray(runOrHyperlinkFragments)) {
          for (let iteratorIndex = 0;iteratorIndex < runOrHyperlinkFragments.length; iteratorIndex++) {
            const runOrHyperlinkFragment = runOrHyperlinkFragments[iteratorIndex];
            paragraphFragment.import(runOrHyperlinkFragment);
          }
        } else {
          paragraphFragment.import(runOrHyperlinkFragments);
        }
      }
    }
  } else if (!vNode) {} else {
    const runFragments = await buildRunOrRuns(vNode, modifiedAttributes, docxDocumentInstance, preserveWhitespace);
    if (Array.isArray(runFragments)) {
      for (let index = 0;index < runFragments.length; index++) {
        const runFragment = runFragments[index];
        paragraphFragment.import(runFragment);
      }
    } else {
      paragraphFragment.import(runFragments);
    }
  }
  paragraphFragment.up();
  return paragraphFragment;
}
function buildGridSpanFragment(spanValue) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "gridSpan").att("@w", "val", String(spanValue)).up();
}
function buildTableCellSpacing(cellSpacing = 0) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblCellSpacing").att("@w", "w", String(cellSpacing)).att("@w", "type", "dxa").up();
}
function buildTableCellBorders(tableCellBorder) {
  const tableCellBordersFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "tcBorders");
  const { color, stroke, ...borders } = tableCellBorder;
  Object.keys(borders).forEach((border) => {
    const borderVal = tableCellBorder[border];
    if (borderVal) {
      const borderFragment = buildBorder(border, borderVal, 0, color, stroke);
      tableCellBordersFragment.import(borderFragment);
    }
  });
  tableCellBordersFragment.up();
  return tableCellBordersFragment;
}
function buildTableCellWidth(tableCellWidth) {
  const colWidth = fixupColumnWidth(tableCellWidth);
  const frag = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tcW");
  if (typeof colWidth === "string" && colWidth.endsWith("%")) {
    return frag.att("@w", "w", colWidth).att("@w", "type", "pct").up();
  } else {
    return frag.att("@w", "w", String(colWidth)).att("@w", "type", "dxa").up();
  }
}
function buildTableCellProperties(attributes) {
  const tableCellPropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "tcPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach((key) => {
      switch (key) {
        case "backgroundColor": {
          if (attributes.backgroundColor) {
            const shadingFragment = buildShading(attributes.backgroundColor);
            tableCellPropertiesFragment.import(shadingFragment);
            delete attributes.backgroundColor;
          }
          break;
        }
        case "verticalAlign": {
          if (attributes.verticalAlign) {
            const verticalAlignmentFragment = buildVerticalAlignment(attributes.verticalAlign);
            tableCellPropertiesFragment.import(verticalAlignmentFragment);
            delete attributes.verticalAlign;
          }
          break;
        }
        case "colSpan": {
          if (attributes.colSpan) {
            const gridSpanFragment = buildGridSpanFragment(attributes.colSpan);
            tableCellPropertiesFragment.import(gridSpanFragment);
            delete attributes.colSpan;
          }
          break;
        }
        case "tableCellBorder": {
          if (attributes.tableCellBorder) {
            const tableCellBorderFragment = buildTableCellBorders(attributes.tableCellBorder);
            tableCellPropertiesFragment.import(tableCellBorderFragment);
            delete attributes.tableCellBorder;
          }
          break;
        }
        case "rowSpan": {
          if (attributes.rowSpan) {
            const verticalMergeFragment = buildVerticalMerge(attributes[key]);
            tableCellPropertiesFragment.import(verticalMergeFragment);
            delete attributes.rowSpan;
          }
          break;
        }
        case "width": {
          const widthFragment = buildTableCellWidth(attributes.width || 0);
          tableCellPropertiesFragment.import(widthFragment);
          delete attributes.width;
          break;
        }
        default:
          break;
      }
    });
  }
  tableCellPropertiesFragment.up();
  return tableCellPropertiesFragment;
}
function fixupTableCellBorder(vNode, attributes) {
  const defaultTableCellBorder = {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    color: "000000",
    stroke: "single"
  };
  if (Object.prototype.hasOwnProperty.call(vNode.properties.style, "border")) {
    if (vNode.properties.style.border === "none" || vNode.properties.style.border === 0) {
      attributes.tableCellBorder = defaultTableCellBorder;
    } else {
      const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style.border);
      attributes.tableCellBorder = {
        top: borderSize,
        left: borderSize,
        bottom: borderSize,
        right: borderSize,
        color: borderColor,
        stroke: borderStroke
      };
    }
  }
  if (vNode.properties.style["border-top"] && vNode.properties.style["border-top"] === "0") {
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      top: 0
    };
  } else if (vNode.properties.style["border-top"] && vNode.properties.style["border-top"] !== "0") {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-top"]);
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      top: borderSize,
      color: borderColor,
      stroke: borderStroke
    };
  }
  if (vNode.properties.style["border-left"] && vNode.properties.style["border-left"] === "0") {
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      left: 0
    };
  } else if (vNode.properties.style["border-left"] && vNode.properties.style["border-left"] !== "0") {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-left"]);
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      left: borderSize,
      color: borderColor,
      stroke: borderStroke
    };
  }
  if (vNode.properties.style["border-bottom"] && vNode.properties.style["border-bottom"] === "0") {
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      bottom: 0
    };
  } else if (vNode.properties.style["border-bottom"] && vNode.properties.style["border-bottom"] !== "0") {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-bottom"]);
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      bottom: borderSize,
      color: borderColor,
      stroke: borderStroke
    };
  }
  if (vNode.properties.style["border-right"] && vNode.properties.style["border-right"] === "0") {
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      right: 0
    };
  } else if (vNode.properties.style["border-right"] && vNode.properties.style["border-right"] !== "0") {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-right"]);
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      right: borderSize,
      color: borderColor,
      stroke: borderStroke
    };
  }
}
async function buildTableCell(vNode, attributes, rowSpanMap, columnIndex, docxDocumentInstance) {
  const tableCellFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tc");
  let modifiedAttributes = { ...attributes };
  if (import_is_vnode.default(vNode) && vNode.properties) {
    if (vNode.properties.rowSpan) {
      rowSpanMap.set(columnIndex.index, {
        rowSpan: vNode.properties.rowSpan - 1,
        colSpan: 0
      });
      modifiedAttributes.rowSpan = "restart";
    } else {
      const previousSpanObject = rowSpanMap.get(columnIndex.index);
      rowSpanMap.set(columnIndex.index, Object.assign({}, previousSpanObject, {
        rowSpan: 0,
        colSpan: previousSpanObject && previousSpanObject.colSpan || 0
      }));
    }
    if (vNode.properties.colSpan || vNode.properties.style && vNode.properties.style["column-span"]) {
      modifiedAttributes.colSpan = vNode.properties.colSpan || vNode.properties.style && vNode.properties.style["column-span"];
      const previousSpanObject = rowSpanMap.get(columnIndex.index);
      rowSpanMap.set(columnIndex.index, Object.assign({}, previousSpanObject, {
        colSpan: Number(modifiedAttributes.colSpan) || 0
      }));
      columnIndex.index += Number(modifiedAttributes.colSpan) - 1;
    }
    if (vNode.properties.style) {
      modifiedAttributes = {
        ...modifiedAttributes,
        ...modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes)
      };
      fixupTableCellBorder(vNode, modifiedAttributes);
    }
  }
  const tableCellPropertiesFragment = buildTableCellProperties(modifiedAttributes);
  tableCellFragment.import(tableCellPropertiesFragment);
  if (vNodeHasChildren(vNode)) {
    for (let index = 0;index < vNode.children.length; index++) {
      const childVNode = vNode.children[index];
      if (import_is_vnode.default(childVNode) && childVNode.tagName === "img") {
        if (modifiedAttributes.maximumWidth) {
          const imageFragment = await buildImage(docxDocumentInstance, childVNode, modifiedAttributes.maximumWidth);
          if (imageFragment) {
            const paragraphFragment = import_xmlbuilder2.fragment({
              namespaceAlias: { w: namespaces_default.w }
            }).ele("@w", "p");
            if (Array.isArray(imageFragment)) {
              imageFragment.forEach((frag) => paragraphFragment.import(frag));
            } else {
              paragraphFragment.import(imageFragment);
            }
            paragraphFragment.up();
            tableCellFragment.import(paragraphFragment);
          }
        }
      } else if (import_is_vnode.default(childVNode) && childVNode.tagName === "figure") {
        if (vNodeHasChildren(childVNode)) {
          for (let iteratorIndex = 0;iteratorIndex < childVNode.children.length; iteratorIndex++) {
            const grandChildVNode = childVNode.children[iteratorIndex];
            if (import_is_vnode.default(grandChildVNode) && grandChildVNode.tagName === "img") {
              const imageFragment = await buildImage(docxDocumentInstance, grandChildVNode, modifiedAttributes.maximumWidth || 0);
              if (imageFragment) {
                const paragraphFragment = import_xmlbuilder2.fragment({
                  namespaceAlias: { w: namespaces_default.w }
                }).ele("@w", "p");
                if (Array.isArray(imageFragment)) {
                  imageFragment.forEach((frag) => paragraphFragment.import(frag));
                } else {
                  paragraphFragment.import(imageFragment);
                }
                paragraphFragment.up();
                tableCellFragment.import(paragraphFragment);
              }
            }
          }
        }
      } else if (import_is_vnode.default(childVNode) && ["ul", "ol"].includes(childVNode.tagName)) {
        if (vNodeHasChildren(childVNode)) {
          await buildList(childVNode, docxDocumentInstance, tableCellFragment);
        }
      } else {
        const paragraphFragment = await buildParagraph(childVNode, modifiedAttributes, docxDocumentInstance);
        tableCellFragment.import(paragraphFragment);
      }
    }
  } else {
    const paragraphFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "p").up();
    tableCellFragment.import(paragraphFragment);
  }
  tableCellFragment.up();
  return tableCellFragment;
}
function buildRowSpanCell(rowSpanMap, columnIndex, attributes) {
  const rowSpanCellFragments = [];
  let spanObject = rowSpanMap.get(columnIndex.index);
  while (spanObject && spanObject.rowSpan) {
    const rowSpanCellFragment = import_xmlbuilder2.fragment({
      namespaceAlias: { w: namespaces_default.w }
    }).ele("@w", "tc");
    const tableCellPropertiesFragment = buildTableCellProperties({
      ...attributes,
      rowSpan: "continue",
      colSpan: spanObject.colSpan ? spanObject.colSpan : 0
    });
    rowSpanCellFragment.import(tableCellPropertiesFragment);
    const paragraphFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "p").up();
    rowSpanCellFragment.import(paragraphFragment);
    rowSpanCellFragment.up();
    rowSpanCellFragments.push(rowSpanCellFragment);
    if (spanObject.rowSpan - 1 === 0) {
      rowSpanMap.delete(columnIndex.index);
    } else {
      rowSpanMap.set(columnIndex.index, {
        rowSpan: spanObject.rowSpan - 1,
        colSpan: spanObject.colSpan || 0
      });
    }
    columnIndex.index += spanObject.colSpan || 1;
    spanObject = rowSpanMap.get(columnIndex.index);
  }
  return rowSpanCellFragments;
}
function buildTableRowProperties(attributes) {
  const tableRowPropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "trPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach((key) => {
      switch (key) {
        case "tableRowHeight": {
          if (attributes.tableRowHeight) {
            const tableRowHeightFragment = buildTableRowHeight(attributes.tableRowHeight);
            tableRowPropertiesFragment.import(tableRowHeightFragment);
            delete attributes.tableRowHeight;
          }
          break;
        }
        case "rowCantSplit":
          if (attributes.rowCantSplit) {
            const cantSplitFragment = import_xmlbuilder2.fragment({
              namespaceAlias: { w: namespaces_default.w }
            }).ele("@w", "cantSplit").up();
            tableRowPropertiesFragment.import(cantSplitFragment);
            delete attributes.rowCantSplit;
          }
          break;
        default:
          break;
      }
    });
  }
  tableRowPropertiesFragment.up();
  return tableRowPropertiesFragment;
}
async function buildTableRow(vNode, attributes, rowSpanMap, docxDocumentInstance) {
  const tableRowFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tr");
  const modifiedAttributes = { ...attributes };
  if (import_is_vnode.default(vNode) && vNode.properties) {
    const firstChild = vNode.children[0];
    if (vNode.properties.style && vNode.properties.style.height || firstChild && import_is_vnode.default(firstChild) && firstChild.properties.style && firstChild.properties.style.height) {
      modifiedAttributes.tableRowHeight = fixupRowHeight(vNode.properties.style && vNode.properties.style.height || (firstChild && import_is_vnode.default(firstChild) && firstChild.properties.style && firstChild.properties.style.height ? firstChild.properties.style.height : undefined));
    }
    if (vNode.properties.style) {
      fixupTableCellBorder(vNode, modifiedAttributes);
    }
  }
  const tableRowPropertiesFragment = buildTableRowProperties(modifiedAttributes);
  tableRowFragment.import(tableRowPropertiesFragment);
  const columnIndex = { index: 0 };
  if (vNodeHasChildren(vNode)) {
    const tableColumns = vNode.children.filter((childVNode) => import_is_vnode.default(childVNode) && ["td", "th"].includes(childVNode.tagName));
    const maximumColumnWidth = docxDocumentInstance.availableDocumentSpace / tableColumns.length;
    for (const column of tableColumns) {
      const rowSpanCellFragments = buildRowSpanCell(rowSpanMap, columnIndex, modifiedAttributes);
      if (Array.isArray(rowSpanCellFragments)) {
        for (let iteratorIndex = 0;iteratorIndex < rowSpanCellFragments.length; iteratorIndex++) {
          const rowSpanCellFragment = rowSpanCellFragments[iteratorIndex];
          tableRowFragment.import(rowSpanCellFragment);
        }
      }
      const tableCellFragment = await buildTableCell(column, { ...modifiedAttributes, maximumWidth: maximumColumnWidth }, rowSpanMap, columnIndex, docxDocumentInstance);
      columnIndex.index++;
      tableRowFragment.import(tableCellFragment);
    }
  }
  if (columnIndex.index < rowSpanMap.size) {
    const rowSpanCellFragments = buildRowSpanCell(rowSpanMap, columnIndex, modifiedAttributes);
    if (Array.isArray(rowSpanCellFragments)) {
      for (let iteratorIndex = 0;iteratorIndex < rowSpanCellFragments.length; iteratorIndex++) {
        const rowSpanCellFragment = rowSpanCellFragments[iteratorIndex];
        tableRowFragment.import(rowSpanCellFragment);
      }
    }
  }
  tableRowFragment.up();
  return tableRowFragment;
}
function buildTableGridCol(gridWidth) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "gridCol").att("@w", "w", String(Math.round(gridWidth)));
}
function buildTableGrid(vNode, attributes) {
  const tableGridFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblGrid");
  if (vNodeHasChildren(vNode)) {
    const gridColumns = vNode.children.filter((childVNode) => import_is_vnode.default(childVNode) && childVNode.tagName === "col");
    const gridWidth = (attributes.maximumWidth || 0) / gridColumns.length;
    for (let index = 0;index < gridColumns.length; index++) {
      const tableGridColFragment = buildTableGridCol(gridWidth);
      tableGridFragment.import(tableGridColFragment);
    }
  }
  tableGridFragment.up();
  return tableGridFragment;
}
function buildTableGridFromTableRow(vNode, attributes) {
  const tableGridFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblGrid");
  if (vNodeHasChildren(vNode)) {
    const numberOfGridColumns = vNode.children.reduce((accumulator, childVNode) => {
      let colSpan;
      if (import_is_vnode.default(childVNode)) {
        const props = childVNode.properties;
        colSpan = props.colSpan || props.style && props.style["column-span"];
      }
      return accumulator + (colSpan ? parseInt(colSpan) : 1);
    }, 0);
    const gridWidth = (attributes.maximumWidth || 0) / numberOfGridColumns;
    for (let index = 0;index < numberOfGridColumns; index++) {
      const tableGridColFragment = buildTableGridCol(gridWidth);
      tableGridFragment.import(tableGridColFragment);
    }
  }
  tableGridFragment.up();
  return tableGridFragment;
}
function buildTableBorders(tableBorder) {
  const tableBordersFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblBorders");
  const { color, stroke, ...borders } = tableBorder;
  Object.keys(borders).forEach((border) => {
    const borderVal = tableBorder[border];
    if (borderVal) {
      const borderFragment = buildBorder(border, borderVal, 0, color, stroke);
      tableBordersFragment.import(borderFragment);
    }
  });
  tableBordersFragment.up();
  return tableBordersFragment;
}
function buildTableWidth(tableWidth) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblW").att("@w", "type", "dxa").att("@w", "w", String(tableWidth)).up();
}
function buildCellMargin(side, margin) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", side).att("@w", "type", "dxa").att("@w", "w", String(margin)).up();
}
function buildTableCellMargins(margin) {
  const tableCellMarFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblCellMar");
  ["top", "bottom"].forEach((side) => {
    const marginFragment = buildCellMargin(side, margin / 2);
    tableCellMarFragment.import(marginFragment);
  });
  ["left", "right"].forEach((side) => {
    const marginFragment = buildCellMargin(side, margin);
    tableCellMarFragment.import(marginFragment);
  });
  return tableCellMarFragment;
}
function buildTableProperties(attributes) {
  const tablePropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "tblPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach((key) => {
      switch (key) {
        case "tableBorder": {
          if (attributes.tableBorder) {
            const tableBordersFragment = buildTableBorders(attributes.tableBorder);
            tablePropertiesFragment.import(tableBordersFragment);
            delete attributes.tableBorder;
          }
          break;
        }
        case "tableCellSpacing": {
          const tableCellSpacingFragment = buildTableCellSpacing(attributes.tableCellSpacing);
          tablePropertiesFragment.import(tableCellSpacingFragment);
          delete attributes.tableCellSpacing;
          break;
        }
        case "width": {
          if (attributes.width) {
            const tableWidthFragment = buildTableWidth(attributes.width);
            tablePropertiesFragment.import(tableWidthFragment);
          }
          delete attributes.width;
          break;
        }
        default:
          break;
      }
    });
  }
  const tableCellMarginFragment = buildTableCellMargins(160);
  tablePropertiesFragment.import(tableCellMarginFragment);
  const alignmentFragment = buildHorizontalAlignment("center");
  tablePropertiesFragment.import(alignmentFragment);
  tablePropertiesFragment.up();
  return tablePropertiesFragment;
}
function cssBorderParser(borderString) {
  const [size, stroke, color] = borderString.split(" ");
  let sizeNum = parseInt(size);
  if (pointRegex.test(size)) {
    const matchedParts = size.match(pointRegex);
    sizeNum = pointToEIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(size)) {
    const matchedParts = size.match(pixelRegex);
    sizeNum = pixelToEIP(Number(matchedParts?.[1]));
  }
  return [
    sizeNum,
    stroke && ["dashed", "dotted", "double"].includes(stroke) ? stroke : "single",
    color && fixupColorCode(color).toUpperCase()
  ];
}
async function buildTable(vNode, attributes, docxDocumentInstance) {
  const tableFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tbl");
  const modifiedAttributes = { ...attributes };
  if (import_is_vnode.default(vNode) && vNode.properties) {
    const tableAttributes = vNode.properties.attributes || {};
    const tableStyles = vNode.properties.style || {};
    let [borderSize, borderStrike, borderColor] = [2, "single", "000000"];
    if (!isNaN(Number(tableAttributes.border))) {
      borderSize = parseInt(tableAttributes.border, 10);
    }
    if (tableStyles.border) {
      const [cssSize, cssStroke, cssColor] = cssBorderParser(tableStyles.border);
      borderSize = Number(cssSize) || borderSize;
      borderColor = String(cssColor) || borderColor;
      borderStrike = String(cssStroke) || borderStrike;
    }
    const tableBorders = {
      top: borderSize,
      bottom: borderSize,
      left: borderSize,
      right: borderSize,
      stroke: borderStrike,
      color: borderColor,
      insideV: 0,
      insideH: 0
    };
    if (tableStyles["border-collapse"] === "collapse") {
      tableBorders.insideV = borderSize;
      tableBorders.insideH = borderSize;
    } else {
      modifiedAttributes.tableCellBorder = {
        top: 1,
        bottom: 1,
        left: 1,
        right: 1,
        color: "000000",
        stroke: "single"
      };
    }
    modifiedAttributes.tableBorder = tableBorders;
    modifiedAttributes.tableCellSpacing = 0;
    let minimumWidth;
    let maximumWidth;
    let width;
    if (pixelRegex.test(tableStyles["min-width"])) {
      minimumWidth = pixelToTWIP(tableStyles["min-width"].match(pixelRegex)[1]);
    } else if (percentageRegex.test(tableStyles["min-width"])) {
      const percentageValue = tableStyles["min-width"].match(percentageRegex)[1];
      minimumWidth = Math.round(percentageValue / 100 * (attributes.maximumWidth || 0));
    }
    if (pixelRegex.test(tableStyles["max-width"])) {
      pixelRegex.lastIndex = 0;
      maximumWidth = pixelToTWIP(tableStyles["max-width"].match(pixelRegex)[1]);
    } else if (percentageRegex.test(tableStyles["max-width"])) {
      percentageRegex.lastIndex = 0;
      const percentageValue = tableStyles["max-width"].match(percentageRegex)[1];
      maximumWidth = Math.round(percentageValue / 100 * (attributes.maximumWidth || 0));
    }
    if (pixelRegex.test(tableStyles.width)) {
      pixelRegex.lastIndex = 0;
      width = pixelToTWIP(tableStyles.width.match(pixelRegex)[1]);
    } else if (percentageRegex.test(tableStyles.width)) {
      percentageRegex.lastIndex = 0;
      const percentageValue = tableStyles.width.match(percentageRegex)[1];
      width = Math.round(percentageValue / 100 * (attributes.maximumWidth || 0));
    }
    if (width) {
      modifiedAttributes.width = width;
      if (maximumWidth) {
        modifiedAttributes.width = Math.min(modifiedAttributes.width, maximumWidth);
      }
      if (minimumWidth) {
        modifiedAttributes.width = Math.max(modifiedAttributes.width, minimumWidth);
      }
    } else if (minimumWidth) {
      modifiedAttributes.width = minimumWidth;
    }
    if (modifiedAttributes.width) {
      modifiedAttributes.width = Math.min(modifiedAttributes.width, attributes.maximumWidth || 0);
    }
  }
  const tablePropertiesFragment = buildTableProperties(modifiedAttributes);
  tableFragment.import(tablePropertiesFragment);
  const rowSpanMap = new Map;
  if (vNodeHasChildren(vNode)) {
    for (let index = 0;index < vNode.children.length; index++) {
      if (import_is_vnode.default(vNode.children[index])) {
        const childVNode = vNode.children[index];
        if (childVNode.tagName === "colgroup") {
          const tableGridFragment = buildTableGrid(childVNode, modifiedAttributes);
          tableFragment.import(tableGridFragment);
        } else if (childVNode.tagName === "thead") {
          for (let iteratorIndex = 0;iteratorIndex < childVNode.children.length; iteratorIndex++) {
            if (import_is_vnode.default(childVNode.children[iteratorIndex])) {
              const grandChildVNode = childVNode.children[iteratorIndex];
              if (grandChildVNode.tagName === "tr") {
                if (iteratorIndex === 0) {
                  const tableGridFragment = buildTableGridFromTableRow(grandChildVNode, modifiedAttributes);
                  tableFragment.import(tableGridFragment);
                }
                const tableRowFragment = await buildTableRow(grandChildVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
                tableFragment.import(tableRowFragment);
              }
            }
          }
        } else if (childVNode.tagName === "tbody") {
          for (let iteratorIndex = 0;iteratorIndex < childVNode.children.length; iteratorIndex++) {
            if (import_is_vnode.default(childVNode.children[iteratorIndex])) {
              const grandChildVNode = childVNode.children[iteratorIndex];
              if (grandChildVNode.tagName === "tr") {
                if (iteratorIndex === 0) {
                  const tableGridFragment = buildTableGridFromTableRow(grandChildVNode, modifiedAttributes);
                  tableFragment.import(tableGridFragment);
                }
                const tableRowFragment = await buildTableRow(grandChildVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
                tableFragment.import(tableRowFragment);
              }
            }
          }
        } else if (childVNode.tagName === "tr") {
          if (index === 0) {
            const tableGridFragment = buildTableGridFromTableRow(childVNode, modifiedAttributes);
            tableFragment.import(tableGridFragment);
          }
          const tableRowFragment = await buildTableRow(childVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
          tableFragment.import(tableRowFragment);
        }
      }
    }
  }
  tableFragment.up();
  return tableFragment;
}
function buildPresetGeometry() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "prstGeom").att("prst", "rect").up();
}
function toEMU(v) {
  if (v === undefined || v === null)
    return;
  if (typeof v === "number")
    return v;
  if (pixelRegex.test(v)) {
    const [, num] = v.match(pixelRegex);
    return pixelToEMU(Number(num));
  }
  if (emRegex.test(v)) {
    const [, num] = v.match(emRegex);
    return emToEmu(Number(num));
  }
  if (remRegex.test(v)) {
    const [, num] = v.match(remRegex);
    return remToEmu(Number(num));
  }
  return Number(v);
}
function buildExtents({ width, height }) {
  if (!width && !height) {
    return;
  }
  const cx = toEMU(width);
  const cy = toEMU(height);
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "ext").att("cx", String(cx ?? "")).att("cy", String(cy ?? "")).up();
}
function buildOffset() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "off").att("x", "0").att("y", "0").up();
}
function buildGraphicFrameTransform(attributes) {
  const graphicFrameTransformFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { a: namespaces_default.a }
  }).ele("@a", "xfrm");
  const offsetFragment = buildOffset();
  graphicFrameTransformFragment.import(offsetFragment);
  const extentsFragment = buildExtents(attributes);
  if (extentsFragment) {
    graphicFrameTransformFragment.import(extentsFragment);
  }
  graphicFrameTransformFragment.up();
  return graphicFrameTransformFragment;
}
function buildShapeProperties(attributes) {
  const shapeProperties = import_xmlbuilder2.fragment({ namespaceAlias: { pic: namespaces_default.pic } }).ele("@pic", "spPr");
  const graphicFrameTransformFragment = buildGraphicFrameTransform(attributes);
  shapeProperties.import(graphicFrameTransformFragment);
  const presetGeometryFragment = buildPresetGeometry();
  shapeProperties.import(presetGeometryFragment);
  shapeProperties.up();
  return shapeProperties;
}
function buildFillRect() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "fillRect").up();
}
function buildStretch() {
  const stretchFragment = import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "stretch");
  const fillRectFragment = buildFillRect();
  stretchFragment.import(fillRectFragment);
  stretchFragment.up();
  return stretchFragment;
}
function buildSrcRectFragment() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "srcRect").att("b", "0").att("l", "0").att("r", "0").att("t", "0").up();
}
function buildBinaryLargeImageOrPicture(relationshipId, isExternalLink) {
  const fragment_obj = import_xmlbuilder2.fragment({
    namespaceAlias: { a: namespaces_default.a, r: namespaces_default.r }
  }).ele("@a", "blip");
  if (isExternalLink) {
    fragment_obj.att("@r", "link", `rId${relationshipId}`);
  } else {
    fragment_obj.att("@r", "embed", `rId${relationshipId}`);
  }
  fragment_obj.att("cstate", "print");
  fragment_obj.up();
  return fragment_obj;
}
function buildBinaryLargeImageOrPictureFill(relationshipId, isExternalLink) {
  const binaryLargeImageOrPictureFillFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { pic: namespaces_default.pic }
  }).ele("@pic", "blipFill");
  const binaryLargeImageOrPictureFragment = buildBinaryLargeImageOrPicture(relationshipId, isExternalLink);
  binaryLargeImageOrPictureFillFragment.import(binaryLargeImageOrPictureFragment);
  const srcRectFragment = buildSrcRectFragment();
  binaryLargeImageOrPictureFillFragment.import(srcRectFragment);
  const stretchFragment = buildStretch();
  binaryLargeImageOrPictureFillFragment.import(stretchFragment);
  binaryLargeImageOrPictureFillFragment.up();
  return binaryLargeImageOrPictureFillFragment;
}
function buildNonVisualPictureDrawingProperties() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { pic: namespaces_default.pic } }).ele("@pic", "cNvPicPr").up();
}
function buildNonVisualDrawingProperties(pictureId, pictureNameWithExtension, pictureDescription = "") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { pic: namespaces_default.pic } }).ele("@pic", "cNvPr").att("id", String(pictureId)).att("name", pictureNameWithExtension).att("descr", pictureDescription).up();
}
function buildNonVisualPictureProperties(pictureId, pictureNameWithExtension, pictureDescription) {
  const nonVisualPicturePropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { pic: namespaces_default.pic }
  }).ele("@pic", "nvPicPr");
  const nonVisualDrawingPropertiesFragment = buildNonVisualDrawingProperties(pictureId, pictureNameWithExtension, pictureDescription);
  nonVisualPicturePropertiesFragment.import(nonVisualDrawingPropertiesFragment);
  const nonVisualPictureDrawingPropertiesFragment = buildNonVisualPictureDrawingProperties();
  nonVisualPicturePropertiesFragment.import(nonVisualPictureDrawingPropertiesFragment);
  nonVisualPicturePropertiesFragment.up();
  return nonVisualPicturePropertiesFragment;
}
function buildPicture({
  id,
  fileNameWithExtension,
  description,
  relationshipId,
  width,
  height,
  isExternalLink
}) {
  const pictureFragment = import_xmlbuilder2.fragment({ namespaceAlias: { pic: namespaces_default.pic } }).ele("@pic", "pic");
  const nonVisualPicturePropertiesFragment = buildNonVisualPictureProperties(id || 0, fileNameWithExtension || "", description || "");
  pictureFragment.import(nonVisualPicturePropertiesFragment);
  const binaryLargeImageOrPictureFill = buildBinaryLargeImageOrPictureFill(relationshipId || 0, isExternalLink);
  pictureFragment.import(binaryLargeImageOrPictureFill);
  const shapeProperties = buildShapeProperties({ width, height });
  pictureFragment.import(shapeProperties);
  pictureFragment.up();
  return pictureFragment;
}
function buildGraphicData(graphicType, attributes) {
  const graphicDataFragment = import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "graphicData").att("uri", "http://schemas.openxmlformats.org/drawingml/2006/picture");
  if (graphicType === "picture") {
    const pictureFragment = buildPicture(attributes);
    graphicDataFragment.import(pictureFragment);
  }
  graphicDataFragment.up();
  return graphicDataFragment;
}
function buildGraphic(graphicType, attributes) {
  const graphicFragment = import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "graphic");
  const graphicDataFragment = buildGraphicData(graphicType, attributes);
  graphicFragment.import(graphicDataFragment);
  graphicFragment.up();
  return graphicFragment;
}
function buildDrawingObjectNonVisualProperties(pictureId, pictureName) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "docPr").att("id", String(pictureId)).att("name", pictureName).up();
}
function buildWrapSquare() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "wrapSquare").att("wrapText", "bothSides").att("distB", "228600").att("distT", "228600").att("distL", "228600").att("distR", "228600").up();
}
function buildEffectExtentFragment() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "effectExtent").att("b", "0").att("l", "0").att("r", "0").att("t", "0").up();
}
function buildExtent({ width, height }) {
  if (!width && !height) {
    return;
  }
  const cx = toEMU(width);
  const cy = toEMU(height);
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "extent").att("cx", String(cx ?? "")).att("cy", String(cy ?? "")).up();
}
function buildPositionV() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "positionV").att("relativeFrom", "paragraph").ele("@wp", "posOffset").txt("19050").up();
}
function buildPositionH() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "positionH").att("relativeFrom", "column").ele("@wp", "posOffset").txt("19050").up();
}
function buildSimplePos() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "simplePos").att("x", "0").att("y", "0").up();
}
function buildAnchoredDrawing(graphicType, attributes) {
  const anchoredDrawingFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { wp: namespaces_default.wp }
  }).ele("@wp", "anchor").att("distB", "0").att("distL", "0").att("distR", "0").att("distT", "0").att("relativeHeight", "0").att("behindDoc", "false").att("locked", "true").att("layoutInCell", "true").att("allowOverlap", "false").att("simplePos", "false");
  const simplePosFragment = buildSimplePos();
  anchoredDrawingFragment.import(simplePosFragment);
  const positionHFragment = buildPositionH();
  anchoredDrawingFragment.import(positionHFragment);
  const positionVFragment = buildPositionV();
  anchoredDrawingFragment.import(positionVFragment);
  const extentFragment = buildExtent({
    width: attributes.width,
    height: attributes.height
  });
  if (extentFragment) {
    anchoredDrawingFragment.import(extentFragment);
  }
  const effectExtentFragment = buildEffectExtentFragment();
  anchoredDrawingFragment.import(effectExtentFragment);
  const wrapSquareFragment = buildWrapSquare();
  anchoredDrawingFragment.import(wrapSquareFragment);
  const drawingObjectNonVisualPropertiesFragment = buildDrawingObjectNonVisualProperties(attributes.id || 0, attributes.fileNameWithExtension || "");
  anchoredDrawingFragment.import(drawingObjectNonVisualPropertiesFragment);
  const graphicFragment = buildGraphic(graphicType, attributes);
  anchoredDrawingFragment.import(graphicFragment);
  anchoredDrawingFragment.up();
  return anchoredDrawingFragment;
}
function buildInlineDrawing(graphicType, attributes) {
  const inlineDrawingFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { wp: namespaces_default.wp }
  }).ele("@wp", "inline").att("distB", "0").att("distL", "0").att("distR", "0").att("distT", "0");
  const extentFragment = buildExtent({
    width: attributes.width,
    height: attributes.height
  });
  if (extentFragment) {
    inlineDrawingFragment.import(extentFragment);
  }
  const effectExtentFragment = buildEffectExtentFragment();
  inlineDrawingFragment.import(effectExtentFragment);
  const drawingObjectNonVisualPropertiesFragment = buildDrawingObjectNonVisualProperties(attributes.id || 0, attributes.fileNameWithExtension || "");
  inlineDrawingFragment.import(drawingObjectNonVisualPropertiesFragment);
  const graphicFragment = buildGraphic(graphicType, attributes);
  inlineDrawingFragment.import(graphicFragment);
  inlineDrawingFragment.up();
  return inlineDrawingFragment;
}
function buildDrawing(attributes) {
  const inlineOrAnchored = attributes.inlineOrAnchored || false;
  const graphicType = attributes.graphicType || "picture";
  const drawingFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "drawing");
  const inlineOrAnchoredDrawingFragment = inlineOrAnchored ? buildInlineDrawing(graphicType, attributes) : buildAnchoredDrawing(graphicType, attributes);
  drawingFragment.import(inlineOrAnchoredDrawingFragment);
  drawingFragment.up();
  return drawingFragment;
}

// src/helpers/render-document-file.ts
var convertHTML = import_html_to_vdom.default({
  VNode: import_vnode3.default,
  VText: import_vtext2.default
});
async function buildImage(docxDocumentInstance, vNode, maximumWidth) {
  let response = null;
  const originalSrc = vNode.properties.src;
  const isUrl = isValidUrl(originalSrc);
  try {
    if (isUrl && docxDocumentInstance.embedImages) {
      vNode.properties.src = await fetchImageToDataUrl(vNode.properties.src);
    }
    if (!isUrl || docxDocumentInstance.embedImages) {
      const base64Uri = decodeURIComponent(vNode.properties.src);
      if (base64Uri) {
        response = docxDocumentInstance.createMediaFile(base64Uri);
      }
    }
  } catch (error) {
    console.error(error);
  }
  if (isUrl && !docxDocumentInstance.embedImages) {
    const documentRelsId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, imageType, originalSrc, "External");
    let actualWidth = 600;
    let actualHeight = 400;
    const fetchedDimensions = await fetchImageDimensionsFromUrl(originalSrc);
    if (fetchedDimensions) {
      actualWidth = fetchedDimensions.width;
      actualHeight = fetchedDimensions.height;
    }
    const defaultWidthInEMU = pixelToEMU(actualWidth);
    const defaultHeightInEMU = pixelToEMU(actualHeight);
    let finalWidthInEMU = defaultWidthInEMU;
    let finalHeightInEMU = defaultHeightInEMU;
    const maxWidth = maximumWidth || docxDocumentInstance.availableDocumentSpace;
    const maximumWidthInEMU = TWIPToEMU(maxWidth || 0);
    if (defaultWidthInEMU > maximumWidthInEMU) {
      const aspectRatio = actualWidth / actualHeight;
      finalWidthInEMU = maximumWidthInEMU;
      finalHeightInEMU = Math.round(finalWidthInEMU / aspectRatio);
    }
    if (vNode.properties && vNode.properties.style) {
      const style = vNode.properties.style;
      if (style.width && style.width !== "auto") {
        if (/(\d+)px/.test(style.width)) {
          finalWidthInEMU = pixelToEMU(parseInt(style.width.match(/(\d+)px/)[1]));
        } else if (/(\d+)em/.test(style.width)) {
          finalWidthInEMU = emToEmu(parseFloat(style.width.match(/(\d+(?:\.\d+)?)em/)[1]));
        } else if (/(\d+)rem/.test(style.width)) {
          finalWidthInEMU = remToEmu(parseFloat(style.width.match(/(\d+(?:\.\d+)?)rem/)[1]));
        } else if (/(\d+)%/.test(style.width)) {
          const percentage = parseFloat(style.width.match(/(\d+(?:\.\d+)?)%/)[1]);
          finalWidthInEMU = Math.round(percentage / 100 * defaultWidthInEMU);
        }
      }
      if (style.height && style.height !== "auto") {
        if (/(\d+)px/.test(style.height)) {
          finalHeightInEMU = pixelToEMU(parseInt(style.height.match(/(\d+)px/)[1]));
        } else if (/(\d+)em/.test(style.height)) {
          finalHeightInEMU = emToEmu(parseFloat(style.height.match(/(\d+(?:\.\d+)?)em/)[1]));
        } else if (/(\d+)rem/.test(style.height)) {
          finalHeightInEMU = remToEmu(parseFloat(style.height.match(/(\d+(?:\.\d+)?)rem/)[1]));
        } else if (/(\d+)%/.test(style.height)) {
          const percentage = parseFloat(style.height.match(/(\d+(?:\.\d+)?)%/)[1]);
          finalHeightInEMU = Math.round(percentage / 100 * defaultHeightInEMU);
          if (!style.width || style.width === "auto") {
            const aspectRatio = actualWidth / actualHeight;
            finalWidthInEMU = Math.round(finalHeightInEMU * aspectRatio);
          }
        }
      }
      if (style.width && style.width !== "auto" && (!style.height || style.height === "auto")) {
        const aspectRatio = actualWidth / actualHeight;
        finalHeightInEMU = Math.round(finalWidthInEMU / aspectRatio);
      } else if (style.height && style.height !== "auto" && (!style.width || style.width === "auto")) {
        const aspectRatio = actualWidth / actualHeight;
        finalWidthInEMU = Math.round(finalHeightInEMU * aspectRatio);
      }
    }
    const imageFragment = await buildRun(vNode, {
      type: "picture",
      inlineOrAnchored: true,
      relationshipId: documentRelsId,
      fileNameWithExtension: originalSrc,
      description: vNode.properties.alt,
      maximumWidth: maxWidth,
      originalWidth: actualWidth,
      originalHeight: actualHeight,
      width: finalWidthInEMU,
      height: finalHeightInEMU,
      isExternalLink: true
    }, docxDocumentInstance);
    return imageFragment;
  }
  if (response) {
    docxDocumentInstance.zip.folder("word")?.folder("media")?.file(response.fileNameWithExtension, Buffer.from(response.fileContent, "base64"), {
      createFolders: false
    });
    const documentRelsId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, imageType, `media/${response.fileNameWithExtension}`, internalRelationship);
    const imageBuffer = Buffer.from(response.fileContent, "base64");
    const imageProperties = await getImageDimensions(imageBuffer);
    const maxWidth = maximumWidth || docxDocumentInstance.availableDocumentSpace;
    const originalWidthInEMU = pixelToEMU(imageProperties.width || 0);
    const originalHeightInEMU = pixelToEMU(imageProperties.height || 0);
    const maximumWidthInEMU = TWIPToEMU(maxWidth || 0);
    const aspectRatio = (imageProperties.width || 0) / (imageProperties.height || 1);
    let finalWidthInEMU = originalWidthInEMU;
    let finalHeightInEMU = originalHeightInEMU;
    if (originalWidthInEMU > maximumWidthInEMU) {
      finalWidthInEMU = maximumWidthInEMU;
      finalHeightInEMU = Math.round(finalWidthInEMU / aspectRatio);
    }
    if (vNode.properties && vNode.properties.style) {
      const style = vNode.properties.style;
      if (style.width && style.width !== "auto") {
        if (/(\d+)px/.test(style.width)) {
          finalWidthInEMU = pixelToEMU(parseInt(style.width.match(/(\d+)px/)[1]));
        } else if (/(\d+)em/.test(style.width)) {
          finalWidthInEMU = emToEmu(parseFloat(style.width.match(/(\d+(?:\.\d+)?)em/)[1]));
        } else if (/(\d+)rem/.test(style.width)) {
          finalWidthInEMU = remToEmu(parseFloat(style.width.match(/(\d+(?:\.\d+)?)rem/)[1]));
        } else if (/(\d+)%/.test(style.width)) {
          const percentage = parseFloat(style.width.match(/(\d+(?:\.\d+)?)%/)[1]);
          finalWidthInEMU = Math.round(percentage / 100 * originalWidthInEMU);
        }
      }
      if (style.height && style.height !== "auto") {
        if (/(\d+)px/.test(style.height)) {
          finalHeightInEMU = pixelToEMU(parseInt(style.height.match(/(\d+)px/)[1]));
        } else if (/(\d+)em/.test(style.height)) {
          finalHeightInEMU = emToEmu(parseFloat(style.height.match(/(\d+(?:\.\d+)?)em/)[1]));
        } else if (/(\d+)rem/.test(style.height)) {
          finalHeightInEMU = remToEmu(parseFloat(style.height.match(/(\d+(?:\.\d+)?)rem/)[1]));
        } else if (/(\d+)%/.test(style.height)) {
          const percentage = parseFloat(style.height.match(/(\d+(?:\.\d+)?)%/)[1]);
          finalHeightInEMU = Math.round(percentage / 100 * originalHeightInEMU);
          if (!style.width || style.width === "auto") {
            finalWidthInEMU = Math.round(finalHeightInEMU * aspectRatio);
          }
        }
      }
      if (style.width && style.width !== "auto" && (!style.height || style.height === "auto")) {
        finalHeightInEMU = Math.round(finalWidthInEMU / aspectRatio);
      } else if (style.height && style.height !== "auto" && (!style.width || style.width === "auto")) {
        finalWidthInEMU = Math.round(finalHeightInEMU * aspectRatio);
      }
    }
    const imageFragment = await buildRun(vNode, {
      type: "picture",
      inlineOrAnchored: true,
      relationshipId: documentRelsId,
      ...response,
      description: vNode.properties.alt,
      maximumWidth: maxWidth,
      originalWidth: imageProperties.width,
      originalHeight: imageProperties.height,
      width: finalWidthInEMU,
      height: finalHeightInEMU
    }, docxDocumentInstance);
    return imageFragment;
  }
}
async function buildList(vNode, docxDocumentInstance, xmlFragment) {
  const listElements = [];
  const parentAttributes = collectParentAttributes(docxDocumentInstance, vNode);
  let vNodeObjects = [
    {
      node: vNode,
      level: 0,
      type: vNode.tagName,
      numberingId: docxDocumentInstance.createNumbering(vNode.tagName, vNode.properties, vNode),
      originalListItem: null
    }
  ];
  while (vNodeObjects.length) {
    const tempVNodeObject = vNodeObjects.shift();
    if (tempVNodeObject) {
      if (import_is_vtext2.default(tempVNodeObject.node) || import_is_vnode2.default(tempVNodeObject.node) && !["ul", "ol", "li"].includes(tempVNodeObject.node.tagName)) {
        const nodeForAttributes = tempVNodeObject.originalListItem || tempVNodeObject.node;
        const listItemAttributes = collectParentAttributes(docxDocumentInstance, nodeForAttributes, parentAttributes);
        const paragraphFragment = await buildParagraph(tempVNodeObject.node, {
          numbering: {
            levelId: tempVNodeObject.level,
            numberingId: tempVNodeObject.numberingId
          },
          ...listItemAttributes
        }, docxDocumentInstance);
        xmlFragment.import(paragraphFragment);
      }
    }
    if (tempVNodeObject?.node.children && tempVNodeObject?.node.children.length && ["ul", "ol", "li"].includes(tempVNodeObject?.node.tagName)) {
      const tempVNodeObjects = tempVNodeObject.node.children.reduce((accumulator, childVNode) => {
        if (["ul", "ol"].includes(childVNode.tagName)) {
          accumulator.push({
            node: childVNode,
            level: tempVNodeObject.level + 1,
            type: childVNode.tagName,
            numberingId: docxDocumentInstance.createNumbering(childVNode.tagName, childVNode.properties, childVNode),
            originalListItem: null
          });
        } else {
          if (accumulator.length > 0 && import_is_vnode2.default(accumulator[accumulator.length - 1].node) && accumulator[accumulator.length - 1].node.tagName.toLowerCase() === "p") {
            accumulator[accumulator.length - 1].node.children.push(childVNode);
          } else {
            const paragraphVNode = new import_vnode3.default("p", import_is_vnode2.default(childVNode) && childVNode.tagName.toLowerCase() === "li" ? childVNode.properties : null, import_is_vtext2.default(childVNode) ? [childVNode] : import_is_vnode2.default(childVNode) ? childVNode.tagName.toLowerCase() === "li" ? [...childVNode.children] : [childVNode] : []);
            const isListItem = import_is_vnode2.default(childVNode) && childVNode.tagName.toLowerCase() === "li";
            accumulator.push({
              node: import_is_vnode2.default(childVNode) ? childVNode.tagName.toLowerCase() === "li" ? childVNode : childVNode.tagName.toLowerCase() !== "p" ? paragraphVNode : childVNode : paragraphVNode,
              level: tempVNodeObject.level,
              type: tempVNodeObject.type,
              numberingId: tempVNodeObject.numberingId,
              originalListItem: isListItem ? childVNode : tempVNodeObject.originalListItem
            });
          }
        }
        return accumulator;
      }, []);
      vNodeObjects = tempVNodeObjects.concat(vNodeObjects);
    }
  }
  return listElements;
}
function collectParentAttributes(docxDocumentInstance, vNode, existingAttributes = {}) {
  const parentAttributes = { ...existingAttributes };
  if (vNode && vNode.properties) {
    const properties = vNode.properties;
    if (properties.style) {
      if (properties.style["font-weight"] === "bold") {
        parentAttributes.strong = true;
      }
      if (properties.style["font-style"] === "italic") {
        parentAttributes.i = true;
      }
      if (properties.style["font-family"] || properties.style.fontFamily) {
        parentAttributes.font = docxDocumentInstance.createFont(properties.style.fontFamily || properties.style["font-family"]);
      }
      if (properties.style.fontSize || properties.style["font-size"]) {
        const fontSize = properties.style.fontSize || properties.style["font-size"];
        parentAttributes.fontSize = fixupFontSize(String(fontSize));
      }
    }
    const classAttr = properties.className || properties.class || properties.attributes && properties.attributes.class || "";
    if (classAttr && docxDocumentInstance.cssClassStyles) {
      classAttr.toString().split(/\s+/).filter(Boolean).forEach((cls) => {
        const clsStyles = docxDocumentInstance.cssClassStyles[cls];
        if (clsStyles) {
          if (clsStyles["font-weight"] === "bold") {
            parentAttributes.strong = true;
          }
          if (clsStyles["font-style"] === "italic") {
            parentAttributes.i = true;
          }
          if (clsStyles["font-family"]) {
            parentAttributes.font = docxDocumentInstance.createFont(clsStyles["font-family"]);
          }
          if (clsStyles["font-size"]) {
            parentAttributes.fontSize = fixupFontSize(String(clsStyles["font-size"]));
          }
          if (clsStyles.color) {
            parentAttributes.color = fixupColorCode(String(clsStyles.color));
          }
        }
      });
    }
    if (!parentAttributes.font && docxDocumentInstance.cssClassStyles && docxDocumentInstance.cssClassStyles.__element_body) {
      const bodyStyles = docxDocumentInstance.cssClassStyles.__element_body;
      if (bodyStyles["font-family"]) {
        parentAttributes.font = docxDocumentInstance.createFont(bodyStyles["font-family"]);
      }
    }
    if (!parentAttributes.font && docxDocumentInstance.cssClassStyles && docxDocumentInstance.cssClassStyles["__element_*"]) {
      const universalStyles = docxDocumentInstance.cssClassStyles["__element_*"];
      if (universalStyles["font-family"]) {
        parentAttributes.font = docxDocumentInstance.createFont(universalStyles["font-family"]);
      }
    }
  }
  if (vNode.tagName === "blockquote") {
    parentAttributes.indentation = { left: 284, right: 0 };
    parentAttributes.textAlign = "justify";
  }
  return parentAttributes;
}
async function findXMLEquivalent(docxDocumentInstance, vNode, xmlFragment, parentAttributes = {}) {
  if (vNode.tagName === "div" && (vNode.properties.attributes.class === "page-break" || vNode.properties.style && vNode.properties.style["page-break-after"])) {
    const paragraphFragment = import_xmlbuilder22.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "p").ele("@w", "r").ele("@w", "br").att("@w", "type", "page").up().up().up();
    xmlFragment.import(paragraphFragment);
    return;
  }
  if (vNode.tagName === "br") {
    xmlFragment.import(await buildParagraph(vNode, {}, docxDocumentInstance));
    return;
  } else if (htmlHeadings.includes(vNode.tagName)) {
    const headingSpacing = {
      1: { before: 160, after: 160 },
      2: { before: 200, after: 200 },
      3: { before: 240, after: 240 },
      4: { before: 320, after: 320 },
      5: { before: 400, after: 400 },
      6: { before: 560, after: 560 }
    };
    const headingLevel = vNode.tagName[1];
    const attributes = {
      paragraphStyle: `Heading${headingLevel}`
    };
    if (vNode.properties?.style && Object.keys(vNode.properties.style).length > 0) {
      const defaultSpacing = headingSpacing[headingLevel];
      if (defaultSpacing) {
        if (defaultSpacing.before !== undefined) {
          attributes.beforeSpacing = defaultSpacing.before;
        }
        if (defaultSpacing.after !== undefined) {
          attributes.afterSpacing = defaultSpacing.after;
        }
      }
    }
    const headingFragment = await buildParagraph(vNode, attributes, docxDocumentInstance);
    xmlFragment.import(headingFragment);
    return;
  } else if (vNode.tagName === "figure") {
    if (vNodeHasChildren(vNode)) {
      for (let index = 0;index < vNode.children.length; index++) {
        const childVNode = vNode.children[index];
        if (childVNode.tagName === "table") {
          const tableFragment = await buildTable(childVNode, {
            maximumWidth: docxDocumentInstance.availableDocumentSpace,
            rowCantSplit: docxDocumentInstance.tableRowCantSplit
          }, docxDocumentInstance);
          xmlFragment.import(tableFragment);
        } else if (childVNode.tagName === "img") {
          const imageFragment = await buildImage(docxDocumentInstance, childVNode, docxDocumentInstance.availableDocumentSpace);
          if (imageFragment) {
            const paragraphFragment = import_xmlbuilder22.fragment({
              namespaceAlias: { w: namespaces_default.w }
            }).ele("@w", "p");
            if (Array.isArray(imageFragment)) {
              imageFragment.forEach((frag) => paragraphFragment.import(frag));
            } else {
              paragraphFragment.import(imageFragment);
            }
            paragraphFragment.up();
            xmlFragment.import(paragraphFragment);
          }
        }
      }
    }
    return;
  } else if (vNode.tagName === "table") {
    const tableFragment = await buildTable(vNode, {
      maximumWidth: docxDocumentInstance.availableDocumentSpace,
      rowCantSplit: docxDocumentInstance.tableRowCantSplit
    }, docxDocumentInstance);
    xmlFragment.import(tableFragment);
    return;
  } else if (["ol", "ul"].includes(vNode.tagName)) {
    await buildList(vNode, docxDocumentInstance, xmlFragment);
    return;
  } else if (vNode.tagName === "img") {
    const imageRunFragment = await buildImage(docxDocumentInstance, vNode, docxDocumentInstance.availableDocumentSpace);
    if (imageRunFragment) {
      const imageParagraphFragment = await buildParagraph(null, {}, docxDocumentInstance);
      if (Array.isArray(imageRunFragment)) {
        imageRunFragment.forEach((frag) => imageParagraphFragment.import(frag));
      } else {
        imageParagraphFragment.import(imageRunFragment);
      }
      xmlFragment.import(imageParagraphFragment);
    }
    return;
  } else if ([
    "a",
    "p",
    "pre"
  ].includes(vNode.tagName)) {
    const preserveWhitespace = vNode.tagName === "pre";
    xmlFragment.import(await buildParagraph(vNode, parentAttributes, docxDocumentInstance, preserveWhitespace));
    return;
  } else if (vNode.tagName === "span" && vNodeHasChildren(vNode) && vNode.children.some((child) => import_is_vnode2.default(child) && child.tagName === "img")) {
    const imageChild = vNode.children.find((child) => import_is_vnode2.default(child) && child.tagName === "img");
    const imageFragment = await buildImage(docxDocumentInstance, imageChild, docxDocumentInstance.availableDocumentSpace);
    if (imageFragment) {
      if (Array.isArray(imageFragment)) {
        imageFragment.forEach((frag) => xmlFragment.import(frag));
      } else {
        xmlFragment.import(imageFragment);
      }
    }
    return;
  } else if (htmlInlineElements.includes(vNode.tagName)) {
    const textFragment = await buildRun(vNode, parentAttributes, docxDocumentInstance);
    if (Array.isArray(textFragment)) {
      textFragment.forEach((frag) => xmlFragment.import(frag));
    } else {
      xmlFragment.import(textFragment);
    }
    return;
  } else if (vNode.tagName === "head") {
    return;
  } else if (["input", "object", "iframe", "embed"].includes(vNode.tagName)) {
    return;
  } else if (vNode.tagName === "blockquote" && vNodeHasChildren(vNode)) {
    const childParentAttributes = collectParentAttributes(docxDocumentInstance, vNode, parentAttributes);
    const paragraphNodes = [];
    const inlineElements = [];
    const citeElements = [];
    for (const childVNode of vNode.children) {
      if (import_is_vnode2.default(childVNode) && childVNode.tagName === "p") {
        paragraphNodes.push(childVNode);
      } else if (import_is_vnode2.default(childVNode) && childVNode.tagName === "cite") {
        citeElements.push(childVNode);
      } else if (import_is_vnode2.default(childVNode) && htmlInlineElements.includes(childVNode.tagName)) {
        inlineElements.push(childVNode);
      } else if (import_is_vtext2.default(childVNode)) {
        const text = childVNode.text.trim();
        if (text) {
          inlineElements.push(childVNode);
        }
      }
    }
    for (let i2 = 0;i2 < paragraphNodes.length; i2++) {
      const pNode = paragraphNodes[i2];
      const paragraphFragment = await buildParagraph(pNode, childParentAttributes, docxDocumentInstance, false);
      if (i2 === paragraphNodes.length - 1) {
        for (const inlineElement of inlineElements) {
          if (import_is_vnode2.default(inlineElement) && htmlInlineElements.includes(inlineElement.tagName)) {
            const runFragment = await buildRun(inlineElement, childParentAttributes, docxDocumentInstance);
            if (Array.isArray(runFragment)) {
              for (const frag of runFragment) {
                paragraphFragment.import(frag);
              }
            } else {
              paragraphFragment.import(runFragment);
            }
          }
        }
      }
      xmlFragment.import(paragraphFragment);
    }
    for (const citeElement of citeElements) {
      const citeParagraphFragment = await buildParagraph(citeElement, childParentAttributes, docxDocumentInstance, false);
      xmlFragment.import(citeParagraphFragment);
    }
    return;
  }
  if (vNodeHasChildren(vNode)) {
    const childParentAttributes = collectParentAttributes(docxDocumentInstance, vNode, parentAttributes);
    let isInParagraph = false;
    let paragraphFrag = import_xmlbuilder22.fragment();
    const inlineTags = [
      "b",
      "br",
      "code",
      "del",
      "em",
      "i",
      "ins",
      "mark",
      "s",
      "span",
      "strike",
      "strong",
      "sub",
      "sup",
      "u"
    ];
    const needsSpaceExtraction = vNode.children.length > 2 && vNode.children.every((child, index) => {
      if (import_is_vtext2.default(child)) {
        const text = child.text;
        return text.trim() === "";
      }
      if (import_is_vnode2.default(child) && inlineTags.includes(child.tagName)) {
        if (child.children && child.children.length === 1 && import_is_vtext2.default(child.children[0])) {
          const childText = child.children[0].text;
          return index === vNode.children.length - 1 || childText.match(/\s+$/);
        }
      }
      return false;
    });
    const childrenToProcess = needsSpaceExtraction ? preprocessParagraphChildren(vNode.children) : vNode.children;
    for (const childVNode of childrenToProcess) {
      if (childVNode.tagName === "img") {
        const imageRunFragment = await buildImage(docxDocumentInstance, childVNode, docxDocumentInstance.availableDocumentSpace);
        if (imageRunFragment) {
          const imageParagraphFragment = await buildParagraph(childVNode, childParentAttributes, docxDocumentInstance);
          if (Array.isArray(imageRunFragment)) {
            imageRunFragment.forEach((frag) => imageParagraphFragment.import(frag));
          } else {
            imageParagraphFragment.import(imageRunFragment);
          }
          xmlFragment.import(imageParagraphFragment);
        }
        isInParagraph = false;
      } else if (import_is_vtext2.default(childVNode) || inlineTags.includes(childVNode.tagName)) {
        if (!isInParagraph) {
          paragraphFrag = xmlFragment.ele("@w", "p");
          isInParagraph = true;
        }
        if (import_is_vtext2.default(childVNode)) {
          const runFragment = await buildRun(childVNode, childParentAttributes, docxDocumentInstance);
          if (Array.isArray(runFragment)) {
            for (const frag of runFragment) {
              paragraphFrag.import(frag);
            }
          } else {
            paragraphFrag.import(runFragment);
          }
        } else if (import_is_vnode2.default(childVNode) && childVNode.tagName === "br") {
          const runFragment = await buildRun(childVNode, childParentAttributes, docxDocumentInstance);
          if (Array.isArray(runFragment)) {
            for (const frag of runFragment) {
              paragraphFrag.import(frag);
            }
          } else {
            paragraphFrag.import(runFragment);
          }
        } else {
          await convertVTreeToXML(docxDocumentInstance, childVNode, paragraphFrag, childParentAttributes);
        }
      } else {
        await convertVTreeToXML(docxDocumentInstance, childVNode, xmlFragment, childParentAttributes);
        isInParagraph = false;
      }
    }
  }
}
async function convertVTreeToXML(docxDocumentInstance, vTree, xmlFragment, parentAttributes = {}) {
  if (!vTree) {} else if (Array.isArray(vTree) && vTree.length) {
    for (let index = 0;index < vTree.length; index++) {
      const vNode = vTree[index];
      await convertVTreeToXML(docxDocumentInstance, vNode, xmlFragment, parentAttributes);
    }
  } else if (import_is_vnode2.default(vTree)) {
    await findXMLEquivalent(docxDocumentInstance, vTree, xmlFragment, parentAttributes);
  } else if (import_is_vtext2.default(vTree)) {
    const text = vTree.text;
    if (text.trim().length > 0) {
      const paragraphFragment = await buildParagraph(vTree, parentAttributes, docxDocumentInstance);
      xmlFragment.import(paragraphFragment);
    }
  }
}
async function renderDocumentFile(docxDocumentInstance) {
  if (!docxDocumentInstance.htmlString) {
    throw new Error("HTML string is required");
  }
  const vTree = convertHTML(docxDocumentInstance.htmlString);
  const xmlFragment = import_xmlbuilder22.fragment({ namespaceAlias: { w: namespaces_default.w } });
  await convertVTreeToXML(docxDocumentInstance, vTree, xmlFragment);
  return xmlFragment;
}
// src/schemas/content-types.ts
var contentTypesXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels"
    ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="jpeg"
    ContentType="image/jpeg"/>
  <Default Extension="jpg"
    ContentType="image/jpeg"/>
  <Default Extension="png"
    ContentType="image/png"/>
  <Default Extension="gif"
    ContentType="image/gif"/>
  <Default Extension="bmp"
    ContentType="image/bmp"/>
  <Default Extension="tiff"
    ContentType="image/tiff"/>
  <Default Extension="tif"
    ContentType="image/tiff"/>
  <Default Extension="webp"
    ContentType="image/webp"/>
  <Default Extension="emf"
    ContentType="image/emf"/>
  <Default Extension="xml"
    ContentType="application/xml"/>
  <Override PartName="/_rels/.rels"
    ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Override PartName="/word/_rels/document.xml.rels"
    ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Override PartName="/word/document.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
  <Override PartName="/word/numbering.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml"/>
  <Override PartName="/word/theme/theme1.xml"
    ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>
  <Override PartName="/word/fontTable.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"/>
  <Override PartName="/docProps/core.xml"
    ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
  <Override PartName="/word/settings.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>
  <Override PartName="/word/webSettings.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"/>
</Types>
`;
var content_types_default = contentTypesXML;
// src/schemas/core.ts
function generateCoreXML(title = "", subject = "", creator = applicationName, keywords = [applicationName], description = "", lastModifiedBy = applicationName, revision = 1, createdAt = new Date, modifiedAt = new Date) {
  const keyws = keywords && Array.isArray(keywords) ? `<cp:keywords>${keywords.join(", ")}</cp:keywords>` : "";
  const crAt = createdAt instanceof Date ? createdAt.toISOString() : new Date().toISOString();
  const modAt = modifiedAt instanceof Date ? modifiedAt.toISOString() : new Date().toISOString();
  return `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <cp:coreProperties
      xmlns:cp="${namespaces_default.coreProperties}"
      xmlns:dc="${namespaces_default.dc}"
      xmlns:dcterms="${namespaces_default.dcterms}"
      xmlns:dcmitype="${namespaces_default.dcmitype}"
      xmlns:xsi="${namespaces_default.xsi}"
    >
      <dc:title>${title}</dc:title>
      <dc:subject>${subject}</dc:subject>
      <dc:creator>${creator}</dc:creator>
      ${keyws}
      <dc:description>${description}</dc:description>
      <cp:lastModifiedBy>${lastModifiedBy}</cp:lastModifiedBy>
      <cp:revision>${revision}</cp:revision>
      <dcterms:created xsi:type="dcterms:W3CDTF">${crAt}</dcterms:created>
      <dcterms:modified xsi:type="dcterms:W3CDTF">${modAt}</dcterms:modified>
    </cp:coreProperties>
  `;
}
// src/schemas/document-rels.ts
var documentRelsXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<Relationships
  xmlns="http://schemas.openxmlformats.org/package/2006/relationships"
>
  <Relationship
    Id="rId1"
    Type="${namespaces_default.numbering}"
    Target="numbering.xml"
  />
  <Relationship
    Id="rId2"
    Type="${namespaces_default.styles}"
    Target="styles.xml"
  />
  <Relationship
    Id="rId3"
    Type="${namespaces_default.settingsRelation}"
    Target="settings.xml"
  />
  <Relationship
    Id="rId4"
    Type="${namespaces_default.webSettingsRelation}"
    Target="webSettings.xml"
  />
  <Relationship
    Id="rId5"
    Type="${namespaces_default.fontTable}"
    Target="fontTable.xml"
  />
</Relationships>
`;
var document_rels_default = documentRelsXML;
// src/schemas/document.template.ts
function generateDocumentTemplate() {
  return `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:document
      xmlns:a="${namespaces_default.a}"
      xmlns:cdr="${namespaces_default.cdr}"
      xmlns:o="${namespaces_default.o}"
      xmlns:pic="${namespaces_default.pic}"
      xmlns:r="${namespaces_default.r}"
      xmlns:v="${namespaces_default.v}"
      xmlns:ve="${namespaces_default.ve}"
      xmlns:vt="${namespaces_default.vt}"
      xmlns:w="${namespaces_default.w}"
      xmlns:w10="${namespaces_default.w10}"
      xmlns:wp="${namespaces_default.wp}"
      xmlns:wne="${namespaces_default.wne}"
      >
      <w:body>
      </w:body>
    </w:document>
  `;
}
// src/schemas/font-table.ts
var fontTableXML = `
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

  <w:fonts
    xmlns:r="${namespaces_default.r}"
    xmlns:w="${namespaces_default.w}"
  >
    <w:font w:name="Arial">
      <w:panose1 w:val="020B0604020202020204"/>
      <w:charset w:val="00"/>
      <w:family w:val="auto"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="00000003" w:usb1="00000000" w:usb2="00000000"
        w:usb3="00000000" w:csb0="00000001" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Calibri">
      <w:panose1 w:val="020F0502020204030204"/>
      <w:charset w:val="00"/>
      <w:family w:val="swiss"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="E4002EFF" w:usb1="C000247B" w:usb2="00000009"
        w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Calibri Light">
      <w:panose1 w:val="020F0302020204030204"/>
      <w:charset w:val="00"/>
      <w:family w:val="swiss"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="E4002EFF" w:usb1="C000247B" w:usb2="00000009"
        w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Courier New">
      <w:panose1 w:val="02070309020205020404"/>
      <w:charset w:val="00"/>
      <w:family w:val="auto"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="00000003" w:usb1="00000000" w:usb2="00000000"
        w:usb3="00000000" w:csb0="00000001" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Symbol">
      <w:panose1 w:val="05050102010706020507"/>
      <w:charset w:val="02"/>
      <w:family w:val="decorative"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="00000000" w:usb1="10000000" w:usb2="00000000"
        w:usb3="00000000" w:csb0="80000000" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Times New Roman">
      <w:panose1 w:val="02020603050405020304"/>
      <w:charset w:val="00"/>
      <w:family w:val="roman"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="E0002EFF" w:usb1="C000785B" w:usb2="00000009"
        w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
    </w:font>
  </w:fonts>
`;
var font_table_default = fontTableXML;
// src/schemas/generic-rels.ts
var genericRelsXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<Relationships
  xmlns="http://schemas.openxmlformats.org/package/2006/relationships"
>
</Relationships>
`;
var generic_rels_default = genericRelsXML;
// src/schemas/numbering.ts
function generateNumberingXMLTemplate() {
  return `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:numbering
      xmlns:w="${namespaces_default.w}"
      xmlns:ve="${namespaces_default.ve}"
      xmlns:o="${namespaces_default.o}"
      xmlns:r="${namespaces_default.r}"
      xmlns:v="${namespaces_default.v}"
      xmlns:wp="${namespaces_default.wp}"
      xmlns:w10="${namespaces_default.w10}"
      xmlns:wne="${namespaces_default.wne}"
    >
    </w:numbering>
  `;
}
// src/schemas/rels.ts
var relsXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<Relationships
  xmlns="http://schemas.openxmlformats.org/package/2006/relationships"
>
  <Relationship
    Id="rId1"
    Type="${namespaces_default.officeDocumentRelation}"
    Target="word/document.xml"
  />
  <Relationship
    Id="rId2"
    Type="${namespaces_default.corePropertiesRelation}"
    Target="docProps/core.xml"
  />
</Relationships>
`;
var rels_default = relsXML;
// src/schemas/settings.ts
var settingsXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<w:settings
  xmlns:w="${namespaces_default.w}"
  xmlns:o="${namespaces_default.o}"
  xmlns:r="${namespaces_default.r}"
  xmlns:v="${namespaces_default.v}"
  xmlns:w10="${namespaces_default.w10}"
  xmlns:sl="${namespaces_default.sl}"
>
  <w:zoom w:percent="100"/>
  <w:defaultTabStop w:val="720"/>
  <w:decimalSymbol w:val="."/>
  <w:listSeparator w:val=","/>
</w:settings>
`;
var settings_default = settingsXML;
// src/schemas/styles.ts
function generateStylesXML(font = defaultFont, fontSize = defaultFontSize, complexScriptFontSize = defaultFontSize, lang = defaultLang) {
  return `
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

  <w:styles xmlns:w="${namespaces_default.w}" xmlns:r="${namespaces_default.r}">
  <w:docDefaults>
    <w:rPrDefault>
    <w:rPr>
      <w:rFonts
        w:ascii="${font}"
        w:eastAsiaTheme="minorHAnsi"
        w:hAnsiTheme="minorHAnsi"
        w:cstheme="minorBidi"
      />
      <w:sz w:val="${fontSize}" />
      <w:szCs w:val="${complexScriptFontSize}" />
      <w:lang w:val="${lang}" w:eastAsia="${lang}" w:bidi="ar-SA" />
    </w:rPr>
    </w:rPrDefault>
    <w:pPrDefault>
    <w:pPr>
      <w:spacing w:after="120" w:line="240" w:lineRule="atLeast" />
    </w:pPr>
    </w:pPrDefault>
  </w:docDefaults>
  <w:style w:type="character" w:styleId="Hyperlink">
    <w:name w:val="Hyperlink" />
    <w:rPr>
    <w:color w:val="0000FF" />
    <w:u w:val="single" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading1">
    <w:name w:val="heading 1" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="480" />
    <w:outlineLvl w:val="0" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="48" />
    <w:szCs w:val="48" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading2">
    <w:name w:val="heading 2" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="360" w:after="80" />
    <w:outlineLvl w:val="1" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="36" />
    <w:szCs w:val="36" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading3">
    <w:name w:val="heading 3" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:semiHidden />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="280" w:after="80" />
    <w:outlineLvl w:val="2" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="28" />
    <w:szCs w:val="28" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading4">
    <w:name w:val="heading 4" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:semiHidden />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="240" w:after="40" />
    <w:outlineLvl w:val="3" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="24" />
    <w:szCs w:val="24" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading5">
    <w:name w:val="heading 5" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:semiHidden />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="220" w:after="40" />
    <w:outlineLvl w:val="4" />
    </w:pPr>
    <w:rPr>
    <w:b />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading6">
    <w:name w:val="heading 6" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:semiHidden />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="200" w:after="40" />
    <w:outlineLvl w:val="5" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="20" />
    <w:szCs w:val="20" />
    </w:rPr>
  </w:style>
  </w:styles>
  `;
}
// src/schemas/theme.ts
function generateThemeXML(font = defaultFont) {
  return `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <a:theme
      xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
      name="Office Theme"
    >
    <a:themeElements>
      <a:clrScheme name="Office">
        <a:dk1>
          <a:sysClr val="windowText" lastClr="000000"/>
        </a:dk1>
        <a:lt1>
          <a:sysClr val="window" lastClr="FFFFFF"/>
        </a:lt1>
        <a:dk2>
          <a:srgbClr val="44546A"/>
        </a:dk2>
        <a:lt2>
          <a:srgbClr val="E7E6E6"/>
        </a:lt2>
        <a:accent1>
          <a:srgbClr val="4472C4"/>
        </a:accent1>
        <a:accent2>
          <a:srgbClr val="ED7D31"/>
        </a:accent2>
        <a:accent3>
          <a:srgbClr val="A5A5A5"/>
        </a:accent3>
        <a:accent4>
          <a:srgbClr val="FFC000"/>
        </a:accent4>
        <a:accent5>
          <a:srgbClr val="5B9BD5"/>
        </a:accent5>
        <a:accent6>
          <a:srgbClr val="70AD47"/>
        </a:accent6>
        <a:hlink>
          <a:srgbClr val="0563C1"/>
        </a:hlink>
        <a:folHlink>
          <a:srgbClr val="954F72"/>
        </a:folHlink>
      </a:clrScheme>
      <a:fontScheme name="Office">
        <a:majorFont>
          <a:latin typeface="${font}"/>
          <a:ea typeface="${font}"/>
          <a:cs typeface=""/>
        </a:majorFont>
        <a:minorFont>
          <a:latin typeface="${font}"/>
          <a:ea typeface="${font}"/>
          <a:cs typeface=""/>
        </a:minorFont>
      </a:fontScheme>
      <a:fmtScheme name="Office">
        <a:fillStyleLst>
          <a:solidFill>
            <a:schemeClr val="phClr"/>
          </a:solidFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:lumMod val="110000"/>
                  <a:satMod val="105000"/>
                  <a:tint val="67000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="105000"/>
                  <a:satMod val="103000"/>
                  <a:tint val="73000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="105000"/>
                  <a:satMod val="109000"/>
                  <a:tint val="81000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:satMod val="103000"/>
                  <a:lumMod val="102000"/>
                  <a:tint val="94000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:satMod val="110000"/>
                  <a:lumMod val="100000"/>
                  <a:shade val="100000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="99000"/>
                  <a:satMod val="120000"/>
                  <a:shade val="78000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
        </a:fillStyleLst>
        <a:lnStyleLst>
          <a:ln w="6350" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
          <a:ln w="12700" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
          <a:ln w="19050" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
        </a:lnStyleLst>
        <a:effectStyleLst>
          <a:effectStyle>
            <a:effectLst/>
          </a:effectStyle>
          <a:effectStyle>
            <a:effectLst/>
          </a:effectStyle>
          <a:effectStyle>
            <a:effectLst>
              <a:outerShdw
                blurRad="57150"
                dist="19050"
                dir="5400000"
                algn="ctr"
                rotWithShape="0"
              >
                <a:srgbClr val="000000">
                  <a:alpha val="63000"/>
                </a:srgbClr>
              </a:outerShdw>
            </a:effectLst>
          </a:effectStyle>
        </a:effectStyleLst>
        <a:bgFillStyleLst>
          <a:solidFill>
            <a:schemeClr val="phClr"/>
          </a:solidFill>
          <a:solidFill>
            <a:schemeClr val="phClr">
              <a:tint val="95000"/>
              <a:satMod val="170000"/>
            </a:schemeClr>
          </a:solidFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:tint val="93000"/>
                  <a:satMod val="150000"/>
                  <a:shade val="98000"/>
                  <a:lumMod val="102000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:tint val="98000"/>
                  <a:satMod val="130000"/>
                  <a:shade val="90000"/>
                  <a:lumMod val="103000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:shade val="63000"/>
                  <a:satMod val="120000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
        </a:bgFillStyleLst>
      </a:fmtScheme>
    </a:themeElements>
  </a:theme>
`;
}
// src/schemas/web-settings.ts
var webSettingsXML = `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:webSettings xmlns:w="${namespaces_default.w}" xmlns:r="${namespaces_default.r}">
    </w:webSettings>
`;
var web_settings_default = webSettingsXML;
// src/utils/font-family-conversion.ts
var removeSimpleOrDoubleQuotes = /(["'])(.*?)\1/;
function fontFamilyToTableObject(fontFamilyString, fallbackFont) {
  const fontFamilyElements = fontFamilyString ? fontFamilyString.split(",").map((fontName) => {
    const trimmedFontName = fontName.trim();
    if (removeSimpleOrDoubleQuotes.test(trimmedFontName)) {
      return trimmedFontName.match(removeSimpleOrDoubleQuotes)?.[2];
    }
    return trimmedFontName;
  }) : [fallbackFont];
  return {
    fontName: fontFamilyElements[0] || fallbackFont,
    genericFontName: fontFamilyElements[fontFamilyElements.length - 1] || fallbackFont
  };
}

// src/utils/list.ts
class ListStyleBuilder {
  defaults;
  constructor(defaults) {
    this.defaults = defaults || { defaultOrderedListStyleType: "decimal" };
  }
  getListStyleType(listType) {
    switch (listType) {
      case "upper-roman":
        return "upperRoman";
      case "lower-roman":
        return "lowerRoman";
      case "upper-alpha":
      case "upper-alpha-bracket-end":
        return "upperLetter";
      case "lower-alpha":
      case "lower-alpha-bracket-end":
        return "lowerLetter";
      case "decimal":
      case "decimal-bracket":
        return "decimal";
      default:
        return this.defaults.defaultOrderedListStyleType;
    }
  }
  getListPrefixSuffix(style, lvl) {
    let listType = this.defaults.defaultOrderedListStyleType;
    if (style && style["list-style-type"]) {
      listType = style["list-style-type"];
    }
    switch (listType) {
      case "upper-roman":
      case "lower-roman":
      case "upper-alpha":
      case "lower-alpha":
        return `%${lvl + 1}.`;
      case "upper-alpha-bracket-end":
      case "lower-alpha-bracket-end":
      case "decimal-bracket-end":
        return `%${lvl + 1})`;
      case "decimal-bracket":
        return `(%${lvl + 1})`;
      case "decimal":
      default:
        return `%${lvl + 1}.`;
    }
  }
}

// src/docx-document.ts
function extractCssClassStyles(html) {
  const styleTagRegex = /<style[^>]*>([\s\S]*?)<\/style>/gi;
  let css = "";
  let m;
  while ((m = styleTagRegex.exec(html)) !== null) {
    css += m[1];
  }
  const classStyles = {};
  const ruleRegex = /\.([\w-]+)\s*\{([^}]*)\}/g;
  let r;
  while ((r = ruleRegex.exec(css)) !== null) {
    const className = r[1].trim();
    const decls = r[2].split(";");
    const kv = {};
    for (const d of decls) {
      const [k, v] = d.split(":").map((s) => s?.trim());
      if (k && v)
        kv[k.toLowerCase()] = v;
    }
    classStyles[className] = kv;
  }
  const elementRuleRegex = /(body|html|p|h[1-6]|div|span|\*)\s*\{([^}]*)\}/g;
  let e;
  while ((e = elementRuleRegex.exec(css)) !== null) {
    const elementName = e[1].trim();
    const decls = e[2].split(";");
    const kv = {};
    for (const d of decls) {
      const [k, v] = d.split(":").map((s) => s?.trim());
      if (k && v)
        kv[k.toLowerCase()] = v;
    }
    classStyles[`__element_${elementName}`] = kv;
  }
  return classStyles;
}
function sha1(content) {
  return createHash("sha1").update(content).digest("hex");
}
function generateContentTypesFragments(contentTypesXML2, type, objects) {
  if (objects && Array.isArray(objects)) {
    objects.forEach((object) => {
      const contentTypesFragment = import_xmlbuilder23.fragment({
        defaultNamespace: { ele: namespaces_default.contentTypes }
      }).ele("Override").att("PartName", `/word/${type}${object[`${type}Id`]}.xml`).att("ContentType", "application/vnd.openxmlformats-officedocument" + `.wordprocessingml.${type}+xml`).up();
      contentTypesXML2.root().import(contentTypesFragment);
    });
  }
}
function generateSectionReferenceXML(documentXML, documentSectionType, objects, isEnabled) {
  if (isEnabled && objects && Array.isArray(objects) && objects.length) {
    const xmlFragment = import_xmlbuilder23.fragment();
    objects.forEach(({ relationshipId, type }) => {
      const objectFragment = import_xmlbuilder23.fragment({
        namespaceAlias: { w: namespaces_default.w, r: namespaces_default.r }
      }).ele("@w", `${documentSectionType}Reference`).att("@r", "id", `rId${relationshipId}`).att("@w", "type", type).up();
      xmlFragment.import(objectFragment);
    });
    const sectPr = documentXML.root().first().last();
    sectPr.import(xmlFragment);
  }
}
function fixupColorCode2(colorCodeString) {
  const input = colorCodeString?.trim() || "";
  if (Object.prototype.hasOwnProperty.call(color_name_default, input.toLowerCase())) {
    const [red, green, blue] = color_name_default[input.toLowerCase()];
    return rgbToHex(red, green, blue).toUpperCase();
  }
  if (rgbRegex.test(input)) {
    const matchedParts = input.match(rgbRegex);
    const red = matchedParts?.[1];
    const green = matchedParts?.[2];
    const blue = matchedParts?.[3];
    return rgbToHex(red, green, blue).toUpperCase();
  }
  if (hslRegex.test(input)) {
    const matchedParts = input.match(hslRegex);
    const hue = Number(matchedParts?.[1]);
    const saturation = Number(matchedParts?.[2]);
    const luminosity = Number(matchedParts?.[3]);
    return hslToHex(hue, saturation, luminosity).toUpperCase();
  }
  if (hexRegex.test(input)) {
    const matchedParts = input.match(hexRegex);
    return (matchedParts?.[1] || "000000").toUpperCase();
  }
  if (hex3Regex.test(input)) {
    const matchedParts = input.match(hex3Regex);
    const red = String(matchedParts?.[1] || 0);
    const green = String(matchedParts?.[2] || 0);
    const blue = String(matchedParts?.[3] || 0);
    return hex3ToHex(red, green, blue).toUpperCase();
  }
  return "000000";
}
function generateXMLString(xmlString) {
  const xmlDocumentString = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, xmlString);
  return xmlDocumentString.toString({ prettyPrint: true });
}
async function generateSectionXML(vTree, type) {
  const sectionXML = import_xmlbuilder23.create({
    encoding: "UTF-8",
    standalone: true,
    namespaceAlias: {
      w: namespaces_default.w,
      ve: namespaces_default.ve,
      o: namespaces_default.o,
      r: namespaces_default.r,
      v: namespaces_default.v,
      wp: namespaces_default.wp,
      w10: namespaces_default.w10
    }
  }).ele("@w", type === "header" ? "hdr" : "ftr");
  const XMLFragment = import_xmlbuilder23.fragment();
  await convertVTreeToXML(this, vTree, XMLFragment);
  if (type === "footer" && XMLFragment.first().node.tagName === "p" && this.pageNumber) {
    XMLFragment.first().import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "fldSimple").att("@w", "instr", "PAGE").ele("@w", "r").up().up());
  }
  sectionXML.root().import(XMLFragment);
  if (type === "header") {
    this.lastHeaderId += 1;
    return {
      headerId: this.lastHeaderId,
      headerXML: sectionXML
    };
  } else {
    this.lastFooterId += 1;
    return {
      footerId: this.lastFooterId,
      footerXML: sectionXML
    };
  }
}

class DocxDocument {
  zip;
  htmlString;
  cssClassStyles;
  orientation;
  pageSize;
  width;
  height;
  margins;
  availableDocumentSpace;
  title;
  subject;
  creator;
  keywords;
  description;
  lastModifiedBy;
  revision;
  createdAt;
  modifiedAt;
  headerType;
  header;
  footerType;
  footer;
  font;
  fontSize;
  complexScriptFontSize;
  lang;
  tableRowCantSplit;
  pageNumber;
  skipFirstHeaderFooter;
  embedImages;
  lineNumberOptions;
  lastNumberingId;
  lastMediaId;
  lastHeaderId;
  lastFooterId;
  stylesObjects;
  numberingObjects;
  fontTableObjects;
  relationshipFilename;
  relationships;
  mediaFiles;
  headerObjects;
  footerObjects;
  documentXML;
  generateSectionXML;
  ListStyleBuilder;
  constructor(properties) {
    this.zip = properties.zip;
    this.htmlString = properties.htmlString;
    this.cssClassStyles = extractCssClassStyles(this.htmlString);
    this.orientation = properties.orientation;
    this.pageSize = properties.pageSize || defaultDocumentOptions.pageSize;
    const isPortraitOrientation = this.orientation === defaultOrientation;
    const height = this.pageSize?.height ? this.pageSize.height : landscapeHeight;
    const width = this.pageSize?.width ? this.pageSize.width : landscapeWidth;
    this.width = isPortraitOrientation ? width : height;
    this.height = isPortraitOrientation ? height : width;
    const marginsObject = properties.margins;
    this.margins = marginsObject && Object.keys(marginsObject).length ? marginsObject : isPortraitOrientation ? portraitMargins : landscapeMargins;
    this.availableDocumentSpace = this.width - this.margins.left - this.margins.right;
    this.title = properties.title || "";
    this.subject = properties.subject || "";
    this.creator = properties.creator || applicationName;
    this.keywords = properties.keywords || [applicationName];
    this.description = properties.description || "";
    this.lastModifiedBy = properties.lastModifiedBy || applicationName;
    this.revision = properties.revision || 1;
    this.createdAt = properties.createdAt || new Date;
    this.modifiedAt = properties.modifiedAt || new Date;
    this.headerType = properties.headerType || "default";
    this.header = properties.header || false;
    this.footerType = properties.footerType || "default";
    this.footer = properties.footer || false;
    this.font = properties.font || defaultFont;
    this.fontSize = properties.fontSize || defaultFontSize;
    this.complexScriptFontSize = properties.complexScriptFontSize || defaultFontSize;
    this.lang = properties.lang || defaultLang;
    this.tableRowCantSplit = properties.table && properties.table.row && properties.table.row.cantSplit || false;
    this.pageNumber = properties.pageNumber || false;
    this.skipFirstHeaderFooter = properties.skipFirstHeaderFooter || false;
    this.embedImages = properties.embedImages !== undefined ? properties.embedImages : true;
    this.lineNumberOptions = properties.lineNumber ? properties.lineNumberOptions : undefined;
    this.lastNumberingId = 0;
    this.lastMediaId = 0;
    this.lastHeaderId = 0;
    this.lastFooterId = 0;
    this.stylesObjects = [];
    this.numberingObjects = [];
    this.fontTableObjects = [];
    this.relationshipFilename = documentFileName;
    this.relationships = [{
      fileName: documentFileName,
      lastRelsId: 5,
      rels: []
    }];
    this.mediaFiles = [];
    this.headerObjects = [];
    this.footerObjects = [];
    this.documentXML = null;
    this.generateContentTypesXML = this.generateContentTypesXML.bind(this);
    this.generateDocumentXML = this.generateDocumentXML.bind(this);
    this.generateCoreXML = this.generateCoreXML.bind(this);
    this.generateSettingsXML = this.generateSettingsXML.bind(this);
    this.generateWebSettingsXML = this.generateWebSettingsXML.bind(this);
    this.generateStylesXML = this.generateStylesXML.bind(this);
    this.generateFontTableXML = this.generateFontTableXML.bind(this);
    this.generateThemeXML = this.generateThemeXML.bind(this);
    this.generateNumberingXML = this.generateNumberingXML.bind(this);
    this.generateRelsXML = this.generateRelsXML.bind(this);
    this.createMediaFile = this.createMediaFile.bind(this);
    this.createDocumentRelationships = this.createDocumentRelationships.bind(this);
    this.generateHeaderXML = this.generateHeaderXML.bind(this);
    this.generateFooterXML = this.generateFooterXML.bind(this);
    this.generateSectionXML = generateSectionXML.bind(this);
    this.ListStyleBuilder = new ListStyleBuilder(properties.numbering);
  }
  generateContentTypesXML() {
    const contentTypesXML2 = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, content_types_default);
    generateContentTypesFragments(contentTypesXML2, "header", this.headerObjects);
    generateContentTypesFragments(contentTypesXML2, "footer", this.footerObjects);
    return contentTypesXML2.toString({ prettyPrint: true });
  }
  generateDocumentXML() {
    const documentXML = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, generateDocumentTemplate());
    const body = documentXML.root().first();
    if (this.documentXML) {
      body.import(this.documentXML);
    } else {
      throw new Error("Document XML must be created before importing");
    }
    const sectPr = import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "sectPr").ele("@w", "pgSz").att("@w", "w", String(this.width)).att("@w", "h", String(this.height)).att("@w", "orient", this.orientation).up().ele("@w", "pgMar").att("@w", "top", String(this.margins?.top || 0)).att("@w", "right", String(this.margins?.right || 0)).att("@w", "bottom", String(this.margins?.bottom || 0)).att("@w", "left", String(this.margins?.left || 0)).att("@w", "header", String(this.margins?.header || 0)).att("@w", "footer", String(this.margins?.footer || 0)).att("@w", "gutter", String(this.margins?.gutter || 0)).up().up();
    body.import(sectPr);
    generateSectionReferenceXML(documentXML, "header", this.headerObjects, this.header);
    generateSectionReferenceXML(documentXML, "footer", this.footerObjects, this.footer);
    if ((this.header || this.footer) && this.skipFirstHeaderFooter) {
      documentXML.root().first().first().import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "titlePg"));
    }
    if (this.lineNumberOptions) {
      const { countBy, start, restart } = this.lineNumberOptions;
      documentXML.root().first().first().import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "lnNumType").att("@w", "countBy", String(countBy)).att("@w", "start", String(start)).att("@w", "restart", String(restart)));
    }
    return documentXML.toString({ prettyPrint: true });
  }
  generateCoreXML() {
    return generateXMLString(generateCoreXML(this.title, this.subject, this.creator, this.keywords, this.description, this.lastModifiedBy, this.revision, this.createdAt, this.modifiedAt));
  }
  generateSettingsXML() {
    return generateXMLString(settings_default);
  }
  generateWebSettingsXML() {
    return generateXMLString(web_settings_default);
  }
  generateStylesXML() {
    return generateXMLString(generateStylesXML(this.font, this.fontSize, this.complexScriptFontSize, this.lang));
  }
  generateFontTableXML() {
    const fontTableXML2 = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, font_table_default);
    const fontNames = [
      "Arial",
      "Calibri",
      "Calibri Light",
      "Courier New",
      "Symbol",
      "Times New Roman"
    ];
    this.fontTableObjects.forEach(({ fontName, genericFontName }) => {
      if (!fontNames.includes(fontName)) {
        fontNames.push(fontName);
        const fontFragment = import_xmlbuilder23.fragment({
          namespaceAlias: { w: namespaces_default.w }
        }).ele("@w", "font").att("@w", "name", fontName);
        switch (genericFontName) {
          case "serif":
            fontFragment.ele("@w", "altName").att("@w", "val", "Times New Roman");
            fontFragment.ele("@w", "family").att("@w", "val", "roman");
            fontFragment.ele("@w", "pitch").att("@w", "val", "variable");
            break;
          case "sans-serif":
            fontFragment.ele("@w", "altName").att("@w", "val", "Arial");
            fontFragment.ele("@w", "family").att("@w", "val", "swiss");
            fontFragment.ele("@w", "pitch").att("@w", "val", "variable");
            break;
          case "monospace":
            fontFragment.ele("@w", "altName").att("@w", "val", "Courier New");
            fontFragment.ele("@w", "family").att("@w", "val", "modern");
            fontFragment.ele("@w", "pitch").att("@w", "val", "fixed");
            break;
          default:
            break;
        }
        fontTableXML2.root().import(fontFragment);
      }
    });
    return fontTableXML2.toString({ prettyPrint: true });
  }
  generateThemeXML() {
    return generateXMLString(generateThemeXML(this.font));
  }
  generateNumberingXML() {
    const numberingXML = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, generateNumberingXMLTemplate());
    const abstractNumberingFragments = import_xmlbuilder23.fragment();
    const numberingFragments = import_xmlbuilder23.fragment();
    this.numberingObjects.forEach(({ numberingId, type, properties }) => {
      const abstractNumberingFragment = import_xmlbuilder23.fragment({
        namespaceAlias: { w: namespaces_default.w }
      }).ele("@w", "abstractNum").att("@w", "abstractNumId", String(numberingId));
      [
        ...Array(8).keys()
      ].forEach((level) => {
        const levelFragment = import_xmlbuilder23.fragment({
          namespaceAlias: { w: namespaces_default.w }
        }).ele("@w", "lvl").att("@w", "ilvl", String(level)).ele("@w", "start").att("@w", "val", type === "ol" ? String(properties?.attributes?.["data-start"] || 1) : "1").up().ele("@w", "numFmt").att("@w", "val", type === "ol" ? this.ListStyleBuilder.getListStyleType(properties?.style?.["list-style-type"] || "decimal") : "bullet").up().ele("@w", "lvlText").att("@w", "val", type === "ol" ? this.ListStyleBuilder.getListPrefixSuffix(properties.style || { "list-style-type": "decimal" }, level) : "•").up().ele("@w", "suff").att("@w", "val", "tab").up().ele("@w", "lvlJc").att("@w", "val", "left").up().ele("@w", "pPr").ele("@w", "tabs").ele("@w", "tab").att("@w", "val", "num").att("@w", "pos", String((level + 1) * 720)).up().up().ele("@w", "ind").att("@w", "left", String((level + 1) * 720)).att("@w", "hanging", "360").up().up().up();
        if (type === "ul") {
          const rPrFragment = import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "rPr");
          rPrFragment.ele("@w", "rFonts").att("@w", "ascii", "Symbol").att("@w", "hAnsi", "Symbol").att("@w", "hint", "default").up();
          const resolvedStyling = properties?.resolvedStyling;
          if (resolvedStyling) {
            if (resolvedStyling.color) {
              const colorValue = fixupColorCode2(resolvedStyling.color);
              if (colorValue && colorValue.length === 6) {
                rPrFragment.ele("@w", "color").att("@w", "val", colorValue).up();
              }
            }
            if (resolvedStyling.fontSize) {
              const fontSizeValue = font_size_default(resolvedStyling.fontSize);
              if (Number.isFinite(fontSizeValue) && fontSizeValue > 0) {
                rPrFragment.ele("@w", "sz").att("@w", "val", String(fontSizeValue)).up();
                rPrFragment.ele("@w", "szCs").att("@w", "val", String(fontSizeValue)).up();
              }
            }
            if (resolvedStyling.fontWeight === "bold") {
              rPrFragment.ele("@w", "b").up();
              rPrFragment.ele("@w", "bCs").up();
            }
            if (resolvedStyling.fontStyle === "italic") {
              rPrFragment.ele("@w", "i").up();
              rPrFragment.ele("@w", "iCs").up();
            }
          }
          levelFragment.last().import(rPrFragment.up());
        } else if (type === "ol") {
          const resolvedStyling = properties?.resolvedStyling;
          if (resolvedStyling && Object.keys(resolvedStyling).length > 0) {
            const rPrFragment = import_xmlbuilder23.fragment({
              namespaceAlias: { w: namespaces_default.w }
            }).ele("@w", "rPr");
            if (resolvedStyling.fontFamily) {
              const fonts = resolvedStyling.fontFamily.split(",").map((f) => f.trim().replace(/['"]/g, ""));
              let fontName = fonts[0];
              for (const font of fonts) {
                if (font && !["serif", "sans-serif", "monospace", "cursive", "fantasy"].includes(font.toLowerCase())) {
                  fontName = font;
                  break;
                }
              }
              rPrFragment.ele("@w", "rFonts").att("@w", "ascii", fontName).att("@w", "hAnsi", fontName).att("@w", "eastAsia", fontName).att("@w", "cs", fontName).att("@w", "hint", "default").up();
            }
            if (resolvedStyling.fontSize) {
              const fontSizeValue = font_size_default(resolvedStyling.fontSize);
              if (Number.isFinite(fontSizeValue) && fontSizeValue > 0) {
                rPrFragment.ele("@w", "sz").att("@w", "val", String(fontSizeValue)).up();
                rPrFragment.ele("@w", "szCs").att("@w", "val", String(fontSizeValue)).up();
              }
            }
            if (resolvedStyling.fontWeight === "bold") {
              rPrFragment.ele("@w", "b").up();
              rPrFragment.ele("@w", "bCs").up();
            }
            if (resolvedStyling.fontStyle === "italic") {
              rPrFragment.ele("@w", "i").up();
              rPrFragment.ele("@w", "iCs").up();
            }
            if (resolvedStyling.color) {
              const colorValue = fixupColorCode2(resolvedStyling.color);
              if (colorValue && colorValue.length === 6) {
                rPrFragment.ele("@w", "color").att("@w", "val", colorValue).up();
              }
            }
            levelFragment.last().import(rPrFragment.up());
          }
        }
        abstractNumberingFragment.import(levelFragment);
      });
      abstractNumberingFragment.up();
      abstractNumberingFragments.import(abstractNumberingFragment);
      numberingFragments.import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "num").att("@w", "numId", String(numberingId)).ele("@w", "abstractNumId").att("@w", "val", String(numberingId)).up().up());
    });
    numberingXML.root().import(abstractNumberingFragments);
    numberingXML.root().import(numberingFragments);
    return numberingXML.toString({ prettyPrint: true });
  }
  appendRelationships(xmlFragment, relationships) {
    relationships.forEach(({ relationshipId, type, target, targetMode }) => {
      xmlFragment.import(import_xmlbuilder23.fragment({ defaultNamespace: { ele: namespaces_default.relationship } }).ele("Relationship").att("Id", `rId${relationshipId}`).att("Type", type).att("Target", target).att("TargetMode", targetMode).up());
    });
  }
  generateRelsXML() {
    const relationshipXMLStrings = this.relationships.map(({ fileName, rels }) => {
      const xmlFragment = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, fileName === documentFileName ? document_rels_default : generic_rels_default);
      this.appendRelationships(xmlFragment.root(), rels);
      return {
        fileName,
        xmlString: xmlFragment.toString({ prettyPrint: true })
      };
    });
    return relationshipXMLStrings;
  }
  createNumbering(type, properties, vNode) {
    this.lastNumberingId += 1;
    const extractStyling = (props) => {
      const styling = {};
      const styleProps = props?.style;
      if (styleProps) {
        if (styleProps["font-family"] || styleProps.fontFamily) {
          styling.fontFamily = styleProps["font-family"] || styleProps.fontFamily;
        }
        if (styleProps["font-size"] || styleProps.fontSize) {
          styling.fontSize = styleProps["font-size"] || styleProps.fontSize;
        }
        if (styleProps["font-weight"]) {
          styling.fontWeight = styleProps["font-weight"];
        }
        if (styleProps["font-style"]) {
          styling.fontStyle = styleProps["font-style"];
        }
        if (styleProps.color) {
          styling.color = styleProps.color;
        }
      }
      const classAttr = props?.className || props?.class || props?.attributes?.class;
      if (classAttr && this.cssClassStyles) {
        const classNames = classAttr.toString().trim().split(/\s+/);
        for (const className of classNames) {
          const classStyles = this.cssClassStyles[className];
          if (classStyles) {
            if (!styling.fontFamily && classStyles["font-family"]) {
              styling.fontFamily = classStyles["font-family"];
            }
            if (!styling.fontSize && classStyles["font-size"]) {
              styling.fontSize = classStyles["font-size"];
            }
            if (!styling.fontWeight && classStyles["font-weight"]) {
              styling.fontWeight = classStyles["font-weight"];
            }
            if (!styling.fontStyle && classStyles["font-style"]) {
              styling.fontStyle = classStyles["font-style"];
            }
            if (!styling.color && classStyles.color) {
              styling.color = classStyles.color;
            }
          }
        }
      }
      if (this.cssClassStyles && this.cssClassStyles.__element_body) {
        const bodyStyles = this.cssClassStyles.__element_body;
        if (!styling.fontFamily && bodyStyles["font-family"]) {
          styling.fontFamily = bodyStyles["font-family"];
        }
        if (!styling.fontSize && bodyStyles["font-size"]) {
          styling.fontSize = bodyStyles["font-size"];
        }
        if (!styling.fontWeight && bodyStyles["font-weight"]) {
          styling.fontWeight = bodyStyles["font-weight"];
        }
        if (!styling.fontStyle && bodyStyles["font-style"]) {
          styling.fontStyle = bodyStyles["font-style"];
        }
        if (!styling.color && bodyStyles.color) {
          styling.color = bodyStyles.color;
        }
      }
      if (this.cssClassStyles && this.cssClassStyles["__element_*"]) {
        const universalStyles = this.cssClassStyles["__element_*"];
        if (!styling.fontFamily && universalStyles["font-family"]) {
          styling.fontFamily = universalStyles["font-family"];
        }
        if (!styling.fontSize && universalStyles["font-size"]) {
          styling.fontSize = universalStyles["font-size"];
        }
        if (!styling.fontWeight && universalStyles["font-weight"]) {
          styling.fontWeight = universalStyles["font-weight"];
        }
        if (!styling.fontStyle && universalStyles["font-style"]) {
          styling.fontStyle = universalStyles["font-style"];
        }
        if (!styling.color && universalStyles.color) {
          styling.color = universalStyles.color;
        }
      }
      return styling;
    };
    const propsWithStyle = properties;
    let resolvedStyling = extractStyling(propsWithStyle);
    if (Object.keys(resolvedStyling).length === 0 && vNode?.children) {
      for (const child of vNode.children) {
        if (child.tagName === "li") {
          const childProps = child.properties;
          resolvedStyling = extractStyling(childProps);
          if (Object.keys(resolvedStyling).length > 0) {
            break;
          }
        }
      }
    }
    this.numberingObjects.push({
      numberingId: this.lastNumberingId,
      type,
      properties: {
        ...properties,
        resolvedStyling
      }
    });
    return this.lastNumberingId;
  }
  createFont(fontFamily) {
    const fontTableObject = fontFamilyToTableObject(fontFamily, this.font);
    this.fontTableObjects.push(fontTableObject);
    return fontTableObject.fontName || "";
  }
  createMediaFile(srcString) {
    const fileData = extractBase64Data(srcString);
    if (!fileData) {
      return null;
    }
    const fileExtension = fileData.extension === "octet-stream" ? "png" : fileData.extension;
    const contentHash = sha1(fileData.base64Content);
    const fileNameWithExtension = `image-${contentHash}.${fileExtension}`;
    this.lastMediaId += 1;
    return {
      id: this.lastMediaId,
      fileContent: fileData.base64Content,
      fileNameWithExtension
    };
  }
  createDocumentRelationships(fileName = "document", type, target, targetMode = "External") {
    let relationshipObject = this.relationships.find((relationship) => relationship.fileName === fileName);
    let lastRelsId = 1;
    if (relationshipObject) {
      lastRelsId = relationshipObject.lastRelsId + 1;
      relationshipObject.lastRelsId = lastRelsId;
    } else {
      relationshipObject = { fileName, lastRelsId, rels: [] };
      this.relationships.push(relationshipObject);
    }
    let relationshipType;
    switch (type) {
      case hyperlinkType:
        relationshipType = namespaces_default.hyperlinks;
        break;
      case imageType:
        relationshipType = namespaces_default.images;
        break;
      case headerType:
        relationshipType = namespaces_default.headers;
        break;
      case footerType:
        relationshipType = namespaces_default.footers;
        break;
      case themeType:
        relationshipType = namespaces_default.themes;
        break;
      default:
        break;
    }
    relationshipObject.rels.push({
      relationshipId: lastRelsId,
      type: relationshipType || "",
      target,
      targetMode
    });
    return lastRelsId;
  }
  generateHeaderXML(vTree) {
    return this.generateSectionXML(vTree, "header");
  }
  generateFooterXML(vTree) {
    return this.generateSectionXML(vTree, "footer");
  }
}

// src/html-to-docx.ts
var convertHTML2 = import_html_to_vdom2.default({
  VNode: import_vnode5.default,
  VText: import_vtext3.default
});
function mergeOptions(options, patch) {
  return { ...options, ...patch };
}
function fixupFontSize2(fontSize) {
  let normalizedFontSize;
  if (pointRegex.test(fontSize)) {
    const matchedParts = fontSize.match(pointRegex);
    normalizedFontSize = pointToHIP(Number(matchedParts?.[1]));
  } else if (fontSize) {
    normalizedFontSize = Number(fontSize);
  } else {
    normalizedFontSize = undefined;
  }
  return normalizedFontSize;
}
function normalizeUnits(dimensioningObject, defaultDimensionsProperty) {
  const normalizedUnitResult = {};
  if (typeof dimensioningObject === "object" && dimensioningObject !== null) {
    Object.keys(dimensioningObject).forEach((key) => {
      if (pixelRegex.test(String(dimensioningObject[key]))) {
        const matchedParts = String(dimensioningObject[key]).match(pixelRegex);
        normalizedUnitResult[key] = pixelToTWIP(Number(matchedParts?.[1]));
      } else if (cmRegex.test(String(dimensioningObject[key]))) {
        const matchedParts = String(dimensioningObject[key]).match(cmRegex);
        normalizedUnitResult[key] = cmToTWIP(Number(matchedParts?.[1]));
      } else if (inchRegex.test(String(dimensioningObject[key]))) {
        const matchedParts = String(dimensioningObject[key]).match(inchRegex);
        normalizedUnitResult[key] = inchToTWIP(Number(matchedParts?.[1]));
      } else if (dimensioningObject[key]) {
        normalizedUnitResult[key] = dimensioningObject[key];
      } else {
        normalizedUnitResult[key] = defaultDimensionsProperty[key];
      }
    });
    return normalizedUnitResult;
  } else {
    return null;
  }
}
function normalizeDocumentOptions(documentOptions) {
  const normalizedDocumentOptions = {
    ...documentOptions
  };
  Object.keys(documentOptions).forEach((key) => {
    switch (key) {
      case "pageSize":
      case "margins":
        normalizedDocumentOptions.margins = normalizeUnits(documentOptions.margins, defaultDocumentOptions.margins);
        break;
      case "fontSize":
      case "complexScriptFontSize":
        normalizedDocumentOptions.complexScriptFontSize = fixupFontSize2(String(documentOptions.complexScriptFontSize));
        break;
      default:
        break;
    }
  });
  return normalizedDocumentOptions;
}
async function addFilesToContainer(zip, htmlString, suppliedDocumentOptions, headerHTMLString, footerHTMLString) {
  const normalizedDocumentOptions = normalizeDocumentOptions(suppliedDocumentOptions);
  const documentOptions = mergeOptions(defaultDocumentOptions, normalizedDocumentOptions);
  if (documentOptions.header && !headerHTMLString) {
    headerHTMLString = defaultHTMLString;
  }
  if (documentOptions.footer && !footerHTMLString) {
    footerHTMLString = defaultHTMLString;
  }
  if (documentOptions.decodeUnicode) {
    headerHTMLString = decode(headerHTMLString);
    htmlString = decode(htmlString);
    footerHTMLString = decode(footerHTMLString);
  }
  headerHTMLString = sanitizeHtml(headerHTMLString);
  htmlString = sanitizeHtml(htmlString);
  footerHTMLString = sanitizeHtml(footerHTMLString);
  const docxDocument = new DocxDocument({
    ...documentOptions,
    zip,
    htmlString,
    orientation: documentOptions.orientation || "portrait",
    table: documentOptions.table || { row: { cantSplit: false } },
    numbering: documentOptions.numbering || { defaultOrderedListStyleType: "decimal" }
  });
  docxDocument.documentXML = await renderDocumentFile(docxDocument);
  zip.folder(relsFolderName)?.file(".rels", import_xmlbuilder24.create({ encoding: "UTF-8", standalone: true }, rels_default).toString({ prettyPrint: true }), { createFolders: false });
  zip.folder("docProps")?.file("core.xml", docxDocument.generateCoreXML(), {
    createFolders: false
  });
  if (docxDocument.header && headerHTMLString) {
    const vTree = convertHTML2(headerHTMLString);
    docxDocument.relationshipFilename = headerFileName;
    const { headerId, headerXML } = await docxDocument.generateHeaderXML(vTree);
    docxDocument.relationshipFilename = documentFileName;
    const fileNameWithExt = `${headerType}${headerId}.xml`;
    const relationshipId = docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, headerType, fileNameWithExt, internalRelationship);
    zip.folder(wordFolder)?.file(fileNameWithExt, headerXML.toString({ prettyPrint: true }), {
      createFolders: false
    });
    docxDocument.headerObjects.push({
      headerId,
      relationshipId,
      type: docxDocument.headerType
    });
  }
  if (docxDocument.footer && footerHTMLString) {
    const vTree = convertHTML2(footerHTMLString);
    docxDocument.relationshipFilename = footerFileName;
    const { footerId, footerXML } = await docxDocument.generateFooterXML(vTree);
    docxDocument.relationshipFilename = documentFileName;
    const fileNameWithExt = `${footerType}${footerId}.xml`;
    const relationshipId = docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, footerType, fileNameWithExt, internalRelationship);
    zip.folder(wordFolder)?.file(fileNameWithExt, footerXML.toString({ prettyPrint: true }), {
      createFolders: false
    });
    docxDocument.footerObjects.push({
      footerId,
      relationshipId,
      type: docxDocument.footerType
    });
  }
  const themeFileNameWithExt = `${themeFileName}.xml`;
  docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, themeType, `${themeFolder}/${themeFileNameWithExt}`, internalRelationship);
  zip.folder(wordFolder)?.folder(themeFolder)?.file(themeFileNameWithExt, docxDocument.generateThemeXML(), {
    createFolders: false
  });
  zip.folder(wordFolder)?.file("document.xml", docxDocument.generateDocumentXML(), {
    createFolders: false
  })?.file("fontTable.xml", docxDocument.generateFontTableXML(), {
    createFolders: false
  })?.file("styles.xml", docxDocument.generateStylesXML(), {
    createFolders: false
  })?.file("numbering.xml", docxDocument.generateNumberingXML(), {
    createFolders: false
  })?.file("settings.xml", docxDocument.generateSettingsXML(), {
    createFolders: false
  })?.file("webSettings.xml", docxDocument.generateWebSettingsXML(), {
    createFolders: false
  });
  const relationshipXMLs = docxDocument.generateRelsXML();
  if (relationshipXMLs && Array.isArray(relationshipXMLs)) {
    relationshipXMLs.forEach(({ fileName, xmlString }) => {
      zip.folder(wordFolder)?.folder(relsFolderName)?.file(`${fileName}.xml.rels`, xmlString, {
        createFolders: false
      });
    });
  }
  zip.file("[Content_Types].xml", docxDocument.generateContentTypesXML(), {
    createFolders: false
  });
  return zip;
}

// index.ts
function minifyHTMLString(htmlString) {
  const preContentMap = new Map;
  let preIndex = 0;
  const protectedHTMLString = htmlString.replace(/<pre(\s[^>]*)?>([^]*?)<\/pre>/gi, (match, attributes, content) => {
    const placeholder = `__PRE_PLACEHOLDER_${preIndex++}__`;
    preContentMap.set(placeholder, content);
    return `<pre${attributes || ""}>${placeholder}</pre>`;
  });
  let minifiedHTMLString = protectedHTMLString.replace(/\n/g, " ").replace(/\r/g, " ").replace(/\r\n/g, " ").replace(/[\t]+</g, "<").replace(/>[\t ]+$/g, ">");
  minifiedHTMLString = minifiedHTMLString.replace(/<!--.*?-->/g, "");
  minifiedHTMLString = minifiedHTMLString.replace(/>\s+</g, ">__SPACE__<");
  const inlineElements = [
    "a",
    "abbr",
    "acronym",
    "b",
    "bdo",
    "big",
    "br",
    "button",
    "cite",
    "code",
    "dfn",
    "em",
    "i",
    "img",
    "input",
    "kbd",
    "label",
    "map",
    "object",
    "q",
    "samp",
    "script",
    "select",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "textarea",
    "tt",
    "var",
    "u",
    "ins",
    "del",
    "s",
    "strike",
    "mark"
  ];
  const inlinePattern = new RegExp(`</(${inlineElements.join("|")})>__SPACE__<(${inlineElements.join("|")})(\\s[^>]*)?>`, "gi");
  minifiedHTMLString = minifiedHTMLString.replace(inlinePattern, "</$1> <$2$3>");
  minifiedHTMLString = minifiedHTMLString.replace(/__SPACE__/g, "");
  preContentMap.forEach((originalContent, placeholder) => {
    minifiedHTMLString = minifiedHTMLString.replace(placeholder, originalContent);
  });
  return minifiedHTMLString;
}
async function generateContainer(htmlString, headerHTMLString, documentOptions, footerHTMLString) {
  const zip = new import_jszip.default;
  await addFilesToContainer(zip, htmlString ? minifyHTMLString(htmlString) : "", documentOptions, headerHTMLString ? minifyHTMLString(headerHTMLString) : "", footerHTMLString ? minifyHTMLString(footerHTMLString) : "");
  const buffer = await zip.generateAsync({ type: "arraybuffer" });
  if (Object.prototype.hasOwnProperty.call(global, "Buffer")) {
    return Buffer.from(new Uint8Array(buffer));
  }
  if (Object.prototype.hasOwnProperty.call(global, "Blob")) {
    return new Blob([buffer], {
      type: "application/" + "vnd.openxmlformats-officedocument.wordprocessingml.document"
    });
  }
  throw new Error("Add blob support using a polyfill. " + "E.g. https://github.com/bjornstar/blob-polyfill");
}
export {
  generateContainer as default
};
