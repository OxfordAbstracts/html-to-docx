import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports, module) => {
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module.exports = { nextTick };
  } else {
    module.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports, module) => {
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/jszip/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === undefined;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = __require("buffer").Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util = __require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
      var obj = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj;
    };
  }
});

// node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS((exports, module) => {
  module.exports = __require("util").deprecate;
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var debugUtil = __require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/jszip/node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
  }
});

// node_modules/jszip/lib/support.js
var require_support = __commonJS((exports) => {
  exports.base64 = true;
  exports.array = true;
  exports.string = true;
  exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  exports.nodebuffer = typeof Buffer !== "undefined";
  exports.uint8array = typeof Uint8Array !== "undefined";
  if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
  } else {
    buffer = new ArrayBuffer(0);
    try {
      exports.blob = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e) {
      try {
        Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        builder = new Builder;
        builder.append(buffer);
        exports.blob = builder.getBlob("application/zip").size === 0;
      } catch (e2) {
        exports.blob = false;
      }
    }
  }
  var buffer;
  var Builder;
  var builder;
  try {
    exports.nodestream = !!require_readable().Readable;
  } catch (e) {
    exports.nodestream = false;
  }
});

// node_modules/jszip/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var utils = require_utils();
  var support = require_support();
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;
    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
      remainingBytes = len - i;
      if (!isArray) {
        chr1 = input.charCodeAt(i++);
        chr2 = i < len ? input.charCodeAt(i++) : 0;
        chr3 = i < len ? input.charCodeAt(i++) : 0;
      } else {
        chr1 = input[i++];
        chr2 = i < len ? input[i++] : 0;
        chr3 = i < len ? input[i++] : 0;
      }
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
      enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
      output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }
    return output.join("");
  };
  exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;
    var dataUrlPrefix = "data:";
    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
      throw new Error("Invalid base64 input, it looks like a data url.");
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (totalLength % 1 !== 0) {
      throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
      output = new Uint8Array(totalLength | 0);
    } else {
      output = new Array(totalLength | 0);
    }
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output[resultIndex++] = chr1;
      if (enc3 !== 64) {
        output[resultIndex++] = chr2;
      }
      if (enc4 !== 64) {
        output[resultIndex++] = chr3;
      }
    }
    return output;
  };
});

// node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS((exports, module) => {
  module.exports = {
    isNode: typeof Buffer !== "undefined",
    newBufferFrom: function(data, encoding) {
      if (Buffer.from && Buffer.from !== Uint8Array.from) {
        return Buffer.from(data, encoding);
      } else {
        if (typeof data === "number") {
          throw new Error('The "data" argument must not be a number');
        }
        return new Buffer(data, encoding);
      }
    },
    allocBuffer: function(size) {
      if (Buffer.alloc) {
        return Buffer.alloc(size);
      } else {
        var buf = new Buffer(size);
        buf.fill(0);
        return buf;
      }
    },
    isBuffer: function(b) {
      return Buffer.isBuffer(b);
    },
    isStream: function(obj) {
      return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
  };
});

// node_modules/immediate/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var Mutation = global.MutationObserver || global.WebKitMutationObserver;
  var scheduleDrain;
  if (false) {
  } else {
    scheduleDrain = function() {
      process.nextTick(nextTick);
    };
  }
  var called;
  var observer;
  var element;
  var channel;
  var draining;
  var queue = [];
  function nextTick() {
    draining = true;
    var i, oldQueue;
    var len = queue.length;
    while (len) {
      oldQueue = queue;
      queue = [];
      i = -1;
      while (++i < len) {
        oldQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  module.exports = immediate;
  function immediate(task) {
    if (queue.push(task) === 1 && !draining) {
      scheduleDrain();
    }
  }
});

// node_modules/lie/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var immediate = require_lib();
  function INTERNAL() {
  }
  var handlers = {};
  var REJECTED = ["REJECTED"];
  var FULFILLED = ["FULFILLED"];
  var PENDING = ["PENDING"];
  if (true) {
    UNHANDLED = ["UNHANDLED"];
  }
  var UNHANDLED;
  module.exports = Promise2;
  function Promise2(resolver) {
    if (typeof resolver !== "function") {
      throw new TypeError("resolver must be a function");
    }
    this.state = PENDING;
    this.queue = [];
    this.outcome = undefined;
    if (true) {
      this.handled = UNHANDLED;
    }
    if (resolver !== INTERNAL) {
      safelyResolveThenable(this, resolver);
    }
  }
  Promise2.prototype.finally = function(callback) {
    if (typeof callback !== "function") {
      return this;
    }
    var p = this.constructor;
    return this.then(resolve2, reject2);
    function resolve2(value) {
      function yes() {
        return value;
      }
      return p.resolve(callback()).then(yes);
    }
    function reject2(reason) {
      function no() {
        throw reason;
      }
      return p.resolve(callback()).then(no);
    }
  };
  Promise2.prototype.catch = function(onRejected) {
    return this.then(null, onRejected);
  };
  Promise2.prototype.then = function(onFulfilled, onRejected) {
    if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
      return this;
    }
    var promise = new this.constructor(INTERNAL);
    if (true) {
      if (this.handled === UNHANDLED) {
        this.handled = null;
      }
    }
    if (this.state !== PENDING) {
      var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
      unwrap(promise, resolver, this.outcome);
    } else {
      this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
    }
    return promise;
  };
  function QueueItem(promise, onFulfilled, onRejected) {
    this.promise = promise;
    if (typeof onFulfilled === "function") {
      this.onFulfilled = onFulfilled;
      this.callFulfilled = this.otherCallFulfilled;
    }
    if (typeof onRejected === "function") {
      this.onRejected = onRejected;
      this.callRejected = this.otherCallRejected;
    }
  }
  QueueItem.prototype.callFulfilled = function(value) {
    handlers.resolve(this.promise, value);
  };
  QueueItem.prototype.otherCallFulfilled = function(value) {
    unwrap(this.promise, this.onFulfilled, value);
  };
  QueueItem.prototype.callRejected = function(value) {
    handlers.reject(this.promise, value);
  };
  QueueItem.prototype.otherCallRejected = function(value) {
    unwrap(this.promise, this.onRejected, value);
  };
  function unwrap(promise, func, value) {
    immediate(function() {
      var returnValue;
      try {
        returnValue = func(value);
      } catch (e) {
        return handlers.reject(promise, e);
      }
      if (returnValue === promise) {
        handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
      } else {
        handlers.resolve(promise, returnValue);
      }
    });
  }
  handlers.resolve = function(self2, value) {
    var result = tryCatch(getThen, value);
    if (result.status === "error") {
      return handlers.reject(self2, result.value);
    }
    var thenable = result.value;
    if (thenable) {
      safelyResolveThenable(self2, thenable);
    } else {
      self2.state = FULFILLED;
      self2.outcome = value;
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callFulfilled(value);
      }
    }
    return self2;
  };
  handlers.reject = function(self2, error) {
    self2.state = REJECTED;
    self2.outcome = error;
    if (true) {
      if (self2.handled === UNHANDLED) {
        immediate(function() {
          if (self2.handled === UNHANDLED) {
            process.emit("unhandledRejection", error, self2);
          }
        });
      }
    }
    var i = -1;
    var len = self2.queue.length;
    while (++i < len) {
      self2.queue[i].callRejected(error);
    }
    return self2;
  };
  function getThen(obj) {
    var then = obj && obj.then;
    if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
      return function appyThen() {
        then.apply(obj, arguments);
      };
    }
  }
  function safelyResolveThenable(self2, thenable) {
    var called = false;
    function onError(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.reject(self2, value);
    }
    function onSuccess(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.resolve(self2, value);
    }
    function tryToUnwrap() {
      thenable(onSuccess, onError);
    }
    var result = tryCatch(tryToUnwrap);
    if (result.status === "error") {
      onError(result.value);
    }
  }
  function tryCatch(func, value) {
    var out = {};
    try {
      out.value = func(value);
      out.status = "success";
    } catch (e) {
      out.status = "error";
      out.value = e;
    }
    return out;
  }
  Promise2.resolve = resolve;
  function resolve(value) {
    if (value instanceof this) {
      return value;
    }
    return handlers.resolve(new this(INTERNAL), value);
  }
  Promise2.reject = reject;
  function reject(reason) {
    var promise = new this(INTERNAL);
    return handlers.reject(promise, reason);
  }
  Promise2.all = all;
  function all(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var values = new Array(len);
    var resolved = 0;
    var i = -1;
    var promise = new this(INTERNAL);
    while (++i < len) {
      allResolver(iterable[i], i);
    }
    return promise;
    function allResolver(value, i2) {
      self2.resolve(value).then(resolveFromAll, function(error) {
        if (!called) {
          called = true;
          handlers.reject(promise, error);
        }
      });
      function resolveFromAll(outValue) {
        values[i2] = outValue;
        if (++resolved === len && !called) {
          called = true;
          handlers.resolve(promise, values);
        }
      }
    }
  }
  Promise2.race = race;
  function race(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var i = -1;
    var promise = new this(INTERNAL);
    while (++i < len) {
      resolver(iterable[i]);
    }
    return promise;
    function resolver(value) {
      self2.resolve(value).then(function(response) {
        if (!called) {
          called = true;
          handlers.resolve(promise, response);
        }
      }, function(error) {
        if (!called) {
          called = true;
          handlers.reject(promise, error);
        }
      });
    }
  }
});

// node_modules/jszip/lib/external.js
var require_external = __commonJS((exports, module) => {
  var ES6Promise = null;
  if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
  } else {
    ES6Promise = require_lib2();
  }
  module.exports = {
    Promise: ES6Promise
  };
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  (function(global2, undefined2) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel;
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
});

// node_modules/jszip/lib/utils.js
var require_utils = __commonJS((exports) => {
  var support = require_support();
  var base64 = require_base64();
  var nodejsUtils = require_nodejsUtils();
  var external = require_external();
  require_setImmediate();
  function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
  }
  exports.newBlob = function(part, type) {
    exports.checkSupport("blob");
    try {
      return new Blob([part], {
        type
      });
    } catch (e) {
      try {
        var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        var builder = new Builder;
        builder.append(part);
        return builder.getBlob(type);
      } catch (e2) {
        throw new Error("Bug : can't construct the Blob.");
      }
    }
  };
  function identity(input) {
    return input;
  }
  function stringToArrayLike(str, array) {
    for (var i = 0;i < str.length; ++i) {
      array[i] = str.charCodeAt(i) & 255;
    }
    return array;
  }
  var arrayToStringHelper = {
    stringifyByChunk: function(array, type, chunk) {
      var result = [], k = 0, len = array.length;
      if (len <= chunk) {
        return String.fromCharCode.apply(null, array);
      }
      while (k < len) {
        if (type === "array" || type === "nodebuffer") {
          result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
        } else {
          result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
        }
        k += chunk;
      }
      return result.join("");
    },
    stringifyByChar: function(array) {
      var resultStr = "";
      for (var i = 0;i < array.length; i++) {
        resultStr += String.fromCharCode(array[i]);
      }
      return resultStr;
    },
    applyCanBeUsed: {
      uint8array: function() {
        try {
          return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (e) {
          return false;
        }
      }(),
      nodebuffer: function() {
        try {
          return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
        } catch (e) {
          return false;
        }
      }()
    }
  };
  function arrayLikeToString(array) {
    var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;
    if (type === "uint8array") {
      canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
      canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }
    if (canUseApply) {
      while (chunk > 1) {
        try {
          return arrayToStringHelper.stringifyByChunk(array, type, chunk);
        } catch (e) {
          chunk = Math.floor(chunk / 2);
        }
      }
    }
    return arrayToStringHelper.stringifyByChar(array);
  }
  exports.applyFromCharCode = arrayLikeToString;
  function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0;i < arrayFrom.length; i++) {
      arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
  }
  var transform = {};
  transform["string"] = {
    string: identity,
    array: function(input) {
      return stringToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return transform["string"]["uint8array"](input).buffer;
    },
    uint8array: function(input) {
      return stringToArrayLike(input, new Uint8Array(input.length));
    },
    nodebuffer: function(input) {
      return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
  };
  transform["array"] = {
    string: arrayLikeToString,
    array: identity,
    arraybuffer: function(input) {
      return new Uint8Array(input).buffer;
    },
    uint8array: function(input) {
      return new Uint8Array(input);
    },
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(input);
    }
  };
  transform["arraybuffer"] = {
    string: function(input) {
      return arrayLikeToString(new Uint8Array(input));
    },
    array: function(input) {
      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    arraybuffer: identity,
    uint8array: function(input) {
      return new Uint8Array(input);
    },
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
  };
  transform["uint8array"] = {
    string: arrayLikeToString,
    array: function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return input.buffer;
    },
    uint8array: identity,
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(input);
    }
  };
  transform["nodebuffer"] = {
    string: arrayLikeToString,
    array: function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    uint8array: function(input) {
      return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    nodebuffer: identity
  };
  exports.transformTo = function(outputType, input) {
    if (!input) {
      input = "";
    }
    if (!outputType) {
      return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
  };
  exports.resolve = function(path) {
    var parts = path.split("/");
    var result = [];
    for (var index = 0;index < parts.length; index++) {
      var part = parts[index];
      if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
        continue;
      } else if (part === "..") {
        result.pop();
      } else {
        result.push(part);
      }
    }
    return result.join("/");
  };
  exports.getTypeOf = function(input) {
    if (typeof input === "string") {
      return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
      return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
      return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
      return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
      return "arraybuffer";
    }
  };
  exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
      throw new Error(type + " is not supported by this platform");
    }
  };
  exports.MAX_VALUE_16BITS = 65535;
  exports.MAX_VALUE_32BITS = -1;
  exports.pretty = function(str) {
    var res = "", code, i;
    for (i = 0;i < (str || "").length; i++) {
      code = str.charCodeAt(i);
      res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
  };
  exports.delay = function(callback, args, self2) {
    setImmediate(function() {
      callback.apply(self2 || null, args || []);
    });
  };
  exports.inherits = function(ctor, superCtor) {
    var Obj = function() {
    };
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj;
  };
  exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0;i < arguments.length; i++) {
      for (attr in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
          result[attr] = arguments[i][attr];
        }
      }
    }
    return result;
  };
  exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
    var promise = external.Promise.resolve(inputData).then(function(data) {
      var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
      if (isBlob && typeof FileReader !== "undefined") {
        return new external.Promise(function(resolve, reject) {
          var reader = new FileReader;
          reader.onload = function(e) {
            resolve(e.target.result);
          };
          reader.onerror = function(e) {
            reject(e.target.error);
          };
          reader.readAsArrayBuffer(data);
        });
      } else {
        return data;
      }
    });
    return promise.then(function(data) {
      var dataType = exports.getTypeOf(data);
      if (!dataType) {
        return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
      }
      if (dataType === "arraybuffer") {
        data = exports.transformTo("uint8array", data);
      } else if (dataType === "string") {
        if (isBase64) {
          data = base64.decode(data);
        } else if (isBinary) {
          if (isOptimizedBinaryString !== true) {
            data = string2binary(data);
          }
        }
      }
      return data;
    });
  };
});

// node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS((exports, module) => {
  function GenericWorker(name) {
    this.name = name || "default";
    this.streamInfo = {};
    this.generatedError = null;
    this.extraStreamInfo = {};
    this.isPaused = true;
    this.isFinished = false;
    this.isLocked = false;
    this._listeners = {
      data: [],
      end: [],
      error: []
    };
    this.previous = null;
  }
  GenericWorker.prototype = {
    push: function(chunk) {
      this.emit("data", chunk);
    },
    end: function() {
      if (this.isFinished) {
        return false;
      }
      this.flush();
      try {
        this.emit("end");
        this.cleanUp();
        this.isFinished = true;
      } catch (e) {
        this.emit("error", e);
      }
      return true;
    },
    error: function(e) {
      if (this.isFinished) {
        return false;
      }
      if (this.isPaused) {
        this.generatedError = e;
      } else {
        this.isFinished = true;
        this.emit("error", e);
        if (this.previous) {
          this.previous.error(e);
        }
        this.cleanUp();
      }
      return true;
    },
    on: function(name, listener) {
      this._listeners[name].push(listener);
      return this;
    },
    cleanUp: function() {
      this.streamInfo = this.generatedError = this.extraStreamInfo = null;
      this._listeners = [];
    },
    emit: function(name, arg) {
      if (this._listeners[name]) {
        for (var i = 0;i < this._listeners[name].length; i++) {
          this._listeners[name][i].call(this, arg);
        }
      }
    },
    pipe: function(next) {
      return next.registerPrevious(this);
    },
    registerPrevious: function(previous) {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.streamInfo = previous.streamInfo;
      this.mergeStreamInfo();
      this.previous = previous;
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.end();
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    },
    pause: function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = true;
      if (this.previous) {
        this.previous.pause();
      }
      return true;
    },
    resume: function() {
      if (!this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = false;
      var withError = false;
      if (this.generatedError) {
        this.error(this.generatedError);
        withError = true;
      }
      if (this.previous) {
        this.previous.resume();
      }
      return !withError;
    },
    flush: function() {
    },
    processChunk: function(chunk) {
      this.push(chunk);
    },
    withStreamInfo: function(key, value) {
      this.extraStreamInfo[key] = value;
      this.mergeStreamInfo();
      return this;
    },
    mergeStreamInfo: function() {
      for (var key in this.extraStreamInfo) {
        if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
          continue;
        }
        this.streamInfo[key] = this.extraStreamInfo[key];
      }
    },
    lock: function() {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.isLocked = true;
      if (this.previous) {
        this.previous.lock();
      }
    },
    toString: function() {
      var me = "Worker " + this.name;
      if (this.previous) {
        return this.previous + " -> " + me;
      } else {
        return me;
      }
    }
  };
  module.exports = GenericWorker;
});

// node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS((exports) => {
  var utils = require_utils();
  var support = require_support();
  var nodejsUtils = require_nodejsUtils();
  var GenericWorker = require_GenericWorker();
  var _utf8len = new Array(256);
  for (i = 0;i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
  }
  var i;
  _utf8len[254] = _utf8len[254] = 1;
  var string2buf = function(str) {
    var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    if (support.uint8array) {
      buf = new Uint8Array(buf_len);
    } else {
      buf = new Array(buf_len);
    }
    for (i2 = 0, m_pos = 0;i2 < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i2++] = c;
      } else if (c < 2048) {
        buf[i2++] = 192 | c >>> 6;
        buf[i2++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i2++] = 224 | c >>> 12;
        buf[i2++] = 128 | c >>> 6 & 63;
        buf[i2++] = 128 | c & 63;
      } else {
        buf[i2++] = 240 | c >>> 18;
        buf[i2++] = 128 | c >>> 12 & 63;
        buf[i2++] = 128 | c >>> 6 & 63;
        buf[i2++] = 128 | c & 63;
      }
    }
    return buf;
  };
  var utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
  var buf2string = function(buf) {
    var i2, out, c, c_len;
    var len = buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i2 = 0;i2 < len; ) {
      c = buf[i2++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len) {
        c = c << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    if (utf16buf.length !== out) {
      if (utf16buf.subarray) {
        utf16buf = utf16buf.subarray(0, out);
      } else {
        utf16buf.length = out;
      }
    }
    return utils.applyFromCharCode(utf16buf);
  };
  exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
      return nodejsUtils.newBufferFrom(str, "utf-8");
    }
    return string2buf(str);
  };
  exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
      return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }
    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
    return buf2string(buf);
  };
  function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  utils.inherits(Utf8DecodeWorker, GenericWorker);
  Utf8DecodeWorker.prototype.processChunk = function(chunk) {
    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: exports.utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker.prototype.flush = function() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: exports.utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  exports.Utf8DecodeWorker = Utf8DecodeWorker;
  function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
  }
  utils.inherits(Utf8EncodeWorker, GenericWorker);
  Utf8EncodeWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: exports.utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  exports.Utf8EncodeWorker = Utf8EncodeWorker;
});

// node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS((exports, module) => {
  var GenericWorker = require_GenericWorker();
  var utils = require_utils();
  function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  utils.inherits(ConvertWorker, GenericWorker);
  ConvertWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: utils.transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  module.exports = ConvertWorker;
});

// node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS((exports, module) => {
  var Readable = require_readable().Readable;
  var utils = require_utils();
  utils.inherits(NodejsStreamOutputAdapter, Readable);
  function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;
    var self2 = this;
    helper.on("data", function(data, meta) {
      if (!self2.push(data)) {
        self2._helper.pause();
      }
      if (updateCb) {
        updateCb(meta);
      }
    }).on("error", function(e) {
      self2.emit("error", e);
    }).on("end", function() {
      self2.push(null);
    });
  }
  NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
  };
  module.exports = NodejsStreamOutputAdapter;
});

// node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS((exports, module) => {
  var utils = require_utils();
  var ConvertWorker = require_ConvertWorker();
  var GenericWorker = require_GenericWorker();
  var base64 = require_base64();
  var support = require_support();
  var external = require_external();
  var NodejsStreamOutputAdapter = null;
  if (support.nodestream) {
    try {
      NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
    } catch (e) {
    }
  }
  function transformZipOutput(type, content, mimeType) {
    switch (type) {
      case "blob":
        return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
      case "base64":
        return base64.encode(content);
      default:
        return utils.transformTo(type, content);
    }
  }
  function concat(type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for (i = 0;i < dataArray.length; i++) {
      totalLength += dataArray[i].length;
    }
    switch (type) {
      case "string":
        return dataArray.join("");
      case "array":
        return Array.prototype.concat.apply([], dataArray);
      case "uint8array":
        res = new Uint8Array(totalLength);
        for (i = 0;i < dataArray.length; i++) {
          res.set(dataArray[i], index);
          index += dataArray[i].length;
        }
        return res;
      case "nodebuffer":
        return Buffer.concat(dataArray);
      default:
        throw new Error("concat : unsupported type '" + type + "'");
    }
  }
  function accumulate(helper, updateCallback) {
    return new external.Promise(function(resolve, reject) {
      var dataArray = [];
      var { _internalType: chunkType, _outputType: resultType, _mimeType: mimeType } = helper;
      helper.on("data", function(data, meta) {
        dataArray.push(data);
        if (updateCallback) {
          updateCallback(meta);
        }
      }).on("error", function(err) {
        dataArray = [];
        reject(err);
      }).on("end", function() {
        try {
          var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
          resolve(result);
        } catch (e) {
          reject(e);
        }
        dataArray = [];
      }).resume();
    });
  }
  function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
      case "blob":
      case "arraybuffer":
        internalType = "uint8array";
        break;
      case "base64":
        internalType = "string";
        break;
    }
    try {
      this._internalType = internalType;
      this._outputType = outputType;
      this._mimeType = mimeType;
      utils.checkSupport(internalType);
      this._worker = worker.pipe(new ConvertWorker(internalType));
      worker.lock();
    } catch (e) {
      this._worker = new GenericWorker("error");
      this._worker.error(e);
    }
  }
  StreamHelper.prototype = {
    accumulate: function(updateCb) {
      return accumulate(this, updateCb);
    },
    on: function(evt, fn) {
      var self2 = this;
      if (evt === "data") {
        this._worker.on(evt, function(chunk) {
          fn.call(self2, chunk.data, chunk.meta);
        });
      } else {
        this._worker.on(evt, function() {
          utils.delay(fn, arguments, self2);
        });
      }
      return this;
    },
    resume: function() {
      utils.delay(this._worker.resume, [], this._worker);
      return this;
    },
    pause: function() {
      this._worker.pause();
      return this;
    },
    toNodejsStream: function(updateCb) {
      utils.checkSupport("nodestream");
      if (this._outputType !== "nodebuffer") {
        throw new Error(this._outputType + " is not supported by this method");
      }
      return new NodejsStreamOutputAdapter(this, {
        objectMode: this._outputType !== "nodebuffer"
      }, updateCb);
    }
  };
  module.exports = StreamHelper;
});

// node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS((exports) => {
  exports.base64 = false;
  exports.binary = false;
  exports.dir = false;
  exports.createFolders = true;
  exports.date = null;
  exports.compression = null;
  exports.compressionOptions = null;
  exports.comment = null;
  exports.unixPermissions = null;
  exports.dosPermissions = null;
});

// node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var DEFAULT_BLOCK_SIZE = 16 * 1024;
  function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self2 = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self2.dataIsReady = true;
      self2.data = data;
      self2.max = data && data.length || 0;
      self2.type = utils.getTypeOf(data);
      if (!self2.isPaused) {
        self2._tickAndRepeat();
      }
    }, function(e) {
      self2.error(e);
    });
  }
  utils.inherits(DataWorker, GenericWorker);
  DataWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      utils.delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker.prototype._tick = function() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
        case "nodebuffer":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  module.exports = DataWorker;
});

// node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  var utils = require_utils();
  function makeTable() {
    var c, table = [];
    for (var n = 0;n < 256; n++) {
      c = n;
      for (var k = 0;k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i = pos;i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i = pos;i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
    }
    return crc ^ -1;
  }
  module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
      return 0;
    }
    var isArray = utils.getTypeOf(input) !== "string";
    if (isArray) {
      return crc32(crc | 0, input, input.length, 0);
    } else {
      return crc32str(crc | 0, input, input.length, 0);
    }
  };
});

// node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS((exports, module) => {
  var GenericWorker = require_GenericWorker();
  var crc32 = require_crc32();
  var utils = require_utils();
  function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  utils.inherits(Crc32Probe, GenericWorker);
  Crc32Probe.prototype.processChunk = function(chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  module.exports = Crc32Probe;
});

// node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  utils.inherits(DataLengthProbe, GenericWorker);
  DataLengthProbe.prototype.processChunk = function(chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
  };
  module.exports = DataLengthProbe;
});

// node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS((exports, module) => {
  var external = require_external();
  var DataWorker = require_DataWorker();
  var Crc32Probe = require_Crc32Probe();
  var DataLengthProbe = require_DataLengthProbe();
  function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
  }
  CompressedObject.prototype = {
    getContentWorker: function() {
      var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
      var that = this;
      worker.on("end", function() {
        if (this.streamInfo["data_length"] !== that.uncompressedSize) {
          throw new Error("Bug : uncompressed data size mismatch");
        }
      });
      return worker;
    },
    getCompressedWorker: function() {
      return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
  };
  CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
  };
  module.exports = CompressedObject;
});

// node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS((exports, module) => {
  var StreamHelper = require_StreamHelper();
  var DataWorker = require_DataWorker();
  var utf8 = require_utf8();
  var CompressedObject = require_compressedObject();
  var GenericWorker = require_GenericWorker();
  var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;
    this._data = data;
    this._dataBinary = options.binary;
    this.options = {
      compression: options.compression,
      compressionOptions: options.compressionOptions
    };
  };
  ZipObject.prototype = {
    internalStream: function(type) {
      var result = null, outputType = "string";
      try {
        if (!type) {
          throw new Error("No output type specified.");
        }
        outputType = type.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
          outputType = "string";
        }
        result = this._decompressWorker();
        var isUnicodeString = !this._dataBinary;
        if (isUnicodeString && !askUnicodeString) {
          result = result.pipe(new utf8.Utf8EncodeWorker);
        }
        if (!isUnicodeString && askUnicodeString) {
          result = result.pipe(new utf8.Utf8DecodeWorker);
        }
      } catch (e) {
        result = new GenericWorker("error");
        result.error(e);
      }
      return new StreamHelper(result, outputType, "");
    },
    async: function(type, onUpdate) {
      return this.internalStream(type).accumulate(onUpdate);
    },
    nodeStream: function(type, onUpdate) {
      return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },
    _compressWorker: function(compression, compressionOptions) {
      if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
        return this._data.getCompressedWorker();
      } else {
        var result = this._decompressWorker();
        if (!this._dataBinary) {
          result = result.pipe(new utf8.Utf8EncodeWorker);
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
      }
    },
    _decompressWorker: function() {
      if (this._data instanceof CompressedObject) {
        return this._data.getContentWorker();
      } else if (this._data instanceof GenericWorker) {
        return this._data;
      } else {
        return new DataWorker(this._data);
      }
    }
  };
  var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
  var removedFn = function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  };
  for (i = 0;i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
  }
  var i;
  module.exports = ZipObject;
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS((exports) => {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0;i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      var i, l, len, pos, chunk, result;
      len = 0;
      for (i = 0, l = chunks.length;i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length;i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i = 0;i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS((exports) => {
  var utils = require_common();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  function send_code(s, c, tree) {
    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0;bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1;h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length;bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1;bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0;n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0;code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0;n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0;code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0;n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (;code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n = 0;n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0;bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0;n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s) {
    var n;
    for (n = 0;n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0;n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0;n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  function smaller(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  function compress_block(s, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0;n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1;n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0;rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0;n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32;n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
  }
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  function _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  exports._tr_init = _tr_init;
  exports._tr_stored_block = _tr_stored_block;
  exports._tr_flush_block = _tr_flush_block;
  exports._tr_tally = _tr_tally;
  exports._tr_align = _tr_align;
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS((exports, module) => {
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  module.exports = adler32;
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS((exports, module) => {
  function makeTable() {
    var c, table = [];
    for (var n = 0;n < 256; n++) {
      c = n;
      for (var k = 0;k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i = pos;i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  module.exports = crc32;
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS((exports, module) => {
  module.exports = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS((exports) => {
  var utils = require_common();
  var trees = require_trees();
  var adler32 = require_adler32();
  var crc32 = require_crc322();
  var msg = require_messages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  function flush_block_only(s, last) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (;; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;
    for (;; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s, flush) {
    var bflush;
    for (;; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees._tr_init(s);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState;
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils.Buf8(s.w_size * 2);
    s.head = new utils.Buf16(s.hash_size);
    s.prev = new utils.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils.Buf8(s.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }
  exports.deflateInit = deflateInit;
  exports.deflateInit2 = deflateInit2;
  exports.deflateReset = deflateReset;
  exports.deflateResetKeep = deflateResetKeep;
  exports.deflateSetHeader = deflateSetHeader;
  exports.deflate = deflate;
  exports.deflateEnd = deflateEnd;
  exports.deflateSetDictionary = deflateSetDictionary;
  exports.deflateInfo = "pako deflate (from Nodeca project)";
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS((exports) => {
  var utils = require_common();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils.Buf8(256);
  for (q = 0;q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  var q;
  _utf8len[254] = _utf8len[254] = 1;
  exports.string2buf = function(str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new utils.Buf8(buf_len);
    for (i = 0, m_pos = 0;i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i = 0;i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  exports.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  exports.binstring2buf = function(str) {
    var buf = new utils.Buf8(str.length);
    for (var i = 0, len = buf.length;i < len; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  };
  exports.buf2string = function(buf, max) {
    var i, out, c, c_len;
    var len = max || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i = 0;i < len; ) {
      c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  exports.utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS((exports, module) => {
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module.exports = ZStream;
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS((exports) => {
  var zlib_deflate = require_deflate();
  var utils = require_common();
  var strings = require_strings();
  var msg = require_messages();
  var ZStream = require_zstream();
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate))
      return new Deflate(options);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS((exports, module) => {
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (;; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (;; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS((exports, module) => {
  var utils = require_common();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0;len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0;sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS;max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1;min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1;len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1;len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0;sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (;; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS((exports) => {
  var utils = require_common();
  var adler32 = require_adler32();
  var crc32 = require_crc322();
  var inflate_fast = require_inffast();
  var inflate_table = require_inftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState;
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix;
  var distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (;; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  exports.inflateReset = inflateReset;
  exports.inflateReset2 = inflateReset2;
  exports.inflateResetKeep = inflateResetKeep;
  exports.inflateInit = inflateInit;
  exports.inflateInit2 = inflateInit2;
  exports.inflate = inflate;
  exports.inflateEnd = inflateEnd;
  exports.inflateGetHeader = inflateGetHeader;
  exports.inflateSetDictionary = inflateSetDictionary;
  exports.inflateInfo = "pako inflate (from Nodeca project)";
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS((exports, module) => {
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  module.exports = GZheader;
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS((exports) => {
  var zlib_inflate = require_inflate();
  var utils = require_common();
  var strings = require_strings();
  var c = require_constants();
  var msg = require_messages();
  var ZStream = require_zstream();
  var GZheader = require_gzheader();
  var toString = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate))
      return new Inflate(options);
    this.options = utils.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader;
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.binstring2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
      if (status === c.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c.Z_BUF_ERROR && allowBufError === true) {
        status = c.Z_OK;
        allowBufError = false;
      }
      if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
    if (status === c.Z_STREAM_END) {
      _mode = c.Z_FINISH;
    }
    if (_mode === c.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c.Z_OK;
    }
    if (_mode === c.Z_SYNC_FLUSH) {
      this.onEnd(c.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  }
  exports.Inflate = Inflate;
  exports.inflate = inflate;
  exports.inflateRaw = inflateRaw;
  exports.ungzip = inflate;
});

// node_modules/pako/index.js
var require_pako = __commonJS((exports, module) => {
  var assign = require_common().assign;
  var deflate = require_deflate2();
  var inflate = require_inflate2();
  var constants = require_constants();
  var pako = {};
  assign(pako, deflate, inflate, constants);
  module.exports = pako;
});

// node_modules/jszip/lib/flate.js
var require_flate = __commonJS((exports) => {
  var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var pako = require_pako();
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
  exports.magic = "\b\x00";
  function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  utils.inherits(FlateWorker, GenericWorker);
  FlateWorker.prototype.processChunk = function(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
  };
  FlateWorker.prototype.flush = function() {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker.prototype._createPako = function() {
    this._pako = new pako[this._pakoAction]({
      raw: true,
      level: this._pakoOptions.level || -1
    });
    var self2 = this;
    this._pako.onData = function(data) {
      self2.push({
        data,
        meta: self2.meta
      });
    };
  };
  exports.compressWorker = function(compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
  };
  exports.uncompressWorker = function() {
    return new FlateWorker("Inflate", {});
  };
});

// node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS((exports) => {
  var GenericWorker = require_GenericWorker();
  exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function() {
      return new GenericWorker("STORE compression");
    },
    uncompressWorker: function() {
      return new GenericWorker("STORE decompression");
    }
  };
  exports.DEFLATE = require_flate();
});

// node_modules/jszip/lib/signature.js
var require_signature = __commonJS((exports) => {
  exports.LOCAL_FILE_HEADER = "PK\x03\x04";
  exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
  exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
  exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
  exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
  exports.DATA_DESCRIPTOR = "PK\x07\b";
});

// node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var utf8 = require_utf8();
  var crc32 = require_crc32();
  var signature = require_signature();
  var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0;i < bytes; i++) {
      hex += String.fromCharCode(dec & 255);
      dec = dec >>> 8;
    }
    return hex;
  };
  var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
    var result = unixPermissions;
    if (!unixPermissions) {
      result = isDir ? 16893 : 33204;
    }
    return (result & 65535) << 16;
  };
  var generateDosExternalFileAttr = function(dosPermissions) {
    return (dosPermissions || 0) & 63;
  };
  var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
    var dataInfo = {
      crc32: 0,
      compressedSize: 0,
      uncompressedSize: 0
    };
    if (!streamedContent || streamingEnded) {
      dataInfo.crc32 = streamInfo["crc32"];
      dataInfo.compressedSize = streamInfo["compressedSize"];
      dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
    }
    var bitflag = 0;
    if (streamedContent) {
      bitflag |= 8;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
      bitflag |= 2048;
    }
    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
      extFileAttr |= 16;
    }
    if (platform === "UNIX") {
      versionMadeBy = 798;
      extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
      versionMadeBy = 20;
      extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }
    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;
    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();
    if (useUTF8ForFileName) {
      unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
      extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
    }
    if (useUTF8ForComment) {
      unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;
      extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
    }
    var header = "";
    header += `
\x00`;
    header += decToHex(bitflag, 2);
    header += compression.magic;
    header += decToHex(dosTime, 2);
    header += decToHex(dosDate, 2);
    header += decToHex(dataInfo.crc32, 4);
    header += decToHex(dataInfo.compressedSize, 4);
    header += decToHex(dataInfo.uncompressedSize, 4);
    header += decToHex(encodedFileName.length, 2);
    header += decToHex(extraFields.length, 2);
    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
    var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\x00\x00" + "\x00\x00" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
    return {
      fileRecord,
      dirRecord
    };
  };
  var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));
    dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
    return dirEnd;
  };
  var generateDataDescriptors = function(streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo["crc32"], 4) + decToHex(streamInfo["compressedSize"], 4) + decToHex(streamInfo["uncompressedSize"], 4);
    return descriptor;
  };
  function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment;
    this.zipPlatform = platform;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  utils.inherits(ZipFileWorker, GenericWorker);
  ZipFileWorker.prototype.push = function(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker.prototype.openedSource = function(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker.prototype.closedSource = function(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker.prototype.flush = function() {
    var localDirLength = this.bytesWritten;
    for (var i = 0;i < this.dirRecords.length; i++) {
      this.push({
        data: this.dirRecords[i],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker.prototype.prepareNextSource = function() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker.prototype.registerPrevious = function(previous) {
    this._sources.push(previous);
    var self2 = this;
    previous.on("data", function(chunk) {
      self2.processChunk(chunk);
    });
    previous.on("end", function() {
      self2.closedSource(self2.previous.streamInfo);
      if (self2._sources.length) {
        self2.prepareNextSource();
      } else {
        self2.end();
      }
    });
    previous.on("error", function(e) {
      self2.error(e);
    });
    return this;
  };
  ZipFileWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker.prototype.error = function(e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
      return false;
    }
    for (var i = 0;i < sources.length; i++) {
      try {
        sources[i].error(e);
      } catch (e2) {
      }
    }
    return true;
  };
  ZipFileWorker.prototype.lock = function() {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0;i < sources.length; i++) {
      sources[i].lock();
    }
  };
  module.exports = ZipFileWorker;
});

// node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS((exports) => {
  var compressions = require_compressions();
  var ZipFileWorker = require_ZipFileWorker();
  var getCompression = function(fileCompression, zipCompression) {
    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
      throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
  };
  exports.generateWorker = function(zip, options, comment) {
    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {
      zip.forEach(function(relativePath, file) {
        entriesCount++;
        var compression = getCompression(file.options.compression, options.compression);
        var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
        var { dir, date } = file;
        file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
          name: relativePath,
          dir,
          date,
          comment: file.comment || "",
          unixPermissions: file.unixPermissions,
          dosPermissions: file.dosPermissions
        }).pipe(zipFileWorker);
      });
      zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
      zipFileWorker.error(e);
    }
    return zipFileWorker;
  };
});

// node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
  }
  utils.inherits(NodejsStreamInputAdapter, GenericWorker);
  NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
    var self2 = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function(chunk) {
      self2.push({
        data: chunk,
        meta: {
          percent: 0
        }
      });
    }).on("error", function(e) {
      if (self2.isPaused) {
        this.generatedError = e;
      } else {
        self2.error(e);
      }
    }).on("end", function() {
      if (self2.isPaused) {
        self2._upstreamEnded = true;
      } else {
        self2.end();
      }
    });
  };
  NodejsStreamInputAdapter.prototype.pause = function() {
    if (!GenericWorker.prototype.pause.call(this)) {
      return false;
    }
    this._stream.pause();
    return true;
  };
  NodejsStreamInputAdapter.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (this._upstreamEnded) {
      this.end();
    } else {
      this._stream.resume();
    }
    return true;
  };
  module.exports = NodejsStreamInputAdapter;
});

// node_modules/jszip/lib/object.js
var require_object = __commonJS((exports, module) => {
  var utf8 = require_utf8();
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var StreamHelper = require_StreamHelper();
  var defaults = require_defaults();
  var CompressedObject = require_compressedObject();
  var ZipObject = require_zipObject();
  var generate = require_generate();
  var nodejsUtils = require_nodejsUtils();
  var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
  var fileAdd = function(name, data, originalOptions) {
    var dataType = utils.getTypeOf(data), parent;
    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date;
    if (o.compression !== null) {
      o.compression = o.compression.toUpperCase();
    }
    if (typeof o.unixPermissions === "string") {
      o.unixPermissions = parseInt(o.unixPermissions, 8);
    }
    if (o.unixPermissions && o.unixPermissions & 16384) {
      o.dir = true;
    }
    if (o.dosPermissions && o.dosPermissions & 16) {
      o.dir = true;
    }
    if (o.dir) {
      name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
      folderAdd.call(this, parent, true);
    }
    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
      o.binary = !isUnicodeString;
    }
    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
      o.base64 = false;
      o.binary = true;
      data = "";
      o.compression = "STORE";
      dataType = "string";
    }
    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
      zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
      zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }
    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
  };
  var parentFolder = function(path) {
    if (path.slice(-1) === "/") {
      path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf("/");
    return lastSlash > 0 ? path.substring(0, lastSlash) : "";
  };
  var forceTrailingSlash = function(path) {
    if (path.slice(-1) !== "/") {
      path += "/";
    }
    return path;
  };
  var folderAdd = function(name, createFolders) {
    createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
    name = forceTrailingSlash(name);
    if (!this.files[name]) {
      fileAdd.call(this, name, null, {
        dir: true,
        createFolders
      });
    }
    return this.files[name];
  };
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  var out = {
    load: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    forEach: function(cb) {
      var filename, relativePath, file;
      for (filename in this.files) {
        file = this.files[filename];
        relativePath = filename.slice(this.root.length, filename.length);
        if (relativePath && filename.slice(0, this.root.length) === this.root) {
          cb(relativePath, file);
        }
      }
    },
    filter: function(search) {
      var result = [];
      this.forEach(function(relativePath, entry) {
        if (search(relativePath, entry)) {
          result.push(entry);
        }
      });
      return result;
    },
    file: function(name, data, o) {
      if (arguments.length === 1) {
        if (isRegExp(name)) {
          var regexp = name;
          return this.filter(function(relativePath, file) {
            return !file.dir && regexp.test(relativePath);
          });
        } else {
          var obj = this.files[this.root + name];
          if (obj && !obj.dir) {
            return obj;
          } else {
            return null;
          }
        }
      } else {
        name = this.root + name;
        fileAdd.call(this, name, data, o);
      }
      return this;
    },
    folder: function(arg) {
      if (!arg) {
        return this;
      }
      if (isRegExp(arg)) {
        return this.filter(function(relativePath, file) {
          return file.dir && arg.test(relativePath);
        });
      }
      var name = this.root + arg;
      var newFolder = folderAdd.call(this, name);
      var ret = this.clone();
      ret.root = newFolder.name;
      return ret;
    },
    remove: function(name) {
      name = this.root + name;
      var file = this.files[name];
      if (!file) {
        if (name.slice(-1) !== "/") {
          name += "/";
        }
        file = this.files[name];
      }
      if (file && !file.dir) {
        delete this.files[name];
      } else {
        var kids = this.filter(function(relativePath, file2) {
          return file2.name.slice(0, name.length) === name;
        });
        for (var i = 0;i < kids.length; i++) {
          delete this.files[kids[i].name];
        }
      }
      return this;
    },
    generate: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
        opts = utils.extend(options || {}, {
          streamFiles: false,
          compression: "STORE",
          compressionOptions: null,
          type: "",
          platform: "DOS",
          comment: null,
          mimeType: "application/zip",
          encodeFileName: utf8.utf8encode
        });
        opts.type = opts.type.toLowerCase();
        opts.compression = opts.compression.toUpperCase();
        if (opts.type === "binarystring") {
          opts.type = "string";
        }
        if (!opts.type) {
          throw new Error("No output type specified.");
        }
        utils.checkSupport(opts.type);
        if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
          opts.platform = "UNIX";
        }
        if (opts.platform === "win32") {
          opts.platform = "DOS";
        }
        var comment = opts.comment || this.comment || "";
        worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    generateAsync: function(options, onUpdate) {
      return this.generateInternalStream(options).accumulate(onUpdate);
    },
    generateNodeStream: function(options, onUpdate) {
      options = options || {};
      if (!options.type) {
        options.type = "nodebuffer";
      }
      return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
  };
  module.exports = out;
});

// node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS((exports, module) => {
  var utils = require_utils();
  function DataReader(data) {
    this.data = data;
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
  }
  DataReader.prototype = {
    checkOffset: function(offset) {
      this.checkIndex(this.index + offset);
    },
    checkIndex: function(newIndex) {
      if (this.length < this.zero + newIndex || newIndex < 0) {
        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
      }
    },
    setIndex: function(newIndex) {
      this.checkIndex(newIndex);
      this.index = newIndex;
    },
    skip: function(n) {
      this.setIndex(this.index + n);
    },
    byteAt: function() {
    },
    readInt: function(size) {
      var result = 0, i;
      this.checkOffset(size);
      for (i = this.index + size - 1;i >= this.index; i--) {
        result = (result << 8) + this.byteAt(i);
      }
      this.index += size;
      return result;
    },
    readString: function(size) {
      return utils.transformTo("string", this.readData(size));
    },
    readData: function() {
    },
    lastIndexOfSignature: function() {
    },
    readAndCheckSignature: function() {
    },
    readDate: function() {
      var dostime = this.readInt(4);
      return new Date(Date.UTC((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1));
    }
  };
  module.exports = DataReader;
});

// node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS((exports, module) => {
  var DataReader = require_DataReader();
  var utils = require_utils();
  function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i = 0;i < this.data.length; i++) {
      data[i] = data[i] & 255;
    }
  }
  utils.inherits(ArrayReader, DataReader);
  ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
  };
  ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4;i >= 0; --i) {
      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
        return i - this.zero;
      }
    }
    return -1;
  };
  ArrayReader.prototype.readAndCheckSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = ArrayReader;
});

// node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS((exports, module) => {
  var DataReader = require_DataReader();
  var utils = require_utils();
  function StringReader(data) {
    DataReader.call(this, data);
  }
  utils.inherits(StringReader, DataReader);
  StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
  };
  StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader.prototype.readAndCheckSignature = function(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = StringReader;
});

// node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS((exports, module) => {
  var ArrayReader = require_ArrayReader();
  var utils = require_utils();
  function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
  }
  utils.inherits(Uint8ArrayReader, ArrayReader);
  Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = Uint8ArrayReader;
});

// node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS((exports, module) => {
  var Uint8ArrayReader = require_Uint8ArrayReader();
  var utils = require_utils();
  function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
  }
  utils.inherits(NodeBufferReader, Uint8ArrayReader);
  NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = NodeBufferReader;
});

// node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS((exports, module) => {
  var utils = require_utils();
  var support = require_support();
  var ArrayReader = require_ArrayReader();
  var StringReader = require_StringReader();
  var NodeBufferReader = require_NodeBufferReader();
  var Uint8ArrayReader = require_Uint8ArrayReader();
  module.exports = function(data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
      return new StringReader(data);
    }
    if (type === "nodebuffer") {
      return new NodeBufferReader(data);
    }
    if (support.uint8array) {
      return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
  };
});

// node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS((exports, module) => {
  var readerFor = require_readerFor();
  var utils = require_utils();
  var CompressedObject = require_compressedObject();
  var crc32fn = require_crc32();
  var utf8 = require_utf8();
  var compressions = require_compressions();
  var support = require_support();
  var MADE_BY_DOS = 0;
  var MADE_BY_UNIX = 3;
  var findCompression = function(compressionMethod) {
    for (var method in compressions) {
      if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
        continue;
      }
      if (compressions[method].magic === compressionMethod) {
        return compressions[method];
      }
    }
    return null;
  };
  function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
  }
  ZipEntry.prototype = {
    isEncrypted: function() {
      return (this.bitFlag & 1) === 1;
    },
    useUTF8: function() {
      return (this.bitFlag & 2048) === 2048;
    },
    readLocalPart: function(reader) {
      var compression, localExtraFieldsLength;
      reader.skip(22);
      this.fileNameLength = reader.readInt(2);
      localExtraFieldsLength = reader.readInt(2);
      this.fileName = reader.readData(this.fileNameLength);
      reader.skip(localExtraFieldsLength);
      if (this.compressedSize === -1 || this.uncompressedSize === -1) {
        throw new Error("Bug or corrupted zip : didn't get enough information from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
      }
      compression = findCompression(this.compressionMethod);
      if (compression === null) {
        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
      }
      this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },
    readCentralPart: function(reader) {
      this.versionMadeBy = reader.readInt(2);
      reader.skip(2);
      this.bitFlag = reader.readInt(2);
      this.compressionMethod = reader.readString(2);
      this.date = reader.readDate();
      this.crc32 = reader.readInt(4);
      this.compressedSize = reader.readInt(4);
      this.uncompressedSize = reader.readInt(4);
      var fileNameLength = reader.readInt(2);
      this.extraFieldsLength = reader.readInt(2);
      this.fileCommentLength = reader.readInt(2);
      this.diskNumberStart = reader.readInt(2);
      this.internalFileAttributes = reader.readInt(2);
      this.externalFileAttributes = reader.readInt(4);
      this.localHeaderOffset = reader.readInt(4);
      if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
      }
      reader.skip(fileNameLength);
      this.readExtraFields(reader);
      this.parseZIP64ExtraField(reader);
      this.fileComment = reader.readData(this.fileCommentLength);
    },
    processAttributes: function() {
      this.unixPermissions = null;
      this.dosPermissions = null;
      var madeBy = this.versionMadeBy >> 8;
      this.dir = this.externalFileAttributes & 16 ? true : false;
      if (madeBy === MADE_BY_DOS) {
        this.dosPermissions = this.externalFileAttributes & 63;
      }
      if (madeBy === MADE_BY_UNIX) {
        this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
      }
      if (!this.dir && this.fileNameStr.slice(-1) === "/") {
        this.dir = true;
      }
    },
    parseZIP64ExtraField: function() {
      if (!this.extraFields[1]) {
        return;
      }
      var extraReader = readerFor(this.extraFields[1].value);
      if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
        this.uncompressedSize = extraReader.readInt(8);
      }
      if (this.compressedSize === utils.MAX_VALUE_32BITS) {
        this.compressedSize = extraReader.readInt(8);
      }
      if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
        this.localHeaderOffset = extraReader.readInt(8);
      }
      if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
        this.diskNumberStart = extraReader.readInt(4);
      }
    },
    readExtraFields: function(reader) {
      var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
      if (!this.extraFields) {
        this.extraFields = {};
      }
      while (reader.index + 4 < end) {
        extraFieldId = reader.readInt(2);
        extraFieldLength = reader.readInt(2);
        extraFieldValue = reader.readData(extraFieldLength);
        this.extraFields[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
      reader.setIndex(end);
    },
    handleUTF8: function() {
      var decodeParamType = support.uint8array ? "uint8array" : "array";
      if (this.useUTF8()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
      } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
          this.fileNameStr = upath;
        } else {
          var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
          this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }
        var ucomment = this.findExtraFieldUnicodeComment();
        if (ucomment !== null) {
          this.fileCommentStr = ucomment;
        } else {
          var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
          this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
        }
      }
    },
    findExtraFieldUnicodePath: function() {
      var upathField = this.extraFields[28789];
      if (upathField) {
        var extraReader = readerFor(upathField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
          return null;
        }
        return utf8.utf8decode(extraReader.readData(upathField.length - 5));
      }
      return null;
    },
    findExtraFieldUnicodeComment: function() {
      var ucommentField = this.extraFields[25461];
      if (ucommentField) {
        var extraReader = readerFor(ucommentField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
          return null;
        }
        return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
      }
      return null;
    }
  };
  module.exports = ZipEntry;
});

// node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS((exports, module) => {
  var readerFor = require_readerFor();
  var utils = require_utils();
  var sig = require_signature();
  var ZipEntry = require_zipEntry();
  var support = require_support();
  function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
  }
  ZipEntries.prototype = {
    checkSignature: function(expectedSignature) {
      if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
      }
    },
    isSignature: function(askedIndex, expectedSignature) {
      var currentIndex = this.reader.index;
      this.reader.setIndex(askedIndex);
      var signature = this.reader.readString(4);
      var result = signature === expectedSignature;
      this.reader.setIndex(currentIndex);
      return result;
    },
    readBlockEndOfCentral: function() {
      this.diskNumber = this.reader.readInt(2);
      this.diskWithCentralDirStart = this.reader.readInt(2);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
      this.centralDirRecords = this.reader.readInt(2);
      this.centralDirSize = this.reader.readInt(4);
      this.centralDirOffset = this.reader.readInt(4);
      this.zipCommentLength = this.reader.readInt(2);
      var zipComment = this.reader.readData(this.zipCommentLength);
      var decodeParamType = support.uint8array ? "uint8array" : "array";
      var decodeContent = utils.transformTo(decodeParamType, zipComment);
      this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    readBlockZip64EndOfCentral: function() {
      this.zip64EndOfCentralSize = this.reader.readInt(8);
      this.reader.skip(4);
      this.diskNumber = this.reader.readInt(4);
      this.diskWithCentralDirStart = this.reader.readInt(4);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
      this.centralDirRecords = this.reader.readInt(8);
      this.centralDirSize = this.reader.readInt(8);
      this.centralDirOffset = this.reader.readInt(8);
      this.zip64ExtensibleData = {};
      var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
      while (index < extraDataSize) {
        extraFieldId = this.reader.readInt(2);
        extraFieldLength = this.reader.readInt(4);
        extraFieldValue = this.reader.readData(extraFieldLength);
        this.zip64ExtensibleData[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
    },
    readBlockZip64EndOfCentralLocator: function() {
      this.diskWithZip64CentralDirStart = this.reader.readInt(4);
      this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
      this.disksCount = this.reader.readInt(4);
      if (this.disksCount > 1) {
        throw new Error("Multi-volumes zip are not supported");
      }
    },
    readLocalFiles: function() {
      var i, file;
      for (i = 0;i < this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.processAttributes();
      }
    },
    readCentralDir: function() {
      var file;
      this.reader.setIndex(this.centralDirOffset);
      while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
        file = new ZipEntry({
          zip64: this.zip64
        }, this.loadOptions);
        file.readCentralPart(this.reader);
        this.files.push(file);
      }
      if (this.centralDirRecords !== this.files.length) {
        if (this.centralDirRecords !== 0 && this.files.length === 0) {
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        } else {
        }
      }
    },
    readEndOfCentral: function() {
      var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
      if (offset < 0) {
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
        if (isGarbage) {
          throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        } else {
          throw new Error("Corrupted zip: can't find end of central directory");
        }
      }
      this.reader.setIndex(offset);
      var endOfCentralDirOffset = offset;
      this.checkSignature(sig.CENTRAL_DIRECTORY_END);
      this.readBlockEndOfCentral();
      if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
        this.zip64 = true;
        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        if (offset < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
        }
        this.reader.setIndex(offset);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        this.readBlockZip64EndOfCentralLocator();
        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
          this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          if (this.relativeOffsetEndOfZip64CentralDir < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          }
        }
        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        this.readBlockZip64EndOfCentral();
      }
      var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
      if (this.zip64) {
        expectedEndOfCentralDirOffset += 20;
        expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
      }
      var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
      if (extraBytes > 0) {
        if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
        } else {
          this.reader.zero = extraBytes;
        }
      } else if (extraBytes < 0) {
        throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
      }
    },
    prepareReader: function(data) {
      this.reader = readerFor(data);
    },
    load: function(data) {
      this.prepareReader(data);
      this.readEndOfCentral();
      this.readCentralDir();
      this.readLocalFiles();
    }
  };
  module.exports = ZipEntries;
});

// node_modules/jszip/lib/load.js
var require_load = __commonJS((exports, module) => {
  var utils = require_utils();
  var external = require_external();
  var utf8 = require_utf8();
  var ZipEntries = require_zipEntries();
  var Crc32Probe = require_Crc32Probe();
  var nodejsUtils = require_nodejsUtils();
  function checkEntryCRC32(zipEntry) {
    return new external.Promise(function(resolve, reject) {
      var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe);
      worker.on("error", function(e) {
        reject(e);
      }).on("end", function() {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
          reject(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
          resolve();
        }
      }).resume();
    });
  }
  module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
      base64: false,
      checkCRC32: false,
      optimizedBinaryString: false,
      createFolders: false,
      decodeFileName: utf8.utf8decode
    });
    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }
    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
      var zipEntries = new ZipEntries(options);
      zipEntries.load(data2);
      return zipEntries;
    }).then(function checkCRC32(zipEntries) {
      var promises = [external.Promise.resolve(zipEntries)];
      var files = zipEntries.files;
      if (options.checkCRC32) {
        for (var i = 0;i < files.length; i++) {
          promises.push(checkEntryCRC32(files[i]));
        }
      }
      return external.Promise.all(promises);
    }).then(function addFiles(results) {
      var zipEntries = results.shift();
      var files = zipEntries.files;
      for (var i = 0;i < files.length; i++) {
        var input = files[i];
        var unsafeName = input.fileNameStr;
        var safeName = utils.resolve(input.fileNameStr);
        zip.file(safeName, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
        if (!input.dir) {
          zip.file(safeName).unsafeOriginalName = unsafeName;
        }
      }
      if (zipEntries.zipComment.length) {
        zip.comment = zipEntries.zipComment;
      }
      return zip;
    });
  };
});

// node_modules/jszip/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  function JSZip() {
    if (!(this instanceof JSZip)) {
      return new JSZip;
    }
    if (arguments.length) {
      throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }
    this.files = Object.create(null);
    this.comment = null;
    this.root = "";
    this.clone = function() {
      var newObj = new JSZip;
      for (var i in this) {
        if (typeof this[i] !== "function") {
          newObj[i] = this[i];
        }
      }
      return newObj;
    };
  }
  JSZip.prototype = require_object();
  JSZip.prototype.loadAsync = require_load();
  JSZip.support = require_support();
  JSZip.defaults = require_defaults();
  JSZip.version = "3.10.1";
  JSZip.loadAsync = function(content, options) {
    return new JSZip().loadAsync(content, options);
  };
  JSZip.external = require_external();
  module.exports = JSZip;
});

// node_modules/html-entities/lib/named-references.js
var require_named_references = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bodyRegExps = { xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g };
  exports.namedReferences = { xml: { entities: { "&lt;": "<", "&gt;": ">", "&quot;": '"', "&apos;": "'", "&amp;": "&" }, characters: { "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;", "&": "&amp;" } }, html4: { entities: { "&apos;": "'", "&nbsp": " ", "&nbsp;": " ", "&iexcl": "¡", "&iexcl;": "¡", "&cent": "¢", "&cent;": "¢", "&pound": "£", "&pound;": "£", "&curren": "¤", "&curren;": "¤", "&yen": "¥", "&yen;": "¥", "&brvbar": "¦", "&brvbar;": "¦", "&sect": "§", "&sect;": "§", "&uml": "¨", "&uml;": "¨", "&copy": "©", "&copy;": "©", "&ordf": "ª", "&ordf;": "ª", "&laquo": "«", "&laquo;": "«", "&not": "¬", "&not;": "¬", "&shy": "­", "&shy;": "­", "&reg": "®", "&reg;": "®", "&macr": "¯", "&macr;": "¯", "&deg": "°", "&deg;": "°", "&plusmn": "±", "&plusmn;": "±", "&sup2": "²", "&sup2;": "²", "&sup3": "³", "&sup3;": "³", "&acute": "´", "&acute;": "´", "&micro": "µ", "&micro;": "µ", "&para": "¶", "&para;": "¶", "&middot": "·", "&middot;": "·", "&cedil": "¸", "&cedil;": "¸", "&sup1": "¹", "&sup1;": "¹", "&ordm": "º", "&ordm;": "º", "&raquo": "»", "&raquo;": "»", "&frac14": "¼", "&frac14;": "¼", "&frac12": "½", "&frac12;": "½", "&frac34": "¾", "&frac34;": "¾", "&iquest": "¿", "&iquest;": "¿", "&Agrave": "À", "&Agrave;": "À", "&Aacute": "Á", "&Aacute;": "Á", "&Acirc": "Â", "&Acirc;": "Â", "&Atilde": "Ã", "&Atilde;": "Ã", "&Auml": "Ä", "&Auml;": "Ä", "&Aring": "Å", "&Aring;": "Å", "&AElig": "Æ", "&AElig;": "Æ", "&Ccedil": "Ç", "&Ccedil;": "Ç", "&Egrave": "È", "&Egrave;": "È", "&Eacute": "É", "&Eacute;": "É", "&Ecirc": "Ê", "&Ecirc;": "Ê", "&Euml": "Ë", "&Euml;": "Ë", "&Igrave": "Ì", "&Igrave;": "Ì", "&Iacute": "Í", "&Iacute;": "Í", "&Icirc": "Î", "&Icirc;": "Î", "&Iuml": "Ï", "&Iuml;": "Ï", "&ETH": "Ð", "&ETH;": "Ð", "&Ntilde": "Ñ", "&Ntilde;": "Ñ", "&Ograve": "Ò", "&Ograve;": "Ò", "&Oacute": "Ó", "&Oacute;": "Ó", "&Ocirc": "Ô", "&Ocirc;": "Ô", "&Otilde": "Õ", "&Otilde;": "Õ", "&Ouml": "Ö", "&Ouml;": "Ö", "&times": "×", "&times;": "×", "&Oslash": "Ø", "&Oslash;": "Ø", "&Ugrave": "Ù", "&Ugrave;": "Ù", "&Uacute": "Ú", "&Uacute;": "Ú", "&Ucirc": "Û", "&Ucirc;": "Û", "&Uuml": "Ü", "&Uuml;": "Ü", "&Yacute": "Ý", "&Yacute;": "Ý", "&THORN": "Þ", "&THORN;": "Þ", "&szlig": "ß", "&szlig;": "ß", "&agrave": "à", "&agrave;": "à", "&aacute": "á", "&aacute;": "á", "&acirc": "â", "&acirc;": "â", "&atilde": "ã", "&atilde;": "ã", "&auml": "ä", "&auml;": "ä", "&aring": "å", "&aring;": "å", "&aelig": "æ", "&aelig;": "æ", "&ccedil": "ç", "&ccedil;": "ç", "&egrave": "è", "&egrave;": "è", "&eacute": "é", "&eacute;": "é", "&ecirc": "ê", "&ecirc;": "ê", "&euml": "ë", "&euml;": "ë", "&igrave": "ì", "&igrave;": "ì", "&iacute": "í", "&iacute;": "í", "&icirc": "î", "&icirc;": "î", "&iuml": "ï", "&iuml;": "ï", "&eth": "ð", "&eth;": "ð", "&ntilde": "ñ", "&ntilde;": "ñ", "&ograve": "ò", "&ograve;": "ò", "&oacute": "ó", "&oacute;": "ó", "&ocirc": "ô", "&ocirc;": "ô", "&otilde": "õ", "&otilde;": "õ", "&ouml": "ö", "&ouml;": "ö", "&divide": "÷", "&divide;": "÷", "&oslash": "ø", "&oslash;": "ø", "&ugrave": "ù", "&ugrave;": "ù", "&uacute": "ú", "&uacute;": "ú", "&ucirc": "û", "&ucirc;": "û", "&uuml": "ü", "&uuml;": "ü", "&yacute": "ý", "&yacute;": "ý", "&thorn": "þ", "&thorn;": "þ", "&yuml": "ÿ", "&yuml;": "ÿ", "&quot": '"', "&quot;": '"', "&amp": "&", "&amp;": "&", "&lt": "<", "&lt;": "<", "&gt": ">", "&gt;": ">", "&OElig;": "Œ", "&oelig;": "œ", "&Scaron;": "Š", "&scaron;": "š", "&Yuml;": "Ÿ", "&circ;": "ˆ", "&tilde;": "˜", "&ensp;": " ", "&emsp;": " ", "&thinsp;": " ", "&zwnj;": "‌", "&zwj;": "‍", "&lrm;": "‎", "&rlm;": "‏", "&ndash;": "–", "&mdash;": "—", "&lsquo;": "‘", "&rsquo;": "’", "&sbquo;": "‚", "&ldquo;": "“", "&rdquo;": "”", "&bdquo;": "„", "&dagger;": "†", "&Dagger;": "‡", "&permil;": "‰", "&lsaquo;": "‹", "&rsaquo;": "›", "&euro;": "€", "&fnof;": "ƒ", "&Alpha;": "Α", "&Beta;": "Β", "&Gamma;": "Γ", "&Delta;": "Δ", "&Epsilon;": "Ε", "&Zeta;": "Ζ", "&Eta;": "Η", "&Theta;": "Θ", "&Iota;": "Ι", "&Kappa;": "Κ", "&Lambda;": "Λ", "&Mu;": "Μ", "&Nu;": "Ν", "&Xi;": "Ξ", "&Omicron;": "Ο", "&Pi;": "Π", "&Rho;": "Ρ", "&Sigma;": "Σ", "&Tau;": "Τ", "&Upsilon;": "Υ", "&Phi;": "Φ", "&Chi;": "Χ", "&Psi;": "Ψ", "&Omega;": "Ω", "&alpha;": "α", "&beta;": "β", "&gamma;": "γ", "&delta;": "δ", "&epsilon;": "ε", "&zeta;": "ζ", "&eta;": "η", "&theta;": "θ", "&iota;": "ι", "&kappa;": "κ", "&lambda;": "λ", "&mu;": "μ", "&nu;": "ν", "&xi;": "ξ", "&omicron;": "ο", "&pi;": "π", "&rho;": "ρ", "&sigmaf;": "ς", "&sigma;": "σ", "&tau;": "τ", "&upsilon;": "υ", "&phi;": "φ", "&chi;": "χ", "&psi;": "ψ", "&omega;": "ω", "&thetasym;": "ϑ", "&upsih;": "ϒ", "&piv;": "ϖ", "&bull;": "•", "&hellip;": "…", "&prime;": "′", "&Prime;": "″", "&oline;": "‾", "&frasl;": "⁄", "&weierp;": "℘", "&image;": "ℑ", "&real;": "ℜ", "&trade;": "™", "&alefsym;": "ℵ", "&larr;": "←", "&uarr;": "↑", "&rarr;": "→", "&darr;": "↓", "&harr;": "↔", "&crarr;": "↵", "&lArr;": "⇐", "&uArr;": "⇑", "&rArr;": "⇒", "&dArr;": "⇓", "&hArr;": "⇔", "&forall;": "∀", "&part;": "∂", "&exist;": "∃", "&empty;": "∅", "&nabla;": "∇", "&isin;": "∈", "&notin;": "∉", "&ni;": "∋", "&prod;": "∏", "&sum;": "∑", "&minus;": "−", "&lowast;": "∗", "&radic;": "√", "&prop;": "∝", "&infin;": "∞", "&ang;": "∠", "&and;": "∧", "&or;": "∨", "&cap;": "∩", "&cup;": "∪", "&int;": "∫", "&there4;": "∴", "&sim;": "∼", "&cong;": "≅", "&asymp;": "≈", "&ne;": "≠", "&equiv;": "≡", "&le;": "≤", "&ge;": "≥", "&sub;": "⊂", "&sup;": "⊃", "&nsub;": "⊄", "&sube;": "⊆", "&supe;": "⊇", "&oplus;": "⊕", "&otimes;": "⊗", "&perp;": "⊥", "&sdot;": "⋅", "&lceil;": "⌈", "&rceil;": "⌉", "&lfloor;": "⌊", "&rfloor;": "⌋", "&lang;": "〈", "&rang;": "〉", "&loz;": "◊", "&spades;": "♠", "&clubs;": "♣", "&hearts;": "♥", "&diams;": "♦" }, characters: { "'": "&apos;", " ": "&nbsp;", "¡": "&iexcl;", "¢": "&cent;", "£": "&pound;", "¤": "&curren;", "¥": "&yen;", "¦": "&brvbar;", "§": "&sect;", "¨": "&uml;", "©": "&copy;", "ª": "&ordf;", "«": "&laquo;", "¬": "&not;", "­": "&shy;", "®": "&reg;", "¯": "&macr;", "°": "&deg;", "±": "&plusmn;", "²": "&sup2;", "³": "&sup3;", "´": "&acute;", "µ": "&micro;", "¶": "&para;", "·": "&middot;", "¸": "&cedil;", "¹": "&sup1;", "º": "&ordm;", "»": "&raquo;", "¼": "&frac14;", "½": "&frac12;", "¾": "&frac34;", "¿": "&iquest;", "À": "&Agrave;", "Á": "&Aacute;", "Â": "&Acirc;", "Ã": "&Atilde;", "Ä": "&Auml;", "Å": "&Aring;", "Æ": "&AElig;", "Ç": "&Ccedil;", "È": "&Egrave;", "É": "&Eacute;", "Ê": "&Ecirc;", "Ë": "&Euml;", "Ì": "&Igrave;", "Í": "&Iacute;", "Î": "&Icirc;", "Ï": "&Iuml;", "Ð": "&ETH;", "Ñ": "&Ntilde;", "Ò": "&Ograve;", "Ó": "&Oacute;", "Ô": "&Ocirc;", "Õ": "&Otilde;", "Ö": "&Ouml;", "×": "&times;", "Ø": "&Oslash;", "Ù": "&Ugrave;", "Ú": "&Uacute;", "Û": "&Ucirc;", "Ü": "&Uuml;", "Ý": "&Yacute;", "Þ": "&THORN;", "ß": "&szlig;", "à": "&agrave;", "á": "&aacute;", "â": "&acirc;", "ã": "&atilde;", "ä": "&auml;", "å": "&aring;", "æ": "&aelig;", "ç": "&ccedil;", "è": "&egrave;", "é": "&eacute;", "ê": "&ecirc;", "ë": "&euml;", "ì": "&igrave;", "í": "&iacute;", "î": "&icirc;", "ï": "&iuml;", "ð": "&eth;", "ñ": "&ntilde;", "ò": "&ograve;", "ó": "&oacute;", "ô": "&ocirc;", "õ": "&otilde;", "ö": "&ouml;", "÷": "&divide;", "ø": "&oslash;", "ù": "&ugrave;", "ú": "&uacute;", "û": "&ucirc;", "ü": "&uuml;", "ý": "&yacute;", "þ": "&thorn;", "ÿ": "&yuml;", '"': "&quot;", "&": "&amp;", "<": "&lt;", ">": "&gt;", "Œ": "&OElig;", "œ": "&oelig;", "Š": "&Scaron;", "š": "&scaron;", "Ÿ": "&Yuml;", "ˆ": "&circ;", "˜": "&tilde;", " ": "&ensp;", " ": "&emsp;", " ": "&thinsp;", "‌": "&zwnj;", "‍": "&zwj;", "‎": "&lrm;", "‏": "&rlm;", "–": "&ndash;", "—": "&mdash;", "‘": "&lsquo;", "’": "&rsquo;", "‚": "&sbquo;", "“": "&ldquo;", "”": "&rdquo;", "„": "&bdquo;", "†": "&dagger;", "‡": "&Dagger;", "‰": "&permil;", "‹": "&lsaquo;", "›": "&rsaquo;", "€": "&euro;", "ƒ": "&fnof;", "Α": "&Alpha;", "Β": "&Beta;", "Γ": "&Gamma;", "Δ": "&Delta;", "Ε": "&Epsilon;", "Ζ": "&Zeta;", "Η": "&Eta;", "Θ": "&Theta;", "Ι": "&Iota;", "Κ": "&Kappa;", "Λ": "&Lambda;", "Μ": "&Mu;", "Ν": "&Nu;", "Ξ": "&Xi;", "Ο": "&Omicron;", "Π": "&Pi;", "Ρ": "&Rho;", "Σ": "&Sigma;", "Τ": "&Tau;", "Υ": "&Upsilon;", "Φ": "&Phi;", "Χ": "&Chi;", "Ψ": "&Psi;", "Ω": "&Omega;", "α": "&alpha;", "β": "&beta;", "γ": "&gamma;", "δ": "&delta;", "ε": "&epsilon;", "ζ": "&zeta;", "η": "&eta;", "θ": "&theta;", "ι": "&iota;", "κ": "&kappa;", "λ": "&lambda;", "μ": "&mu;", "ν": "&nu;", "ξ": "&xi;", "ο": "&omicron;", "π": "&pi;", "ρ": "&rho;", "ς": "&sigmaf;", "σ": "&sigma;", "τ": "&tau;", "υ": "&upsilon;", "φ": "&phi;", "χ": "&chi;", "ψ": "&psi;", "ω": "&omega;", "ϑ": "&thetasym;", "ϒ": "&upsih;", "ϖ": "&piv;", "•": "&bull;", "…": "&hellip;", "′": "&prime;", "″": "&Prime;", "‾": "&oline;", "⁄": "&frasl;", "℘": "&weierp;", "ℑ": "&image;", "ℜ": "&real;", "™": "&trade;", "ℵ": "&alefsym;", "←": "&larr;", "↑": "&uarr;", "→": "&rarr;", "↓": "&darr;", "↔": "&harr;", "↵": "&crarr;", "⇐": "&lArr;", "⇑": "&uArr;", "⇒": "&rArr;", "⇓": "&dArr;", "⇔": "&hArr;", "∀": "&forall;", "∂": "&part;", "∃": "&exist;", "∅": "&empty;", "∇": "&nabla;", "∈": "&isin;", "∉": "&notin;", "∋": "&ni;", "∏": "&prod;", "∑": "&sum;", "−": "&minus;", "∗": "&lowast;", "√": "&radic;", "∝": "&prop;", "∞": "&infin;", "∠": "&ang;", "∧": "&and;", "∨": "&or;", "∩": "&cap;", "∪": "&cup;", "∫": "&int;", "∴": "&there4;", "∼": "&sim;", "≅": "&cong;", "≈": "&asymp;", "≠": "&ne;", "≡": "&equiv;", "≤": "&le;", "≥": "&ge;", "⊂": "&sub;", "⊃": "&sup;", "⊄": "&nsub;", "⊆": "&sube;", "⊇": "&supe;", "⊕": "&oplus;", "⊗": "&otimes;", "⊥": "&perp;", "⋅": "&sdot;", "⌈": "&lceil;", "⌉": "&rceil;", "⌊": "&lfloor;", "⌋": "&rfloor;", "〈": "&lang;", "〉": "&rang;", "◊": "&loz;", "♠": "&spades;", "♣": "&clubs;", "♥": "&hearts;", "♦": "&diams;" } }, html5: { entities: { "&AElig": "Æ", "&AElig;": "Æ", "&AMP": "&", "&AMP;": "&", "&Aacute": "Á", "&Aacute;": "Á", "&Abreve;": "Ă", "&Acirc": "Â", "&Acirc;": "Â", "&Acy;": "А", "&Afr;": "\uD835\uDD04", "&Agrave": "À", "&Agrave;": "À", "&Alpha;": "Α", "&Amacr;": "Ā", "&And;": "⩓", "&Aogon;": "Ą", "&Aopf;": "\uD835\uDD38", "&ApplyFunction;": "⁡", "&Aring": "Å", "&Aring;": "Å", "&Ascr;": "\uD835\uDC9C", "&Assign;": "≔", "&Atilde": "Ã", "&Atilde;": "Ã", "&Auml": "Ä", "&Auml;": "Ä", "&Backslash;": "∖", "&Barv;": "⫧", "&Barwed;": "⌆", "&Bcy;": "Б", "&Because;": "∵", "&Bernoullis;": "ℬ", "&Beta;": "Β", "&Bfr;": "\uD835\uDD05", "&Bopf;": "\uD835\uDD39", "&Breve;": "˘", "&Bscr;": "ℬ", "&Bumpeq;": "≎", "&CHcy;": "Ч", "&COPY": "©", "&COPY;": "©", "&Cacute;": "Ć", "&Cap;": "⋒", "&CapitalDifferentialD;": "ⅅ", "&Cayleys;": "ℭ", "&Ccaron;": "Č", "&Ccedil": "Ç", "&Ccedil;": "Ç", "&Ccirc;": "Ĉ", "&Cconint;": "∰", "&Cdot;": "Ċ", "&Cedilla;": "¸", "&CenterDot;": "·", "&Cfr;": "ℭ", "&Chi;": "Χ", "&CircleDot;": "⊙", "&CircleMinus;": "⊖", "&CirclePlus;": "⊕", "&CircleTimes;": "⊗", "&ClockwiseContourIntegral;": "∲", "&CloseCurlyDoubleQuote;": "”", "&CloseCurlyQuote;": "’", "&Colon;": "∷", "&Colone;": "⩴", "&Congruent;": "≡", "&Conint;": "∯", "&ContourIntegral;": "∮", "&Copf;": "ℂ", "&Coproduct;": "∐", "&CounterClockwiseContourIntegral;": "∳", "&Cross;": "⨯", "&Cscr;": "\uD835\uDC9E", "&Cup;": "⋓", "&CupCap;": "≍", "&DD;": "ⅅ", "&DDotrahd;": "⤑", "&DJcy;": "Ђ", "&DScy;": "Ѕ", "&DZcy;": "Џ", "&Dagger;": "‡", "&Darr;": "↡", "&Dashv;": "⫤", "&Dcaron;": "Ď", "&Dcy;": "Д", "&Del;": "∇", "&Delta;": "Δ", "&Dfr;": "\uD835\uDD07", "&DiacriticalAcute;": "´", "&DiacriticalDot;": "˙", "&DiacriticalDoubleAcute;": "˝", "&DiacriticalGrave;": "`", "&DiacriticalTilde;": "˜", "&Diamond;": "⋄", "&DifferentialD;": "ⅆ", "&Dopf;": "\uD835\uDD3B", "&Dot;": "¨", "&DotDot;": "⃜", "&DotEqual;": "≐", "&DoubleContourIntegral;": "∯", "&DoubleDot;": "¨", "&DoubleDownArrow;": "⇓", "&DoubleLeftArrow;": "⇐", "&DoubleLeftRightArrow;": "⇔", "&DoubleLeftTee;": "⫤", "&DoubleLongLeftArrow;": "⟸", "&DoubleLongLeftRightArrow;": "⟺", "&DoubleLongRightArrow;": "⟹", "&DoubleRightArrow;": "⇒", "&DoubleRightTee;": "⊨", "&DoubleUpArrow;": "⇑", "&DoubleUpDownArrow;": "⇕", "&DoubleVerticalBar;": "∥", "&DownArrow;": "↓", "&DownArrowBar;": "⤓", "&DownArrowUpArrow;": "⇵", "&DownBreve;": "̑", "&DownLeftRightVector;": "⥐", "&DownLeftTeeVector;": "⥞", "&DownLeftVector;": "↽", "&DownLeftVectorBar;": "⥖", "&DownRightTeeVector;": "⥟", "&DownRightVector;": "⇁", "&DownRightVectorBar;": "⥗", "&DownTee;": "⊤", "&DownTeeArrow;": "↧", "&Downarrow;": "⇓", "&Dscr;": "\uD835\uDC9F", "&Dstrok;": "Đ", "&ENG;": "Ŋ", "&ETH": "Ð", "&ETH;": "Ð", "&Eacute": "É", "&Eacute;": "É", "&Ecaron;": "Ě", "&Ecirc": "Ê", "&Ecirc;": "Ê", "&Ecy;": "Э", "&Edot;": "Ė", "&Efr;": "\uD835\uDD08", "&Egrave": "È", "&Egrave;": "È", "&Element;": "∈", "&Emacr;": "Ē", "&EmptySmallSquare;": "◻", "&EmptyVerySmallSquare;": "▫", "&Eogon;": "Ę", "&Eopf;": "\uD835\uDD3C", "&Epsilon;": "Ε", "&Equal;": "⩵", "&EqualTilde;": "≂", "&Equilibrium;": "⇌", "&Escr;": "ℰ", "&Esim;": "⩳", "&Eta;": "Η", "&Euml": "Ë", "&Euml;": "Ë", "&Exists;": "∃", "&ExponentialE;": "ⅇ", "&Fcy;": "Ф", "&Ffr;": "\uD835\uDD09", "&FilledSmallSquare;": "◼", "&FilledVerySmallSquare;": "▪", "&Fopf;": "\uD835\uDD3D", "&ForAll;": "∀", "&Fouriertrf;": "ℱ", "&Fscr;": "ℱ", "&GJcy;": "Ѓ", "&GT": ">", "&GT;": ">", "&Gamma;": "Γ", "&Gammad;": "Ϝ", "&Gbreve;": "Ğ", "&Gcedil;": "Ģ", "&Gcirc;": "Ĝ", "&Gcy;": "Г", "&Gdot;": "Ġ", "&Gfr;": "\uD835\uDD0A", "&Gg;": "⋙", "&Gopf;": "\uD835\uDD3E", "&GreaterEqual;": "≥", "&GreaterEqualLess;": "⋛", "&GreaterFullEqual;": "≧", "&GreaterGreater;": "⪢", "&GreaterLess;": "≷", "&GreaterSlantEqual;": "⩾", "&GreaterTilde;": "≳", "&Gscr;": "\uD835\uDCA2", "&Gt;": "≫", "&HARDcy;": "Ъ", "&Hacek;": "ˇ", "&Hat;": "^", "&Hcirc;": "Ĥ", "&Hfr;": "ℌ", "&HilbertSpace;": "ℋ", "&Hopf;": "ℍ", "&HorizontalLine;": "─", "&Hscr;": "ℋ", "&Hstrok;": "Ħ", "&HumpDownHump;": "≎", "&HumpEqual;": "≏", "&IEcy;": "Е", "&IJlig;": "Ĳ", "&IOcy;": "Ё", "&Iacute": "Í", "&Iacute;": "Í", "&Icirc": "Î", "&Icirc;": "Î", "&Icy;": "И", "&Idot;": "İ", "&Ifr;": "ℑ", "&Igrave": "Ì", "&Igrave;": "Ì", "&Im;": "ℑ", "&Imacr;": "Ī", "&ImaginaryI;": "ⅈ", "&Implies;": "⇒", "&Int;": "∬", "&Integral;": "∫", "&Intersection;": "⋂", "&InvisibleComma;": "⁣", "&InvisibleTimes;": "⁢", "&Iogon;": "Į", "&Iopf;": "\uD835\uDD40", "&Iota;": "Ι", "&Iscr;": "ℐ", "&Itilde;": "Ĩ", "&Iukcy;": "І", "&Iuml": "Ï", "&Iuml;": "Ï", "&Jcirc;": "Ĵ", "&Jcy;": "Й", "&Jfr;": "\uD835\uDD0D", "&Jopf;": "\uD835\uDD41", "&Jscr;": "\uD835\uDCA5", "&Jsercy;": "Ј", "&Jukcy;": "Є", "&KHcy;": "Х", "&KJcy;": "Ќ", "&Kappa;": "Κ", "&Kcedil;": "Ķ", "&Kcy;": "К", "&Kfr;": "\uD835\uDD0E", "&Kopf;": "\uD835\uDD42", "&Kscr;": "\uD835\uDCA6", "&LJcy;": "Љ", "&LT": "<", "&LT;": "<", "&Lacute;": "Ĺ", "&Lambda;": "Λ", "&Lang;": "⟪", "&Laplacetrf;": "ℒ", "&Larr;": "↞", "&Lcaron;": "Ľ", "&Lcedil;": "Ļ", "&Lcy;": "Л", "&LeftAngleBracket;": "⟨", "&LeftArrow;": "←", "&LeftArrowBar;": "⇤", "&LeftArrowRightArrow;": "⇆", "&LeftCeiling;": "⌈", "&LeftDoubleBracket;": "⟦", "&LeftDownTeeVector;": "⥡", "&LeftDownVector;": "⇃", "&LeftDownVectorBar;": "⥙", "&LeftFloor;": "⌊", "&LeftRightArrow;": "↔", "&LeftRightVector;": "⥎", "&LeftTee;": "⊣", "&LeftTeeArrow;": "↤", "&LeftTeeVector;": "⥚", "&LeftTriangle;": "⊲", "&LeftTriangleBar;": "⧏", "&LeftTriangleEqual;": "⊴", "&LeftUpDownVector;": "⥑", "&LeftUpTeeVector;": "⥠", "&LeftUpVector;": "↿", "&LeftUpVectorBar;": "⥘", "&LeftVector;": "↼", "&LeftVectorBar;": "⥒", "&Leftarrow;": "⇐", "&Leftrightarrow;": "⇔", "&LessEqualGreater;": "⋚", "&LessFullEqual;": "≦", "&LessGreater;": "≶", "&LessLess;": "⪡", "&LessSlantEqual;": "⩽", "&LessTilde;": "≲", "&Lfr;": "\uD835\uDD0F", "&Ll;": "⋘", "&Lleftarrow;": "⇚", "&Lmidot;": "Ŀ", "&LongLeftArrow;": "⟵", "&LongLeftRightArrow;": "⟷", "&LongRightArrow;": "⟶", "&Longleftarrow;": "⟸", "&Longleftrightarrow;": "⟺", "&Longrightarrow;": "⟹", "&Lopf;": "\uD835\uDD43", "&LowerLeftArrow;": "↙", "&LowerRightArrow;": "↘", "&Lscr;": "ℒ", "&Lsh;": "↰", "&Lstrok;": "Ł", "&Lt;": "≪", "&Map;": "⤅", "&Mcy;": "М", "&MediumSpace;": " ", "&Mellintrf;": "ℳ", "&Mfr;": "\uD835\uDD10", "&MinusPlus;": "∓", "&Mopf;": "\uD835\uDD44", "&Mscr;": "ℳ", "&Mu;": "Μ", "&NJcy;": "Њ", "&Nacute;": "Ń", "&Ncaron;": "Ň", "&Ncedil;": "Ņ", "&Ncy;": "Н", "&NegativeMediumSpace;": "​", "&NegativeThickSpace;": "​", "&NegativeThinSpace;": "​", "&NegativeVeryThinSpace;": "​", "&NestedGreaterGreater;": "≫", "&NestedLessLess;": "≪", "&NewLine;": `
`, "&Nfr;": "\uD835\uDD11", "&NoBreak;": "⁠", "&NonBreakingSpace;": " ", "&Nopf;": "ℕ", "&Not;": "⫬", "&NotCongruent;": "≢", "&NotCupCap;": "≭", "&NotDoubleVerticalBar;": "∦", "&NotElement;": "∉", "&NotEqual;": "≠", "&NotEqualTilde;": "≂̸", "&NotExists;": "∄", "&NotGreater;": "≯", "&NotGreaterEqual;": "≱", "&NotGreaterFullEqual;": "≧̸", "&NotGreaterGreater;": "≫̸", "&NotGreaterLess;": "≹", "&NotGreaterSlantEqual;": "⩾̸", "&NotGreaterTilde;": "≵", "&NotHumpDownHump;": "≎̸", "&NotHumpEqual;": "≏̸", "&NotLeftTriangle;": "⋪", "&NotLeftTriangleBar;": "⧏̸", "&NotLeftTriangleEqual;": "⋬", "&NotLess;": "≮", "&NotLessEqual;": "≰", "&NotLessGreater;": "≸", "&NotLessLess;": "≪̸", "&NotLessSlantEqual;": "⩽̸", "&NotLessTilde;": "≴", "&NotNestedGreaterGreater;": "⪢̸", "&NotNestedLessLess;": "⪡̸", "&NotPrecedes;": "⊀", "&NotPrecedesEqual;": "⪯̸", "&NotPrecedesSlantEqual;": "⋠", "&NotReverseElement;": "∌", "&NotRightTriangle;": "⋫", "&NotRightTriangleBar;": "⧐̸", "&NotRightTriangleEqual;": "⋭", "&NotSquareSubset;": "⊏̸", "&NotSquareSubsetEqual;": "⋢", "&NotSquareSuperset;": "⊐̸", "&NotSquareSupersetEqual;": "⋣", "&NotSubset;": "⊂⃒", "&NotSubsetEqual;": "⊈", "&NotSucceeds;": "⊁", "&NotSucceedsEqual;": "⪰̸", "&NotSucceedsSlantEqual;": "⋡", "&NotSucceedsTilde;": "≿̸", "&NotSuperset;": "⊃⃒", "&NotSupersetEqual;": "⊉", "&NotTilde;": "≁", "&NotTildeEqual;": "≄", "&NotTildeFullEqual;": "≇", "&NotTildeTilde;": "≉", "&NotVerticalBar;": "∤", "&Nscr;": "\uD835\uDCA9", "&Ntilde": "Ñ", "&Ntilde;": "Ñ", "&Nu;": "Ν", "&OElig;": "Œ", "&Oacute": "Ó", "&Oacute;": "Ó", "&Ocirc": "Ô", "&Ocirc;": "Ô", "&Ocy;": "О", "&Odblac;": "Ő", "&Ofr;": "\uD835\uDD12", "&Ograve": "Ò", "&Ograve;": "Ò", "&Omacr;": "Ō", "&Omega;": "Ω", "&Omicron;": "Ο", "&Oopf;": "\uD835\uDD46", "&OpenCurlyDoubleQuote;": "“", "&OpenCurlyQuote;": "‘", "&Or;": "⩔", "&Oscr;": "\uD835\uDCAA", "&Oslash": "Ø", "&Oslash;": "Ø", "&Otilde": "Õ", "&Otilde;": "Õ", "&Otimes;": "⨷", "&Ouml": "Ö", "&Ouml;": "Ö", "&OverBar;": "‾", "&OverBrace;": "⏞", "&OverBracket;": "⎴", "&OverParenthesis;": "⏜", "&PartialD;": "∂", "&Pcy;": "П", "&Pfr;": "\uD835\uDD13", "&Phi;": "Φ", "&Pi;": "Π", "&PlusMinus;": "±", "&Poincareplane;": "ℌ", "&Popf;": "ℙ", "&Pr;": "⪻", "&Precedes;": "≺", "&PrecedesEqual;": "⪯", "&PrecedesSlantEqual;": "≼", "&PrecedesTilde;": "≾", "&Prime;": "″", "&Product;": "∏", "&Proportion;": "∷", "&Proportional;": "∝", "&Pscr;": "\uD835\uDCAB", "&Psi;": "Ψ", "&QUOT": '"', "&QUOT;": '"', "&Qfr;": "\uD835\uDD14", "&Qopf;": "ℚ", "&Qscr;": "\uD835\uDCAC", "&RBarr;": "⤐", "&REG": "®", "&REG;": "®", "&Racute;": "Ŕ", "&Rang;": "⟫", "&Rarr;": "↠", "&Rarrtl;": "⤖", "&Rcaron;": "Ř", "&Rcedil;": "Ŗ", "&Rcy;": "Р", "&Re;": "ℜ", "&ReverseElement;": "∋", "&ReverseEquilibrium;": "⇋", "&ReverseUpEquilibrium;": "⥯", "&Rfr;": "ℜ", "&Rho;": "Ρ", "&RightAngleBracket;": "⟩", "&RightArrow;": "→", "&RightArrowBar;": "⇥", "&RightArrowLeftArrow;": "⇄", "&RightCeiling;": "⌉", "&RightDoubleBracket;": "⟧", "&RightDownTeeVector;": "⥝", "&RightDownVector;": "⇂", "&RightDownVectorBar;": "⥕", "&RightFloor;": "⌋", "&RightTee;": "⊢", "&RightTeeArrow;": "↦", "&RightTeeVector;": "⥛", "&RightTriangle;": "⊳", "&RightTriangleBar;": "⧐", "&RightTriangleEqual;": "⊵", "&RightUpDownVector;": "⥏", "&RightUpTeeVector;": "⥜", "&RightUpVector;": "↾", "&RightUpVectorBar;": "⥔", "&RightVector;": "⇀", "&RightVectorBar;": "⥓", "&Rightarrow;": "⇒", "&Ropf;": "ℝ", "&RoundImplies;": "⥰", "&Rrightarrow;": "⇛", "&Rscr;": "ℛ", "&Rsh;": "↱", "&RuleDelayed;": "⧴", "&SHCHcy;": "Щ", "&SHcy;": "Ш", "&SOFTcy;": "Ь", "&Sacute;": "Ś", "&Sc;": "⪼", "&Scaron;": "Š", "&Scedil;": "Ş", "&Scirc;": "Ŝ", "&Scy;": "С", "&Sfr;": "\uD835\uDD16", "&ShortDownArrow;": "↓", "&ShortLeftArrow;": "←", "&ShortRightArrow;": "→", "&ShortUpArrow;": "↑", "&Sigma;": "Σ", "&SmallCircle;": "∘", "&Sopf;": "\uD835\uDD4A", "&Sqrt;": "√", "&Square;": "□", "&SquareIntersection;": "⊓", "&SquareSubset;": "⊏", "&SquareSubsetEqual;": "⊑", "&SquareSuperset;": "⊐", "&SquareSupersetEqual;": "⊒", "&SquareUnion;": "⊔", "&Sscr;": "\uD835\uDCAE", "&Star;": "⋆", "&Sub;": "⋐", "&Subset;": "⋐", "&SubsetEqual;": "⊆", "&Succeeds;": "≻", "&SucceedsEqual;": "⪰", "&SucceedsSlantEqual;": "≽", "&SucceedsTilde;": "≿", "&SuchThat;": "∋", "&Sum;": "∑", "&Sup;": "⋑", "&Superset;": "⊃", "&SupersetEqual;": "⊇", "&Supset;": "⋑", "&THORN": "Þ", "&THORN;": "Þ", "&TRADE;": "™", "&TSHcy;": "Ћ", "&TScy;": "Ц", "&Tab;": "\t", "&Tau;": "Τ", "&Tcaron;": "Ť", "&Tcedil;": "Ţ", "&Tcy;": "Т", "&Tfr;": "\uD835\uDD17", "&Therefore;": "∴", "&Theta;": "Θ", "&ThickSpace;": "  ", "&ThinSpace;": " ", "&Tilde;": "∼", "&TildeEqual;": "≃", "&TildeFullEqual;": "≅", "&TildeTilde;": "≈", "&Topf;": "\uD835\uDD4B", "&TripleDot;": "⃛", "&Tscr;": "\uD835\uDCAF", "&Tstrok;": "Ŧ", "&Uacute": "Ú", "&Uacute;": "Ú", "&Uarr;": "↟", "&Uarrocir;": "⥉", "&Ubrcy;": "Ў", "&Ubreve;": "Ŭ", "&Ucirc": "Û", "&Ucirc;": "Û", "&Ucy;": "У", "&Udblac;": "Ű", "&Ufr;": "\uD835\uDD18", "&Ugrave": "Ù", "&Ugrave;": "Ù", "&Umacr;": "Ū", "&UnderBar;": "_", "&UnderBrace;": "⏟", "&UnderBracket;": "⎵", "&UnderParenthesis;": "⏝", "&Union;": "⋃", "&UnionPlus;": "⊎", "&Uogon;": "Ų", "&Uopf;": "\uD835\uDD4C", "&UpArrow;": "↑", "&UpArrowBar;": "⤒", "&UpArrowDownArrow;": "⇅", "&UpDownArrow;": "↕", "&UpEquilibrium;": "⥮", "&UpTee;": "⊥", "&UpTeeArrow;": "↥", "&Uparrow;": "⇑", "&Updownarrow;": "⇕", "&UpperLeftArrow;": "↖", "&UpperRightArrow;": "↗", "&Upsi;": "ϒ", "&Upsilon;": "Υ", "&Uring;": "Ů", "&Uscr;": "\uD835\uDCB0", "&Utilde;": "Ũ", "&Uuml": "Ü", "&Uuml;": "Ü", "&VDash;": "⊫", "&Vbar;": "⫫", "&Vcy;": "В", "&Vdash;": "⊩", "&Vdashl;": "⫦", "&Vee;": "⋁", "&Verbar;": "‖", "&Vert;": "‖", "&VerticalBar;": "∣", "&VerticalLine;": "|", "&VerticalSeparator;": "❘", "&VerticalTilde;": "≀", "&VeryThinSpace;": " ", "&Vfr;": "\uD835\uDD19", "&Vopf;": "\uD835\uDD4D", "&Vscr;": "\uD835\uDCB1", "&Vvdash;": "⊪", "&Wcirc;": "Ŵ", "&Wedge;": "⋀", "&Wfr;": "\uD835\uDD1A", "&Wopf;": "\uD835\uDD4E", "&Wscr;": "\uD835\uDCB2", "&Xfr;": "\uD835\uDD1B", "&Xi;": "Ξ", "&Xopf;": "\uD835\uDD4F", "&Xscr;": "\uD835\uDCB3", "&YAcy;": "Я", "&YIcy;": "Ї", "&YUcy;": "Ю", "&Yacute": "Ý", "&Yacute;": "Ý", "&Ycirc;": "Ŷ", "&Ycy;": "Ы", "&Yfr;": "\uD835\uDD1C", "&Yopf;": "\uD835\uDD50", "&Yscr;": "\uD835\uDCB4", "&Yuml;": "Ÿ", "&ZHcy;": "Ж", "&Zacute;": "Ź", "&Zcaron;": "Ž", "&Zcy;": "З", "&Zdot;": "Ż", "&ZeroWidthSpace;": "​", "&Zeta;": "Ζ", "&Zfr;": "ℨ", "&Zopf;": "ℤ", "&Zscr;": "\uD835\uDCB5", "&aacute": "á", "&aacute;": "á", "&abreve;": "ă", "&ac;": "∾", "&acE;": "∾̳", "&acd;": "∿", "&acirc": "â", "&acirc;": "â", "&acute": "´", "&acute;": "´", "&acy;": "а", "&aelig": "æ", "&aelig;": "æ", "&af;": "⁡", "&afr;": "\uD835\uDD1E", "&agrave": "à", "&agrave;": "à", "&alefsym;": "ℵ", "&aleph;": "ℵ", "&alpha;": "α", "&amacr;": "ā", "&amalg;": "⨿", "&amp": "&", "&amp;": "&", "&and;": "∧", "&andand;": "⩕", "&andd;": "⩜", "&andslope;": "⩘", "&andv;": "⩚", "&ang;": "∠", "&ange;": "⦤", "&angle;": "∠", "&angmsd;": "∡", "&angmsdaa;": "⦨", "&angmsdab;": "⦩", "&angmsdac;": "⦪", "&angmsdad;": "⦫", "&angmsdae;": "⦬", "&angmsdaf;": "⦭", "&angmsdag;": "⦮", "&angmsdah;": "⦯", "&angrt;": "∟", "&angrtvb;": "⊾", "&angrtvbd;": "⦝", "&angsph;": "∢", "&angst;": "Å", "&angzarr;": "⍼", "&aogon;": "ą", "&aopf;": "\uD835\uDD52", "&ap;": "≈", "&apE;": "⩰", "&apacir;": "⩯", "&ape;": "≊", "&apid;": "≋", "&apos;": "'", "&approx;": "≈", "&approxeq;": "≊", "&aring": "å", "&aring;": "å", "&ascr;": "\uD835\uDCB6", "&ast;": "*", "&asymp;": "≈", "&asympeq;": "≍", "&atilde": "ã", "&atilde;": "ã", "&auml": "ä", "&auml;": "ä", "&awconint;": "∳", "&awint;": "⨑", "&bNot;": "⫭", "&backcong;": "≌", "&backepsilon;": "϶", "&backprime;": "‵", "&backsim;": "∽", "&backsimeq;": "⋍", "&barvee;": "⊽", "&barwed;": "⌅", "&barwedge;": "⌅", "&bbrk;": "⎵", "&bbrktbrk;": "⎶", "&bcong;": "≌", "&bcy;": "б", "&bdquo;": "„", "&becaus;": "∵", "&because;": "∵", "&bemptyv;": "⦰", "&bepsi;": "϶", "&bernou;": "ℬ", "&beta;": "β", "&beth;": "ℶ", "&between;": "≬", "&bfr;": "\uD835\uDD1F", "&bigcap;": "⋂", "&bigcirc;": "◯", "&bigcup;": "⋃", "&bigodot;": "⨀", "&bigoplus;": "⨁", "&bigotimes;": "⨂", "&bigsqcup;": "⨆", "&bigstar;": "★", "&bigtriangledown;": "▽", "&bigtriangleup;": "△", "&biguplus;": "⨄", "&bigvee;": "⋁", "&bigwedge;": "⋀", "&bkarow;": "⤍", "&blacklozenge;": "⧫", "&blacksquare;": "▪", "&blacktriangle;": "▴", "&blacktriangledown;": "▾", "&blacktriangleleft;": "◂", "&blacktriangleright;": "▸", "&blank;": "␣", "&blk12;": "▒", "&blk14;": "░", "&blk34;": "▓", "&block;": "█", "&bne;": "=⃥", "&bnequiv;": "≡⃥", "&bnot;": "⌐", "&bopf;": "\uD835\uDD53", "&bot;": "⊥", "&bottom;": "⊥", "&bowtie;": "⋈", "&boxDL;": "╗", "&boxDR;": "╔", "&boxDl;": "╖", "&boxDr;": "╓", "&boxH;": "═", "&boxHD;": "╦", "&boxHU;": "╩", "&boxHd;": "╤", "&boxHu;": "╧", "&boxUL;": "╝", "&boxUR;": "╚", "&boxUl;": "╜", "&boxUr;": "╙", "&boxV;": "║", "&boxVH;": "╬", "&boxVL;": "╣", "&boxVR;": "╠", "&boxVh;": "╫", "&boxVl;": "╢", "&boxVr;": "╟", "&boxbox;": "⧉", "&boxdL;": "╕", "&boxdR;": "╒", "&boxdl;": "┐", "&boxdr;": "┌", "&boxh;": "─", "&boxhD;": "╥", "&boxhU;": "╨", "&boxhd;": "┬", "&boxhu;": "┴", "&boxminus;": "⊟", "&boxplus;": "⊞", "&boxtimes;": "⊠", "&boxuL;": "╛", "&boxuR;": "╘", "&boxul;": "┘", "&boxur;": "└", "&boxv;": "│", "&boxvH;": "╪", "&boxvL;": "╡", "&boxvR;": "╞", "&boxvh;": "┼", "&boxvl;": "┤", "&boxvr;": "├", "&bprime;": "‵", "&breve;": "˘", "&brvbar": "¦", "&brvbar;": "¦", "&bscr;": "\uD835\uDCB7", "&bsemi;": "⁏", "&bsim;": "∽", "&bsime;": "⋍", "&bsol;": "\\", "&bsolb;": "⧅", "&bsolhsub;": "⟈", "&bull;": "•", "&bullet;": "•", "&bump;": "≎", "&bumpE;": "⪮", "&bumpe;": "≏", "&bumpeq;": "≏", "&cacute;": "ć", "&cap;": "∩", "&capand;": "⩄", "&capbrcup;": "⩉", "&capcap;": "⩋", "&capcup;": "⩇", "&capdot;": "⩀", "&caps;": "∩︀", "&caret;": "⁁", "&caron;": "ˇ", "&ccaps;": "⩍", "&ccaron;": "č", "&ccedil": "ç", "&ccedil;": "ç", "&ccirc;": "ĉ", "&ccups;": "⩌", "&ccupssm;": "⩐", "&cdot;": "ċ", "&cedil": "¸", "&cedil;": "¸", "&cemptyv;": "⦲", "&cent": "¢", "&cent;": "¢", "&centerdot;": "·", "&cfr;": "\uD835\uDD20", "&chcy;": "ч", "&check;": "✓", "&checkmark;": "✓", "&chi;": "χ", "&cir;": "○", "&cirE;": "⧃", "&circ;": "ˆ", "&circeq;": "≗", "&circlearrowleft;": "↺", "&circlearrowright;": "↻", "&circledR;": "®", "&circledS;": "Ⓢ", "&circledast;": "⊛", "&circledcirc;": "⊚", "&circleddash;": "⊝", "&cire;": "≗", "&cirfnint;": "⨐", "&cirmid;": "⫯", "&cirscir;": "⧂", "&clubs;": "♣", "&clubsuit;": "♣", "&colon;": ":", "&colone;": "≔", "&coloneq;": "≔", "&comma;": ",", "&commat;": "@", "&comp;": "∁", "&compfn;": "∘", "&complement;": "∁", "&complexes;": "ℂ", "&cong;": "≅", "&congdot;": "⩭", "&conint;": "∮", "&copf;": "\uD835\uDD54", "&coprod;": "∐", "&copy": "©", "&copy;": "©", "&copysr;": "℗", "&crarr;": "↵", "&cross;": "✗", "&cscr;": "\uD835\uDCB8", "&csub;": "⫏", "&csube;": "⫑", "&csup;": "⫐", "&csupe;": "⫒", "&ctdot;": "⋯", "&cudarrl;": "⤸", "&cudarrr;": "⤵", "&cuepr;": "⋞", "&cuesc;": "⋟", "&cularr;": "↶", "&cularrp;": "⤽", "&cup;": "∪", "&cupbrcap;": "⩈", "&cupcap;": "⩆", "&cupcup;": "⩊", "&cupdot;": "⊍", "&cupor;": "⩅", "&cups;": "∪︀", "&curarr;": "↷", "&curarrm;": "⤼", "&curlyeqprec;": "⋞", "&curlyeqsucc;": "⋟", "&curlyvee;": "⋎", "&curlywedge;": "⋏", "&curren": "¤", "&curren;": "¤", "&curvearrowleft;": "↶", "&curvearrowright;": "↷", "&cuvee;": "⋎", "&cuwed;": "⋏", "&cwconint;": "∲", "&cwint;": "∱", "&cylcty;": "⌭", "&dArr;": "⇓", "&dHar;": "⥥", "&dagger;": "†", "&daleth;": "ℸ", "&darr;": "↓", "&dash;": "‐", "&dashv;": "⊣", "&dbkarow;": "⤏", "&dblac;": "˝", "&dcaron;": "ď", "&dcy;": "д", "&dd;": "ⅆ", "&ddagger;": "‡", "&ddarr;": "⇊", "&ddotseq;": "⩷", "&deg": "°", "&deg;": "°", "&delta;": "δ", "&demptyv;": "⦱", "&dfisht;": "⥿", "&dfr;": "\uD835\uDD21", "&dharl;": "⇃", "&dharr;": "⇂", "&diam;": "⋄", "&diamond;": "⋄", "&diamondsuit;": "♦", "&diams;": "♦", "&die;": "¨", "&digamma;": "ϝ", "&disin;": "⋲", "&div;": "÷", "&divide": "÷", "&divide;": "÷", "&divideontimes;": "⋇", "&divonx;": "⋇", "&djcy;": "ђ", "&dlcorn;": "⌞", "&dlcrop;": "⌍", "&dollar;": "$", "&dopf;": "\uD835\uDD55", "&dot;": "˙", "&doteq;": "≐", "&doteqdot;": "≑", "&dotminus;": "∸", "&dotplus;": "∔", "&dotsquare;": "⊡", "&doublebarwedge;": "⌆", "&downarrow;": "↓", "&downdownarrows;": "⇊", "&downharpoonleft;": "⇃", "&downharpoonright;": "⇂", "&drbkarow;": "⤐", "&drcorn;": "⌟", "&drcrop;": "⌌", "&dscr;": "\uD835\uDCB9", "&dscy;": "ѕ", "&dsol;": "⧶", "&dstrok;": "đ", "&dtdot;": "⋱", "&dtri;": "▿", "&dtrif;": "▾", "&duarr;": "⇵", "&duhar;": "⥯", "&dwangle;": "⦦", "&dzcy;": "џ", "&dzigrarr;": "⟿", "&eDDot;": "⩷", "&eDot;": "≑", "&eacute": "é", "&eacute;": "é", "&easter;": "⩮", "&ecaron;": "ě", "&ecir;": "≖", "&ecirc": "ê", "&ecirc;": "ê", "&ecolon;": "≕", "&ecy;": "э", "&edot;": "ė", "&ee;": "ⅇ", "&efDot;": "≒", "&efr;": "\uD835\uDD22", "&eg;": "⪚", "&egrave": "è", "&egrave;": "è", "&egs;": "⪖", "&egsdot;": "⪘", "&el;": "⪙", "&elinters;": "⏧", "&ell;": "ℓ", "&els;": "⪕", "&elsdot;": "⪗", "&emacr;": "ē", "&empty;": "∅", "&emptyset;": "∅", "&emptyv;": "∅", "&emsp13;": " ", "&emsp14;": " ", "&emsp;": " ", "&eng;": "ŋ", "&ensp;": " ", "&eogon;": "ę", "&eopf;": "\uD835\uDD56", "&epar;": "⋕", "&eparsl;": "⧣", "&eplus;": "⩱", "&epsi;": "ε", "&epsilon;": "ε", "&epsiv;": "ϵ", "&eqcirc;": "≖", "&eqcolon;": "≕", "&eqsim;": "≂", "&eqslantgtr;": "⪖", "&eqslantless;": "⪕", "&equals;": "=", "&equest;": "≟", "&equiv;": "≡", "&equivDD;": "⩸", "&eqvparsl;": "⧥", "&erDot;": "≓", "&erarr;": "⥱", "&escr;": "ℯ", "&esdot;": "≐", "&esim;": "≂", "&eta;": "η", "&eth": "ð", "&eth;": "ð", "&euml": "ë", "&euml;": "ë", "&euro;": "€", "&excl;": "!", "&exist;": "∃", "&expectation;": "ℰ", "&exponentiale;": "ⅇ", "&fallingdotseq;": "≒", "&fcy;": "ф", "&female;": "♀", "&ffilig;": "ﬃ", "&fflig;": "ﬀ", "&ffllig;": "ﬄ", "&ffr;": "\uD835\uDD23", "&filig;": "ﬁ", "&fjlig;": "fj", "&flat;": "♭", "&fllig;": "ﬂ", "&fltns;": "▱", "&fnof;": "ƒ", "&fopf;": "\uD835\uDD57", "&forall;": "∀", "&fork;": "⋔", "&forkv;": "⫙", "&fpartint;": "⨍", "&frac12": "½", "&frac12;": "½", "&frac13;": "⅓", "&frac14": "¼", "&frac14;": "¼", "&frac15;": "⅕", "&frac16;": "⅙", "&frac18;": "⅛", "&frac23;": "⅔", "&frac25;": "⅖", "&frac34": "¾", "&frac34;": "¾", "&frac35;": "⅗", "&frac38;": "⅜", "&frac45;": "⅘", "&frac56;": "⅚", "&frac58;": "⅝", "&frac78;": "⅞", "&frasl;": "⁄", "&frown;": "⌢", "&fscr;": "\uD835\uDCBB", "&gE;": "≧", "&gEl;": "⪌", "&gacute;": "ǵ", "&gamma;": "γ", "&gammad;": "ϝ", "&gap;": "⪆", "&gbreve;": "ğ", "&gcirc;": "ĝ", "&gcy;": "г", "&gdot;": "ġ", "&ge;": "≥", "&gel;": "⋛", "&geq;": "≥", "&geqq;": "≧", "&geqslant;": "⩾", "&ges;": "⩾", "&gescc;": "⪩", "&gesdot;": "⪀", "&gesdoto;": "⪂", "&gesdotol;": "⪄", "&gesl;": "⋛︀", "&gesles;": "⪔", "&gfr;": "\uD835\uDD24", "&gg;": "≫", "&ggg;": "⋙", "&gimel;": "ℷ", "&gjcy;": "ѓ", "&gl;": "≷", "&glE;": "⪒", "&gla;": "⪥", "&glj;": "⪤", "&gnE;": "≩", "&gnap;": "⪊", "&gnapprox;": "⪊", "&gne;": "⪈", "&gneq;": "⪈", "&gneqq;": "≩", "&gnsim;": "⋧", "&gopf;": "\uD835\uDD58", "&grave;": "`", "&gscr;": "ℊ", "&gsim;": "≳", "&gsime;": "⪎", "&gsiml;": "⪐", "&gt": ">", "&gt;": ">", "&gtcc;": "⪧", "&gtcir;": "⩺", "&gtdot;": "⋗", "&gtlPar;": "⦕", "&gtquest;": "⩼", "&gtrapprox;": "⪆", "&gtrarr;": "⥸", "&gtrdot;": "⋗", "&gtreqless;": "⋛", "&gtreqqless;": "⪌", "&gtrless;": "≷", "&gtrsim;": "≳", "&gvertneqq;": "≩︀", "&gvnE;": "≩︀", "&hArr;": "⇔", "&hairsp;": " ", "&half;": "½", "&hamilt;": "ℋ", "&hardcy;": "ъ", "&harr;": "↔", "&harrcir;": "⥈", "&harrw;": "↭", "&hbar;": "ℏ", "&hcirc;": "ĥ", "&hearts;": "♥", "&heartsuit;": "♥", "&hellip;": "…", "&hercon;": "⊹", "&hfr;": "\uD835\uDD25", "&hksearow;": "⤥", "&hkswarow;": "⤦", "&hoarr;": "⇿", "&homtht;": "∻", "&hookleftarrow;": "↩", "&hookrightarrow;": "↪", "&hopf;": "\uD835\uDD59", "&horbar;": "―", "&hscr;": "\uD835\uDCBD", "&hslash;": "ℏ", "&hstrok;": "ħ", "&hybull;": "⁃", "&hyphen;": "‐", "&iacute": "í", "&iacute;": "í", "&ic;": "⁣", "&icirc": "î", "&icirc;": "î", "&icy;": "и", "&iecy;": "е", "&iexcl": "¡", "&iexcl;": "¡", "&iff;": "⇔", "&ifr;": "\uD835\uDD26", "&igrave": "ì", "&igrave;": "ì", "&ii;": "ⅈ", "&iiiint;": "⨌", "&iiint;": "∭", "&iinfin;": "⧜", "&iiota;": "℩", "&ijlig;": "ĳ", "&imacr;": "ī", "&image;": "ℑ", "&imagline;": "ℐ", "&imagpart;": "ℑ", "&imath;": "ı", "&imof;": "⊷", "&imped;": "Ƶ", "&in;": "∈", "&incare;": "℅", "&infin;": "∞", "&infintie;": "⧝", "&inodot;": "ı", "&int;": "∫", "&intcal;": "⊺", "&integers;": "ℤ", "&intercal;": "⊺", "&intlarhk;": "⨗", "&intprod;": "⨼", "&iocy;": "ё", "&iogon;": "į", "&iopf;": "\uD835\uDD5A", "&iota;": "ι", "&iprod;": "⨼", "&iquest": "¿", "&iquest;": "¿", "&iscr;": "\uD835\uDCBE", "&isin;": "∈", "&isinE;": "⋹", "&isindot;": "⋵", "&isins;": "⋴", "&isinsv;": "⋳", "&isinv;": "∈", "&it;": "⁢", "&itilde;": "ĩ", "&iukcy;": "і", "&iuml": "ï", "&iuml;": "ï", "&jcirc;": "ĵ", "&jcy;": "й", "&jfr;": "\uD835\uDD27", "&jmath;": "ȷ", "&jopf;": "\uD835\uDD5B", "&jscr;": "\uD835\uDCBF", "&jsercy;": "ј", "&jukcy;": "є", "&kappa;": "κ", "&kappav;": "ϰ", "&kcedil;": "ķ", "&kcy;": "к", "&kfr;": "\uD835\uDD28", "&kgreen;": "ĸ", "&khcy;": "х", "&kjcy;": "ќ", "&kopf;": "\uD835\uDD5C", "&kscr;": "\uD835\uDCC0", "&lAarr;": "⇚", "&lArr;": "⇐", "&lAtail;": "⤛", "&lBarr;": "⤎", "&lE;": "≦", "&lEg;": "⪋", "&lHar;": "⥢", "&lacute;": "ĺ", "&laemptyv;": "⦴", "&lagran;": "ℒ", "&lambda;": "λ", "&lang;": "⟨", "&langd;": "⦑", "&langle;": "⟨", "&lap;": "⪅", "&laquo": "«", "&laquo;": "«", "&larr;": "←", "&larrb;": "⇤", "&larrbfs;": "⤟", "&larrfs;": "⤝", "&larrhk;": "↩", "&larrlp;": "↫", "&larrpl;": "⤹", "&larrsim;": "⥳", "&larrtl;": "↢", "&lat;": "⪫", "&latail;": "⤙", "&late;": "⪭", "&lates;": "⪭︀", "&lbarr;": "⤌", "&lbbrk;": "❲", "&lbrace;": "{", "&lbrack;": "[", "&lbrke;": "⦋", "&lbrksld;": "⦏", "&lbrkslu;": "⦍", "&lcaron;": "ľ", "&lcedil;": "ļ", "&lceil;": "⌈", "&lcub;": "{", "&lcy;": "л", "&ldca;": "⤶", "&ldquo;": "“", "&ldquor;": "„", "&ldrdhar;": "⥧", "&ldrushar;": "⥋", "&ldsh;": "↲", "&le;": "≤", "&leftarrow;": "←", "&leftarrowtail;": "↢", "&leftharpoondown;": "↽", "&leftharpoonup;": "↼", "&leftleftarrows;": "⇇", "&leftrightarrow;": "↔", "&leftrightarrows;": "⇆", "&leftrightharpoons;": "⇋", "&leftrightsquigarrow;": "↭", "&leftthreetimes;": "⋋", "&leg;": "⋚", "&leq;": "≤", "&leqq;": "≦", "&leqslant;": "⩽", "&les;": "⩽", "&lescc;": "⪨", "&lesdot;": "⩿", "&lesdoto;": "⪁", "&lesdotor;": "⪃", "&lesg;": "⋚︀", "&lesges;": "⪓", "&lessapprox;": "⪅", "&lessdot;": "⋖", "&lesseqgtr;": "⋚", "&lesseqqgtr;": "⪋", "&lessgtr;": "≶", "&lesssim;": "≲", "&lfisht;": "⥼", "&lfloor;": "⌊", "&lfr;": "\uD835\uDD29", "&lg;": "≶", "&lgE;": "⪑", "&lhard;": "↽", "&lharu;": "↼", "&lharul;": "⥪", "&lhblk;": "▄", "&ljcy;": "љ", "&ll;": "≪", "&llarr;": "⇇", "&llcorner;": "⌞", "&llhard;": "⥫", "&lltri;": "◺", "&lmidot;": "ŀ", "&lmoust;": "⎰", "&lmoustache;": "⎰", "&lnE;": "≨", "&lnap;": "⪉", "&lnapprox;": "⪉", "&lne;": "⪇", "&lneq;": "⪇", "&lneqq;": "≨", "&lnsim;": "⋦", "&loang;": "⟬", "&loarr;": "⇽", "&lobrk;": "⟦", "&longleftarrow;": "⟵", "&longleftrightarrow;": "⟷", "&longmapsto;": "⟼", "&longrightarrow;": "⟶", "&looparrowleft;": "↫", "&looparrowright;": "↬", "&lopar;": "⦅", "&lopf;": "\uD835\uDD5D", "&loplus;": "⨭", "&lotimes;": "⨴", "&lowast;": "∗", "&lowbar;": "_", "&loz;": "◊", "&lozenge;": "◊", "&lozf;": "⧫", "&lpar;": "(", "&lparlt;": "⦓", "&lrarr;": "⇆", "&lrcorner;": "⌟", "&lrhar;": "⇋", "&lrhard;": "⥭", "&lrm;": "‎", "&lrtri;": "⊿", "&lsaquo;": "‹", "&lscr;": "\uD835\uDCC1", "&lsh;": "↰", "&lsim;": "≲", "&lsime;": "⪍", "&lsimg;": "⪏", "&lsqb;": "[", "&lsquo;": "‘", "&lsquor;": "‚", "&lstrok;": "ł", "&lt": "<", "&lt;": "<", "&ltcc;": "⪦", "&ltcir;": "⩹", "&ltdot;": "⋖", "&lthree;": "⋋", "&ltimes;": "⋉", "&ltlarr;": "⥶", "&ltquest;": "⩻", "&ltrPar;": "⦖", "&ltri;": "◃", "&ltrie;": "⊴", "&ltrif;": "◂", "&lurdshar;": "⥊", "&luruhar;": "⥦", "&lvertneqq;": "≨︀", "&lvnE;": "≨︀", "&mDDot;": "∺", "&macr": "¯", "&macr;": "¯", "&male;": "♂", "&malt;": "✠", "&maltese;": "✠", "&map;": "↦", "&mapsto;": "↦", "&mapstodown;": "↧", "&mapstoleft;": "↤", "&mapstoup;": "↥", "&marker;": "▮", "&mcomma;": "⨩", "&mcy;": "м", "&mdash;": "—", "&measuredangle;": "∡", "&mfr;": "\uD835\uDD2A", "&mho;": "℧", "&micro": "µ", "&micro;": "µ", "&mid;": "∣", "&midast;": "*", "&midcir;": "⫰", "&middot": "·", "&middot;": "·", "&minus;": "−", "&minusb;": "⊟", "&minusd;": "∸", "&minusdu;": "⨪", "&mlcp;": "⫛", "&mldr;": "…", "&mnplus;": "∓", "&models;": "⊧", "&mopf;": "\uD835\uDD5E", "&mp;": "∓", "&mscr;": "\uD835\uDCC2", "&mstpos;": "∾", "&mu;": "μ", "&multimap;": "⊸", "&mumap;": "⊸", "&nGg;": "⋙̸", "&nGt;": "≫⃒", "&nGtv;": "≫̸", "&nLeftarrow;": "⇍", "&nLeftrightarrow;": "⇎", "&nLl;": "⋘̸", "&nLt;": "≪⃒", "&nLtv;": "≪̸", "&nRightarrow;": "⇏", "&nVDash;": "⊯", "&nVdash;": "⊮", "&nabla;": "∇", "&nacute;": "ń", "&nang;": "∠⃒", "&nap;": "≉", "&napE;": "⩰̸", "&napid;": "≋̸", "&napos;": "ŉ", "&napprox;": "≉", "&natur;": "♮", "&natural;": "♮", "&naturals;": "ℕ", "&nbsp": " ", "&nbsp;": " ", "&nbump;": "≎̸", "&nbumpe;": "≏̸", "&ncap;": "⩃", "&ncaron;": "ň", "&ncedil;": "ņ", "&ncong;": "≇", "&ncongdot;": "⩭̸", "&ncup;": "⩂", "&ncy;": "н", "&ndash;": "–", "&ne;": "≠", "&neArr;": "⇗", "&nearhk;": "⤤", "&nearr;": "↗", "&nearrow;": "↗", "&nedot;": "≐̸", "&nequiv;": "≢", "&nesear;": "⤨", "&nesim;": "≂̸", "&nexist;": "∄", "&nexists;": "∄", "&nfr;": "\uD835\uDD2B", "&ngE;": "≧̸", "&nge;": "≱", "&ngeq;": "≱", "&ngeqq;": "≧̸", "&ngeqslant;": "⩾̸", "&nges;": "⩾̸", "&ngsim;": "≵", "&ngt;": "≯", "&ngtr;": "≯", "&nhArr;": "⇎", "&nharr;": "↮", "&nhpar;": "⫲", "&ni;": "∋", "&nis;": "⋼", "&nisd;": "⋺", "&niv;": "∋", "&njcy;": "њ", "&nlArr;": "⇍", "&nlE;": "≦̸", "&nlarr;": "↚", "&nldr;": "‥", "&nle;": "≰", "&nleftarrow;": "↚", "&nleftrightarrow;": "↮", "&nleq;": "≰", "&nleqq;": "≦̸", "&nleqslant;": "⩽̸", "&nles;": "⩽̸", "&nless;": "≮", "&nlsim;": "≴", "&nlt;": "≮", "&nltri;": "⋪", "&nltrie;": "⋬", "&nmid;": "∤", "&nopf;": "\uD835\uDD5F", "&not": "¬", "&not;": "¬", "&notin;": "∉", "&notinE;": "⋹̸", "&notindot;": "⋵̸", "&notinva;": "∉", "&notinvb;": "⋷", "&notinvc;": "⋶", "&notni;": "∌", "&notniva;": "∌", "&notnivb;": "⋾", "&notnivc;": "⋽", "&npar;": "∦", "&nparallel;": "∦", "&nparsl;": "⫽⃥", "&npart;": "∂̸", "&npolint;": "⨔", "&npr;": "⊀", "&nprcue;": "⋠", "&npre;": "⪯̸", "&nprec;": "⊀", "&npreceq;": "⪯̸", "&nrArr;": "⇏", "&nrarr;": "↛", "&nrarrc;": "⤳̸", "&nrarrw;": "↝̸", "&nrightarrow;": "↛", "&nrtri;": "⋫", "&nrtrie;": "⋭", "&nsc;": "⊁", "&nsccue;": "⋡", "&nsce;": "⪰̸", "&nscr;": "\uD835\uDCC3", "&nshortmid;": "∤", "&nshortparallel;": "∦", "&nsim;": "≁", "&nsime;": "≄", "&nsimeq;": "≄", "&nsmid;": "∤", "&nspar;": "∦", "&nsqsube;": "⋢", "&nsqsupe;": "⋣", "&nsub;": "⊄", "&nsubE;": "⫅̸", "&nsube;": "⊈", "&nsubset;": "⊂⃒", "&nsubseteq;": "⊈", "&nsubseteqq;": "⫅̸", "&nsucc;": "⊁", "&nsucceq;": "⪰̸", "&nsup;": "⊅", "&nsupE;": "⫆̸", "&nsupe;": "⊉", "&nsupset;": "⊃⃒", "&nsupseteq;": "⊉", "&nsupseteqq;": "⫆̸", "&ntgl;": "≹", "&ntilde": "ñ", "&ntilde;": "ñ", "&ntlg;": "≸", "&ntriangleleft;": "⋪", "&ntrianglelefteq;": "⋬", "&ntriangleright;": "⋫", "&ntrianglerighteq;": "⋭", "&nu;": "ν", "&num;": "#", "&numero;": "№", "&numsp;": " ", "&nvDash;": "⊭", "&nvHarr;": "⤄", "&nvap;": "≍⃒", "&nvdash;": "⊬", "&nvge;": "≥⃒", "&nvgt;": ">⃒", "&nvinfin;": "⧞", "&nvlArr;": "⤂", "&nvle;": "≤⃒", "&nvlt;": "<⃒", "&nvltrie;": "⊴⃒", "&nvrArr;": "⤃", "&nvrtrie;": "⊵⃒", "&nvsim;": "∼⃒", "&nwArr;": "⇖", "&nwarhk;": "⤣", "&nwarr;": "↖", "&nwarrow;": "↖", "&nwnear;": "⤧", "&oS;": "Ⓢ", "&oacute": "ó", "&oacute;": "ó", "&oast;": "⊛", "&ocir;": "⊚", "&ocirc": "ô", "&ocirc;": "ô", "&ocy;": "о", "&odash;": "⊝", "&odblac;": "ő", "&odiv;": "⨸", "&odot;": "⊙", "&odsold;": "⦼", "&oelig;": "œ", "&ofcir;": "⦿", "&ofr;": "\uD835\uDD2C", "&ogon;": "˛", "&ograve": "ò", "&ograve;": "ò", "&ogt;": "⧁", "&ohbar;": "⦵", "&ohm;": "Ω", "&oint;": "∮", "&olarr;": "↺", "&olcir;": "⦾", "&olcross;": "⦻", "&oline;": "‾", "&olt;": "⧀", "&omacr;": "ō", "&omega;": "ω", "&omicron;": "ο", "&omid;": "⦶", "&ominus;": "⊖", "&oopf;": "\uD835\uDD60", "&opar;": "⦷", "&operp;": "⦹", "&oplus;": "⊕", "&or;": "∨", "&orarr;": "↻", "&ord;": "⩝", "&order;": "ℴ", "&orderof;": "ℴ", "&ordf": "ª", "&ordf;": "ª", "&ordm": "º", "&ordm;": "º", "&origof;": "⊶", "&oror;": "⩖", "&orslope;": "⩗", "&orv;": "⩛", "&oscr;": "ℴ", "&oslash": "ø", "&oslash;": "ø", "&osol;": "⊘", "&otilde": "õ", "&otilde;": "õ", "&otimes;": "⊗", "&otimesas;": "⨶", "&ouml": "ö", "&ouml;": "ö", "&ovbar;": "⌽", "&par;": "∥", "&para": "¶", "&para;": "¶", "&parallel;": "∥", "&parsim;": "⫳", "&parsl;": "⫽", "&part;": "∂", "&pcy;": "п", "&percnt;": "%", "&period;": ".", "&permil;": "‰", "&perp;": "⊥", "&pertenk;": "‱", "&pfr;": "\uD835\uDD2D", "&phi;": "φ", "&phiv;": "ϕ", "&phmmat;": "ℳ", "&phone;": "☎", "&pi;": "π", "&pitchfork;": "⋔", "&piv;": "ϖ", "&planck;": "ℏ", "&planckh;": "ℎ", "&plankv;": "ℏ", "&plus;": "+", "&plusacir;": "⨣", "&plusb;": "⊞", "&pluscir;": "⨢", "&plusdo;": "∔", "&plusdu;": "⨥", "&pluse;": "⩲", "&plusmn": "±", "&plusmn;": "±", "&plussim;": "⨦", "&plustwo;": "⨧", "&pm;": "±", "&pointint;": "⨕", "&popf;": "\uD835\uDD61", "&pound": "£", "&pound;": "£", "&pr;": "≺", "&prE;": "⪳", "&prap;": "⪷", "&prcue;": "≼", "&pre;": "⪯", "&prec;": "≺", "&precapprox;": "⪷", "&preccurlyeq;": "≼", "&preceq;": "⪯", "&precnapprox;": "⪹", "&precneqq;": "⪵", "&precnsim;": "⋨", "&precsim;": "≾", "&prime;": "′", "&primes;": "ℙ", "&prnE;": "⪵", "&prnap;": "⪹", "&prnsim;": "⋨", "&prod;": "∏", "&profalar;": "⌮", "&profline;": "⌒", "&profsurf;": "⌓", "&prop;": "∝", "&propto;": "∝", "&prsim;": "≾", "&prurel;": "⊰", "&pscr;": "\uD835\uDCC5", "&psi;": "ψ", "&puncsp;": " ", "&qfr;": "\uD835\uDD2E", "&qint;": "⨌", "&qopf;": "\uD835\uDD62", "&qprime;": "⁗", "&qscr;": "\uD835\uDCC6", "&quaternions;": "ℍ", "&quatint;": "⨖", "&quest;": "?", "&questeq;": "≟", "&quot": '"', "&quot;": '"', "&rAarr;": "⇛", "&rArr;": "⇒", "&rAtail;": "⤜", "&rBarr;": "⤏", "&rHar;": "⥤", "&race;": "∽̱", "&racute;": "ŕ", "&radic;": "√", "&raemptyv;": "⦳", "&rang;": "⟩", "&rangd;": "⦒", "&range;": "⦥", "&rangle;": "⟩", "&raquo": "»", "&raquo;": "»", "&rarr;": "→", "&rarrap;": "⥵", "&rarrb;": "⇥", "&rarrbfs;": "⤠", "&rarrc;": "⤳", "&rarrfs;": "⤞", "&rarrhk;": "↪", "&rarrlp;": "↬", "&rarrpl;": "⥅", "&rarrsim;": "⥴", "&rarrtl;": "↣", "&rarrw;": "↝", "&ratail;": "⤚", "&ratio;": "∶", "&rationals;": "ℚ", "&rbarr;": "⤍", "&rbbrk;": "❳", "&rbrace;": "}", "&rbrack;": "]", "&rbrke;": "⦌", "&rbrksld;": "⦎", "&rbrkslu;": "⦐", "&rcaron;": "ř", "&rcedil;": "ŗ", "&rceil;": "⌉", "&rcub;": "}", "&rcy;": "р", "&rdca;": "⤷", "&rdldhar;": "⥩", "&rdquo;": "”", "&rdquor;": "”", "&rdsh;": "↳", "&real;": "ℜ", "&realine;": "ℛ", "&realpart;": "ℜ", "&reals;": "ℝ", "&rect;": "▭", "&reg": "®", "&reg;": "®", "&rfisht;": "⥽", "&rfloor;": "⌋", "&rfr;": "\uD835\uDD2F", "&rhard;": "⇁", "&rharu;": "⇀", "&rharul;": "⥬", "&rho;": "ρ", "&rhov;": "ϱ", "&rightarrow;": "→", "&rightarrowtail;": "↣", "&rightharpoondown;": "⇁", "&rightharpoonup;": "⇀", "&rightleftarrows;": "⇄", "&rightleftharpoons;": "⇌", "&rightrightarrows;": "⇉", "&rightsquigarrow;": "↝", "&rightthreetimes;": "⋌", "&ring;": "˚", "&risingdotseq;": "≓", "&rlarr;": "⇄", "&rlhar;": "⇌", "&rlm;": "‏", "&rmoust;": "⎱", "&rmoustache;": "⎱", "&rnmid;": "⫮", "&roang;": "⟭", "&roarr;": "⇾", "&robrk;": "⟧", "&ropar;": "⦆", "&ropf;": "\uD835\uDD63", "&roplus;": "⨮", "&rotimes;": "⨵", "&rpar;": ")", "&rpargt;": "⦔", "&rppolint;": "⨒", "&rrarr;": "⇉", "&rsaquo;": "›", "&rscr;": "\uD835\uDCC7", "&rsh;": "↱", "&rsqb;": "]", "&rsquo;": "’", "&rsquor;": "’", "&rthree;": "⋌", "&rtimes;": "⋊", "&rtri;": "▹", "&rtrie;": "⊵", "&rtrif;": "▸", "&rtriltri;": "⧎", "&ruluhar;": "⥨", "&rx;": "℞", "&sacute;": "ś", "&sbquo;": "‚", "&sc;": "≻", "&scE;": "⪴", "&scap;": "⪸", "&scaron;": "š", "&sccue;": "≽", "&sce;": "⪰", "&scedil;": "ş", "&scirc;": "ŝ", "&scnE;": "⪶", "&scnap;": "⪺", "&scnsim;": "⋩", "&scpolint;": "⨓", "&scsim;": "≿", "&scy;": "с", "&sdot;": "⋅", "&sdotb;": "⊡", "&sdote;": "⩦", "&seArr;": "⇘", "&searhk;": "⤥", "&searr;": "↘", "&searrow;": "↘", "&sect": "§", "&sect;": "§", "&semi;": ";", "&seswar;": "⤩", "&setminus;": "∖", "&setmn;": "∖", "&sext;": "✶", "&sfr;": "\uD835\uDD30", "&sfrown;": "⌢", "&sharp;": "♯", "&shchcy;": "щ", "&shcy;": "ш", "&shortmid;": "∣", "&shortparallel;": "∥", "&shy": "­", "&shy;": "­", "&sigma;": "σ", "&sigmaf;": "ς", "&sigmav;": "ς", "&sim;": "∼", "&simdot;": "⩪", "&sime;": "≃", "&simeq;": "≃", "&simg;": "⪞", "&simgE;": "⪠", "&siml;": "⪝", "&simlE;": "⪟", "&simne;": "≆", "&simplus;": "⨤", "&simrarr;": "⥲", "&slarr;": "←", "&smallsetminus;": "∖", "&smashp;": "⨳", "&smeparsl;": "⧤", "&smid;": "∣", "&smile;": "⌣", "&smt;": "⪪", "&smte;": "⪬", "&smtes;": "⪬︀", "&softcy;": "ь", "&sol;": "/", "&solb;": "⧄", "&solbar;": "⌿", "&sopf;": "\uD835\uDD64", "&spades;": "♠", "&spadesuit;": "♠", "&spar;": "∥", "&sqcap;": "⊓", "&sqcaps;": "⊓︀", "&sqcup;": "⊔", "&sqcups;": "⊔︀", "&sqsub;": "⊏", "&sqsube;": "⊑", "&sqsubset;": "⊏", "&sqsubseteq;": "⊑", "&sqsup;": "⊐", "&sqsupe;": "⊒", "&sqsupset;": "⊐", "&sqsupseteq;": "⊒", "&squ;": "□", "&square;": "□", "&squarf;": "▪", "&squf;": "▪", "&srarr;": "→", "&sscr;": "\uD835\uDCC8", "&ssetmn;": "∖", "&ssmile;": "⌣", "&sstarf;": "⋆", "&star;": "☆", "&starf;": "★", "&straightepsilon;": "ϵ", "&straightphi;": "ϕ", "&strns;": "¯", "&sub;": "⊂", "&subE;": "⫅", "&subdot;": "⪽", "&sube;": "⊆", "&subedot;": "⫃", "&submult;": "⫁", "&subnE;": "⫋", "&subne;": "⊊", "&subplus;": "⪿", "&subrarr;": "⥹", "&subset;": "⊂", "&subseteq;": "⊆", "&subseteqq;": "⫅", "&subsetneq;": "⊊", "&subsetneqq;": "⫋", "&subsim;": "⫇", "&subsub;": "⫕", "&subsup;": "⫓", "&succ;": "≻", "&succapprox;": "⪸", "&succcurlyeq;": "≽", "&succeq;": "⪰", "&succnapprox;": "⪺", "&succneqq;": "⪶", "&succnsim;": "⋩", "&succsim;": "≿", "&sum;": "∑", "&sung;": "♪", "&sup1": "¹", "&sup1;": "¹", "&sup2": "²", "&sup2;": "²", "&sup3": "³", "&sup3;": "³", "&sup;": "⊃", "&supE;": "⫆", "&supdot;": "⪾", "&supdsub;": "⫘", "&supe;": "⊇", "&supedot;": "⫄", "&suphsol;": "⟉", "&suphsub;": "⫗", "&suplarr;": "⥻", "&supmult;": "⫂", "&supnE;": "⫌", "&supne;": "⊋", "&supplus;": "⫀", "&supset;": "⊃", "&supseteq;": "⊇", "&supseteqq;": "⫆", "&supsetneq;": "⊋", "&supsetneqq;": "⫌", "&supsim;": "⫈", "&supsub;": "⫔", "&supsup;": "⫖", "&swArr;": "⇙", "&swarhk;": "⤦", "&swarr;": "↙", "&swarrow;": "↙", "&swnwar;": "⤪", "&szlig": "ß", "&szlig;": "ß", "&target;": "⌖", "&tau;": "τ", "&tbrk;": "⎴", "&tcaron;": "ť", "&tcedil;": "ţ", "&tcy;": "т", "&tdot;": "⃛", "&telrec;": "⌕", "&tfr;": "\uD835\uDD31", "&there4;": "∴", "&therefore;": "∴", "&theta;": "θ", "&thetasym;": "ϑ", "&thetav;": "ϑ", "&thickapprox;": "≈", "&thicksim;": "∼", "&thinsp;": " ", "&thkap;": "≈", "&thksim;": "∼", "&thorn": "þ", "&thorn;": "þ", "&tilde;": "˜", "&times": "×", "&times;": "×", "&timesb;": "⊠", "&timesbar;": "⨱", "&timesd;": "⨰", "&tint;": "∭", "&toea;": "⤨", "&top;": "⊤", "&topbot;": "⌶", "&topcir;": "⫱", "&topf;": "\uD835\uDD65", "&topfork;": "⫚", "&tosa;": "⤩", "&tprime;": "‴", "&trade;": "™", "&triangle;": "▵", "&triangledown;": "▿", "&triangleleft;": "◃", "&trianglelefteq;": "⊴", "&triangleq;": "≜", "&triangleright;": "▹", "&trianglerighteq;": "⊵", "&tridot;": "◬", "&trie;": "≜", "&triminus;": "⨺", "&triplus;": "⨹", "&trisb;": "⧍", "&tritime;": "⨻", "&trpezium;": "⏢", "&tscr;": "\uD835\uDCC9", "&tscy;": "ц", "&tshcy;": "ћ", "&tstrok;": "ŧ", "&twixt;": "≬", "&twoheadleftarrow;": "↞", "&twoheadrightarrow;": "↠", "&uArr;": "⇑", "&uHar;": "⥣", "&uacute": "ú", "&uacute;": "ú", "&uarr;": "↑", "&ubrcy;": "ў", "&ubreve;": "ŭ", "&ucirc": "û", "&ucirc;": "û", "&ucy;": "у", "&udarr;": "⇅", "&udblac;": "ű", "&udhar;": "⥮", "&ufisht;": "⥾", "&ufr;": "\uD835\uDD32", "&ugrave": "ù", "&ugrave;": "ù", "&uharl;": "↿", "&uharr;": "↾", "&uhblk;": "▀", "&ulcorn;": "⌜", "&ulcorner;": "⌜", "&ulcrop;": "⌏", "&ultri;": "◸", "&umacr;": "ū", "&uml": "¨", "&uml;": "¨", "&uogon;": "ų", "&uopf;": "\uD835\uDD66", "&uparrow;": "↑", "&updownarrow;": "↕", "&upharpoonleft;": "↿", "&upharpoonright;": "↾", "&uplus;": "⊎", "&upsi;": "υ", "&upsih;": "ϒ", "&upsilon;": "υ", "&upuparrows;": "⇈", "&urcorn;": "⌝", "&urcorner;": "⌝", "&urcrop;": "⌎", "&uring;": "ů", "&urtri;": "◹", "&uscr;": "\uD835\uDCCA", "&utdot;": "⋰", "&utilde;": "ũ", "&utri;": "▵", "&utrif;": "▴", "&uuarr;": "⇈", "&uuml": "ü", "&uuml;": "ü", "&uwangle;": "⦧", "&vArr;": "⇕", "&vBar;": "⫨", "&vBarv;": "⫩", "&vDash;": "⊨", "&vangrt;": "⦜", "&varepsilon;": "ϵ", "&varkappa;": "ϰ", "&varnothing;": "∅", "&varphi;": "ϕ", "&varpi;": "ϖ", "&varpropto;": "∝", "&varr;": "↕", "&varrho;": "ϱ", "&varsigma;": "ς", "&varsubsetneq;": "⊊︀", "&varsubsetneqq;": "⫋︀", "&varsupsetneq;": "⊋︀", "&varsupsetneqq;": "⫌︀", "&vartheta;": "ϑ", "&vartriangleleft;": "⊲", "&vartriangleright;": "⊳", "&vcy;": "в", "&vdash;": "⊢", "&vee;": "∨", "&veebar;": "⊻", "&veeeq;": "≚", "&vellip;": "⋮", "&verbar;": "|", "&vert;": "|", "&vfr;": "\uD835\uDD33", "&vltri;": "⊲", "&vnsub;": "⊂⃒", "&vnsup;": "⊃⃒", "&vopf;": "\uD835\uDD67", "&vprop;": "∝", "&vrtri;": "⊳", "&vscr;": "\uD835\uDCCB", "&vsubnE;": "⫋︀", "&vsubne;": "⊊︀", "&vsupnE;": "⫌︀", "&vsupne;": "⊋︀", "&vzigzag;": "⦚", "&wcirc;": "ŵ", "&wedbar;": "⩟", "&wedge;": "∧", "&wedgeq;": "≙", "&weierp;": "℘", "&wfr;": "\uD835\uDD34", "&wopf;": "\uD835\uDD68", "&wp;": "℘", "&wr;": "≀", "&wreath;": "≀", "&wscr;": "\uD835\uDCCC", "&xcap;": "⋂", "&xcirc;": "◯", "&xcup;": "⋃", "&xdtri;": "▽", "&xfr;": "\uD835\uDD35", "&xhArr;": "⟺", "&xharr;": "⟷", "&xi;": "ξ", "&xlArr;": "⟸", "&xlarr;": "⟵", "&xmap;": "⟼", "&xnis;": "⋻", "&xodot;": "⨀", "&xopf;": "\uD835\uDD69", "&xoplus;": "⨁", "&xotime;": "⨂", "&xrArr;": "⟹", "&xrarr;": "⟶", "&xscr;": "\uD835\uDCCD", "&xsqcup;": "⨆", "&xuplus;": "⨄", "&xutri;": "△", "&xvee;": "⋁", "&xwedge;": "⋀", "&yacute": "ý", "&yacute;": "ý", "&yacy;": "я", "&ycirc;": "ŷ", "&ycy;": "ы", "&yen": "¥", "&yen;": "¥", "&yfr;": "\uD835\uDD36", "&yicy;": "ї", "&yopf;": "\uD835\uDD6A", "&yscr;": "\uD835\uDCCE", "&yucy;": "ю", "&yuml": "ÿ", "&yuml;": "ÿ", "&zacute;": "ź", "&zcaron;": "ž", "&zcy;": "з", "&zdot;": "ż", "&zeetrf;": "ℨ", "&zeta;": "ζ", "&zfr;": "\uD835\uDD37", "&zhcy;": "ж", "&zigrarr;": "⇝", "&zopf;": "\uD835\uDD6B", "&zscr;": "\uD835\uDCCF", "&zwj;": "‍", "&zwnj;": "‌" }, characters: { "Æ": "&AElig;", "&": "&amp;", "Á": "&Aacute;", "Ă": "&Abreve;", "Â": "&Acirc;", "А": "&Acy;", "\uD835\uDD04": "&Afr;", "À": "&Agrave;", "Α": "&Alpha;", "Ā": "&Amacr;", "⩓": "&And;", "Ą": "&Aogon;", "\uD835\uDD38": "&Aopf;", "⁡": "&af;", "Å": "&angst;", "\uD835\uDC9C": "&Ascr;", "≔": "&coloneq;", "Ã": "&Atilde;", "Ä": "&Auml;", "∖": "&ssetmn;", "⫧": "&Barv;", "⌆": "&doublebarwedge;", "Б": "&Bcy;", "∵": "&because;", "ℬ": "&bernou;", "Β": "&Beta;", "\uD835\uDD05": "&Bfr;", "\uD835\uDD39": "&Bopf;", "˘": "&breve;", "≎": "&bump;", "Ч": "&CHcy;", "©": "&copy;", "Ć": "&Cacute;", "⋒": "&Cap;", "ⅅ": "&DD;", "ℭ": "&Cfr;", "Č": "&Ccaron;", "Ç": "&Ccedil;", "Ĉ": "&Ccirc;", "∰": "&Cconint;", "Ċ": "&Cdot;", "¸": "&cedil;", "·": "&middot;", "Χ": "&Chi;", "⊙": "&odot;", "⊖": "&ominus;", "⊕": "&oplus;", "⊗": "&otimes;", "∲": "&cwconint;", "”": "&rdquor;", "’": "&rsquor;", "∷": "&Proportion;", "⩴": "&Colone;", "≡": "&equiv;", "∯": "&DoubleContourIntegral;", "∮": "&oint;", "ℂ": "&complexes;", "∐": "&coprod;", "∳": "&awconint;", "⨯": "&Cross;", "\uD835\uDC9E": "&Cscr;", "⋓": "&Cup;", "≍": "&asympeq;", "⤑": "&DDotrahd;", "Ђ": "&DJcy;", "Ѕ": "&DScy;", "Џ": "&DZcy;", "‡": "&ddagger;", "↡": "&Darr;", "⫤": "&DoubleLeftTee;", "Ď": "&Dcaron;", "Д": "&Dcy;", "∇": "&nabla;", "Δ": "&Delta;", "\uD835\uDD07": "&Dfr;", "´": "&acute;", "˙": "&dot;", "˝": "&dblac;", "`": "&grave;", "˜": "&tilde;", "⋄": "&diamond;", "ⅆ": "&dd;", "\uD835\uDD3B": "&Dopf;", "¨": "&uml;", "⃜": "&DotDot;", "≐": "&esdot;", "⇓": "&dArr;", "⇐": "&lArr;", "⇔": "&iff;", "⟸": "&xlArr;", "⟺": "&xhArr;", "⟹": "&xrArr;", "⇒": "&rArr;", "⊨": "&vDash;", "⇑": "&uArr;", "⇕": "&vArr;", "∥": "&spar;", "↓": "&downarrow;", "⤓": "&DownArrowBar;", "⇵": "&duarr;", "̑": "&DownBreve;", "⥐": "&DownLeftRightVector;", "⥞": "&DownLeftTeeVector;", "↽": "&lhard;", "⥖": "&DownLeftVectorBar;", "⥟": "&DownRightTeeVector;", "⇁": "&rightharpoondown;", "⥗": "&DownRightVectorBar;", "⊤": "&top;", "↧": "&mapstodown;", "\uD835\uDC9F": "&Dscr;", "Đ": "&Dstrok;", "Ŋ": "&ENG;", "Ð": "&ETH;", "É": "&Eacute;", "Ě": "&Ecaron;", "Ê": "&Ecirc;", "Э": "&Ecy;", "Ė": "&Edot;", "\uD835\uDD08": "&Efr;", "È": "&Egrave;", "∈": "&isinv;", "Ē": "&Emacr;", "◻": "&EmptySmallSquare;", "▫": "&EmptyVerySmallSquare;", "Ę": "&Eogon;", "\uD835\uDD3C": "&Eopf;", "Ε": "&Epsilon;", "⩵": "&Equal;", "≂": "&esim;", "⇌": "&rlhar;", "ℰ": "&expectation;", "⩳": "&Esim;", "Η": "&Eta;", "Ë": "&Euml;", "∃": "&exist;", "ⅇ": "&exponentiale;", "Ф": "&Fcy;", "\uD835\uDD09": "&Ffr;", "◼": "&FilledSmallSquare;", "▪": "&squf;", "\uD835\uDD3D": "&Fopf;", "∀": "&forall;", "ℱ": "&Fscr;", "Ѓ": "&GJcy;", ">": "&gt;", "Γ": "&Gamma;", "Ϝ": "&Gammad;", "Ğ": "&Gbreve;", "Ģ": "&Gcedil;", "Ĝ": "&Gcirc;", "Г": "&Gcy;", "Ġ": "&Gdot;", "\uD835\uDD0A": "&Gfr;", "⋙": "&ggg;", "\uD835\uDD3E": "&Gopf;", "≥": "&geq;", "⋛": "&gtreqless;", "≧": "&geqq;", "⪢": "&GreaterGreater;", "≷": "&gtrless;", "⩾": "&ges;", "≳": "&gtrsim;", "\uD835\uDCA2": "&Gscr;", "≫": "&gg;", "Ъ": "&HARDcy;", "ˇ": "&caron;", "^": "&Hat;", "Ĥ": "&Hcirc;", "ℌ": "&Poincareplane;", "ℋ": "&hamilt;", "ℍ": "&quaternions;", "─": "&boxh;", "Ħ": "&Hstrok;", "≏": "&bumpeq;", "Е": "&IEcy;", "Ĳ": "&IJlig;", "Ё": "&IOcy;", "Í": "&Iacute;", "Î": "&Icirc;", "И": "&Icy;", "İ": "&Idot;", "ℑ": "&imagpart;", "Ì": "&Igrave;", "Ī": "&Imacr;", "ⅈ": "&ii;", "∬": "&Int;", "∫": "&int;", "⋂": "&xcap;", "⁣": "&ic;", "⁢": "&it;", "Į": "&Iogon;", "\uD835\uDD40": "&Iopf;", "Ι": "&Iota;", "ℐ": "&imagline;", "Ĩ": "&Itilde;", "І": "&Iukcy;", "Ï": "&Iuml;", "Ĵ": "&Jcirc;", "Й": "&Jcy;", "\uD835\uDD0D": "&Jfr;", "\uD835\uDD41": "&Jopf;", "\uD835\uDCA5": "&Jscr;", "Ј": "&Jsercy;", "Є": "&Jukcy;", "Х": "&KHcy;", "Ќ": "&KJcy;", "Κ": "&Kappa;", "Ķ": "&Kcedil;", "К": "&Kcy;", "\uD835\uDD0E": "&Kfr;", "\uD835\uDD42": "&Kopf;", "\uD835\uDCA6": "&Kscr;", "Љ": "&LJcy;", "<": "&lt;", "Ĺ": "&Lacute;", "Λ": "&Lambda;", "⟪": "&Lang;", "ℒ": "&lagran;", "↞": "&twoheadleftarrow;", "Ľ": "&Lcaron;", "Ļ": "&Lcedil;", "Л": "&Lcy;", "⟨": "&langle;", "←": "&slarr;", "⇤": "&larrb;", "⇆": "&lrarr;", "⌈": "&lceil;", "⟦": "&lobrk;", "⥡": "&LeftDownTeeVector;", "⇃": "&downharpoonleft;", "⥙": "&LeftDownVectorBar;", "⌊": "&lfloor;", "↔": "&leftrightarrow;", "⥎": "&LeftRightVector;", "⊣": "&dashv;", "↤": "&mapstoleft;", "⥚": "&LeftTeeVector;", "⊲": "&vltri;", "⧏": "&LeftTriangleBar;", "⊴": "&trianglelefteq;", "⥑": "&LeftUpDownVector;", "⥠": "&LeftUpTeeVector;", "↿": "&upharpoonleft;", "⥘": "&LeftUpVectorBar;", "↼": "&lharu;", "⥒": "&LeftVectorBar;", "⋚": "&lesseqgtr;", "≦": "&leqq;", "≶": "&lg;", "⪡": "&LessLess;", "⩽": "&les;", "≲": "&lsim;", "\uD835\uDD0F": "&Lfr;", "⋘": "&Ll;", "⇚": "&lAarr;", "Ŀ": "&Lmidot;", "⟵": "&xlarr;", "⟷": "&xharr;", "⟶": "&xrarr;", "\uD835\uDD43": "&Lopf;", "↙": "&swarrow;", "↘": "&searrow;", "↰": "&lsh;", "Ł": "&Lstrok;", "≪": "&ll;", "⤅": "&Map;", "М": "&Mcy;", " ": "&MediumSpace;", "ℳ": "&phmmat;", "\uD835\uDD10": "&Mfr;", "∓": "&mp;", "\uD835\uDD44": "&Mopf;", "Μ": "&Mu;", "Њ": "&NJcy;", "Ń": "&Nacute;", "Ň": "&Ncaron;", "Ņ": "&Ncedil;", "Н": "&Ncy;", "​": "&ZeroWidthSpace;", "\n": "&NewLine;", "\uD835\uDD11": "&Nfr;", "⁠": "&NoBreak;", " ": "&nbsp;", "ℕ": "&naturals;", "⫬": "&Not;", "≢": "&nequiv;", "≭": "&NotCupCap;", "∦": "&nspar;", "∉": "&notinva;", "≠": "&ne;", "≂̸": "&nesim;", "∄": "&nexists;", "≯": "&ngtr;", "≱": "&ngeq;", "≧̸": "&ngeqq;", "≫̸": "&nGtv;", "≹": "&ntgl;", "⩾̸": "&nges;", "≵": "&ngsim;", "≎̸": "&nbump;", "≏̸": "&nbumpe;", "⋪": "&ntriangleleft;", "⧏̸": "&NotLeftTriangleBar;", "⋬": "&ntrianglelefteq;", "≮": "&nlt;", "≰": "&nleq;", "≸": "&ntlg;", "≪̸": "&nLtv;", "⩽̸": "&nles;", "≴": "&nlsim;", "⪢̸": "&NotNestedGreaterGreater;", "⪡̸": "&NotNestedLessLess;", "⊀": "&nprec;", "⪯̸": "&npreceq;", "⋠": "&nprcue;", "∌": "&notniva;", "⋫": "&ntriangleright;", "⧐̸": "&NotRightTriangleBar;", "⋭": "&ntrianglerighteq;", "⊏̸": "&NotSquareSubset;", "⋢": "&nsqsube;", "⊐̸": "&NotSquareSuperset;", "⋣": "&nsqsupe;", "⊂⃒": "&vnsub;", "⊈": "&nsubseteq;", "⊁": "&nsucc;", "⪰̸": "&nsucceq;", "⋡": "&nsccue;", "≿̸": "&NotSucceedsTilde;", "⊃⃒": "&vnsup;", "⊉": "&nsupseteq;", "≁": "&nsim;", "≄": "&nsimeq;", "≇": "&ncong;", "≉": "&napprox;", "∤": "&nsmid;", "\uD835\uDCA9": "&Nscr;", "Ñ": "&Ntilde;", "Ν": "&Nu;", "Œ": "&OElig;", "Ó": "&Oacute;", "Ô": "&Ocirc;", "О": "&Ocy;", "Ő": "&Odblac;", "\uD835\uDD12": "&Ofr;", "Ò": "&Ograve;", "Ō": "&Omacr;", "Ω": "&ohm;", "Ο": "&Omicron;", "\uD835\uDD46": "&Oopf;", "“": "&ldquo;", "‘": "&lsquo;", "⩔": "&Or;", "\uD835\uDCAA": "&Oscr;", "Ø": "&Oslash;", "Õ": "&Otilde;", "⨷": "&Otimes;", "Ö": "&Ouml;", "‾": "&oline;", "⏞": "&OverBrace;", "⎴": "&tbrk;", "⏜": "&OverParenthesis;", "∂": "&part;", "П": "&Pcy;", "\uD835\uDD13": "&Pfr;", "Φ": "&Phi;", "Π": "&Pi;", "±": "&pm;", "ℙ": "&primes;", "⪻": "&Pr;", "≺": "&prec;", "⪯": "&preceq;", "≼": "&preccurlyeq;", "≾": "&prsim;", "″": "&Prime;", "∏": "&prod;", "∝": "&vprop;", "\uD835\uDCAB": "&Pscr;", "Ψ": "&Psi;", '"': "&quot;", "\uD835\uDD14": "&Qfr;", "ℚ": "&rationals;", "\uD835\uDCAC": "&Qscr;", "⤐": "&drbkarow;", "®": "&reg;", "Ŕ": "&Racute;", "⟫": "&Rang;", "↠": "&twoheadrightarrow;", "⤖": "&Rarrtl;", "Ř": "&Rcaron;", "Ŗ": "&Rcedil;", "Р": "&Rcy;", "ℜ": "&realpart;", "∋": "&niv;", "⇋": "&lrhar;", "⥯": "&duhar;", "Ρ": "&Rho;", "⟩": "&rangle;", "→": "&srarr;", "⇥": "&rarrb;", "⇄": "&rlarr;", "⌉": "&rceil;", "⟧": "&robrk;", "⥝": "&RightDownTeeVector;", "⇂": "&downharpoonright;", "⥕": "&RightDownVectorBar;", "⌋": "&rfloor;", "⊢": "&vdash;", "↦": "&mapsto;", "⥛": "&RightTeeVector;", "⊳": "&vrtri;", "⧐": "&RightTriangleBar;", "⊵": "&trianglerighteq;", "⥏": "&RightUpDownVector;", "⥜": "&RightUpTeeVector;", "↾": "&upharpoonright;", "⥔": "&RightUpVectorBar;", "⇀": "&rightharpoonup;", "⥓": "&RightVectorBar;", "ℝ": "&reals;", "⥰": "&RoundImplies;", "⇛": "&rAarr;", "ℛ": "&realine;", "↱": "&rsh;", "⧴": "&RuleDelayed;", "Щ": "&SHCHcy;", "Ш": "&SHcy;", "Ь": "&SOFTcy;", "Ś": "&Sacute;", "⪼": "&Sc;", "Š": "&Scaron;", "Ş": "&Scedil;", "Ŝ": "&Scirc;", "С": "&Scy;", "\uD835\uDD16": "&Sfr;", "↑": "&uparrow;", "Σ": "&Sigma;", "∘": "&compfn;", "\uD835\uDD4A": "&Sopf;", "√": "&radic;", "□": "&square;", "⊓": "&sqcap;", "⊏": "&sqsubset;", "⊑": "&sqsubseteq;", "⊐": "&sqsupset;", "⊒": "&sqsupseteq;", "⊔": "&sqcup;", "\uD835\uDCAE": "&Sscr;", "⋆": "&sstarf;", "⋐": "&Subset;", "⊆": "&subseteq;", "≻": "&succ;", "⪰": "&succeq;", "≽": "&succcurlyeq;", "≿": "&succsim;", "∑": "&sum;", "⋑": "&Supset;", "⊃": "&supset;", "⊇": "&supseteq;", "Þ": "&THORN;", "™": "&trade;", "Ћ": "&TSHcy;", "Ц": "&TScy;", "\t": "&Tab;", "Τ": "&Tau;", "Ť": "&Tcaron;", "Ţ": "&Tcedil;", "Т": "&Tcy;", "\uD835\uDD17": "&Tfr;", "∴": "&therefore;", "Θ": "&Theta;", "  ": "&ThickSpace;", " ": "&thinsp;", "∼": "&thksim;", "≃": "&simeq;", "≅": "&cong;", "≈": "&thkap;", "\uD835\uDD4B": "&Topf;", "⃛": "&tdot;", "\uD835\uDCAF": "&Tscr;", "Ŧ": "&Tstrok;", "Ú": "&Uacute;", "↟": "&Uarr;", "⥉": "&Uarrocir;", "Ў": "&Ubrcy;", "Ŭ": "&Ubreve;", "Û": "&Ucirc;", "У": "&Ucy;", "Ű": "&Udblac;", "\uD835\uDD18": "&Ufr;", "Ù": "&Ugrave;", "Ū": "&Umacr;", _: "&lowbar;", "⏟": "&UnderBrace;", "⎵": "&bbrk;", "⏝": "&UnderParenthesis;", "⋃": "&xcup;", "⊎": "&uplus;", "Ų": "&Uogon;", "\uD835\uDD4C": "&Uopf;", "⤒": "&UpArrowBar;", "⇅": "&udarr;", "↕": "&varr;", "⥮": "&udhar;", "⊥": "&perp;", "↥": "&mapstoup;", "↖": "&nwarrow;", "↗": "&nearrow;", "ϒ": "&upsih;", "Υ": "&Upsilon;", "Ů": "&Uring;", "\uD835\uDCB0": "&Uscr;", "Ũ": "&Utilde;", "Ü": "&Uuml;", "⊫": "&VDash;", "⫫": "&Vbar;", "В": "&Vcy;", "⊩": "&Vdash;", "⫦": "&Vdashl;", "⋁": "&xvee;", "‖": "&Vert;", "∣": "&smid;", "|": "&vert;", "❘": "&VerticalSeparator;", "≀": "&wreath;", " ": "&hairsp;", "\uD835\uDD19": "&Vfr;", "\uD835\uDD4D": "&Vopf;", "\uD835\uDCB1": "&Vscr;", "⊪": "&Vvdash;", "Ŵ": "&Wcirc;", "⋀": "&xwedge;", "\uD835\uDD1A": "&Wfr;", "\uD835\uDD4E": "&Wopf;", "\uD835\uDCB2": "&Wscr;", "\uD835\uDD1B": "&Xfr;", "Ξ": "&Xi;", "\uD835\uDD4F": "&Xopf;", "\uD835\uDCB3": "&Xscr;", "Я": "&YAcy;", "Ї": "&YIcy;", "Ю": "&YUcy;", "Ý": "&Yacute;", "Ŷ": "&Ycirc;", "Ы": "&Ycy;", "\uD835\uDD1C": "&Yfr;", "\uD835\uDD50": "&Yopf;", "\uD835\uDCB4": "&Yscr;", "Ÿ": "&Yuml;", "Ж": "&ZHcy;", "Ź": "&Zacute;", "Ž": "&Zcaron;", "З": "&Zcy;", "Ż": "&Zdot;", "Ζ": "&Zeta;", "ℨ": "&zeetrf;", "ℤ": "&integers;", "\uD835\uDCB5": "&Zscr;", "á": "&aacute;", "ă": "&abreve;", "∾": "&mstpos;", "∾̳": "&acE;", "∿": "&acd;", "â": "&acirc;", "а": "&acy;", "æ": "&aelig;", "\uD835\uDD1E": "&afr;", "à": "&agrave;", "ℵ": "&aleph;", "α": "&alpha;", "ā": "&amacr;", "⨿": "&amalg;", "∧": "&wedge;", "⩕": "&andand;", "⩜": "&andd;", "⩘": "&andslope;", "⩚": "&andv;", "∠": "&angle;", "⦤": "&ange;", "∡": "&measuredangle;", "⦨": "&angmsdaa;", "⦩": "&angmsdab;", "⦪": "&angmsdac;", "⦫": "&angmsdad;", "⦬": "&angmsdae;", "⦭": "&angmsdaf;", "⦮": "&angmsdag;", "⦯": "&angmsdah;", "∟": "&angrt;", "⊾": "&angrtvb;", "⦝": "&angrtvbd;", "∢": "&angsph;", "⍼": "&angzarr;", "ą": "&aogon;", "\uD835\uDD52": "&aopf;", "⩰": "&apE;", "⩯": "&apacir;", "≊": "&approxeq;", "≋": "&apid;", "'": "&apos;", "å": "&aring;", "\uD835\uDCB6": "&ascr;", "*": "&midast;", "ã": "&atilde;", "ä": "&auml;", "⨑": "&awint;", "⫭": "&bNot;", "≌": "&bcong;", "϶": "&bepsi;", "‵": "&bprime;", "∽": "&bsim;", "⋍": "&bsime;", "⊽": "&barvee;", "⌅": "&barwedge;", "⎶": "&bbrktbrk;", "б": "&bcy;", "„": "&ldquor;", "⦰": "&bemptyv;", "β": "&beta;", "ℶ": "&beth;", "≬": "&twixt;", "\uD835\uDD1F": "&bfr;", "◯": "&xcirc;", "⨀": "&xodot;", "⨁": "&xoplus;", "⨂": "&xotime;", "⨆": "&xsqcup;", "★": "&starf;", "▽": "&xdtri;", "△": "&xutri;", "⨄": "&xuplus;", "⤍": "&rbarr;", "⧫": "&lozf;", "▴": "&utrif;", "▾": "&dtrif;", "◂": "&ltrif;", "▸": "&rtrif;", "␣": "&blank;", "▒": "&blk12;", "░": "&blk14;", "▓": "&blk34;", "█": "&block;", "=⃥": "&bne;", "≡⃥": "&bnequiv;", "⌐": "&bnot;", "\uD835\uDD53": "&bopf;", "⋈": "&bowtie;", "╗": "&boxDL;", "╔": "&boxDR;", "╖": "&boxDl;", "╓": "&boxDr;", "═": "&boxH;", "╦": "&boxHD;", "╩": "&boxHU;", "╤": "&boxHd;", "╧": "&boxHu;", "╝": "&boxUL;", "╚": "&boxUR;", "╜": "&boxUl;", "╙": "&boxUr;", "║": "&boxV;", "╬": "&boxVH;", "╣": "&boxVL;", "╠": "&boxVR;", "╫": "&boxVh;", "╢": "&boxVl;", "╟": "&boxVr;", "⧉": "&boxbox;", "╕": "&boxdL;", "╒": "&boxdR;", "┐": "&boxdl;", "┌": "&boxdr;", "╥": "&boxhD;", "╨": "&boxhU;", "┬": "&boxhd;", "┴": "&boxhu;", "⊟": "&minusb;", "⊞": "&plusb;", "⊠": "&timesb;", "╛": "&boxuL;", "╘": "&boxuR;", "┘": "&boxul;", "└": "&boxur;", "│": "&boxv;", "╪": "&boxvH;", "╡": "&boxvL;", "╞": "&boxvR;", "┼": "&boxvh;", "┤": "&boxvl;", "├": "&boxvr;", "¦": "&brvbar;", "\uD835\uDCB7": "&bscr;", "⁏": "&bsemi;", "\\": "&bsol;", "⧅": "&bsolb;", "⟈": "&bsolhsub;", "•": "&bullet;", "⪮": "&bumpE;", "ć": "&cacute;", "∩": "&cap;", "⩄": "&capand;", "⩉": "&capbrcup;", "⩋": "&capcap;", "⩇": "&capcup;", "⩀": "&capdot;", "∩︀": "&caps;", "⁁": "&caret;", "⩍": "&ccaps;", "č": "&ccaron;", "ç": "&ccedil;", "ĉ": "&ccirc;", "⩌": "&ccups;", "⩐": "&ccupssm;", "ċ": "&cdot;", "⦲": "&cemptyv;", "¢": "&cent;", "\uD835\uDD20": "&cfr;", "ч": "&chcy;", "✓": "&checkmark;", "χ": "&chi;", "○": "&cir;", "⧃": "&cirE;", "ˆ": "&circ;", "≗": "&cire;", "↺": "&olarr;", "↻": "&orarr;", "Ⓢ": "&oS;", "⊛": "&oast;", "⊚": "&ocir;", "⊝": "&odash;", "⨐": "&cirfnint;", "⫯": "&cirmid;", "⧂": "&cirscir;", "♣": "&clubsuit;", ":": "&colon;", ",": "&comma;", "@": "&commat;", "∁": "&complement;", "⩭": "&congdot;", "\uD835\uDD54": "&copf;", "℗": "&copysr;", "↵": "&crarr;", "✗": "&cross;", "\uD835\uDCB8": "&cscr;", "⫏": "&csub;", "⫑": "&csube;", "⫐": "&csup;", "⫒": "&csupe;", "⋯": "&ctdot;", "⤸": "&cudarrl;", "⤵": "&cudarrr;", "⋞": "&curlyeqprec;", "⋟": "&curlyeqsucc;", "↶": "&curvearrowleft;", "⤽": "&cularrp;", "∪": "&cup;", "⩈": "&cupbrcap;", "⩆": "&cupcap;", "⩊": "&cupcup;", "⊍": "&cupdot;", "⩅": "&cupor;", "∪︀": "&cups;", "↷": "&curvearrowright;", "⤼": "&curarrm;", "⋎": "&cuvee;", "⋏": "&cuwed;", "¤": "&curren;", "∱": "&cwint;", "⌭": "&cylcty;", "⥥": "&dHar;", "†": "&dagger;", "ℸ": "&daleth;", "‐": "&hyphen;", "⤏": "&rBarr;", "ď": "&dcaron;", "д": "&dcy;", "⇊": "&downdownarrows;", "⩷": "&eDDot;", "°": "&deg;", "δ": "&delta;", "⦱": "&demptyv;", "⥿": "&dfisht;", "\uD835\uDD21": "&dfr;", "♦": "&diams;", "ϝ": "&gammad;", "⋲": "&disin;", "÷": "&divide;", "⋇": "&divonx;", "ђ": "&djcy;", "⌞": "&llcorner;", "⌍": "&dlcrop;", $: "&dollar;", "\uD835\uDD55": "&dopf;", "≑": "&eDot;", "∸": "&minusd;", "∔": "&plusdo;", "⊡": "&sdotb;", "⌟": "&lrcorner;", "⌌": "&drcrop;", "\uD835\uDCB9": "&dscr;", "ѕ": "&dscy;", "⧶": "&dsol;", "đ": "&dstrok;", "⋱": "&dtdot;", "▿": "&triangledown;", "⦦": "&dwangle;", "џ": "&dzcy;", "⟿": "&dzigrarr;", "é": "&eacute;", "⩮": "&easter;", "ě": "&ecaron;", "≖": "&eqcirc;", "ê": "&ecirc;", "≕": "&eqcolon;", "э": "&ecy;", "ė": "&edot;", "≒": "&fallingdotseq;", "\uD835\uDD22": "&efr;", "⪚": "&eg;", "è": "&egrave;", "⪖": "&eqslantgtr;", "⪘": "&egsdot;", "⪙": "&el;", "⏧": "&elinters;", "ℓ": "&ell;", "⪕": "&eqslantless;", "⪗": "&elsdot;", "ē": "&emacr;", "∅": "&varnothing;", " ": "&emsp13;", " ": "&emsp14;", " ": "&emsp;", "ŋ": "&eng;", " ": "&ensp;", "ę": "&eogon;", "\uD835\uDD56": "&eopf;", "⋕": "&epar;", "⧣": "&eparsl;", "⩱": "&eplus;", "ε": "&epsilon;", "ϵ": "&varepsilon;", "=": "&equals;", "≟": "&questeq;", "⩸": "&equivDD;", "⧥": "&eqvparsl;", "≓": "&risingdotseq;", "⥱": "&erarr;", "ℯ": "&escr;", "η": "&eta;", "ð": "&eth;", "ë": "&euml;", "€": "&euro;", "!": "&excl;", "ф": "&fcy;", "♀": "&female;", "ﬃ": "&ffilig;", "ﬀ": "&fflig;", "ﬄ": "&ffllig;", "\uD835\uDD23": "&ffr;", "ﬁ": "&filig;", fj: "&fjlig;", "♭": "&flat;", "ﬂ": "&fllig;", "▱": "&fltns;", "ƒ": "&fnof;", "\uD835\uDD57": "&fopf;", "⋔": "&pitchfork;", "⫙": "&forkv;", "⨍": "&fpartint;", "½": "&half;", "⅓": "&frac13;", "¼": "&frac14;", "⅕": "&frac15;", "⅙": "&frac16;", "⅛": "&frac18;", "⅔": "&frac23;", "⅖": "&frac25;", "¾": "&frac34;", "⅗": "&frac35;", "⅜": "&frac38;", "⅘": "&frac45;", "⅚": "&frac56;", "⅝": "&frac58;", "⅞": "&frac78;", "⁄": "&frasl;", "⌢": "&sfrown;", "\uD835\uDCBB": "&fscr;", "⪌": "&gtreqqless;", "ǵ": "&gacute;", "γ": "&gamma;", "⪆": "&gtrapprox;", "ğ": "&gbreve;", "ĝ": "&gcirc;", "г": "&gcy;", "ġ": "&gdot;", "⪩": "&gescc;", "⪀": "&gesdot;", "⪂": "&gesdoto;", "⪄": "&gesdotol;", "⋛︀": "&gesl;", "⪔": "&gesles;", "\uD835\uDD24": "&gfr;", "ℷ": "&gimel;", "ѓ": "&gjcy;", "⪒": "&glE;", "⪥": "&gla;", "⪤": "&glj;", "≩": "&gneqq;", "⪊": "&gnapprox;", "⪈": "&gneq;", "⋧": "&gnsim;", "\uD835\uDD58": "&gopf;", "ℊ": "&gscr;", "⪎": "&gsime;", "⪐": "&gsiml;", "⪧": "&gtcc;", "⩺": "&gtcir;", "⋗": "&gtrdot;", "⦕": "&gtlPar;", "⩼": "&gtquest;", "⥸": "&gtrarr;", "≩︀": "&gvnE;", "ъ": "&hardcy;", "⥈": "&harrcir;", "↭": "&leftrightsquigarrow;", "ℏ": "&plankv;", "ĥ": "&hcirc;", "♥": "&heartsuit;", "…": "&mldr;", "⊹": "&hercon;", "\uD835\uDD25": "&hfr;", "⤥": "&searhk;", "⤦": "&swarhk;", "⇿": "&hoarr;", "∻": "&homtht;", "↩": "&larrhk;", "↪": "&rarrhk;", "\uD835\uDD59": "&hopf;", "―": "&horbar;", "\uD835\uDCBD": "&hscr;", "ħ": "&hstrok;", "⁃": "&hybull;", "í": "&iacute;", "î": "&icirc;", "и": "&icy;", "е": "&iecy;", "¡": "&iexcl;", "\uD835\uDD26": "&ifr;", "ì": "&igrave;", "⨌": "&qint;", "∭": "&tint;", "⧜": "&iinfin;", "℩": "&iiota;", "ĳ": "&ijlig;", "ī": "&imacr;", "ı": "&inodot;", "⊷": "&imof;", "Ƶ": "&imped;", "℅": "&incare;", "∞": "&infin;", "⧝": "&infintie;", "⊺": "&intercal;", "⨗": "&intlarhk;", "⨼": "&iprod;", "ё": "&iocy;", "į": "&iogon;", "\uD835\uDD5A": "&iopf;", "ι": "&iota;", "¿": "&iquest;", "\uD835\uDCBE": "&iscr;", "⋹": "&isinE;", "⋵": "&isindot;", "⋴": "&isins;", "⋳": "&isinsv;", "ĩ": "&itilde;", "і": "&iukcy;", "ï": "&iuml;", "ĵ": "&jcirc;", "й": "&jcy;", "\uD835\uDD27": "&jfr;", "ȷ": "&jmath;", "\uD835\uDD5B": "&jopf;", "\uD835\uDCBF": "&jscr;", "ј": "&jsercy;", "є": "&jukcy;", "κ": "&kappa;", "ϰ": "&varkappa;", "ķ": "&kcedil;", "к": "&kcy;", "\uD835\uDD28": "&kfr;", "ĸ": "&kgreen;", "х": "&khcy;", "ќ": "&kjcy;", "\uD835\uDD5C": "&kopf;", "\uD835\uDCC0": "&kscr;", "⤛": "&lAtail;", "⤎": "&lBarr;", "⪋": "&lesseqqgtr;", "⥢": "&lHar;", "ĺ": "&lacute;", "⦴": "&laemptyv;", "λ": "&lambda;", "⦑": "&langd;", "⪅": "&lessapprox;", "«": "&laquo;", "⤟": "&larrbfs;", "⤝": "&larrfs;", "↫": "&looparrowleft;", "⤹": "&larrpl;", "⥳": "&larrsim;", "↢": "&leftarrowtail;", "⪫": "&lat;", "⤙": "&latail;", "⪭": "&late;", "⪭︀": "&lates;", "⤌": "&lbarr;", "❲": "&lbbrk;", "{": "&lcub;", "[": "&lsqb;", "⦋": "&lbrke;", "⦏": "&lbrksld;", "⦍": "&lbrkslu;", "ľ": "&lcaron;", "ļ": "&lcedil;", "л": "&lcy;", "⤶": "&ldca;", "⥧": "&ldrdhar;", "⥋": "&ldrushar;", "↲": "&ldsh;", "≤": "&leq;", "⇇": "&llarr;", "⋋": "&lthree;", "⪨": "&lescc;", "⩿": "&lesdot;", "⪁": "&lesdoto;", "⪃": "&lesdotor;", "⋚︀": "&lesg;", "⪓": "&lesges;", "⋖": "&ltdot;", "⥼": "&lfisht;", "\uD835\uDD29": "&lfr;", "⪑": "&lgE;", "⥪": "&lharul;", "▄": "&lhblk;", "љ": "&ljcy;", "⥫": "&llhard;", "◺": "&lltri;", "ŀ": "&lmidot;", "⎰": "&lmoustache;", "≨": "&lneqq;", "⪉": "&lnapprox;", "⪇": "&lneq;", "⋦": "&lnsim;", "⟬": "&loang;", "⇽": "&loarr;", "⟼": "&xmap;", "↬": "&rarrlp;", "⦅": "&lopar;", "\uD835\uDD5D": "&lopf;", "⨭": "&loplus;", "⨴": "&lotimes;", "∗": "&lowast;", "◊": "&lozenge;", "(": "&lpar;", "⦓": "&lparlt;", "⥭": "&lrhard;", "‎": "&lrm;", "⊿": "&lrtri;", "‹": "&lsaquo;", "\uD835\uDCC1": "&lscr;", "⪍": "&lsime;", "⪏": "&lsimg;", "‚": "&sbquo;", "ł": "&lstrok;", "⪦": "&ltcc;", "⩹": "&ltcir;", "⋉": "&ltimes;", "⥶": "&ltlarr;", "⩻": "&ltquest;", "⦖": "&ltrPar;", "◃": "&triangleleft;", "⥊": "&lurdshar;", "⥦": "&luruhar;", "≨︀": "&lvnE;", "∺": "&mDDot;", "¯": "&strns;", "♂": "&male;", "✠": "&maltese;", "▮": "&marker;", "⨩": "&mcomma;", "м": "&mcy;", "—": "&mdash;", "\uD835\uDD2A": "&mfr;", "℧": "&mho;", "µ": "&micro;", "⫰": "&midcir;", "−": "&minus;", "⨪": "&minusdu;", "⫛": "&mlcp;", "⊧": "&models;", "\uD835\uDD5E": "&mopf;", "\uD835\uDCC2": "&mscr;", "μ": "&mu;", "⊸": "&mumap;", "⋙̸": "&nGg;", "≫⃒": "&nGt;", "⇍": "&nlArr;", "⇎": "&nhArr;", "⋘̸": "&nLl;", "≪⃒": "&nLt;", "⇏": "&nrArr;", "⊯": "&nVDash;", "⊮": "&nVdash;", "ń": "&nacute;", "∠⃒": "&nang;", "⩰̸": "&napE;", "≋̸": "&napid;", "ŉ": "&napos;", "♮": "&natural;", "⩃": "&ncap;", "ň": "&ncaron;", "ņ": "&ncedil;", "⩭̸": "&ncongdot;", "⩂": "&ncup;", "н": "&ncy;", "–": "&ndash;", "⇗": "&neArr;", "⤤": "&nearhk;", "≐̸": "&nedot;", "⤨": "&toea;", "\uD835\uDD2B": "&nfr;", "↮": "&nleftrightarrow;", "⫲": "&nhpar;", "⋼": "&nis;", "⋺": "&nisd;", "њ": "&njcy;", "≦̸": "&nleqq;", "↚": "&nleftarrow;", "‥": "&nldr;", "\uD835\uDD5F": "&nopf;", "¬": "&not;", "⋹̸": "&notinE;", "⋵̸": "&notindot;", "⋷": "&notinvb;", "⋶": "&notinvc;", "⋾": "&notnivb;", "⋽": "&notnivc;", "⫽⃥": "&nparsl;", "∂̸": "&npart;", "⨔": "&npolint;", "↛": "&nrightarrow;", "⤳̸": "&nrarrc;", "↝̸": "&nrarrw;", "\uD835\uDCC3": "&nscr;", "⊄": "&nsub;", "⫅̸": "&nsubseteqq;", "⊅": "&nsup;", "⫆̸": "&nsupseteqq;", "ñ": "&ntilde;", "ν": "&nu;", "#": "&num;", "№": "&numero;", " ": "&numsp;", "⊭": "&nvDash;", "⤄": "&nvHarr;", "≍⃒": "&nvap;", "⊬": "&nvdash;", "≥⃒": "&nvge;", ">⃒": "&nvgt;", "⧞": "&nvinfin;", "⤂": "&nvlArr;", "≤⃒": "&nvle;", "<⃒": "&nvlt;", "⊴⃒": "&nvltrie;", "⤃": "&nvrArr;", "⊵⃒": "&nvrtrie;", "∼⃒": "&nvsim;", "⇖": "&nwArr;", "⤣": "&nwarhk;", "⤧": "&nwnear;", "ó": "&oacute;", "ô": "&ocirc;", "о": "&ocy;", "ő": "&odblac;", "⨸": "&odiv;", "⦼": "&odsold;", "œ": "&oelig;", "⦿": "&ofcir;", "\uD835\uDD2C": "&ofr;", "˛": "&ogon;", "ò": "&ograve;", "⧁": "&ogt;", "⦵": "&ohbar;", "⦾": "&olcir;", "⦻": "&olcross;", "⧀": "&olt;", "ō": "&omacr;", "ω": "&omega;", "ο": "&omicron;", "⦶": "&omid;", "\uD835\uDD60": "&oopf;", "⦷": "&opar;", "⦹": "&operp;", "∨": "&vee;", "⩝": "&ord;", "ℴ": "&oscr;", "ª": "&ordf;", "º": "&ordm;", "⊶": "&origof;", "⩖": "&oror;", "⩗": "&orslope;", "⩛": "&orv;", "ø": "&oslash;", "⊘": "&osol;", "õ": "&otilde;", "⨶": "&otimesas;", "ö": "&ouml;", "⌽": "&ovbar;", "¶": "&para;", "⫳": "&parsim;", "⫽": "&parsl;", "п": "&pcy;", "%": "&percnt;", ".": "&period;", "‰": "&permil;", "‱": "&pertenk;", "\uD835\uDD2D": "&pfr;", "φ": "&phi;", "ϕ": "&varphi;", "☎": "&phone;", "π": "&pi;", "ϖ": "&varpi;", "ℎ": "&planckh;", "+": "&plus;", "⨣": "&plusacir;", "⨢": "&pluscir;", "⨥": "&plusdu;", "⩲": "&pluse;", "⨦": "&plussim;", "⨧": "&plustwo;", "⨕": "&pointint;", "\uD835\uDD61": "&popf;", "£": "&pound;", "⪳": "&prE;", "⪷": "&precapprox;", "⪹": "&prnap;", "⪵": "&prnE;", "⋨": "&prnsim;", "′": "&prime;", "⌮": "&profalar;", "⌒": "&profline;", "⌓": "&profsurf;", "⊰": "&prurel;", "\uD835\uDCC5": "&pscr;", "ψ": "&psi;", " ": "&puncsp;", "\uD835\uDD2E": "&qfr;", "\uD835\uDD62": "&qopf;", "⁗": "&qprime;", "\uD835\uDCC6": "&qscr;", "⨖": "&quatint;", "?": "&quest;", "⤜": "&rAtail;", "⥤": "&rHar;", "∽̱": "&race;", "ŕ": "&racute;", "⦳": "&raemptyv;", "⦒": "&rangd;", "⦥": "&range;", "»": "&raquo;", "⥵": "&rarrap;", "⤠": "&rarrbfs;", "⤳": "&rarrc;", "⤞": "&rarrfs;", "⥅": "&rarrpl;", "⥴": "&rarrsim;", "↣": "&rightarrowtail;", "↝": "&rightsquigarrow;", "⤚": "&ratail;", "∶": "&ratio;", "❳": "&rbbrk;", "}": "&rcub;", "]": "&rsqb;", "⦌": "&rbrke;", "⦎": "&rbrksld;", "⦐": "&rbrkslu;", "ř": "&rcaron;", "ŗ": "&rcedil;", "р": "&rcy;", "⤷": "&rdca;", "⥩": "&rdldhar;", "↳": "&rdsh;", "▭": "&rect;", "⥽": "&rfisht;", "\uD835\uDD2F": "&rfr;", "⥬": "&rharul;", "ρ": "&rho;", "ϱ": "&varrho;", "⇉": "&rrarr;", "⋌": "&rthree;", "˚": "&ring;", "‏": "&rlm;", "⎱": "&rmoustache;", "⫮": "&rnmid;", "⟭": "&roang;", "⇾": "&roarr;", "⦆": "&ropar;", "\uD835\uDD63": "&ropf;", "⨮": "&roplus;", "⨵": "&rotimes;", ")": "&rpar;", "⦔": "&rpargt;", "⨒": "&rppolint;", "›": "&rsaquo;", "\uD835\uDCC7": "&rscr;", "⋊": "&rtimes;", "▹": "&triangleright;", "⧎": "&rtriltri;", "⥨": "&ruluhar;", "℞": "&rx;", "ś": "&sacute;", "⪴": "&scE;", "⪸": "&succapprox;", "š": "&scaron;", "ş": "&scedil;", "ŝ": "&scirc;", "⪶": "&succneqq;", "⪺": "&succnapprox;", "⋩": "&succnsim;", "⨓": "&scpolint;", "с": "&scy;", "⋅": "&sdot;", "⩦": "&sdote;", "⇘": "&seArr;", "§": "&sect;", ";": "&semi;", "⤩": "&tosa;", "✶": "&sext;", "\uD835\uDD30": "&sfr;", "♯": "&sharp;", "щ": "&shchcy;", "ш": "&shcy;", "­": "&shy;", "σ": "&sigma;", "ς": "&varsigma;", "⩪": "&simdot;", "⪞": "&simg;", "⪠": "&simgE;", "⪝": "&siml;", "⪟": "&simlE;", "≆": "&simne;", "⨤": "&simplus;", "⥲": "&simrarr;", "⨳": "&smashp;", "⧤": "&smeparsl;", "⌣": "&ssmile;", "⪪": "&smt;", "⪬": "&smte;", "⪬︀": "&smtes;", "ь": "&softcy;", "/": "&sol;", "⧄": "&solb;", "⌿": "&solbar;", "\uD835\uDD64": "&sopf;", "♠": "&spadesuit;", "⊓︀": "&sqcaps;", "⊔︀": "&sqcups;", "\uD835\uDCC8": "&sscr;", "☆": "&star;", "⊂": "&subset;", "⫅": "&subseteqq;", "⪽": "&subdot;", "⫃": "&subedot;", "⫁": "&submult;", "⫋": "&subsetneqq;", "⊊": "&subsetneq;", "⪿": "&subplus;", "⥹": "&subrarr;", "⫇": "&subsim;", "⫕": "&subsub;", "⫓": "&subsup;", "♪": "&sung;", "¹": "&sup1;", "²": "&sup2;", "³": "&sup3;", "⫆": "&supseteqq;", "⪾": "&supdot;", "⫘": "&supdsub;", "⫄": "&supedot;", "⟉": "&suphsol;", "⫗": "&suphsub;", "⥻": "&suplarr;", "⫂": "&supmult;", "⫌": "&supsetneqq;", "⊋": "&supsetneq;", "⫀": "&supplus;", "⫈": "&supsim;", "⫔": "&supsub;", "⫖": "&supsup;", "⇙": "&swArr;", "⤪": "&swnwar;", "ß": "&szlig;", "⌖": "&target;", "τ": "&tau;", "ť": "&tcaron;", "ţ": "&tcedil;", "т": "&tcy;", "⌕": "&telrec;", "\uD835\uDD31": "&tfr;", "θ": "&theta;", "ϑ": "&vartheta;", "þ": "&thorn;", "×": "&times;", "⨱": "&timesbar;", "⨰": "&timesd;", "⌶": "&topbot;", "⫱": "&topcir;", "\uD835\uDD65": "&topf;", "⫚": "&topfork;", "‴": "&tprime;", "▵": "&utri;", "≜": "&trie;", "◬": "&tridot;", "⨺": "&triminus;", "⨹": "&triplus;", "⧍": "&trisb;", "⨻": "&tritime;", "⏢": "&trpezium;", "\uD835\uDCC9": "&tscr;", "ц": "&tscy;", "ћ": "&tshcy;", "ŧ": "&tstrok;", "⥣": "&uHar;", "ú": "&uacute;", "ў": "&ubrcy;", "ŭ": "&ubreve;", "û": "&ucirc;", "у": "&ucy;", "ű": "&udblac;", "⥾": "&ufisht;", "\uD835\uDD32": "&ufr;", "ù": "&ugrave;", "▀": "&uhblk;", "⌜": "&ulcorner;", "⌏": "&ulcrop;", "◸": "&ultri;", "ū": "&umacr;", "ų": "&uogon;", "\uD835\uDD66": "&uopf;", "υ": "&upsilon;", "⇈": "&uuarr;", "⌝": "&urcorner;", "⌎": "&urcrop;", "ů": "&uring;", "◹": "&urtri;", "\uD835\uDCCA": "&uscr;", "⋰": "&utdot;", "ũ": "&utilde;", "ü": "&uuml;", "⦧": "&uwangle;", "⫨": "&vBar;", "⫩": "&vBarv;", "⦜": "&vangrt;", "⊊︀": "&vsubne;", "⫋︀": "&vsubnE;", "⊋︀": "&vsupne;", "⫌︀": "&vsupnE;", "в": "&vcy;", "⊻": "&veebar;", "≚": "&veeeq;", "⋮": "&vellip;", "\uD835\uDD33": "&vfr;", "\uD835\uDD67": "&vopf;", "\uD835\uDCCB": "&vscr;", "⦚": "&vzigzag;", "ŵ": "&wcirc;", "⩟": "&wedbar;", "≙": "&wedgeq;", "℘": "&wp;", "\uD835\uDD34": "&wfr;", "\uD835\uDD68": "&wopf;", "\uD835\uDCCC": "&wscr;", "\uD835\uDD35": "&xfr;", "ξ": "&xi;", "⋻": "&xnis;", "\uD835\uDD69": "&xopf;", "\uD835\uDCCD": "&xscr;", "ý": "&yacute;", "я": "&yacy;", "ŷ": "&ycirc;", "ы": "&ycy;", "¥": "&yen;", "\uD835\uDD36": "&yfr;", "ї": "&yicy;", "\uD835\uDD6A": "&yopf;", "\uD835\uDCCE": "&yscr;", "ю": "&yucy;", "ÿ": "&yuml;", "ź": "&zacute;", "ž": "&zcaron;", "з": "&zcy;", "ż": "&zdot;", "ζ": "&zeta;", "\uD835\uDD37": "&zfr;", "ж": "&zhcy;", "⇝": "&zigrarr;", "\uD835\uDD6B": "&zopf;", "\uD835\uDCCF": "&zscr;", "‍": "&zwj;", "‌": "&zwnj;" } } };
});

// node_modules/html-entities/lib/numeric-unicode-map.js
var require_numeric_unicode_map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.numericUnicodeMap = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
});

// node_modules/html-entities/lib/surrogate-pairs.js
var require_surrogate_pairs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromCodePoint = String.fromCodePoint || function(astralCodePoint) {
    return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
  };
  exports.getCodePoint = String.prototype.codePointAt ? function(input, position) {
    return input.codePointAt(position);
  } : function(input, position) {
    return (input.charCodeAt(position) - 55296) * 1024 + input.charCodeAt(position + 1) - 56320 + 65536;
  };
  exports.highSurrogateFrom = 55296;
  exports.highSurrogateTo = 56319;
});

// node_modules/html-entities/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var named_references_1 = require_named_references();
  var numeric_unicode_map_1 = require_numeric_unicode_map();
  var surrogate_pairs_1 = require_surrogate_pairs();
  var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), { all: named_references_1.namedReferences.html5 });
  function replaceUsingRegExp(macroText, macroRegExp, macroReplacer) {
    macroRegExp.lastIndex = 0;
    var replaceMatch = macroRegExp.exec(macroText);
    var replaceResult;
    if (replaceMatch) {
      replaceResult = "";
      var replaceLastIndex = 0;
      do {
        if (replaceLastIndex !== replaceMatch.index) {
          replaceResult += macroText.substring(replaceLastIndex, replaceMatch.index);
        }
        var replaceInput = replaceMatch[0];
        replaceResult += macroReplacer(replaceInput);
        replaceLastIndex = replaceMatch.index + replaceInput.length;
      } while (replaceMatch = macroRegExp.exec(macroText));
      if (replaceLastIndex !== macroText.length) {
        replaceResult += macroText.substring(replaceLastIndex);
      }
    } else {
      replaceResult = macroText;
    }
    return replaceResult;
  }
  var encodeRegExps = { specialChars: /[<>'"&]/g, nonAscii: /[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, nonAsciiPrintable: /[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, nonAsciiPrintableOnly: /[\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, extensive: /[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g };
  var defaultEncodeOptions = { mode: "specialChars", level: "all", numeric: "decimal" };
  function encode(text, _a) {
    var _b = _a === undefined ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === undefined ? "specialChars" : _c, _d = _b.numeric, numeric = _d === undefined ? "decimal" : _d, _e = _b.level, level = _e === undefined ? "all" : _e;
    if (!text) {
      return "";
    }
    var encodeRegExp = encodeRegExps[mode];
    var references = allNamedReferences[level].characters;
    var isHex = numeric === "hexadecimal";
    return replaceUsingRegExp(text, encodeRegExp, function(input) {
      var result = references[input];
      if (!result) {
        var code = input.length > 1 ? surrogate_pairs_1.getCodePoint(input, 0) : input.charCodeAt(0);
        result = (isHex ? "&#x" + code.toString(16) : "&#" + code) + ";";
      }
      return result;
    });
  }
  exports.encode = encode;
  var defaultDecodeOptions = { scope: "body", level: "all" };
  var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
  var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
  var baseDecodeRegExps = { xml: { strict, attribute, body: named_references_1.bodyRegExps.xml }, html4: { strict, attribute, body: named_references_1.bodyRegExps.html4 }, html5: { strict, attribute, body: named_references_1.bodyRegExps.html5 } };
  var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
  var fromCharCode = String.fromCharCode;
  var outOfBoundsChar = fromCharCode(65533);
  var defaultDecodeEntityOptions = { level: "all" };
  function getDecodedEntity(entity, references, isAttribute, isStrict) {
    var decodeResult = entity;
    var decodeEntityLastChar = entity[entity.length - 1];
    if (isAttribute && decodeEntityLastChar === "=") {
      decodeResult = entity;
    } else if (isStrict && decodeEntityLastChar !== ";") {
      decodeResult = entity;
    } else {
      var decodeResultByReference = references[entity];
      if (decodeResultByReference) {
        decodeResult = decodeResultByReference;
      } else if (entity[0] === "&" && entity[1] === "#") {
        var decodeSecondChar = entity[2];
        var decodeCode = decodeSecondChar == "x" || decodeSecondChar == "X" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
        decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode] || decodeCode);
      }
    }
    return decodeResult;
  }
  function decodeEntity(entity, _a) {
    var _b = (_a === undefined ? defaultDecodeEntityOptions : _a).level, level = _b === undefined ? "all" : _b;
    if (!entity) {
      return "";
    }
    return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);
  }
  exports.decodeEntity = decodeEntity;
  function decode(text, _a) {
    var _b = _a === undefined ? defaultDecodeOptions : _a, _c = _b.level, level = _c === undefined ? "all" : _c, _d = _b.scope, scope = _d === undefined ? level === "xml" ? "strict" : "body" : _d;
    if (!text) {
      return "";
    }
    var decodeRegExp = decodeRegExps[level][scope];
    var references = allNamedReferences[level].entities;
    var isAttribute = scope === "attribute";
    var isStrict = scope === "strict";
    return replaceUsingRegExp(text, decodeRegExp, function(entity) {
      return getDecodedEntity(entity, references, isAttribute, isStrict);
    });
  }
  exports.decode = decode;
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS((exports, module) => {
  /*! https://mths.be/punycode v1.4.1 by @mathias */
  (function(root) {
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = typeof module == "object" && module && !module.nodeType && module;
    var freeGlobal = typeof global == "object" && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root = freeGlobal;
    }
    var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length = string.length, value, extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map(array, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (;delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode(input) {
      var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j = 0;j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
        for (oldi = i, w = 1, k = base;; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return ucs2encode(output);
    }
    function encode(input) {
      var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n = initialN;
      delta = 0;
      bias = initialBias;
      for (j = 0;j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m = maxInt, j = 0;j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (j = 0;j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            for (q = delta, k = base;; k += base) {
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    }
    punycode = {
      version: "1.4.1",
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
      },
      decode,
      encode,
      toASCII,
      toUnicode
    };
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      define("punycode", function() {
        return punycode;
      });
    } else if (freeExports && freeModule) {
      if (exports == freeExports) {
        freeModule.exports = punycode;
      } else {
        for (key in punycode) {
          punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
        }
      }
    } else {
      root.punycode = punycode;
    }
  })(exports);
});

// node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
  module.exports = Object;
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
  module.exports = Math.abs;
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
  module.exports = Math.floor;
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
  module.exports = Math.max;
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
  module.exports = Math.min;
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
  module.exports = Math.pow;
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports, module) => {
  module.exports = Math.round;
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports, module) => {
  module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports, module) => {
  var $isNaN = require_isNaN();
  module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports, module) => {
  var $Object = require_es_object_atoms();
  module.exports = $Object.getPrototypeOf || null;
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
  module.exports = Function.prototype.call;
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
  module.exports = Function.prototype.apply;
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module.exports = $reflectApply || bind.call($call, $apply);
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $TypeError = require_type();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports, module) => {
  var reflectGetProto = require_Reflect_getPrototypeOf();
  var originalGetProto = require_Object_getPrototypeOf();
  var getDunderProto = require_get();
  module.exports = reflectGetProto ? function getProto(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto(O) {
    return getDunderProto(O);
  } : null;
});

// node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var round = require_round();
  var sign = require_sign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = require_get_proto();
  var $ObjectGPO = require_Object_getPrototypeOf();
  var $ReflectGPO = require_Reflect_getPrototypeOf();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow,
    "%Math.round%": round,
    "%Math.sign%": sign,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBindBasic = require_call_bind_apply_helpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic([intrinsic]);
    }
    return intrinsic;
  };
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports, module) => {
  var hasSymbols = require_shams();
  module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
  };
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS((exports, module) => {
  var callBound = require_call_bound();
  var hasToStringTag = require_shams2()();
  var hasOwn = require_hasown();
  var gOPD = require_gopd();
  var fn;
  if (hasToStringTag) {
    $exec = callBound("RegExp.prototype.exec");
    isRegexMarker = {};
    throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn = function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    };
  } else {
    $toString = callBound("Object.prototype.toString");
    regexClass = "[object RegExp]";
    fn = function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  var $exec;
  var isRegexMarker;
  var throwRegexMarker;
  var badStringifier;
  var $toString;
  var regexClass;
  module.exports = fn;
});

// node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS((exports, module) => {
  var callBound = require_call_bound();
  var isRegex = require_is_regex();
  var $exec = callBound("RegExp.prototype.exec");
  var $TypeError = require_type();
  module.exports = function regexTester(regex) {
    if (!isRegex(regex)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s) {
      return $exec(regex, s) !== null;
    };
  };
});

// node_modules/ent/reversed.json
var require_reversed = __commonJS((exports, module) => {
  module.exports = {
    "9": "Tab;",
    "10": "NewLine;",
    "33": "excl;",
    "34": "quot;",
    "35": "num;",
    "36": "dollar;",
    "37": "percnt;",
    "38": "amp;",
    "39": "apos;",
    "40": "lpar;",
    "41": "rpar;",
    "42": "midast;",
    "43": "plus;",
    "44": "comma;",
    "46": "period;",
    "47": "sol;",
    "58": "colon;",
    "59": "semi;",
    "60": "lt;",
    "61": "equals;",
    "62": "gt;",
    "63": "quest;",
    "64": "commat;",
    "91": "lsqb;",
    "92": "bsol;",
    "93": "rsqb;",
    "94": "Hat;",
    "95": "UnderBar;",
    "96": "grave;",
    "123": "lcub;",
    "124": "VerticalLine;",
    "125": "rcub;",
    "160": "NonBreakingSpace;",
    "161": "iexcl;",
    "162": "cent;",
    "163": "pound;",
    "164": "curren;",
    "165": "yen;",
    "166": "brvbar;",
    "167": "sect;",
    "168": "uml;",
    "169": "copy;",
    "170": "ordf;",
    "171": "laquo;",
    "172": "not;",
    "173": "shy;",
    "174": "reg;",
    "175": "strns;",
    "176": "deg;",
    "177": "pm;",
    "178": "sup2;",
    "179": "sup3;",
    "180": "DiacriticalAcute;",
    "181": "micro;",
    "182": "para;",
    "183": "middot;",
    "184": "Cedilla;",
    "185": "sup1;",
    "186": "ordm;",
    "187": "raquo;",
    "188": "frac14;",
    "189": "half;",
    "190": "frac34;",
    "191": "iquest;",
    "192": "Agrave;",
    "193": "Aacute;",
    "194": "Acirc;",
    "195": "Atilde;",
    "196": "Auml;",
    "197": "Aring;",
    "198": "AElig;",
    "199": "Ccedil;",
    "200": "Egrave;",
    "201": "Eacute;",
    "202": "Ecirc;",
    "203": "Euml;",
    "204": "Igrave;",
    "205": "Iacute;",
    "206": "Icirc;",
    "207": "Iuml;",
    "208": "ETH;",
    "209": "Ntilde;",
    "210": "Ograve;",
    "211": "Oacute;",
    "212": "Ocirc;",
    "213": "Otilde;",
    "214": "Ouml;",
    "215": "times;",
    "216": "Oslash;",
    "217": "Ugrave;",
    "218": "Uacute;",
    "219": "Ucirc;",
    "220": "Uuml;",
    "221": "Yacute;",
    "222": "THORN;",
    "223": "szlig;",
    "224": "agrave;",
    "225": "aacute;",
    "226": "acirc;",
    "227": "atilde;",
    "228": "auml;",
    "229": "aring;",
    "230": "aelig;",
    "231": "ccedil;",
    "232": "egrave;",
    "233": "eacute;",
    "234": "ecirc;",
    "235": "euml;",
    "236": "igrave;",
    "237": "iacute;",
    "238": "icirc;",
    "239": "iuml;",
    "240": "eth;",
    "241": "ntilde;",
    "242": "ograve;",
    "243": "oacute;",
    "244": "ocirc;",
    "245": "otilde;",
    "246": "ouml;",
    "247": "divide;",
    "248": "oslash;",
    "249": "ugrave;",
    "250": "uacute;",
    "251": "ucirc;",
    "252": "uuml;",
    "253": "yacute;",
    "254": "thorn;",
    "255": "yuml;",
    "256": "Amacr;",
    "257": "amacr;",
    "258": "Abreve;",
    "259": "abreve;",
    "260": "Aogon;",
    "261": "aogon;",
    "262": "Cacute;",
    "263": "cacute;",
    "264": "Ccirc;",
    "265": "ccirc;",
    "266": "Cdot;",
    "267": "cdot;",
    "268": "Ccaron;",
    "269": "ccaron;",
    "270": "Dcaron;",
    "271": "dcaron;",
    "272": "Dstrok;",
    "273": "dstrok;",
    "274": "Emacr;",
    "275": "emacr;",
    "278": "Edot;",
    "279": "edot;",
    "280": "Eogon;",
    "281": "eogon;",
    "282": "Ecaron;",
    "283": "ecaron;",
    "284": "Gcirc;",
    "285": "gcirc;",
    "286": "Gbreve;",
    "287": "gbreve;",
    "288": "Gdot;",
    "289": "gdot;",
    "290": "Gcedil;",
    "292": "Hcirc;",
    "293": "hcirc;",
    "294": "Hstrok;",
    "295": "hstrok;",
    "296": "Itilde;",
    "297": "itilde;",
    "298": "Imacr;",
    "299": "imacr;",
    "302": "Iogon;",
    "303": "iogon;",
    "304": "Idot;",
    "305": "inodot;",
    "306": "IJlig;",
    "307": "ijlig;",
    "308": "Jcirc;",
    "309": "jcirc;",
    "310": "Kcedil;",
    "311": "kcedil;",
    "312": "kgreen;",
    "313": "Lacute;",
    "314": "lacute;",
    "315": "Lcedil;",
    "316": "lcedil;",
    "317": "Lcaron;",
    "318": "lcaron;",
    "319": "Lmidot;",
    "320": "lmidot;",
    "321": "Lstrok;",
    "322": "lstrok;",
    "323": "Nacute;",
    "324": "nacute;",
    "325": "Ncedil;",
    "326": "ncedil;",
    "327": "Ncaron;",
    "328": "ncaron;",
    "329": "napos;",
    "330": "ENG;",
    "331": "eng;",
    "332": "Omacr;",
    "333": "omacr;",
    "336": "Odblac;",
    "337": "odblac;",
    "338": "OElig;",
    "339": "oelig;",
    "340": "Racute;",
    "341": "racute;",
    "342": "Rcedil;",
    "343": "rcedil;",
    "344": "Rcaron;",
    "345": "rcaron;",
    "346": "Sacute;",
    "347": "sacute;",
    "348": "Scirc;",
    "349": "scirc;",
    "350": "Scedil;",
    "351": "scedil;",
    "352": "Scaron;",
    "353": "scaron;",
    "354": "Tcedil;",
    "355": "tcedil;",
    "356": "Tcaron;",
    "357": "tcaron;",
    "358": "Tstrok;",
    "359": "tstrok;",
    "360": "Utilde;",
    "361": "utilde;",
    "362": "Umacr;",
    "363": "umacr;",
    "364": "Ubreve;",
    "365": "ubreve;",
    "366": "Uring;",
    "367": "uring;",
    "368": "Udblac;",
    "369": "udblac;",
    "370": "Uogon;",
    "371": "uogon;",
    "372": "Wcirc;",
    "373": "wcirc;",
    "374": "Ycirc;",
    "375": "ycirc;",
    "376": "Yuml;",
    "377": "Zacute;",
    "378": "zacute;",
    "379": "Zdot;",
    "380": "zdot;",
    "381": "Zcaron;",
    "382": "zcaron;",
    "402": "fnof;",
    "437": "imped;",
    "501": "gacute;",
    "567": "jmath;",
    "710": "circ;",
    "711": "Hacek;",
    "728": "breve;",
    "729": "dot;",
    "730": "ring;",
    "731": "ogon;",
    "732": "tilde;",
    "733": "DiacriticalDoubleAcute;",
    "785": "DownBreve;",
    "913": "Alpha;",
    "914": "Beta;",
    "915": "Gamma;",
    "916": "Delta;",
    "917": "Epsilon;",
    "918": "Zeta;",
    "919": "Eta;",
    "920": "Theta;",
    "921": "Iota;",
    "922": "Kappa;",
    "923": "Lambda;",
    "924": "Mu;",
    "925": "Nu;",
    "926": "Xi;",
    "927": "Omicron;",
    "928": "Pi;",
    "929": "Rho;",
    "931": "Sigma;",
    "932": "Tau;",
    "933": "Upsilon;",
    "934": "Phi;",
    "935": "Chi;",
    "936": "Psi;",
    "937": "Omega;",
    "945": "alpha;",
    "946": "beta;",
    "947": "gamma;",
    "948": "delta;",
    "949": "epsilon;",
    "950": "zeta;",
    "951": "eta;",
    "952": "theta;",
    "953": "iota;",
    "954": "kappa;",
    "955": "lambda;",
    "956": "mu;",
    "957": "nu;",
    "958": "xi;",
    "959": "omicron;",
    "960": "pi;",
    "961": "rho;",
    "962": "varsigma;",
    "963": "sigma;",
    "964": "tau;",
    "965": "upsilon;",
    "966": "phi;",
    "967": "chi;",
    "968": "psi;",
    "969": "omega;",
    "977": "vartheta;",
    "978": "upsih;",
    "981": "varphi;",
    "982": "varpi;",
    "988": "Gammad;",
    "989": "gammad;",
    "1008": "varkappa;",
    "1009": "varrho;",
    "1013": "varepsilon;",
    "1014": "bepsi;",
    "1025": "IOcy;",
    "1026": "DJcy;",
    "1027": "GJcy;",
    "1028": "Jukcy;",
    "1029": "DScy;",
    "1030": "Iukcy;",
    "1031": "YIcy;",
    "1032": "Jsercy;",
    "1033": "LJcy;",
    "1034": "NJcy;",
    "1035": "TSHcy;",
    "1036": "KJcy;",
    "1038": "Ubrcy;",
    "1039": "DZcy;",
    "1040": "Acy;",
    "1041": "Bcy;",
    "1042": "Vcy;",
    "1043": "Gcy;",
    "1044": "Dcy;",
    "1045": "IEcy;",
    "1046": "ZHcy;",
    "1047": "Zcy;",
    "1048": "Icy;",
    "1049": "Jcy;",
    "1050": "Kcy;",
    "1051": "Lcy;",
    "1052": "Mcy;",
    "1053": "Ncy;",
    "1054": "Ocy;",
    "1055": "Pcy;",
    "1056": "Rcy;",
    "1057": "Scy;",
    "1058": "Tcy;",
    "1059": "Ucy;",
    "1060": "Fcy;",
    "1061": "KHcy;",
    "1062": "TScy;",
    "1063": "CHcy;",
    "1064": "SHcy;",
    "1065": "SHCHcy;",
    "1066": "HARDcy;",
    "1067": "Ycy;",
    "1068": "SOFTcy;",
    "1069": "Ecy;",
    "1070": "YUcy;",
    "1071": "YAcy;",
    "1072": "acy;",
    "1073": "bcy;",
    "1074": "vcy;",
    "1075": "gcy;",
    "1076": "dcy;",
    "1077": "iecy;",
    "1078": "zhcy;",
    "1079": "zcy;",
    "1080": "icy;",
    "1081": "jcy;",
    "1082": "kcy;",
    "1083": "lcy;",
    "1084": "mcy;",
    "1085": "ncy;",
    "1086": "ocy;",
    "1087": "pcy;",
    "1088": "rcy;",
    "1089": "scy;",
    "1090": "tcy;",
    "1091": "ucy;",
    "1092": "fcy;",
    "1093": "khcy;",
    "1094": "tscy;",
    "1095": "chcy;",
    "1096": "shcy;",
    "1097": "shchcy;",
    "1098": "hardcy;",
    "1099": "ycy;",
    "1100": "softcy;",
    "1101": "ecy;",
    "1102": "yucy;",
    "1103": "yacy;",
    "1105": "iocy;",
    "1106": "djcy;",
    "1107": "gjcy;",
    "1108": "jukcy;",
    "1109": "dscy;",
    "1110": "iukcy;",
    "1111": "yicy;",
    "1112": "jsercy;",
    "1113": "ljcy;",
    "1114": "njcy;",
    "1115": "tshcy;",
    "1116": "kjcy;",
    "1118": "ubrcy;",
    "1119": "dzcy;",
    "8194": "ensp;",
    "8195": "emsp;",
    "8196": "emsp13;",
    "8197": "emsp14;",
    "8199": "numsp;",
    "8200": "puncsp;",
    "8201": "ThinSpace;",
    "8202": "VeryThinSpace;",
    "8203": "ZeroWidthSpace;",
    "8204": "zwnj;",
    "8205": "zwj;",
    "8206": "lrm;",
    "8207": "rlm;",
    "8208": "hyphen;",
    "8211": "ndash;",
    "8212": "mdash;",
    "8213": "horbar;",
    "8214": "Vert;",
    "8216": "OpenCurlyQuote;",
    "8217": "rsquor;",
    "8218": "sbquo;",
    "8220": "OpenCurlyDoubleQuote;",
    "8221": "rdquor;",
    "8222": "ldquor;",
    "8224": "dagger;",
    "8225": "ddagger;",
    "8226": "bullet;",
    "8229": "nldr;",
    "8230": "mldr;",
    "8240": "permil;",
    "8241": "pertenk;",
    "8242": "prime;",
    "8243": "Prime;",
    "8244": "tprime;",
    "8245": "bprime;",
    "8249": "lsaquo;",
    "8250": "rsaquo;",
    "8254": "OverBar;",
    "8257": "caret;",
    "8259": "hybull;",
    "8260": "frasl;",
    "8271": "bsemi;",
    "8279": "qprime;",
    "8287": "MediumSpace;",
    "8288": "NoBreak;",
    "8289": "ApplyFunction;",
    "8290": "it;",
    "8291": "InvisibleComma;",
    "8364": "euro;",
    "8411": "TripleDot;",
    "8412": "DotDot;",
    "8450": "Copf;",
    "8453": "incare;",
    "8458": "gscr;",
    "8459": "Hscr;",
    "8460": "Poincareplane;",
    "8461": "quaternions;",
    "8462": "planckh;",
    "8463": "plankv;",
    "8464": "Iscr;",
    "8465": "imagpart;",
    "8466": "Lscr;",
    "8467": "ell;",
    "8469": "Nopf;",
    "8470": "numero;",
    "8471": "copysr;",
    "8472": "wp;",
    "8473": "primes;",
    "8474": "rationals;",
    "8475": "Rscr;",
    "8476": "Rfr;",
    "8477": "Ropf;",
    "8478": "rx;",
    "8482": "trade;",
    "8484": "Zopf;",
    "8487": "mho;",
    "8488": "Zfr;",
    "8489": "iiota;",
    "8492": "Bscr;",
    "8493": "Cfr;",
    "8495": "escr;",
    "8496": "expectation;",
    "8497": "Fscr;",
    "8499": "phmmat;",
    "8500": "oscr;",
    "8501": "aleph;",
    "8502": "beth;",
    "8503": "gimel;",
    "8504": "daleth;",
    "8517": "DD;",
    "8518": "DifferentialD;",
    "8519": "exponentiale;",
    "8520": "ImaginaryI;",
    "8531": "frac13;",
    "8532": "frac23;",
    "8533": "frac15;",
    "8534": "frac25;",
    "8535": "frac35;",
    "8536": "frac45;",
    "8537": "frac16;",
    "8538": "frac56;",
    "8539": "frac18;",
    "8540": "frac38;",
    "8541": "frac58;",
    "8542": "frac78;",
    "8592": "slarr;",
    "8593": "uparrow;",
    "8594": "srarr;",
    "8595": "ShortDownArrow;",
    "8596": "leftrightarrow;",
    "8597": "varr;",
    "8598": "UpperLeftArrow;",
    "8599": "UpperRightArrow;",
    "8600": "searrow;",
    "8601": "swarrow;",
    "8602": "nleftarrow;",
    "8603": "nrightarrow;",
    "8605": "rightsquigarrow;",
    "8606": "twoheadleftarrow;",
    "8607": "Uarr;",
    "8608": "twoheadrightarrow;",
    "8609": "Darr;",
    "8610": "leftarrowtail;",
    "8611": "rightarrowtail;",
    "8612": "mapstoleft;",
    "8613": "UpTeeArrow;",
    "8614": "RightTeeArrow;",
    "8615": "mapstodown;",
    "8617": "larrhk;",
    "8618": "rarrhk;",
    "8619": "looparrowleft;",
    "8620": "rarrlp;",
    "8621": "leftrightsquigarrow;",
    "8622": "nleftrightarrow;",
    "8624": "lsh;",
    "8625": "rsh;",
    "8626": "ldsh;",
    "8627": "rdsh;",
    "8629": "crarr;",
    "8630": "curvearrowleft;",
    "8631": "curvearrowright;",
    "8634": "olarr;",
    "8635": "orarr;",
    "8636": "lharu;",
    "8637": "lhard;",
    "8638": "upharpoonright;",
    "8639": "upharpoonleft;",
    "8640": "RightVector;",
    "8641": "rightharpoondown;",
    "8642": "RightDownVector;",
    "8643": "LeftDownVector;",
    "8644": "rlarr;",
    "8645": "UpArrowDownArrow;",
    "8646": "lrarr;",
    "8647": "llarr;",
    "8648": "uuarr;",
    "8649": "rrarr;",
    "8650": "downdownarrows;",
    "8651": "ReverseEquilibrium;",
    "8652": "rlhar;",
    "8653": "nLeftarrow;",
    "8654": "nLeftrightarrow;",
    "8655": "nRightarrow;",
    "8656": "Leftarrow;",
    "8657": "Uparrow;",
    "8658": "Rightarrow;",
    "8659": "Downarrow;",
    "8660": "Leftrightarrow;",
    "8661": "vArr;",
    "8662": "nwArr;",
    "8663": "neArr;",
    "8664": "seArr;",
    "8665": "swArr;",
    "8666": "Lleftarrow;",
    "8667": "Rrightarrow;",
    "8669": "zigrarr;",
    "8676": "LeftArrowBar;",
    "8677": "RightArrowBar;",
    "8693": "duarr;",
    "8701": "loarr;",
    "8702": "roarr;",
    "8703": "hoarr;",
    "8704": "forall;",
    "8705": "complement;",
    "8706": "PartialD;",
    "8707": "Exists;",
    "8708": "NotExists;",
    "8709": "varnothing;",
    "8711": "nabla;",
    "8712": "isinv;",
    "8713": "notinva;",
    "8715": "SuchThat;",
    "8716": "NotReverseElement;",
    "8719": "Product;",
    "8720": "Coproduct;",
    "8721": "sum;",
    "8722": "minus;",
    "8723": "mp;",
    "8724": "plusdo;",
    "8726": "ssetmn;",
    "8727": "lowast;",
    "8728": "SmallCircle;",
    "8730": "Sqrt;",
    "8733": "vprop;",
    "8734": "infin;",
    "8735": "angrt;",
    "8736": "angle;",
    "8737": "measuredangle;",
    "8738": "angsph;",
    "8739": "VerticalBar;",
    "8740": "nsmid;",
    "8741": "spar;",
    "8742": "nspar;",
    "8743": "wedge;",
    "8744": "vee;",
    "8745": "cap;",
    "8746": "cup;",
    "8747": "Integral;",
    "8748": "Int;",
    "8749": "tint;",
    "8750": "oint;",
    "8751": "DoubleContourIntegral;",
    "8752": "Cconint;",
    "8753": "cwint;",
    "8754": "cwconint;",
    "8755": "CounterClockwiseContourIntegral;",
    "8756": "therefore;",
    "8757": "because;",
    "8758": "ratio;",
    "8759": "Proportion;",
    "8760": "minusd;",
    "8762": "mDDot;",
    "8763": "homtht;",
    "8764": "Tilde;",
    "8765": "bsim;",
    "8766": "mstpos;",
    "8767": "acd;",
    "8768": "wreath;",
    "8769": "nsim;",
    "8770": "esim;",
    "8771": "TildeEqual;",
    "8772": "nsimeq;",
    "8773": "TildeFullEqual;",
    "8774": "simne;",
    "8775": "NotTildeFullEqual;",
    "8776": "TildeTilde;",
    "8777": "NotTildeTilde;",
    "8778": "approxeq;",
    "8779": "apid;",
    "8780": "bcong;",
    "8781": "CupCap;",
    "8782": "HumpDownHump;",
    "8783": "HumpEqual;",
    "8784": "esdot;",
    "8785": "eDot;",
    "8786": "fallingdotseq;",
    "8787": "risingdotseq;",
    "8788": "coloneq;",
    "8789": "eqcolon;",
    "8790": "eqcirc;",
    "8791": "cire;",
    "8793": "wedgeq;",
    "8794": "veeeq;",
    "8796": "trie;",
    "8799": "questeq;",
    "8800": "NotEqual;",
    "8801": "equiv;",
    "8802": "NotCongruent;",
    "8804": "leq;",
    "8805": "GreaterEqual;",
    "8806": "LessFullEqual;",
    "8807": "GreaterFullEqual;",
    "8808": "lneqq;",
    "8809": "gneqq;",
    "8810": "NestedLessLess;",
    "8811": "NestedGreaterGreater;",
    "8812": "twixt;",
    "8813": "NotCupCap;",
    "8814": "NotLess;",
    "8815": "NotGreater;",
    "8816": "NotLessEqual;",
    "8817": "NotGreaterEqual;",
    "8818": "lsim;",
    "8819": "gtrsim;",
    "8820": "NotLessTilde;",
    "8821": "NotGreaterTilde;",
    "8822": "lg;",
    "8823": "gtrless;",
    "8824": "ntlg;",
    "8825": "ntgl;",
    "8826": "Precedes;",
    "8827": "Succeeds;",
    "8828": "PrecedesSlantEqual;",
    "8829": "SucceedsSlantEqual;",
    "8830": "prsim;",
    "8831": "succsim;",
    "8832": "nprec;",
    "8833": "nsucc;",
    "8834": "subset;",
    "8835": "supset;",
    "8836": "nsub;",
    "8837": "nsup;",
    "8838": "SubsetEqual;",
    "8839": "supseteq;",
    "8840": "nsubseteq;",
    "8841": "nsupseteq;",
    "8842": "subsetneq;",
    "8843": "supsetneq;",
    "8845": "cupdot;",
    "8846": "uplus;",
    "8847": "SquareSubset;",
    "8848": "SquareSuperset;",
    "8849": "SquareSubsetEqual;",
    "8850": "SquareSupersetEqual;",
    "8851": "SquareIntersection;",
    "8852": "SquareUnion;",
    "8853": "oplus;",
    "8854": "ominus;",
    "8855": "otimes;",
    "8856": "osol;",
    "8857": "odot;",
    "8858": "ocir;",
    "8859": "oast;",
    "8861": "odash;",
    "8862": "plusb;",
    "8863": "minusb;",
    "8864": "timesb;",
    "8865": "sdotb;",
    "8866": "vdash;",
    "8867": "LeftTee;",
    "8868": "top;",
    "8869": "UpTee;",
    "8871": "models;",
    "8872": "vDash;",
    "8873": "Vdash;",
    "8874": "Vvdash;",
    "8875": "VDash;",
    "8876": "nvdash;",
    "8877": "nvDash;",
    "8878": "nVdash;",
    "8879": "nVDash;",
    "8880": "prurel;",
    "8882": "vltri;",
    "8883": "vrtri;",
    "8884": "trianglelefteq;",
    "8885": "trianglerighteq;",
    "8886": "origof;",
    "8887": "imof;",
    "8888": "mumap;",
    "8889": "hercon;",
    "8890": "intercal;",
    "8891": "veebar;",
    "8893": "barvee;",
    "8894": "angrtvb;",
    "8895": "lrtri;",
    "8896": "xwedge;",
    "8897": "xvee;",
    "8898": "xcap;",
    "8899": "xcup;",
    "8900": "diamond;",
    "8901": "sdot;",
    "8902": "Star;",
    "8903": "divonx;",
    "8904": "bowtie;",
    "8905": "ltimes;",
    "8906": "rtimes;",
    "8907": "lthree;",
    "8908": "rthree;",
    "8909": "bsime;",
    "8910": "cuvee;",
    "8911": "cuwed;",
    "8912": "Subset;",
    "8913": "Supset;",
    "8914": "Cap;",
    "8915": "Cup;",
    "8916": "pitchfork;",
    "8917": "epar;",
    "8918": "ltdot;",
    "8919": "gtrdot;",
    "8920": "Ll;",
    "8921": "ggg;",
    "8922": "LessEqualGreater;",
    "8923": "gtreqless;",
    "8926": "curlyeqprec;",
    "8927": "curlyeqsucc;",
    "8928": "nprcue;",
    "8929": "nsccue;",
    "8930": "nsqsube;",
    "8931": "nsqsupe;",
    "8934": "lnsim;",
    "8935": "gnsim;",
    "8936": "prnsim;",
    "8937": "succnsim;",
    "8938": "ntriangleleft;",
    "8939": "ntriangleright;",
    "8940": "ntrianglelefteq;",
    "8941": "ntrianglerighteq;",
    "8942": "vellip;",
    "8943": "ctdot;",
    "8944": "utdot;",
    "8945": "dtdot;",
    "8946": "disin;",
    "8947": "isinsv;",
    "8948": "isins;",
    "8949": "isindot;",
    "8950": "notinvc;",
    "8951": "notinvb;",
    "8953": "isinE;",
    "8954": "nisd;",
    "8955": "xnis;",
    "8956": "nis;",
    "8957": "notnivc;",
    "8958": "notnivb;",
    "8965": "barwedge;",
    "8966": "doublebarwedge;",
    "8968": "LeftCeiling;",
    "8969": "RightCeiling;",
    "8970": "lfloor;",
    "8971": "RightFloor;",
    "8972": "drcrop;",
    "8973": "dlcrop;",
    "8974": "urcrop;",
    "8975": "ulcrop;",
    "8976": "bnot;",
    "8978": "profline;",
    "8979": "profsurf;",
    "8981": "telrec;",
    "8982": "target;",
    "8988": "ulcorner;",
    "8989": "urcorner;",
    "8990": "llcorner;",
    "8991": "lrcorner;",
    "8994": "sfrown;",
    "8995": "ssmile;",
    "9005": "cylcty;",
    "9006": "profalar;",
    "9014": "topbot;",
    "9021": "ovbar;",
    "9023": "solbar;",
    "9084": "angzarr;",
    "9136": "lmoustache;",
    "9137": "rmoustache;",
    "9140": "tbrk;",
    "9141": "UnderBracket;",
    "9142": "bbrktbrk;",
    "9180": "OverParenthesis;",
    "9181": "UnderParenthesis;",
    "9182": "OverBrace;",
    "9183": "UnderBrace;",
    "9186": "trpezium;",
    "9191": "elinters;",
    "9251": "blank;",
    "9416": "oS;",
    "9472": "HorizontalLine;",
    "9474": "boxv;",
    "9484": "boxdr;",
    "9488": "boxdl;",
    "9492": "boxur;",
    "9496": "boxul;",
    "9500": "boxvr;",
    "9508": "boxvl;",
    "9516": "boxhd;",
    "9524": "boxhu;",
    "9532": "boxvh;",
    "9552": "boxH;",
    "9553": "boxV;",
    "9554": "boxdR;",
    "9555": "boxDr;",
    "9556": "boxDR;",
    "9557": "boxdL;",
    "9558": "boxDl;",
    "9559": "boxDL;",
    "9560": "boxuR;",
    "9561": "boxUr;",
    "9562": "boxUR;",
    "9563": "boxuL;",
    "9564": "boxUl;",
    "9565": "boxUL;",
    "9566": "boxvR;",
    "9567": "boxVr;",
    "9568": "boxVR;",
    "9569": "boxvL;",
    "9570": "boxVl;",
    "9571": "boxVL;",
    "9572": "boxHd;",
    "9573": "boxhD;",
    "9574": "boxHD;",
    "9575": "boxHu;",
    "9576": "boxhU;",
    "9577": "boxHU;",
    "9578": "boxvH;",
    "9579": "boxVh;",
    "9580": "boxVH;",
    "9600": "uhblk;",
    "9604": "lhblk;",
    "9608": "block;",
    "9617": "blk14;",
    "9618": "blk12;",
    "9619": "blk34;",
    "9633": "square;",
    "9642": "squf;",
    "9643": "EmptyVerySmallSquare;",
    "9645": "rect;",
    "9646": "marker;",
    "9649": "fltns;",
    "9651": "xutri;",
    "9652": "utrif;",
    "9653": "utri;",
    "9656": "rtrif;",
    "9657": "triangleright;",
    "9661": "xdtri;",
    "9662": "dtrif;",
    "9663": "triangledown;",
    "9666": "ltrif;",
    "9667": "triangleleft;",
    "9674": "lozenge;",
    "9675": "cir;",
    "9708": "tridot;",
    "9711": "xcirc;",
    "9720": "ultri;",
    "9721": "urtri;",
    "9722": "lltri;",
    "9723": "EmptySmallSquare;",
    "9724": "FilledSmallSquare;",
    "9733": "starf;",
    "9734": "star;",
    "9742": "phone;",
    "9792": "female;",
    "9794": "male;",
    "9824": "spadesuit;",
    "9827": "clubsuit;",
    "9829": "heartsuit;",
    "9830": "diams;",
    "9834": "sung;",
    "9837": "flat;",
    "9838": "natural;",
    "9839": "sharp;",
    "10003": "checkmark;",
    "10007": "cross;",
    "10016": "maltese;",
    "10038": "sext;",
    "10072": "VerticalSeparator;",
    "10098": "lbbrk;",
    "10099": "rbbrk;",
    "10184": "bsolhsub;",
    "10185": "suphsol;",
    "10214": "lobrk;",
    "10215": "robrk;",
    "10216": "LeftAngleBracket;",
    "10217": "RightAngleBracket;",
    "10218": "Lang;",
    "10219": "Rang;",
    "10220": "loang;",
    "10221": "roang;",
    "10229": "xlarr;",
    "10230": "xrarr;",
    "10231": "xharr;",
    "10232": "xlArr;",
    "10233": "xrArr;",
    "10234": "xhArr;",
    "10236": "xmap;",
    "10239": "dzigrarr;",
    "10498": "nvlArr;",
    "10499": "nvrArr;",
    "10500": "nvHarr;",
    "10501": "Map;",
    "10508": "lbarr;",
    "10509": "rbarr;",
    "10510": "lBarr;",
    "10511": "rBarr;",
    "10512": "RBarr;",
    "10513": "DDotrahd;",
    "10514": "UpArrowBar;",
    "10515": "DownArrowBar;",
    "10518": "Rarrtl;",
    "10521": "latail;",
    "10522": "ratail;",
    "10523": "lAtail;",
    "10524": "rAtail;",
    "10525": "larrfs;",
    "10526": "rarrfs;",
    "10527": "larrbfs;",
    "10528": "rarrbfs;",
    "10531": "nwarhk;",
    "10532": "nearhk;",
    "10533": "searhk;",
    "10534": "swarhk;",
    "10535": "nwnear;",
    "10536": "toea;",
    "10537": "tosa;",
    "10538": "swnwar;",
    "10547": "rarrc;",
    "10549": "cudarrr;",
    "10550": "ldca;",
    "10551": "rdca;",
    "10552": "cudarrl;",
    "10553": "larrpl;",
    "10556": "curarrm;",
    "10557": "cularrp;",
    "10565": "rarrpl;",
    "10568": "harrcir;",
    "10569": "Uarrocir;",
    "10570": "lurdshar;",
    "10571": "ldrushar;",
    "10574": "LeftRightVector;",
    "10575": "RightUpDownVector;",
    "10576": "DownLeftRightVector;",
    "10577": "LeftUpDownVector;",
    "10578": "LeftVectorBar;",
    "10579": "RightVectorBar;",
    "10580": "RightUpVectorBar;",
    "10581": "RightDownVectorBar;",
    "10582": "DownLeftVectorBar;",
    "10583": "DownRightVectorBar;",
    "10584": "LeftUpVectorBar;",
    "10585": "LeftDownVectorBar;",
    "10586": "LeftTeeVector;",
    "10587": "RightTeeVector;",
    "10588": "RightUpTeeVector;",
    "10589": "RightDownTeeVector;",
    "10590": "DownLeftTeeVector;",
    "10591": "DownRightTeeVector;",
    "10592": "LeftUpTeeVector;",
    "10593": "LeftDownTeeVector;",
    "10594": "lHar;",
    "10595": "uHar;",
    "10596": "rHar;",
    "10597": "dHar;",
    "10598": "luruhar;",
    "10599": "ldrdhar;",
    "10600": "ruluhar;",
    "10601": "rdldhar;",
    "10602": "lharul;",
    "10603": "llhard;",
    "10604": "rharul;",
    "10605": "lrhard;",
    "10606": "UpEquilibrium;",
    "10607": "ReverseUpEquilibrium;",
    "10608": "RoundImplies;",
    "10609": "erarr;",
    "10610": "simrarr;",
    "10611": "larrsim;",
    "10612": "rarrsim;",
    "10613": "rarrap;",
    "10614": "ltlarr;",
    "10616": "gtrarr;",
    "10617": "subrarr;",
    "10619": "suplarr;",
    "10620": "lfisht;",
    "10621": "rfisht;",
    "10622": "ufisht;",
    "10623": "dfisht;",
    "10629": "lopar;",
    "10630": "ropar;",
    "10635": "lbrke;",
    "10636": "rbrke;",
    "10637": "lbrkslu;",
    "10638": "rbrksld;",
    "10639": "lbrksld;",
    "10640": "rbrkslu;",
    "10641": "langd;",
    "10642": "rangd;",
    "10643": "lparlt;",
    "10644": "rpargt;",
    "10645": "gtlPar;",
    "10646": "ltrPar;",
    "10650": "vzigzag;",
    "10652": "vangrt;",
    "10653": "angrtvbd;",
    "10660": "ange;",
    "10661": "range;",
    "10662": "dwangle;",
    "10663": "uwangle;",
    "10664": "angmsdaa;",
    "10665": "angmsdab;",
    "10666": "angmsdac;",
    "10667": "angmsdad;",
    "10668": "angmsdae;",
    "10669": "angmsdaf;",
    "10670": "angmsdag;",
    "10671": "angmsdah;",
    "10672": "bemptyv;",
    "10673": "demptyv;",
    "10674": "cemptyv;",
    "10675": "raemptyv;",
    "10676": "laemptyv;",
    "10677": "ohbar;",
    "10678": "omid;",
    "10679": "opar;",
    "10681": "operp;",
    "10683": "olcross;",
    "10684": "odsold;",
    "10686": "olcir;",
    "10687": "ofcir;",
    "10688": "olt;",
    "10689": "ogt;",
    "10690": "cirscir;",
    "10691": "cirE;",
    "10692": "solb;",
    "10693": "bsolb;",
    "10697": "boxbox;",
    "10701": "trisb;",
    "10702": "rtriltri;",
    "10703": "LeftTriangleBar;",
    "10704": "RightTriangleBar;",
    "10716": "iinfin;",
    "10717": "infintie;",
    "10718": "nvinfin;",
    "10723": "eparsl;",
    "10724": "smeparsl;",
    "10725": "eqvparsl;",
    "10731": "lozf;",
    "10740": "RuleDelayed;",
    "10742": "dsol;",
    "10752": "xodot;",
    "10753": "xoplus;",
    "10754": "xotime;",
    "10756": "xuplus;",
    "10758": "xsqcup;",
    "10764": "qint;",
    "10765": "fpartint;",
    "10768": "cirfnint;",
    "10769": "awint;",
    "10770": "rppolint;",
    "10771": "scpolint;",
    "10772": "npolint;",
    "10773": "pointint;",
    "10774": "quatint;",
    "10775": "intlarhk;",
    "10786": "pluscir;",
    "10787": "plusacir;",
    "10788": "simplus;",
    "10789": "plusdu;",
    "10790": "plussim;",
    "10791": "plustwo;",
    "10793": "mcomma;",
    "10794": "minusdu;",
    "10797": "loplus;",
    "10798": "roplus;",
    "10799": "Cross;",
    "10800": "timesd;",
    "10801": "timesbar;",
    "10803": "smashp;",
    "10804": "lotimes;",
    "10805": "rotimes;",
    "10806": "otimesas;",
    "10807": "Otimes;",
    "10808": "odiv;",
    "10809": "triplus;",
    "10810": "triminus;",
    "10811": "tritime;",
    "10812": "iprod;",
    "10815": "amalg;",
    "10816": "capdot;",
    "10818": "ncup;",
    "10819": "ncap;",
    "10820": "capand;",
    "10821": "cupor;",
    "10822": "cupcap;",
    "10823": "capcup;",
    "10824": "cupbrcap;",
    "10825": "capbrcup;",
    "10826": "cupcup;",
    "10827": "capcap;",
    "10828": "ccups;",
    "10829": "ccaps;",
    "10832": "ccupssm;",
    "10835": "And;",
    "10836": "Or;",
    "10837": "andand;",
    "10838": "oror;",
    "10839": "orslope;",
    "10840": "andslope;",
    "10842": "andv;",
    "10843": "orv;",
    "10844": "andd;",
    "10845": "ord;",
    "10847": "wedbar;",
    "10854": "sdote;",
    "10858": "simdot;",
    "10861": "congdot;",
    "10862": "easter;",
    "10863": "apacir;",
    "10864": "apE;",
    "10865": "eplus;",
    "10866": "pluse;",
    "10867": "Esim;",
    "10868": "Colone;",
    "10869": "Equal;",
    "10871": "eDDot;",
    "10872": "equivDD;",
    "10873": "ltcir;",
    "10874": "gtcir;",
    "10875": "ltquest;",
    "10876": "gtquest;",
    "10877": "LessSlantEqual;",
    "10878": "GreaterSlantEqual;",
    "10879": "lesdot;",
    "10880": "gesdot;",
    "10881": "lesdoto;",
    "10882": "gesdoto;",
    "10883": "lesdotor;",
    "10884": "gesdotol;",
    "10885": "lessapprox;",
    "10886": "gtrapprox;",
    "10887": "lneq;",
    "10888": "gneq;",
    "10889": "lnapprox;",
    "10890": "gnapprox;",
    "10891": "lesseqqgtr;",
    "10892": "gtreqqless;",
    "10893": "lsime;",
    "10894": "gsime;",
    "10895": "lsimg;",
    "10896": "gsiml;",
    "10897": "lgE;",
    "10898": "glE;",
    "10899": "lesges;",
    "10900": "gesles;",
    "10901": "eqslantless;",
    "10902": "eqslantgtr;",
    "10903": "elsdot;",
    "10904": "egsdot;",
    "10905": "el;",
    "10906": "eg;",
    "10909": "siml;",
    "10910": "simg;",
    "10911": "simlE;",
    "10912": "simgE;",
    "10913": "LessLess;",
    "10914": "GreaterGreater;",
    "10916": "glj;",
    "10917": "gla;",
    "10918": "ltcc;",
    "10919": "gtcc;",
    "10920": "lescc;",
    "10921": "gescc;",
    "10922": "smt;",
    "10923": "lat;",
    "10924": "smte;",
    "10925": "late;",
    "10926": "bumpE;",
    "10927": "preceq;",
    "10928": "succeq;",
    "10931": "prE;",
    "10932": "scE;",
    "10933": "prnE;",
    "10934": "succneqq;",
    "10935": "precapprox;",
    "10936": "succapprox;",
    "10937": "prnap;",
    "10938": "succnapprox;",
    "10939": "Pr;",
    "10940": "Sc;",
    "10941": "subdot;",
    "10942": "supdot;",
    "10943": "subplus;",
    "10944": "supplus;",
    "10945": "submult;",
    "10946": "supmult;",
    "10947": "subedot;",
    "10948": "supedot;",
    "10949": "subseteqq;",
    "10950": "supseteqq;",
    "10951": "subsim;",
    "10952": "supsim;",
    "10955": "subsetneqq;",
    "10956": "supsetneqq;",
    "10959": "csub;",
    "10960": "csup;",
    "10961": "csube;",
    "10962": "csupe;",
    "10963": "subsup;",
    "10964": "supsub;",
    "10965": "subsub;",
    "10966": "supsup;",
    "10967": "suphsub;",
    "10968": "supdsub;",
    "10969": "forkv;",
    "10970": "topfork;",
    "10971": "mlcp;",
    "10980": "DoubleLeftTee;",
    "10982": "Vdashl;",
    "10983": "Barv;",
    "10984": "vBar;",
    "10985": "vBarv;",
    "10987": "Vbar;",
    "10988": "Not;",
    "10989": "bNot;",
    "10990": "rnmid;",
    "10991": "cirmid;",
    "10992": "midcir;",
    "10993": "topcir;",
    "10994": "nhpar;",
    "10995": "parsim;",
    "11005": "parsl;",
    "64256": "fflig;",
    "64257": "filig;",
    "64258": "fllig;",
    "64259": "ffilig;",
    "64260": "ffllig;"
  };
});

// node_modules/ent/encode.js
var require_encode = __commonJS((exports, module) => {
  var punycode = require_punycode();
  var $decode = punycode.ucs2.decode;
  var $encode = punycode.ucs2.encode;
  var $TypeError = require_type();
  var regexTest = require_safe_regex_test();
  var revEntities = require_reversed();
  var endsInSemicolon = regexTest(/;$/);
  var defaultSpecial = {
    '"': true,
    "'": true,
    "<": true,
    ">": true,
    "&": true
  };
  module.exports = function encode(str, opts) {
    if (typeof str !== "string") {
      throw new $TypeError("Expected a String");
    }
    var numeric = !opts || !opts.named;
    if (opts && typeof opts.numeric !== "undefined") {
      numeric = opts.numeric;
    }
    var special = opts && opts.special || defaultSpecial;
    var codePoints = $decode(str);
    var chars = [];
    for (var i = 0;i < codePoints.length; i++) {
      var cc = codePoints[i];
      var c = $encode([cc]);
      var e = revEntities[cc];
      if (e && (cc >= 127 || special[c]) && !numeric) {
        var hasSemi = endsInSemicolon(e);
        chars[chars.length] = "&" + (hasSemi ? e : e + ";");
      } else if (cc < 32 || cc >= 127 || special[c]) {
        chars[chars.length] = "&#" + cc + ";";
      } else {
        chars[chars.length] = c;
      }
    }
    return chars.join("");
  };
});

// node_modules/ent/entities.json
var require_entities = __commonJS((exports, module) => {
  module.exports = {
    "Aacute;": "Á",
    Aacute: "Á",
    "aacute;": "á",
    aacute: "á",
    "Abreve;": "Ă",
    "abreve;": "ă",
    "ac;": "∾",
    "acd;": "∿",
    "acE;": "∾̳",
    "Acirc;": "Â",
    Acirc: "Â",
    "acirc;": "â",
    acirc: "â",
    "acute;": "´",
    acute: "´",
    "Acy;": "А",
    "acy;": "а",
    "AElig;": "Æ",
    AElig: "Æ",
    "aelig;": "æ",
    aelig: "æ",
    "af;": "⁡",
    "Afr;": "\uD835\uDD04",
    "afr;": "\uD835\uDD1E",
    "Agrave;": "À",
    Agrave: "À",
    "agrave;": "à",
    agrave: "à",
    "alefsym;": "ℵ",
    "aleph;": "ℵ",
    "Alpha;": "Α",
    "alpha;": "α",
    "Amacr;": "Ā",
    "amacr;": "ā",
    "amalg;": "⨿",
    "AMP;": "&",
    AMP: "&",
    "amp;": "&",
    amp: "&",
    "And;": "⩓",
    "and;": "∧",
    "andand;": "⩕",
    "andd;": "⩜",
    "andslope;": "⩘",
    "andv;": "⩚",
    "ang;": "∠",
    "ange;": "⦤",
    "angle;": "∠",
    "angmsd;": "∡",
    "angmsdaa;": "⦨",
    "angmsdab;": "⦩",
    "angmsdac;": "⦪",
    "angmsdad;": "⦫",
    "angmsdae;": "⦬",
    "angmsdaf;": "⦭",
    "angmsdag;": "⦮",
    "angmsdah;": "⦯",
    "angrt;": "∟",
    "angrtvb;": "⊾",
    "angrtvbd;": "⦝",
    "angsph;": "∢",
    "angst;": "Å",
    "angzarr;": "⍼",
    "Aogon;": "Ą",
    "aogon;": "ą",
    "Aopf;": "\uD835\uDD38",
    "aopf;": "\uD835\uDD52",
    "ap;": "≈",
    "apacir;": "⩯",
    "apE;": "⩰",
    "ape;": "≊",
    "apid;": "≋",
    "apos;": "'",
    "ApplyFunction;": "⁡",
    "approx;": "≈",
    "approxeq;": "≊",
    "Aring;": "Å",
    Aring: "Å",
    "aring;": "å",
    aring: "å",
    "Ascr;": "\uD835\uDC9C",
    "ascr;": "\uD835\uDCB6",
    "Assign;": "≔",
    "ast;": "*",
    "asymp;": "≈",
    "asympeq;": "≍",
    "Atilde;": "Ã",
    Atilde: "Ã",
    "atilde;": "ã",
    atilde: "ã",
    "Auml;": "Ä",
    Auml: "Ä",
    "auml;": "ä",
    auml: "ä",
    "awconint;": "∳",
    "awint;": "⨑",
    "backcong;": "≌",
    "backepsilon;": "϶",
    "backprime;": "‵",
    "backsim;": "∽",
    "backsimeq;": "⋍",
    "Backslash;": "∖",
    "Barv;": "⫧",
    "barvee;": "⊽",
    "Barwed;": "⌆",
    "barwed;": "⌅",
    "barwedge;": "⌅",
    "bbrk;": "⎵",
    "bbrktbrk;": "⎶",
    "bcong;": "≌",
    "Bcy;": "Б",
    "bcy;": "б",
    "bdquo;": "„",
    "becaus;": "∵",
    "Because;": "∵",
    "because;": "∵",
    "bemptyv;": "⦰",
    "bepsi;": "϶",
    "bernou;": "ℬ",
    "Bernoullis;": "ℬ",
    "Beta;": "Β",
    "beta;": "β",
    "beth;": "ℶ",
    "between;": "≬",
    "Bfr;": "\uD835\uDD05",
    "bfr;": "\uD835\uDD1F",
    "bigcap;": "⋂",
    "bigcirc;": "◯",
    "bigcup;": "⋃",
    "bigodot;": "⨀",
    "bigoplus;": "⨁",
    "bigotimes;": "⨂",
    "bigsqcup;": "⨆",
    "bigstar;": "★",
    "bigtriangledown;": "▽",
    "bigtriangleup;": "△",
    "biguplus;": "⨄",
    "bigvee;": "⋁",
    "bigwedge;": "⋀",
    "bkarow;": "⤍",
    "blacklozenge;": "⧫",
    "blacksquare;": "▪",
    "blacktriangle;": "▴",
    "blacktriangledown;": "▾",
    "blacktriangleleft;": "◂",
    "blacktriangleright;": "▸",
    "blank;": "␣",
    "blk12;": "▒",
    "blk14;": "░",
    "blk34;": "▓",
    "block;": "█",
    "bne;": "=⃥",
    "bnequiv;": "≡⃥",
    "bNot;": "⫭",
    "bnot;": "⌐",
    "Bopf;": "\uD835\uDD39",
    "bopf;": "\uD835\uDD53",
    "bot;": "⊥",
    "bottom;": "⊥",
    "bowtie;": "⋈",
    "boxbox;": "⧉",
    "boxDL;": "╗",
    "boxDl;": "╖",
    "boxdL;": "╕",
    "boxdl;": "┐",
    "boxDR;": "╔",
    "boxDr;": "╓",
    "boxdR;": "╒",
    "boxdr;": "┌",
    "boxH;": "═",
    "boxh;": "─",
    "boxHD;": "╦",
    "boxHd;": "╤",
    "boxhD;": "╥",
    "boxhd;": "┬",
    "boxHU;": "╩",
    "boxHu;": "╧",
    "boxhU;": "╨",
    "boxhu;": "┴",
    "boxminus;": "⊟",
    "boxplus;": "⊞",
    "boxtimes;": "⊠",
    "boxUL;": "╝",
    "boxUl;": "╜",
    "boxuL;": "╛",
    "boxul;": "┘",
    "boxUR;": "╚",
    "boxUr;": "╙",
    "boxuR;": "╘",
    "boxur;": "└",
    "boxV;": "║",
    "boxv;": "│",
    "boxVH;": "╬",
    "boxVh;": "╫",
    "boxvH;": "╪",
    "boxvh;": "┼",
    "boxVL;": "╣",
    "boxVl;": "╢",
    "boxvL;": "╡",
    "boxvl;": "┤",
    "boxVR;": "╠",
    "boxVr;": "╟",
    "boxvR;": "╞",
    "boxvr;": "├",
    "bprime;": "‵",
    "Breve;": "˘",
    "breve;": "˘",
    "brvbar;": "¦",
    brvbar: "¦",
    "Bscr;": "ℬ",
    "bscr;": "\uD835\uDCB7",
    "bsemi;": "⁏",
    "bsim;": "∽",
    "bsime;": "⋍",
    "bsol;": "\\",
    "bsolb;": "⧅",
    "bsolhsub;": "⟈",
    "bull;": "•",
    "bullet;": "•",
    "bump;": "≎",
    "bumpE;": "⪮",
    "bumpe;": "≏",
    "Bumpeq;": "≎",
    "bumpeq;": "≏",
    "Cacute;": "Ć",
    "cacute;": "ć",
    "Cap;": "⋒",
    "cap;": "∩",
    "capand;": "⩄",
    "capbrcup;": "⩉",
    "capcap;": "⩋",
    "capcup;": "⩇",
    "capdot;": "⩀",
    "CapitalDifferentialD;": "ⅅ",
    "caps;": "∩︀",
    "caret;": "⁁",
    "caron;": "ˇ",
    "Cayleys;": "ℭ",
    "ccaps;": "⩍",
    "Ccaron;": "Č",
    "ccaron;": "č",
    "Ccedil;": "Ç",
    Ccedil: "Ç",
    "ccedil;": "ç",
    ccedil: "ç",
    "Ccirc;": "Ĉ",
    "ccirc;": "ĉ",
    "Cconint;": "∰",
    "ccups;": "⩌",
    "ccupssm;": "⩐",
    "Cdot;": "Ċ",
    "cdot;": "ċ",
    "cedil;": "¸",
    cedil: "¸",
    "Cedilla;": "¸",
    "cemptyv;": "⦲",
    "cent;": "¢",
    cent: "¢",
    "CenterDot;": "·",
    "centerdot;": "·",
    "Cfr;": "ℭ",
    "cfr;": "\uD835\uDD20",
    "CHcy;": "Ч",
    "chcy;": "ч",
    "check;": "✓",
    "checkmark;": "✓",
    "Chi;": "Χ",
    "chi;": "χ",
    "cir;": "○",
    "circ;": "ˆ",
    "circeq;": "≗",
    "circlearrowleft;": "↺",
    "circlearrowright;": "↻",
    "circledast;": "⊛",
    "circledcirc;": "⊚",
    "circleddash;": "⊝",
    "CircleDot;": "⊙",
    "circledR;": "®",
    "circledS;": "Ⓢ",
    "CircleMinus;": "⊖",
    "CirclePlus;": "⊕",
    "CircleTimes;": "⊗",
    "cirE;": "⧃",
    "cire;": "≗",
    "cirfnint;": "⨐",
    "cirmid;": "⫯",
    "cirscir;": "⧂",
    "ClockwiseContourIntegral;": "∲",
    "CloseCurlyDoubleQuote;": "”",
    "CloseCurlyQuote;": "’",
    "clubs;": "♣",
    "clubsuit;": "♣",
    "Colon;": "∷",
    "colon;": ":",
    "Colone;": "⩴",
    "colone;": "≔",
    "coloneq;": "≔",
    "comma;": ",",
    "commat;": "@",
    "comp;": "∁",
    "compfn;": "∘",
    "complement;": "∁",
    "complexes;": "ℂ",
    "cong;": "≅",
    "congdot;": "⩭",
    "Congruent;": "≡",
    "Conint;": "∯",
    "conint;": "∮",
    "ContourIntegral;": "∮",
    "Copf;": "ℂ",
    "copf;": "\uD835\uDD54",
    "coprod;": "∐",
    "Coproduct;": "∐",
    "COPY;": "©",
    COPY: "©",
    "copy;": "©",
    copy: "©",
    "copysr;": "℗",
    "CounterClockwiseContourIntegral;": "∳",
    "crarr;": "↵",
    "Cross;": "⨯",
    "cross;": "✗",
    "Cscr;": "\uD835\uDC9E",
    "cscr;": "\uD835\uDCB8",
    "csub;": "⫏",
    "csube;": "⫑",
    "csup;": "⫐",
    "csupe;": "⫒",
    "ctdot;": "⋯",
    "cudarrl;": "⤸",
    "cudarrr;": "⤵",
    "cuepr;": "⋞",
    "cuesc;": "⋟",
    "cularr;": "↶",
    "cularrp;": "⤽",
    "Cup;": "⋓",
    "cup;": "∪",
    "cupbrcap;": "⩈",
    "CupCap;": "≍",
    "cupcap;": "⩆",
    "cupcup;": "⩊",
    "cupdot;": "⊍",
    "cupor;": "⩅",
    "cups;": "∪︀",
    "curarr;": "↷",
    "curarrm;": "⤼",
    "curlyeqprec;": "⋞",
    "curlyeqsucc;": "⋟",
    "curlyvee;": "⋎",
    "curlywedge;": "⋏",
    "curren;": "¤",
    curren: "¤",
    "curvearrowleft;": "↶",
    "curvearrowright;": "↷",
    "cuvee;": "⋎",
    "cuwed;": "⋏",
    "cwconint;": "∲",
    "cwint;": "∱",
    "cylcty;": "⌭",
    "Dagger;": "‡",
    "dagger;": "†",
    "daleth;": "ℸ",
    "Darr;": "↡",
    "dArr;": "⇓",
    "darr;": "↓",
    "dash;": "‐",
    "Dashv;": "⫤",
    "dashv;": "⊣",
    "dbkarow;": "⤏",
    "dblac;": "˝",
    "Dcaron;": "Ď",
    "dcaron;": "ď",
    "Dcy;": "Д",
    "dcy;": "д",
    "DD;": "ⅅ",
    "dd;": "ⅆ",
    "ddagger;": "‡",
    "ddarr;": "⇊",
    "DDotrahd;": "⤑",
    "ddotseq;": "⩷",
    "deg;": "°",
    deg: "°",
    "Del;": "∇",
    "Delta;": "Δ",
    "delta;": "δ",
    "demptyv;": "⦱",
    "dfisht;": "⥿",
    "Dfr;": "\uD835\uDD07",
    "dfr;": "\uD835\uDD21",
    "dHar;": "⥥",
    "dharl;": "⇃",
    "dharr;": "⇂",
    "DiacriticalAcute;": "´",
    "DiacriticalDot;": "˙",
    "DiacriticalDoubleAcute;": "˝",
    "DiacriticalGrave;": "`",
    "DiacriticalTilde;": "˜",
    "diam;": "⋄",
    "Diamond;": "⋄",
    "diamond;": "⋄",
    "diamondsuit;": "♦",
    "diams;": "♦",
    "die;": "¨",
    "DifferentialD;": "ⅆ",
    "digamma;": "ϝ",
    "disin;": "⋲",
    "div;": "÷",
    "divide;": "÷",
    divide: "÷",
    "divideontimes;": "⋇",
    "divonx;": "⋇",
    "DJcy;": "Ђ",
    "djcy;": "ђ",
    "dlcorn;": "⌞",
    "dlcrop;": "⌍",
    "dollar;": "$",
    "Dopf;": "\uD835\uDD3B",
    "dopf;": "\uD835\uDD55",
    "Dot;": "¨",
    "dot;": "˙",
    "DotDot;": "⃜",
    "doteq;": "≐",
    "doteqdot;": "≑",
    "DotEqual;": "≐",
    "dotminus;": "∸",
    "dotplus;": "∔",
    "dotsquare;": "⊡",
    "doublebarwedge;": "⌆",
    "DoubleContourIntegral;": "∯",
    "DoubleDot;": "¨",
    "DoubleDownArrow;": "⇓",
    "DoubleLeftArrow;": "⇐",
    "DoubleLeftRightArrow;": "⇔",
    "DoubleLeftTee;": "⫤",
    "DoubleLongLeftArrow;": "⟸",
    "DoubleLongLeftRightArrow;": "⟺",
    "DoubleLongRightArrow;": "⟹",
    "DoubleRightArrow;": "⇒",
    "DoubleRightTee;": "⊨",
    "DoubleUpArrow;": "⇑",
    "DoubleUpDownArrow;": "⇕",
    "DoubleVerticalBar;": "∥",
    "DownArrow;": "↓",
    "Downarrow;": "⇓",
    "downarrow;": "↓",
    "DownArrowBar;": "⤓",
    "DownArrowUpArrow;": "⇵",
    "DownBreve;": "̑",
    "downdownarrows;": "⇊",
    "downharpoonleft;": "⇃",
    "downharpoonright;": "⇂",
    "DownLeftRightVector;": "⥐",
    "DownLeftTeeVector;": "⥞",
    "DownLeftVector;": "↽",
    "DownLeftVectorBar;": "⥖",
    "DownRightTeeVector;": "⥟",
    "DownRightVector;": "⇁",
    "DownRightVectorBar;": "⥗",
    "DownTee;": "⊤",
    "DownTeeArrow;": "↧",
    "drbkarow;": "⤐",
    "drcorn;": "⌟",
    "drcrop;": "⌌",
    "Dscr;": "\uD835\uDC9F",
    "dscr;": "\uD835\uDCB9",
    "DScy;": "Ѕ",
    "dscy;": "ѕ",
    "dsol;": "⧶",
    "Dstrok;": "Đ",
    "dstrok;": "đ",
    "dtdot;": "⋱",
    "dtri;": "▿",
    "dtrif;": "▾",
    "duarr;": "⇵",
    "duhar;": "⥯",
    "dwangle;": "⦦",
    "DZcy;": "Џ",
    "dzcy;": "џ",
    "dzigrarr;": "⟿",
    "Eacute;": "É",
    Eacute: "É",
    "eacute;": "é",
    eacute: "é",
    "easter;": "⩮",
    "Ecaron;": "Ě",
    "ecaron;": "ě",
    "ecir;": "≖",
    "Ecirc;": "Ê",
    Ecirc: "Ê",
    "ecirc;": "ê",
    ecirc: "ê",
    "ecolon;": "≕",
    "Ecy;": "Э",
    "ecy;": "э",
    "eDDot;": "⩷",
    "Edot;": "Ė",
    "eDot;": "≑",
    "edot;": "ė",
    "ee;": "ⅇ",
    "efDot;": "≒",
    "Efr;": "\uD835\uDD08",
    "efr;": "\uD835\uDD22",
    "eg;": "⪚",
    "Egrave;": "È",
    Egrave: "È",
    "egrave;": "è",
    egrave: "è",
    "egs;": "⪖",
    "egsdot;": "⪘",
    "el;": "⪙",
    "Element;": "∈",
    "elinters;": "⏧",
    "ell;": "ℓ",
    "els;": "⪕",
    "elsdot;": "⪗",
    "Emacr;": "Ē",
    "emacr;": "ē",
    "empty;": "∅",
    "emptyset;": "∅",
    "EmptySmallSquare;": "◻",
    "emptyv;": "∅",
    "EmptyVerySmallSquare;": "▫",
    "emsp;": " ",
    "emsp13;": " ",
    "emsp14;": " ",
    "ENG;": "Ŋ",
    "eng;": "ŋ",
    "ensp;": " ",
    "Eogon;": "Ę",
    "eogon;": "ę",
    "Eopf;": "\uD835\uDD3C",
    "eopf;": "\uD835\uDD56",
    "epar;": "⋕",
    "eparsl;": "⧣",
    "eplus;": "⩱",
    "epsi;": "ε",
    "Epsilon;": "Ε",
    "epsilon;": "ε",
    "epsiv;": "ϵ",
    "eqcirc;": "≖",
    "eqcolon;": "≕",
    "eqsim;": "≂",
    "eqslantgtr;": "⪖",
    "eqslantless;": "⪕",
    "Equal;": "⩵",
    "equals;": "=",
    "EqualTilde;": "≂",
    "equest;": "≟",
    "Equilibrium;": "⇌",
    "equiv;": "≡",
    "equivDD;": "⩸",
    "eqvparsl;": "⧥",
    "erarr;": "⥱",
    "erDot;": "≓",
    "Escr;": "ℰ",
    "escr;": "ℯ",
    "esdot;": "≐",
    "Esim;": "⩳",
    "esim;": "≂",
    "Eta;": "Η",
    "eta;": "η",
    "ETH;": "Ð",
    ETH: "Ð",
    "eth;": "ð",
    eth: "ð",
    "Euml;": "Ë",
    Euml: "Ë",
    "euml;": "ë",
    euml: "ë",
    "euro;": "€",
    "excl;": "!",
    "exist;": "∃",
    "Exists;": "∃",
    "expectation;": "ℰ",
    "ExponentialE;": "ⅇ",
    "exponentiale;": "ⅇ",
    "fallingdotseq;": "≒",
    "Fcy;": "Ф",
    "fcy;": "ф",
    "female;": "♀",
    "ffilig;": "ﬃ",
    "fflig;": "ﬀ",
    "ffllig;": "ﬄ",
    "Ffr;": "\uD835\uDD09",
    "ffr;": "\uD835\uDD23",
    "filig;": "ﬁ",
    "FilledSmallSquare;": "◼",
    "FilledVerySmallSquare;": "▪",
    "fjlig;": "fj",
    "flat;": "♭",
    "fllig;": "ﬂ",
    "fltns;": "▱",
    "fnof;": "ƒ",
    "Fopf;": "\uD835\uDD3D",
    "fopf;": "\uD835\uDD57",
    "ForAll;": "∀",
    "forall;": "∀",
    "fork;": "⋔",
    "forkv;": "⫙",
    "Fouriertrf;": "ℱ",
    "fpartint;": "⨍",
    "frac12;": "½",
    frac12: "½",
    "frac13;": "⅓",
    "frac14;": "¼",
    frac14: "¼",
    "frac15;": "⅕",
    "frac16;": "⅙",
    "frac18;": "⅛",
    "frac23;": "⅔",
    "frac25;": "⅖",
    "frac34;": "¾",
    frac34: "¾",
    "frac35;": "⅗",
    "frac38;": "⅜",
    "frac45;": "⅘",
    "frac56;": "⅚",
    "frac58;": "⅝",
    "frac78;": "⅞",
    "frasl;": "⁄",
    "frown;": "⌢",
    "Fscr;": "ℱ",
    "fscr;": "\uD835\uDCBB",
    "gacute;": "ǵ",
    "Gamma;": "Γ",
    "gamma;": "γ",
    "Gammad;": "Ϝ",
    "gammad;": "ϝ",
    "gap;": "⪆",
    "Gbreve;": "Ğ",
    "gbreve;": "ğ",
    "Gcedil;": "Ģ",
    "Gcirc;": "Ĝ",
    "gcirc;": "ĝ",
    "Gcy;": "Г",
    "gcy;": "г",
    "Gdot;": "Ġ",
    "gdot;": "ġ",
    "gE;": "≧",
    "ge;": "≥",
    "gEl;": "⪌",
    "gel;": "⋛",
    "geq;": "≥",
    "geqq;": "≧",
    "geqslant;": "⩾",
    "ges;": "⩾",
    "gescc;": "⪩",
    "gesdot;": "⪀",
    "gesdoto;": "⪂",
    "gesdotol;": "⪄",
    "gesl;": "⋛︀",
    "gesles;": "⪔",
    "Gfr;": "\uD835\uDD0A",
    "gfr;": "\uD835\uDD24",
    "Gg;": "⋙",
    "gg;": "≫",
    "ggg;": "⋙",
    "gimel;": "ℷ",
    "GJcy;": "Ѓ",
    "gjcy;": "ѓ",
    "gl;": "≷",
    "gla;": "⪥",
    "glE;": "⪒",
    "glj;": "⪤",
    "gnap;": "⪊",
    "gnapprox;": "⪊",
    "gnE;": "≩",
    "gne;": "⪈",
    "gneq;": "⪈",
    "gneqq;": "≩",
    "gnsim;": "⋧",
    "Gopf;": "\uD835\uDD3E",
    "gopf;": "\uD835\uDD58",
    "grave;": "`",
    "GreaterEqual;": "≥",
    "GreaterEqualLess;": "⋛",
    "GreaterFullEqual;": "≧",
    "GreaterGreater;": "⪢",
    "GreaterLess;": "≷",
    "GreaterSlantEqual;": "⩾",
    "GreaterTilde;": "≳",
    "Gscr;": "\uD835\uDCA2",
    "gscr;": "ℊ",
    "gsim;": "≳",
    "gsime;": "⪎",
    "gsiml;": "⪐",
    "GT;": ">",
    GT: ">",
    "Gt;": "≫",
    "gt;": ">",
    gt: ">",
    "gtcc;": "⪧",
    "gtcir;": "⩺",
    "gtdot;": "⋗",
    "gtlPar;": "⦕",
    "gtquest;": "⩼",
    "gtrapprox;": "⪆",
    "gtrarr;": "⥸",
    "gtrdot;": "⋗",
    "gtreqless;": "⋛",
    "gtreqqless;": "⪌",
    "gtrless;": "≷",
    "gtrsim;": "≳",
    "gvertneqq;": "≩︀",
    "gvnE;": "≩︀",
    "Hacek;": "ˇ",
    "hairsp;": " ",
    "half;": "½",
    "hamilt;": "ℋ",
    "HARDcy;": "Ъ",
    "hardcy;": "ъ",
    "hArr;": "⇔",
    "harr;": "↔",
    "harrcir;": "⥈",
    "harrw;": "↭",
    "Hat;": "^",
    "hbar;": "ℏ",
    "Hcirc;": "Ĥ",
    "hcirc;": "ĥ",
    "hearts;": "♥",
    "heartsuit;": "♥",
    "hellip;": "…",
    "hercon;": "⊹",
    "Hfr;": "ℌ",
    "hfr;": "\uD835\uDD25",
    "HilbertSpace;": "ℋ",
    "hksearow;": "⤥",
    "hkswarow;": "⤦",
    "hoarr;": "⇿",
    "homtht;": "∻",
    "hookleftarrow;": "↩",
    "hookrightarrow;": "↪",
    "Hopf;": "ℍ",
    "hopf;": "\uD835\uDD59",
    "horbar;": "―",
    "HorizontalLine;": "─",
    "Hscr;": "ℋ",
    "hscr;": "\uD835\uDCBD",
    "hslash;": "ℏ",
    "Hstrok;": "Ħ",
    "hstrok;": "ħ",
    "HumpDownHump;": "≎",
    "HumpEqual;": "≏",
    "hybull;": "⁃",
    "hyphen;": "‐",
    "Iacute;": "Í",
    Iacute: "Í",
    "iacute;": "í",
    iacute: "í",
    "ic;": "⁣",
    "Icirc;": "Î",
    Icirc: "Î",
    "icirc;": "î",
    icirc: "î",
    "Icy;": "И",
    "icy;": "и",
    "Idot;": "İ",
    "IEcy;": "Е",
    "iecy;": "е",
    "iexcl;": "¡",
    iexcl: "¡",
    "iff;": "⇔",
    "Ifr;": "ℑ",
    "ifr;": "\uD835\uDD26",
    "Igrave;": "Ì",
    Igrave: "Ì",
    "igrave;": "ì",
    igrave: "ì",
    "ii;": "ⅈ",
    "iiiint;": "⨌",
    "iiint;": "∭",
    "iinfin;": "⧜",
    "iiota;": "℩",
    "IJlig;": "Ĳ",
    "ijlig;": "ĳ",
    "Im;": "ℑ",
    "Imacr;": "Ī",
    "imacr;": "ī",
    "image;": "ℑ",
    "ImaginaryI;": "ⅈ",
    "imagline;": "ℐ",
    "imagpart;": "ℑ",
    "imath;": "ı",
    "imof;": "⊷",
    "imped;": "Ƶ",
    "Implies;": "⇒",
    "in;": "∈",
    "incare;": "℅",
    "infin;": "∞",
    "infintie;": "⧝",
    "inodot;": "ı",
    "Int;": "∬",
    "int;": "∫",
    "intcal;": "⊺",
    "integers;": "ℤ",
    "Integral;": "∫",
    "intercal;": "⊺",
    "Intersection;": "⋂",
    "intlarhk;": "⨗",
    "intprod;": "⨼",
    "InvisibleComma;": "⁣",
    "InvisibleTimes;": "⁢",
    "IOcy;": "Ё",
    "iocy;": "ё",
    "Iogon;": "Į",
    "iogon;": "į",
    "Iopf;": "\uD835\uDD40",
    "iopf;": "\uD835\uDD5A",
    "Iota;": "Ι",
    "iota;": "ι",
    "iprod;": "⨼",
    "iquest;": "¿",
    iquest: "¿",
    "Iscr;": "ℐ",
    "iscr;": "\uD835\uDCBE",
    "isin;": "∈",
    "isindot;": "⋵",
    "isinE;": "⋹",
    "isins;": "⋴",
    "isinsv;": "⋳",
    "isinv;": "∈",
    "it;": "⁢",
    "Itilde;": "Ĩ",
    "itilde;": "ĩ",
    "Iukcy;": "І",
    "iukcy;": "і",
    "Iuml;": "Ï",
    Iuml: "Ï",
    "iuml;": "ï",
    iuml: "ï",
    "Jcirc;": "Ĵ",
    "jcirc;": "ĵ",
    "Jcy;": "Й",
    "jcy;": "й",
    "Jfr;": "\uD835\uDD0D",
    "jfr;": "\uD835\uDD27",
    "jmath;": "ȷ",
    "Jopf;": "\uD835\uDD41",
    "jopf;": "\uD835\uDD5B",
    "Jscr;": "\uD835\uDCA5",
    "jscr;": "\uD835\uDCBF",
    "Jsercy;": "Ј",
    "jsercy;": "ј",
    "Jukcy;": "Є",
    "jukcy;": "є",
    "Kappa;": "Κ",
    "kappa;": "κ",
    "kappav;": "ϰ",
    "Kcedil;": "Ķ",
    "kcedil;": "ķ",
    "Kcy;": "К",
    "kcy;": "к",
    "Kfr;": "\uD835\uDD0E",
    "kfr;": "\uD835\uDD28",
    "kgreen;": "ĸ",
    "KHcy;": "Х",
    "khcy;": "х",
    "KJcy;": "Ќ",
    "kjcy;": "ќ",
    "Kopf;": "\uD835\uDD42",
    "kopf;": "\uD835\uDD5C",
    "Kscr;": "\uD835\uDCA6",
    "kscr;": "\uD835\uDCC0",
    "lAarr;": "⇚",
    "Lacute;": "Ĺ",
    "lacute;": "ĺ",
    "laemptyv;": "⦴",
    "lagran;": "ℒ",
    "Lambda;": "Λ",
    "lambda;": "λ",
    "Lang;": "⟪",
    "lang;": "⟨",
    "langd;": "⦑",
    "langle;": "⟨",
    "lap;": "⪅",
    "Laplacetrf;": "ℒ",
    "laquo;": "«",
    laquo: "«",
    "Larr;": "↞",
    "lArr;": "⇐",
    "larr;": "←",
    "larrb;": "⇤",
    "larrbfs;": "⤟",
    "larrfs;": "⤝",
    "larrhk;": "↩",
    "larrlp;": "↫",
    "larrpl;": "⤹",
    "larrsim;": "⥳",
    "larrtl;": "↢",
    "lat;": "⪫",
    "lAtail;": "⤛",
    "latail;": "⤙",
    "late;": "⪭",
    "lates;": "⪭︀",
    "lBarr;": "⤎",
    "lbarr;": "⤌",
    "lbbrk;": "❲",
    "lbrace;": "{",
    "lbrack;": "[",
    "lbrke;": "⦋",
    "lbrksld;": "⦏",
    "lbrkslu;": "⦍",
    "Lcaron;": "Ľ",
    "lcaron;": "ľ",
    "Lcedil;": "Ļ",
    "lcedil;": "ļ",
    "lceil;": "⌈",
    "lcub;": "{",
    "Lcy;": "Л",
    "lcy;": "л",
    "ldca;": "⤶",
    "ldquo;": "“",
    "ldquor;": "„",
    "ldrdhar;": "⥧",
    "ldrushar;": "⥋",
    "ldsh;": "↲",
    "lE;": "≦",
    "le;": "≤",
    "LeftAngleBracket;": "⟨",
    "LeftArrow;": "←",
    "Leftarrow;": "⇐",
    "leftarrow;": "←",
    "LeftArrowBar;": "⇤",
    "LeftArrowRightArrow;": "⇆",
    "leftarrowtail;": "↢",
    "LeftCeiling;": "⌈",
    "LeftDoubleBracket;": "⟦",
    "LeftDownTeeVector;": "⥡",
    "LeftDownVector;": "⇃",
    "LeftDownVectorBar;": "⥙",
    "LeftFloor;": "⌊",
    "leftharpoondown;": "↽",
    "leftharpoonup;": "↼",
    "leftleftarrows;": "⇇",
    "LeftRightArrow;": "↔",
    "Leftrightarrow;": "⇔",
    "leftrightarrow;": "↔",
    "leftrightarrows;": "⇆",
    "leftrightharpoons;": "⇋",
    "leftrightsquigarrow;": "↭",
    "LeftRightVector;": "⥎",
    "LeftTee;": "⊣",
    "LeftTeeArrow;": "↤",
    "LeftTeeVector;": "⥚",
    "leftthreetimes;": "⋋",
    "LeftTriangle;": "⊲",
    "LeftTriangleBar;": "⧏",
    "LeftTriangleEqual;": "⊴",
    "LeftUpDownVector;": "⥑",
    "LeftUpTeeVector;": "⥠",
    "LeftUpVector;": "↿",
    "LeftUpVectorBar;": "⥘",
    "LeftVector;": "↼",
    "LeftVectorBar;": "⥒",
    "lEg;": "⪋",
    "leg;": "⋚",
    "leq;": "≤",
    "leqq;": "≦",
    "leqslant;": "⩽",
    "les;": "⩽",
    "lescc;": "⪨",
    "lesdot;": "⩿",
    "lesdoto;": "⪁",
    "lesdotor;": "⪃",
    "lesg;": "⋚︀",
    "lesges;": "⪓",
    "lessapprox;": "⪅",
    "lessdot;": "⋖",
    "lesseqgtr;": "⋚",
    "lesseqqgtr;": "⪋",
    "LessEqualGreater;": "⋚",
    "LessFullEqual;": "≦",
    "LessGreater;": "≶",
    "lessgtr;": "≶",
    "LessLess;": "⪡",
    "lesssim;": "≲",
    "LessSlantEqual;": "⩽",
    "LessTilde;": "≲",
    "lfisht;": "⥼",
    "lfloor;": "⌊",
    "Lfr;": "\uD835\uDD0F",
    "lfr;": "\uD835\uDD29",
    "lg;": "≶",
    "lgE;": "⪑",
    "lHar;": "⥢",
    "lhard;": "↽",
    "lharu;": "↼",
    "lharul;": "⥪",
    "lhblk;": "▄",
    "LJcy;": "Љ",
    "ljcy;": "љ",
    "Ll;": "⋘",
    "ll;": "≪",
    "llarr;": "⇇",
    "llcorner;": "⌞",
    "Lleftarrow;": "⇚",
    "llhard;": "⥫",
    "lltri;": "◺",
    "Lmidot;": "Ŀ",
    "lmidot;": "ŀ",
    "lmoust;": "⎰",
    "lmoustache;": "⎰",
    "lnap;": "⪉",
    "lnapprox;": "⪉",
    "lnE;": "≨",
    "lne;": "⪇",
    "lneq;": "⪇",
    "lneqq;": "≨",
    "lnsim;": "⋦",
    "loang;": "⟬",
    "loarr;": "⇽",
    "lobrk;": "⟦",
    "LongLeftArrow;": "⟵",
    "Longleftarrow;": "⟸",
    "longleftarrow;": "⟵",
    "LongLeftRightArrow;": "⟷",
    "Longleftrightarrow;": "⟺",
    "longleftrightarrow;": "⟷",
    "longmapsto;": "⟼",
    "LongRightArrow;": "⟶",
    "Longrightarrow;": "⟹",
    "longrightarrow;": "⟶",
    "looparrowleft;": "↫",
    "looparrowright;": "↬",
    "lopar;": "⦅",
    "Lopf;": "\uD835\uDD43",
    "lopf;": "\uD835\uDD5D",
    "loplus;": "⨭",
    "lotimes;": "⨴",
    "lowast;": "∗",
    "lowbar;": "_",
    "LowerLeftArrow;": "↙",
    "LowerRightArrow;": "↘",
    "loz;": "◊",
    "lozenge;": "◊",
    "lozf;": "⧫",
    "lpar;": "(",
    "lparlt;": "⦓",
    "lrarr;": "⇆",
    "lrcorner;": "⌟",
    "lrhar;": "⇋",
    "lrhard;": "⥭",
    "lrm;": "‎",
    "lrtri;": "⊿",
    "lsaquo;": "‹",
    "Lscr;": "ℒ",
    "lscr;": "\uD835\uDCC1",
    "Lsh;": "↰",
    "lsh;": "↰",
    "lsim;": "≲",
    "lsime;": "⪍",
    "lsimg;": "⪏",
    "lsqb;": "[",
    "lsquo;": "‘",
    "lsquor;": "‚",
    "Lstrok;": "Ł",
    "lstrok;": "ł",
    "LT;": "<",
    LT: "<",
    "Lt;": "≪",
    "lt;": "<",
    lt: "<",
    "ltcc;": "⪦",
    "ltcir;": "⩹",
    "ltdot;": "⋖",
    "lthree;": "⋋",
    "ltimes;": "⋉",
    "ltlarr;": "⥶",
    "ltquest;": "⩻",
    "ltri;": "◃",
    "ltrie;": "⊴",
    "ltrif;": "◂",
    "ltrPar;": "⦖",
    "lurdshar;": "⥊",
    "luruhar;": "⥦",
    "lvertneqq;": "≨︀",
    "lvnE;": "≨︀",
    "macr;": "¯",
    macr: "¯",
    "male;": "♂",
    "malt;": "✠",
    "maltese;": "✠",
    "Map;": "⤅",
    "map;": "↦",
    "mapsto;": "↦",
    "mapstodown;": "↧",
    "mapstoleft;": "↤",
    "mapstoup;": "↥",
    "marker;": "▮",
    "mcomma;": "⨩",
    "Mcy;": "М",
    "mcy;": "м",
    "mdash;": "—",
    "mDDot;": "∺",
    "measuredangle;": "∡",
    "MediumSpace;": " ",
    "Mellintrf;": "ℳ",
    "Mfr;": "\uD835\uDD10",
    "mfr;": "\uD835\uDD2A",
    "mho;": "℧",
    "micro;": "µ",
    micro: "µ",
    "mid;": "∣",
    "midast;": "*",
    "midcir;": "⫰",
    "middot;": "·",
    middot: "·",
    "minus;": "−",
    "minusb;": "⊟",
    "minusd;": "∸",
    "minusdu;": "⨪",
    "MinusPlus;": "∓",
    "mlcp;": "⫛",
    "mldr;": "…",
    "mnplus;": "∓",
    "models;": "⊧",
    "Mopf;": "\uD835\uDD44",
    "mopf;": "\uD835\uDD5E",
    "mp;": "∓",
    "Mscr;": "ℳ",
    "mscr;": "\uD835\uDCC2",
    "mstpos;": "∾",
    "Mu;": "Μ",
    "mu;": "μ",
    "multimap;": "⊸",
    "mumap;": "⊸",
    "nabla;": "∇",
    "Nacute;": "Ń",
    "nacute;": "ń",
    "nang;": "∠⃒",
    "nap;": "≉",
    "napE;": "⩰̸",
    "napid;": "≋̸",
    "napos;": "ŉ",
    "napprox;": "≉",
    "natur;": "♮",
    "natural;": "♮",
    "naturals;": "ℕ",
    "nbsp;": " ",
    nbsp: " ",
    "nbump;": "≎̸",
    "nbumpe;": "≏̸",
    "ncap;": "⩃",
    "Ncaron;": "Ň",
    "ncaron;": "ň",
    "Ncedil;": "Ņ",
    "ncedil;": "ņ",
    "ncong;": "≇",
    "ncongdot;": "⩭̸",
    "ncup;": "⩂",
    "Ncy;": "Н",
    "ncy;": "н",
    "ndash;": "–",
    "ne;": "≠",
    "nearhk;": "⤤",
    "neArr;": "⇗",
    "nearr;": "↗",
    "nearrow;": "↗",
    "nedot;": "≐̸",
    "NegativeMediumSpace;": "​",
    "NegativeThickSpace;": "​",
    "NegativeThinSpace;": "​",
    "NegativeVeryThinSpace;": "​",
    "nequiv;": "≢",
    "nesear;": "⤨",
    "nesim;": "≂̸",
    "NestedGreaterGreater;": "≫",
    "NestedLessLess;": "≪",
    "NewLine;": `
`,
    "nexist;": "∄",
    "nexists;": "∄",
    "Nfr;": "\uD835\uDD11",
    "nfr;": "\uD835\uDD2B",
    "ngE;": "≧̸",
    "nge;": "≱",
    "ngeq;": "≱",
    "ngeqq;": "≧̸",
    "ngeqslant;": "⩾̸",
    "nges;": "⩾̸",
    "nGg;": "⋙̸",
    "ngsim;": "≵",
    "nGt;": "≫⃒",
    "ngt;": "≯",
    "ngtr;": "≯",
    "nGtv;": "≫̸",
    "nhArr;": "⇎",
    "nharr;": "↮",
    "nhpar;": "⫲",
    "ni;": "∋",
    "nis;": "⋼",
    "nisd;": "⋺",
    "niv;": "∋",
    "NJcy;": "Њ",
    "njcy;": "њ",
    "nlArr;": "⇍",
    "nlarr;": "↚",
    "nldr;": "‥",
    "nlE;": "≦̸",
    "nle;": "≰",
    "nLeftarrow;": "⇍",
    "nleftarrow;": "↚",
    "nLeftrightarrow;": "⇎",
    "nleftrightarrow;": "↮",
    "nleq;": "≰",
    "nleqq;": "≦̸",
    "nleqslant;": "⩽̸",
    "nles;": "⩽̸",
    "nless;": "≮",
    "nLl;": "⋘̸",
    "nlsim;": "≴",
    "nLt;": "≪⃒",
    "nlt;": "≮",
    "nltri;": "⋪",
    "nltrie;": "⋬",
    "nLtv;": "≪̸",
    "nmid;": "∤",
    "NoBreak;": "⁠",
    "NonBreakingSpace;": " ",
    "Nopf;": "ℕ",
    "nopf;": "\uD835\uDD5F",
    "Not;": "⫬",
    "not;": "¬",
    not: "¬",
    "NotCongruent;": "≢",
    "NotCupCap;": "≭",
    "NotDoubleVerticalBar;": "∦",
    "NotElement;": "∉",
    "NotEqual;": "≠",
    "NotEqualTilde;": "≂̸",
    "NotExists;": "∄",
    "NotGreater;": "≯",
    "NotGreaterEqual;": "≱",
    "NotGreaterFullEqual;": "≧̸",
    "NotGreaterGreater;": "≫̸",
    "NotGreaterLess;": "≹",
    "NotGreaterSlantEqual;": "⩾̸",
    "NotGreaterTilde;": "≵",
    "NotHumpDownHump;": "≎̸",
    "NotHumpEqual;": "≏̸",
    "notin;": "∉",
    "notindot;": "⋵̸",
    "notinE;": "⋹̸",
    "notinva;": "∉",
    "notinvb;": "⋷",
    "notinvc;": "⋶",
    "NotLeftTriangle;": "⋪",
    "NotLeftTriangleBar;": "⧏̸",
    "NotLeftTriangleEqual;": "⋬",
    "NotLess;": "≮",
    "NotLessEqual;": "≰",
    "NotLessGreater;": "≸",
    "NotLessLess;": "≪̸",
    "NotLessSlantEqual;": "⩽̸",
    "NotLessTilde;": "≴",
    "NotNestedGreaterGreater;": "⪢̸",
    "NotNestedLessLess;": "⪡̸",
    "notni;": "∌",
    "notniva;": "∌",
    "notnivb;": "⋾",
    "notnivc;": "⋽",
    "NotPrecedes;": "⊀",
    "NotPrecedesEqual;": "⪯̸",
    "NotPrecedesSlantEqual;": "⋠",
    "NotReverseElement;": "∌",
    "NotRightTriangle;": "⋫",
    "NotRightTriangleBar;": "⧐̸",
    "NotRightTriangleEqual;": "⋭",
    "NotSquareSubset;": "⊏̸",
    "NotSquareSubsetEqual;": "⋢",
    "NotSquareSuperset;": "⊐̸",
    "NotSquareSupersetEqual;": "⋣",
    "NotSubset;": "⊂⃒",
    "NotSubsetEqual;": "⊈",
    "NotSucceeds;": "⊁",
    "NotSucceedsEqual;": "⪰̸",
    "NotSucceedsSlantEqual;": "⋡",
    "NotSucceedsTilde;": "≿̸",
    "NotSuperset;": "⊃⃒",
    "NotSupersetEqual;": "⊉",
    "NotTilde;": "≁",
    "NotTildeEqual;": "≄",
    "NotTildeFullEqual;": "≇",
    "NotTildeTilde;": "≉",
    "NotVerticalBar;": "∤",
    "npar;": "∦",
    "nparallel;": "∦",
    "nparsl;": "⫽⃥",
    "npart;": "∂̸",
    "npolint;": "⨔",
    "npr;": "⊀",
    "nprcue;": "⋠",
    "npre;": "⪯̸",
    "nprec;": "⊀",
    "npreceq;": "⪯̸",
    "nrArr;": "⇏",
    "nrarr;": "↛",
    "nrarrc;": "⤳̸",
    "nrarrw;": "↝̸",
    "nRightarrow;": "⇏",
    "nrightarrow;": "↛",
    "nrtri;": "⋫",
    "nrtrie;": "⋭",
    "nsc;": "⊁",
    "nsccue;": "⋡",
    "nsce;": "⪰̸",
    "Nscr;": "\uD835\uDCA9",
    "nscr;": "\uD835\uDCC3",
    "nshortmid;": "∤",
    "nshortparallel;": "∦",
    "nsim;": "≁",
    "nsime;": "≄",
    "nsimeq;": "≄",
    "nsmid;": "∤",
    "nspar;": "∦",
    "nsqsube;": "⋢",
    "nsqsupe;": "⋣",
    "nsub;": "⊄",
    "nsubE;": "⫅̸",
    "nsube;": "⊈",
    "nsubset;": "⊂⃒",
    "nsubseteq;": "⊈",
    "nsubseteqq;": "⫅̸",
    "nsucc;": "⊁",
    "nsucceq;": "⪰̸",
    "nsup;": "⊅",
    "nsupE;": "⫆̸",
    "nsupe;": "⊉",
    "nsupset;": "⊃⃒",
    "nsupseteq;": "⊉",
    "nsupseteqq;": "⫆̸",
    "ntgl;": "≹",
    "Ntilde;": "Ñ",
    Ntilde: "Ñ",
    "ntilde;": "ñ",
    ntilde: "ñ",
    "ntlg;": "≸",
    "ntriangleleft;": "⋪",
    "ntrianglelefteq;": "⋬",
    "ntriangleright;": "⋫",
    "ntrianglerighteq;": "⋭",
    "Nu;": "Ν",
    "nu;": "ν",
    "num;": "#",
    "numero;": "№",
    "numsp;": " ",
    "nvap;": "≍⃒",
    "nVDash;": "⊯",
    "nVdash;": "⊮",
    "nvDash;": "⊭",
    "nvdash;": "⊬",
    "nvge;": "≥⃒",
    "nvgt;": ">⃒",
    "nvHarr;": "⤄",
    "nvinfin;": "⧞",
    "nvlArr;": "⤂",
    "nvle;": "≤⃒",
    "nvlt;": "<⃒",
    "nvltrie;": "⊴⃒",
    "nvrArr;": "⤃",
    "nvrtrie;": "⊵⃒",
    "nvsim;": "∼⃒",
    "nwarhk;": "⤣",
    "nwArr;": "⇖",
    "nwarr;": "↖",
    "nwarrow;": "↖",
    "nwnear;": "⤧",
    "Oacute;": "Ó",
    Oacute: "Ó",
    "oacute;": "ó",
    oacute: "ó",
    "oast;": "⊛",
    "ocir;": "⊚",
    "Ocirc;": "Ô",
    Ocirc: "Ô",
    "ocirc;": "ô",
    ocirc: "ô",
    "Ocy;": "О",
    "ocy;": "о",
    "odash;": "⊝",
    "Odblac;": "Ő",
    "odblac;": "ő",
    "odiv;": "⨸",
    "odot;": "⊙",
    "odsold;": "⦼",
    "OElig;": "Œ",
    "oelig;": "œ",
    "ofcir;": "⦿",
    "Ofr;": "\uD835\uDD12",
    "ofr;": "\uD835\uDD2C",
    "ogon;": "˛",
    "Ograve;": "Ò",
    Ograve: "Ò",
    "ograve;": "ò",
    ograve: "ò",
    "ogt;": "⧁",
    "ohbar;": "⦵",
    "ohm;": "Ω",
    "oint;": "∮",
    "olarr;": "↺",
    "olcir;": "⦾",
    "olcross;": "⦻",
    "oline;": "‾",
    "olt;": "⧀",
    "Omacr;": "Ō",
    "omacr;": "ō",
    "Omega;": "Ω",
    "omega;": "ω",
    "Omicron;": "Ο",
    "omicron;": "ο",
    "omid;": "⦶",
    "ominus;": "⊖",
    "Oopf;": "\uD835\uDD46",
    "oopf;": "\uD835\uDD60",
    "opar;": "⦷",
    "OpenCurlyDoubleQuote;": "“",
    "OpenCurlyQuote;": "‘",
    "operp;": "⦹",
    "oplus;": "⊕",
    "Or;": "⩔",
    "or;": "∨",
    "orarr;": "↻",
    "ord;": "⩝",
    "order;": "ℴ",
    "orderof;": "ℴ",
    "ordf;": "ª",
    ordf: "ª",
    "ordm;": "º",
    ordm: "º",
    "origof;": "⊶",
    "oror;": "⩖",
    "orslope;": "⩗",
    "orv;": "⩛",
    "oS;": "Ⓢ",
    "Oscr;": "\uD835\uDCAA",
    "oscr;": "ℴ",
    "Oslash;": "Ø",
    Oslash: "Ø",
    "oslash;": "ø",
    oslash: "ø",
    "osol;": "⊘",
    "Otilde;": "Õ",
    Otilde: "Õ",
    "otilde;": "õ",
    otilde: "õ",
    "Otimes;": "⨷",
    "otimes;": "⊗",
    "otimesas;": "⨶",
    "Ouml;": "Ö",
    Ouml: "Ö",
    "ouml;": "ö",
    ouml: "ö",
    "ovbar;": "⌽",
    "OverBar;": "‾",
    "OverBrace;": "⏞",
    "OverBracket;": "⎴",
    "OverParenthesis;": "⏜",
    "par;": "∥",
    "para;": "¶",
    para: "¶",
    "parallel;": "∥",
    "parsim;": "⫳",
    "parsl;": "⫽",
    "part;": "∂",
    "PartialD;": "∂",
    "Pcy;": "П",
    "pcy;": "п",
    "percnt;": "%",
    "period;": ".",
    "permil;": "‰",
    "perp;": "⊥",
    "pertenk;": "‱",
    "Pfr;": "\uD835\uDD13",
    "pfr;": "\uD835\uDD2D",
    "Phi;": "Φ",
    "phi;": "φ",
    "phiv;": "ϕ",
    "phmmat;": "ℳ",
    "phone;": "☎",
    "Pi;": "Π",
    "pi;": "π",
    "pitchfork;": "⋔",
    "piv;": "ϖ",
    "planck;": "ℏ",
    "planckh;": "ℎ",
    "plankv;": "ℏ",
    "plus;": "+",
    "plusacir;": "⨣",
    "plusb;": "⊞",
    "pluscir;": "⨢",
    "plusdo;": "∔",
    "plusdu;": "⨥",
    "pluse;": "⩲",
    "PlusMinus;": "±",
    "plusmn;": "±",
    plusmn: "±",
    "plussim;": "⨦",
    "plustwo;": "⨧",
    "pm;": "±",
    "Poincareplane;": "ℌ",
    "pointint;": "⨕",
    "Popf;": "ℙ",
    "popf;": "\uD835\uDD61",
    "pound;": "£",
    pound: "£",
    "Pr;": "⪻",
    "pr;": "≺",
    "prap;": "⪷",
    "prcue;": "≼",
    "prE;": "⪳",
    "pre;": "⪯",
    "prec;": "≺",
    "precapprox;": "⪷",
    "preccurlyeq;": "≼",
    "Precedes;": "≺",
    "PrecedesEqual;": "⪯",
    "PrecedesSlantEqual;": "≼",
    "PrecedesTilde;": "≾",
    "preceq;": "⪯",
    "precnapprox;": "⪹",
    "precneqq;": "⪵",
    "precnsim;": "⋨",
    "precsim;": "≾",
    "Prime;": "″",
    "prime;": "′",
    "primes;": "ℙ",
    "prnap;": "⪹",
    "prnE;": "⪵",
    "prnsim;": "⋨",
    "prod;": "∏",
    "Product;": "∏",
    "profalar;": "⌮",
    "profline;": "⌒",
    "profsurf;": "⌓",
    "prop;": "∝",
    "Proportion;": "∷",
    "Proportional;": "∝",
    "propto;": "∝",
    "prsim;": "≾",
    "prurel;": "⊰",
    "Pscr;": "\uD835\uDCAB",
    "pscr;": "\uD835\uDCC5",
    "Psi;": "Ψ",
    "psi;": "ψ",
    "puncsp;": " ",
    "Qfr;": "\uD835\uDD14",
    "qfr;": "\uD835\uDD2E",
    "qint;": "⨌",
    "Qopf;": "ℚ",
    "qopf;": "\uD835\uDD62",
    "qprime;": "⁗",
    "Qscr;": "\uD835\uDCAC",
    "qscr;": "\uD835\uDCC6",
    "quaternions;": "ℍ",
    "quatint;": "⨖",
    "quest;": "?",
    "questeq;": "≟",
    "QUOT;": '"',
    QUOT: '"',
    "quot;": '"',
    quot: '"',
    "rAarr;": "⇛",
    "race;": "∽̱",
    "Racute;": "Ŕ",
    "racute;": "ŕ",
    "radic;": "√",
    "raemptyv;": "⦳",
    "Rang;": "⟫",
    "rang;": "⟩",
    "rangd;": "⦒",
    "range;": "⦥",
    "rangle;": "⟩",
    "raquo;": "»",
    raquo: "»",
    "Rarr;": "↠",
    "rArr;": "⇒",
    "rarr;": "→",
    "rarrap;": "⥵",
    "rarrb;": "⇥",
    "rarrbfs;": "⤠",
    "rarrc;": "⤳",
    "rarrfs;": "⤞",
    "rarrhk;": "↪",
    "rarrlp;": "↬",
    "rarrpl;": "⥅",
    "rarrsim;": "⥴",
    "Rarrtl;": "⤖",
    "rarrtl;": "↣",
    "rarrw;": "↝",
    "rAtail;": "⤜",
    "ratail;": "⤚",
    "ratio;": "∶",
    "rationals;": "ℚ",
    "RBarr;": "⤐",
    "rBarr;": "⤏",
    "rbarr;": "⤍",
    "rbbrk;": "❳",
    "rbrace;": "}",
    "rbrack;": "]",
    "rbrke;": "⦌",
    "rbrksld;": "⦎",
    "rbrkslu;": "⦐",
    "Rcaron;": "Ř",
    "rcaron;": "ř",
    "Rcedil;": "Ŗ",
    "rcedil;": "ŗ",
    "rceil;": "⌉",
    "rcub;": "}",
    "Rcy;": "Р",
    "rcy;": "р",
    "rdca;": "⤷",
    "rdldhar;": "⥩",
    "rdquo;": "”",
    "rdquor;": "”",
    "rdsh;": "↳",
    "Re;": "ℜ",
    "real;": "ℜ",
    "realine;": "ℛ",
    "realpart;": "ℜ",
    "reals;": "ℝ",
    "rect;": "▭",
    "REG;": "®",
    REG: "®",
    "reg;": "®",
    reg: "®",
    "ReverseElement;": "∋",
    "ReverseEquilibrium;": "⇋",
    "ReverseUpEquilibrium;": "⥯",
    "rfisht;": "⥽",
    "rfloor;": "⌋",
    "Rfr;": "ℜ",
    "rfr;": "\uD835\uDD2F",
    "rHar;": "⥤",
    "rhard;": "⇁",
    "rharu;": "⇀",
    "rharul;": "⥬",
    "Rho;": "Ρ",
    "rho;": "ρ",
    "rhov;": "ϱ",
    "RightAngleBracket;": "⟩",
    "RightArrow;": "→",
    "Rightarrow;": "⇒",
    "rightarrow;": "→",
    "RightArrowBar;": "⇥",
    "RightArrowLeftArrow;": "⇄",
    "rightarrowtail;": "↣",
    "RightCeiling;": "⌉",
    "RightDoubleBracket;": "⟧",
    "RightDownTeeVector;": "⥝",
    "RightDownVector;": "⇂",
    "RightDownVectorBar;": "⥕",
    "RightFloor;": "⌋",
    "rightharpoondown;": "⇁",
    "rightharpoonup;": "⇀",
    "rightleftarrows;": "⇄",
    "rightleftharpoons;": "⇌",
    "rightrightarrows;": "⇉",
    "rightsquigarrow;": "↝",
    "RightTee;": "⊢",
    "RightTeeArrow;": "↦",
    "RightTeeVector;": "⥛",
    "rightthreetimes;": "⋌",
    "RightTriangle;": "⊳",
    "RightTriangleBar;": "⧐",
    "RightTriangleEqual;": "⊵",
    "RightUpDownVector;": "⥏",
    "RightUpTeeVector;": "⥜",
    "RightUpVector;": "↾",
    "RightUpVectorBar;": "⥔",
    "RightVector;": "⇀",
    "RightVectorBar;": "⥓",
    "ring;": "˚",
    "risingdotseq;": "≓",
    "rlarr;": "⇄",
    "rlhar;": "⇌",
    "rlm;": "‏",
    "rmoust;": "⎱",
    "rmoustache;": "⎱",
    "rnmid;": "⫮",
    "roang;": "⟭",
    "roarr;": "⇾",
    "robrk;": "⟧",
    "ropar;": "⦆",
    "Ropf;": "ℝ",
    "ropf;": "\uD835\uDD63",
    "roplus;": "⨮",
    "rotimes;": "⨵",
    "RoundImplies;": "⥰",
    "rpar;": ")",
    "rpargt;": "⦔",
    "rppolint;": "⨒",
    "rrarr;": "⇉",
    "Rrightarrow;": "⇛",
    "rsaquo;": "›",
    "Rscr;": "ℛ",
    "rscr;": "\uD835\uDCC7",
    "Rsh;": "↱",
    "rsh;": "↱",
    "rsqb;": "]",
    "rsquo;": "’",
    "rsquor;": "’",
    "rthree;": "⋌",
    "rtimes;": "⋊",
    "rtri;": "▹",
    "rtrie;": "⊵",
    "rtrif;": "▸",
    "rtriltri;": "⧎",
    "RuleDelayed;": "⧴",
    "ruluhar;": "⥨",
    "rx;": "℞",
    "Sacute;": "Ś",
    "sacute;": "ś",
    "sbquo;": "‚",
    "Sc;": "⪼",
    "sc;": "≻",
    "scap;": "⪸",
    "Scaron;": "Š",
    "scaron;": "š",
    "sccue;": "≽",
    "scE;": "⪴",
    "sce;": "⪰",
    "Scedil;": "Ş",
    "scedil;": "ş",
    "Scirc;": "Ŝ",
    "scirc;": "ŝ",
    "scnap;": "⪺",
    "scnE;": "⪶",
    "scnsim;": "⋩",
    "scpolint;": "⨓",
    "scsim;": "≿",
    "Scy;": "С",
    "scy;": "с",
    "sdot;": "⋅",
    "sdotb;": "⊡",
    "sdote;": "⩦",
    "searhk;": "⤥",
    "seArr;": "⇘",
    "searr;": "↘",
    "searrow;": "↘",
    "sect;": "§",
    sect: "§",
    "semi;": ";",
    "seswar;": "⤩",
    "setminus;": "∖",
    "setmn;": "∖",
    "sext;": "✶",
    "Sfr;": "\uD835\uDD16",
    "sfr;": "\uD835\uDD30",
    "sfrown;": "⌢",
    "sharp;": "♯",
    "SHCHcy;": "Щ",
    "shchcy;": "щ",
    "SHcy;": "Ш",
    "shcy;": "ш",
    "ShortDownArrow;": "↓",
    "ShortLeftArrow;": "←",
    "shortmid;": "∣",
    "shortparallel;": "∥",
    "ShortRightArrow;": "→",
    "ShortUpArrow;": "↑",
    "shy;": "­",
    shy: "­",
    "Sigma;": "Σ",
    "sigma;": "σ",
    "sigmaf;": "ς",
    "sigmav;": "ς",
    "sim;": "∼",
    "simdot;": "⩪",
    "sime;": "≃",
    "simeq;": "≃",
    "simg;": "⪞",
    "simgE;": "⪠",
    "siml;": "⪝",
    "simlE;": "⪟",
    "simne;": "≆",
    "simplus;": "⨤",
    "simrarr;": "⥲",
    "slarr;": "←",
    "SmallCircle;": "∘",
    "smallsetminus;": "∖",
    "smashp;": "⨳",
    "smeparsl;": "⧤",
    "smid;": "∣",
    "smile;": "⌣",
    "smt;": "⪪",
    "smte;": "⪬",
    "smtes;": "⪬︀",
    "SOFTcy;": "Ь",
    "softcy;": "ь",
    "sol;": "/",
    "solb;": "⧄",
    "solbar;": "⌿",
    "Sopf;": "\uD835\uDD4A",
    "sopf;": "\uD835\uDD64",
    "spades;": "♠",
    "spadesuit;": "♠",
    "spar;": "∥",
    "sqcap;": "⊓",
    "sqcaps;": "⊓︀",
    "sqcup;": "⊔",
    "sqcups;": "⊔︀",
    "Sqrt;": "√",
    "sqsub;": "⊏",
    "sqsube;": "⊑",
    "sqsubset;": "⊏",
    "sqsubseteq;": "⊑",
    "sqsup;": "⊐",
    "sqsupe;": "⊒",
    "sqsupset;": "⊐",
    "sqsupseteq;": "⊒",
    "squ;": "□",
    "Square;": "□",
    "square;": "□",
    "SquareIntersection;": "⊓",
    "SquareSubset;": "⊏",
    "SquareSubsetEqual;": "⊑",
    "SquareSuperset;": "⊐",
    "SquareSupersetEqual;": "⊒",
    "SquareUnion;": "⊔",
    "squarf;": "▪",
    "squf;": "▪",
    "srarr;": "→",
    "Sscr;": "\uD835\uDCAE",
    "sscr;": "\uD835\uDCC8",
    "ssetmn;": "∖",
    "ssmile;": "⌣",
    "sstarf;": "⋆",
    "Star;": "⋆",
    "star;": "☆",
    "starf;": "★",
    "straightepsilon;": "ϵ",
    "straightphi;": "ϕ",
    "strns;": "¯",
    "Sub;": "⋐",
    "sub;": "⊂",
    "subdot;": "⪽",
    "subE;": "⫅",
    "sube;": "⊆",
    "subedot;": "⫃",
    "submult;": "⫁",
    "subnE;": "⫋",
    "subne;": "⊊",
    "subplus;": "⪿",
    "subrarr;": "⥹",
    "Subset;": "⋐",
    "subset;": "⊂",
    "subseteq;": "⊆",
    "subseteqq;": "⫅",
    "SubsetEqual;": "⊆",
    "subsetneq;": "⊊",
    "subsetneqq;": "⫋",
    "subsim;": "⫇",
    "subsub;": "⫕",
    "subsup;": "⫓",
    "succ;": "≻",
    "succapprox;": "⪸",
    "succcurlyeq;": "≽",
    "Succeeds;": "≻",
    "SucceedsEqual;": "⪰",
    "SucceedsSlantEqual;": "≽",
    "SucceedsTilde;": "≿",
    "succeq;": "⪰",
    "succnapprox;": "⪺",
    "succneqq;": "⪶",
    "succnsim;": "⋩",
    "succsim;": "≿",
    "SuchThat;": "∋",
    "Sum;": "∑",
    "sum;": "∑",
    "sung;": "♪",
    "Sup;": "⋑",
    "sup;": "⊃",
    "sup1;": "¹",
    sup1: "¹",
    "sup2;": "²",
    sup2: "²",
    "sup3;": "³",
    sup3: "³",
    "supdot;": "⪾",
    "supdsub;": "⫘",
    "supE;": "⫆",
    "supe;": "⊇",
    "supedot;": "⫄",
    "Superset;": "⊃",
    "SupersetEqual;": "⊇",
    "suphsol;": "⟉",
    "suphsub;": "⫗",
    "suplarr;": "⥻",
    "supmult;": "⫂",
    "supnE;": "⫌",
    "supne;": "⊋",
    "supplus;": "⫀",
    "Supset;": "⋑",
    "supset;": "⊃",
    "supseteq;": "⊇",
    "supseteqq;": "⫆",
    "supsetneq;": "⊋",
    "supsetneqq;": "⫌",
    "supsim;": "⫈",
    "supsub;": "⫔",
    "supsup;": "⫖",
    "swarhk;": "⤦",
    "swArr;": "⇙",
    "swarr;": "↙",
    "swarrow;": "↙",
    "swnwar;": "⤪",
    "szlig;": "ß",
    szlig: "ß",
    "Tab;": "\t",
    "target;": "⌖",
    "Tau;": "Τ",
    "tau;": "τ",
    "tbrk;": "⎴",
    "Tcaron;": "Ť",
    "tcaron;": "ť",
    "Tcedil;": "Ţ",
    "tcedil;": "ţ",
    "Tcy;": "Т",
    "tcy;": "т",
    "tdot;": "⃛",
    "telrec;": "⌕",
    "Tfr;": "\uD835\uDD17",
    "tfr;": "\uD835\uDD31",
    "there4;": "∴",
    "Therefore;": "∴",
    "therefore;": "∴",
    "Theta;": "Θ",
    "theta;": "θ",
    "thetasym;": "ϑ",
    "thetav;": "ϑ",
    "thickapprox;": "≈",
    "thicksim;": "∼",
    "ThickSpace;": "  ",
    "thinsp;": " ",
    "ThinSpace;": " ",
    "thkap;": "≈",
    "thksim;": "∼",
    "THORN;": "Þ",
    THORN: "Þ",
    "thorn;": "þ",
    thorn: "þ",
    "Tilde;": "∼",
    "tilde;": "˜",
    "TildeEqual;": "≃",
    "TildeFullEqual;": "≅",
    "TildeTilde;": "≈",
    "times;": "×",
    times: "×",
    "timesb;": "⊠",
    "timesbar;": "⨱",
    "timesd;": "⨰",
    "tint;": "∭",
    "toea;": "⤨",
    "top;": "⊤",
    "topbot;": "⌶",
    "topcir;": "⫱",
    "Topf;": "\uD835\uDD4B",
    "topf;": "\uD835\uDD65",
    "topfork;": "⫚",
    "tosa;": "⤩",
    "tprime;": "‴",
    "TRADE;": "™",
    "trade;": "™",
    "triangle;": "▵",
    "triangledown;": "▿",
    "triangleleft;": "◃",
    "trianglelefteq;": "⊴",
    "triangleq;": "≜",
    "triangleright;": "▹",
    "trianglerighteq;": "⊵",
    "tridot;": "◬",
    "trie;": "≜",
    "triminus;": "⨺",
    "TripleDot;": "⃛",
    "triplus;": "⨹",
    "trisb;": "⧍",
    "tritime;": "⨻",
    "trpezium;": "⏢",
    "Tscr;": "\uD835\uDCAF",
    "tscr;": "\uD835\uDCC9",
    "TScy;": "Ц",
    "tscy;": "ц",
    "TSHcy;": "Ћ",
    "tshcy;": "ћ",
    "Tstrok;": "Ŧ",
    "tstrok;": "ŧ",
    "twixt;": "≬",
    "twoheadleftarrow;": "↞",
    "twoheadrightarrow;": "↠",
    "Uacute;": "Ú",
    Uacute: "Ú",
    "uacute;": "ú",
    uacute: "ú",
    "Uarr;": "↟",
    "uArr;": "⇑",
    "uarr;": "↑",
    "Uarrocir;": "⥉",
    "Ubrcy;": "Ў",
    "ubrcy;": "ў",
    "Ubreve;": "Ŭ",
    "ubreve;": "ŭ",
    "Ucirc;": "Û",
    Ucirc: "Û",
    "ucirc;": "û",
    ucirc: "û",
    "Ucy;": "У",
    "ucy;": "у",
    "udarr;": "⇅",
    "Udblac;": "Ű",
    "udblac;": "ű",
    "udhar;": "⥮",
    "ufisht;": "⥾",
    "Ufr;": "\uD835\uDD18",
    "ufr;": "\uD835\uDD32",
    "Ugrave;": "Ù",
    Ugrave: "Ù",
    "ugrave;": "ù",
    ugrave: "ù",
    "uHar;": "⥣",
    "uharl;": "↿",
    "uharr;": "↾",
    "uhblk;": "▀",
    "ulcorn;": "⌜",
    "ulcorner;": "⌜",
    "ulcrop;": "⌏",
    "ultri;": "◸",
    "Umacr;": "Ū",
    "umacr;": "ū",
    "uml;": "¨",
    uml: "¨",
    "UnderBar;": "_",
    "UnderBrace;": "⏟",
    "UnderBracket;": "⎵",
    "UnderParenthesis;": "⏝",
    "Union;": "⋃",
    "UnionPlus;": "⊎",
    "Uogon;": "Ų",
    "uogon;": "ų",
    "Uopf;": "\uD835\uDD4C",
    "uopf;": "\uD835\uDD66",
    "UpArrow;": "↑",
    "Uparrow;": "⇑",
    "uparrow;": "↑",
    "UpArrowBar;": "⤒",
    "UpArrowDownArrow;": "⇅",
    "UpDownArrow;": "↕",
    "Updownarrow;": "⇕",
    "updownarrow;": "↕",
    "UpEquilibrium;": "⥮",
    "upharpoonleft;": "↿",
    "upharpoonright;": "↾",
    "uplus;": "⊎",
    "UpperLeftArrow;": "↖",
    "UpperRightArrow;": "↗",
    "Upsi;": "ϒ",
    "upsi;": "υ",
    "upsih;": "ϒ",
    "Upsilon;": "Υ",
    "upsilon;": "υ",
    "UpTee;": "⊥",
    "UpTeeArrow;": "↥",
    "upuparrows;": "⇈",
    "urcorn;": "⌝",
    "urcorner;": "⌝",
    "urcrop;": "⌎",
    "Uring;": "Ů",
    "uring;": "ů",
    "urtri;": "◹",
    "Uscr;": "\uD835\uDCB0",
    "uscr;": "\uD835\uDCCA",
    "utdot;": "⋰",
    "Utilde;": "Ũ",
    "utilde;": "ũ",
    "utri;": "▵",
    "utrif;": "▴",
    "uuarr;": "⇈",
    "Uuml;": "Ü",
    Uuml: "Ü",
    "uuml;": "ü",
    uuml: "ü",
    "uwangle;": "⦧",
    "vangrt;": "⦜",
    "varepsilon;": "ϵ",
    "varkappa;": "ϰ",
    "varnothing;": "∅",
    "varphi;": "ϕ",
    "varpi;": "ϖ",
    "varpropto;": "∝",
    "vArr;": "⇕",
    "varr;": "↕",
    "varrho;": "ϱ",
    "varsigma;": "ς",
    "varsubsetneq;": "⊊︀",
    "varsubsetneqq;": "⫋︀",
    "varsupsetneq;": "⊋︀",
    "varsupsetneqq;": "⫌︀",
    "vartheta;": "ϑ",
    "vartriangleleft;": "⊲",
    "vartriangleright;": "⊳",
    "Vbar;": "⫫",
    "vBar;": "⫨",
    "vBarv;": "⫩",
    "Vcy;": "В",
    "vcy;": "в",
    "VDash;": "⊫",
    "Vdash;": "⊩",
    "vDash;": "⊨",
    "vdash;": "⊢",
    "Vdashl;": "⫦",
    "Vee;": "⋁",
    "vee;": "∨",
    "veebar;": "⊻",
    "veeeq;": "≚",
    "vellip;": "⋮",
    "Verbar;": "‖",
    "verbar;": "|",
    "Vert;": "‖",
    "vert;": "|",
    "VerticalBar;": "∣",
    "VerticalLine;": "|",
    "VerticalSeparator;": "❘",
    "VerticalTilde;": "≀",
    "VeryThinSpace;": " ",
    "Vfr;": "\uD835\uDD19",
    "vfr;": "\uD835\uDD33",
    "vltri;": "⊲",
    "vnsub;": "⊂⃒",
    "vnsup;": "⊃⃒",
    "Vopf;": "\uD835\uDD4D",
    "vopf;": "\uD835\uDD67",
    "vprop;": "∝",
    "vrtri;": "⊳",
    "Vscr;": "\uD835\uDCB1",
    "vscr;": "\uD835\uDCCB",
    "vsubnE;": "⫋︀",
    "vsubne;": "⊊︀",
    "vsupnE;": "⫌︀",
    "vsupne;": "⊋︀",
    "Vvdash;": "⊪",
    "vzigzag;": "⦚",
    "Wcirc;": "Ŵ",
    "wcirc;": "ŵ",
    "wedbar;": "⩟",
    "Wedge;": "⋀",
    "wedge;": "∧",
    "wedgeq;": "≙",
    "weierp;": "℘",
    "Wfr;": "\uD835\uDD1A",
    "wfr;": "\uD835\uDD34",
    "Wopf;": "\uD835\uDD4E",
    "wopf;": "\uD835\uDD68",
    "wp;": "℘",
    "wr;": "≀",
    "wreath;": "≀",
    "Wscr;": "\uD835\uDCB2",
    "wscr;": "\uD835\uDCCC",
    "xcap;": "⋂",
    "xcirc;": "◯",
    "xcup;": "⋃",
    "xdtri;": "▽",
    "Xfr;": "\uD835\uDD1B",
    "xfr;": "\uD835\uDD35",
    "xhArr;": "⟺",
    "xharr;": "⟷",
    "Xi;": "Ξ",
    "xi;": "ξ",
    "xlArr;": "⟸",
    "xlarr;": "⟵",
    "xmap;": "⟼",
    "xnis;": "⋻",
    "xodot;": "⨀",
    "Xopf;": "\uD835\uDD4F",
    "xopf;": "\uD835\uDD69",
    "xoplus;": "⨁",
    "xotime;": "⨂",
    "xrArr;": "⟹",
    "xrarr;": "⟶",
    "Xscr;": "\uD835\uDCB3",
    "xscr;": "\uD835\uDCCD",
    "xsqcup;": "⨆",
    "xuplus;": "⨄",
    "xutri;": "△",
    "xvee;": "⋁",
    "xwedge;": "⋀",
    "Yacute;": "Ý",
    Yacute: "Ý",
    "yacute;": "ý",
    yacute: "ý",
    "YAcy;": "Я",
    "yacy;": "я",
    "Ycirc;": "Ŷ",
    "ycirc;": "ŷ",
    "Ycy;": "Ы",
    "ycy;": "ы",
    "yen;": "¥",
    yen: "¥",
    "Yfr;": "\uD835\uDD1C",
    "yfr;": "\uD835\uDD36",
    "YIcy;": "Ї",
    "yicy;": "ї",
    "Yopf;": "\uD835\uDD50",
    "yopf;": "\uD835\uDD6A",
    "Yscr;": "\uD835\uDCB4",
    "yscr;": "\uD835\uDCCE",
    "YUcy;": "Ю",
    "yucy;": "ю",
    "Yuml;": "Ÿ",
    "yuml;": "ÿ",
    yuml: "ÿ",
    "Zacute;": "Ź",
    "zacute;": "ź",
    "Zcaron;": "Ž",
    "zcaron;": "ž",
    "Zcy;": "З",
    "zcy;": "з",
    "Zdot;": "Ż",
    "zdot;": "ż",
    "zeetrf;": "ℨ",
    "ZeroWidthSpace;": "​",
    "Zeta;": "Ζ",
    "zeta;": "ζ",
    "Zfr;": "ℨ",
    "zfr;": "\uD835\uDD37",
    "ZHcy;": "Ж",
    "zhcy;": "ж",
    "zigrarr;": "⇝",
    "Zopf;": "ℤ",
    "zopf;": "\uD835\uDD6B",
    "Zscr;": "\uD835\uDCB5",
    "zscr;": "\uD835\uDCCF",
    "zwj;": "‍",
    "zwnj;": "‌"
  };
});

// node_modules/ent/decode.js
var require_decode = __commonJS((exports, module) => {
  var punycode = require_punycode();
  var $encode = punycode.ucs2.encode;
  var regexTest = require_safe_regex_test();
  var callBound = require_call_bound();
  var $TypeError = require_type();
  var entities = require_entities();
  var endsInSemicolon = regexTest(/;$/);
  var $replace = callBound("String.prototype.replace");
  var $exec = callBound("RegExp.prototype.exec");
  var $parseInt = parseInt;
  module.exports = function decode(str) {
    if (typeof str !== "string") {
      throw new $TypeError("Expected a String");
    }
    return $replace(str, /&(#?[^;\W]+;?)/g, function(_, match) {
      var m = $exec(/^#(\d+);?$/, match);
      if (m) {
        return $encode([$parseInt(m[1], 10)]);
      }
      var m2 = $exec(/^#[Xx]([A-Fa-f0-9]+);?/, match);
      if (m2) {
        return $encode([$parseInt(m2[1], 16)]);
      }
      var hasSemi = endsInSemicolon(match);
      var withoutSemi = hasSemi ? $replace(match, /;$/, "") : match;
      var target = entities[withoutSemi] || hasSemi && entities[match];
      if (typeof target === "number") {
        return $encode([target]);
      } else if (typeof target === "string") {
        return target;
      }
      return "&" + match;
    });
  };
});

// node_modules/ent/index.js
var require_ent = __commonJS((exports) => {
  exports.encode = require_encode();
  exports.decode = require_decode();
});

// node_modules/html-to-vdom/lib/convert-tag-attributes.js
var require_convert_tag_attributes = __commonJS((exports, module) => {
  var decode = require_ent().decode;
  var MUST_USE_ATTRIBUTE = 1;
  var MUST_USE_PROPERTY = 2;
  var HAS_BOOLEAN_VALUE = 8;
  var HAS_NUMERIC_VALUE = 16;
  var HAS_POSITIVE_NUMERIC_VALUE = 32 | 16;
  var HAS_OVERLOADED_BOOLEAN_VALUE = 64;
  function checkMask(value, bitmask) {
    return (value & bitmask) === bitmask;
  }
  var isCustomAttribute = RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/);
  var HTMLDOMPropertyConfig = {
    Properties: {
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoFocus: HAS_BOOLEAN_VALUE,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      challenge: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      className: MUST_USE_ATTRIBUTE,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      dateTime: MUST_USE_ATTRIBUTE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      headers: null,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      high: null,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      is: MUST_USE_ATTRIBUTE,
      keyParams: MUST_USE_ATTRIBUTE,
      keyType: MUST_USE_ATTRIBUTE,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      low: null,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      minLength: MUST_USE_ATTRIBUTE,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      autoCapitalize: null,
      autoCorrect: null,
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      itemID: MUST_USE_ATTRIBUTE,
      itemRef: MUST_USE_ATTRIBUTE,
      property: null,
      unselectable: MUST_USE_ATTRIBUTE
    }
  };
  var parseStyles = function(input) {
    var attributes = input.split(";");
    var styles = attributes.reduce(function(object, attribute) {
      var entry = attribute.split(/:(.+)/);
      if (entry[0] && entry[1]) {
        object[entry[0].trim()] = entry[1].trim();
      }
      return object;
    }, {});
    return styles;
  };
  var propertyToAttributeMapping = {
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv",
    acceptCharset: "accept-charset"
  };
  var propertyValueConversions = {
    style: parseStyles,
    placeholder: decode,
    title: decode,
    alt: decode
  };
  var getPropertyInfo = function() {
    var propInfoByAttributeName = {};
    Object.keys(HTMLDOMPropertyConfig.Properties).forEach(function(propName) {
      var propConfig = HTMLDOMPropertyConfig.Properties[propName];
      var attributeName = propertyToAttributeMapping[propName] || propName.toLowerCase();
      var propertyInfo = {
        attributeName,
        propertyName: propName,
        mustUseAttribute: checkMask(propConfig, MUST_USE_ATTRIBUTE),
        mustUseProperty: checkMask(propConfig, MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      propInfoByAttributeName[attributeName] = propertyInfo;
    });
    return function(attributeName) {
      return propInfoByAttributeName[attributeName];
    };
  }();
  var convertTagAttributes = function(tag) {
    var attributes = tag.attribs;
    var vdomProperties = {
      attributes: {}
    };
    Object.keys(attributes).forEach(function(attributeName) {
      var lowerCased = attributeName.toLowerCase();
      var propInfo = getPropertyInfo(lowerCased);
      var value = attributes[attributeName];
      if (isCustomAttribute(attributeName) || !propInfo) {
        vdomProperties.attributes[attributeName] = value;
        return;
      }
      var valueConverter = propertyValueConversions[propInfo.propertyName];
      if (valueConverter) {
        value = valueConverter(value);
      }
      if (propInfo.mustUseAttribute) {
        if (propInfo.hasBooleanValue) {
          vdomProperties.attributes[propInfo.attributeName] = "";
        } else {
          vdomProperties.attributes[propInfo.attributeName] = value;
        }
      } else {
        var isTrue;
        if (propInfo.hasBooleanValue) {
          isTrue = value === "" || value.toLowerCase() === propInfo.attributeName;
          vdomProperties[propInfo.propertyName] = isTrue ? true : false;
        } else if (propInfo.hasOverloadedBooleanValue) {
          isTrue = value === "";
          vdomProperties[propInfo.propertyName] = isTrue ? true : value;
        } else if (propInfo.hasNumericValue || propInfo.hasPositiveNumericValue) {
          vdomProperties[propInfo.propertyName] = Number(value);
        } else {
          vdomProperties[propInfo.propertyName] = value;
        }
      }
    });
    return vdomProperties;
  };
  module.exports = convertTagAttributes;
});

// node_modules/html-to-vdom/lib/htmlparser-to-vdom.js
var require_htmlparser_to_vdom = __commonJS((exports, module) => {
  var decode = require_ent().decode;
  var convertTagAttributes = require_convert_tag_attributes();
  module.exports = function createConverter(VNode, VText) {
    var converter = {
      convert: function(node, getVNodeKey) {
        if (node.type === "tag" || node.type === "script" || node.type === "style") {
          return converter.convertTag(node, getVNodeKey);
        } else if (node.type === "text") {
          return new VText(decode(node.data));
        } else {
          return new VText("");
        }
      },
      convertTag: function(tag, getVNodeKey) {
        var attributes = convertTagAttributes(tag);
        var key;
        if (getVNodeKey) {
          key = getVNodeKey(attributes);
        }
        var children = Array.prototype.map.call(tag.children || [], function(node) {
          return converter.convert(node, getVNodeKey);
        });
        return new VNode(tag.name, attributes, children, key);
      }
    };
    return converter;
  };
});

// node_modules/entities/maps/decode.json
var require_decode2 = __commonJS((exports, module) => {
  module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS((exports, module) => {
  var decodeMap = require_decode2();
  module.exports = decodeCodePoint;
  function decodeCodePoint(codePoint) {
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "�";
    }
    if (codePoint in decodeMap) {
      codePoint = decodeMap[codePoint];
    }
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
});

// node_modules/entities/maps/entities.json
var require_entities2 = __commonJS((exports, module) => {
  module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "\uD835\uDD04", afr: "\uD835\uDD1E", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "\uD835\uDD38", aopf: "\uD835\uDD52", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "\uD835\uDC9C", ascr: "\uD835\uDCB6", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "\uD835\uDD05", bfr: "\uD835\uDD1F", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "\uD835\uDD39", bopf: "\uD835\uDD53", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "\uD835\uDCB7", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "\uD835\uDD20", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "\uD835\uDD54", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "\uD835\uDC9E", cscr: "\uD835\uDCB8", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "\uD835\uDD07", dfr: "\uD835\uDD21", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "\uD835\uDD3B", dopf: "\uD835\uDD55", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "\uD835\uDC9F", dscr: "\uD835\uDCB9", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "\uD835\uDD08", efr: "\uD835\uDD22", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "\uD835\uDD3C", eopf: "\uD835\uDD56", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "\uD835\uDD09", ffr: "\uD835\uDD23", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "\uD835\uDD3D", fopf: "\uD835\uDD57", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "\uD835\uDCBB", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "\uD835\uDD0A", gfr: "\uD835\uDD24", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "\uD835\uDD3E", gopf: "\uD835\uDD58", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "\uD835\uDCA2", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "\uD835\uDD25", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "\uD835\uDD59", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "\uD835\uDCBD", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "\uD835\uDD26", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "\uD835\uDD40", iopf: "\uD835\uDD5A", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "\uD835\uDCBE", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "\uD835\uDD0D", jfr: "\uD835\uDD27", jmath: "ȷ", Jopf: "\uD835\uDD41", jopf: "\uD835\uDD5B", Jscr: "\uD835\uDCA5", jscr: "\uD835\uDCBF", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "\uD835\uDD0E", kfr: "\uD835\uDD28", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "\uD835\uDD42", kopf: "\uD835\uDD5C", Kscr: "\uD835\uDCA6", kscr: "\uD835\uDCC0", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "\uD835\uDD0F", lfr: "\uD835\uDD29", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "\uD835\uDD43", lopf: "\uD835\uDD5D", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "\uD835\uDCC1", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "\uD835\uDD10", mfr: "\uD835\uDD2A", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "\uD835\uDD44", mopf: "\uD835\uDD5E", mp: "∓", mscr: "\uD835\uDCC2", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: `
`, nexist: "∄", nexists: "∄", Nfr: "\uD835\uDD11", nfr: "\uD835\uDD2B", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "\uD835\uDD5F", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "\uD835\uDCA9", nscr: "\uD835\uDCC3", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "\uD835\uDD12", ofr: "\uD835\uDD2C", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "\uD835\uDD46", oopf: "\uD835\uDD60", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "\uD835\uDCAA", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "\uD835\uDD13", pfr: "\uD835\uDD2D", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "\uD835\uDD61", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "\uD835\uDCAB", pscr: "\uD835\uDCC5", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "\uD835\uDD14", qfr: "\uD835\uDD2E", qint: "⨌", qopf: "\uD835\uDD62", Qopf: "ℚ", qprime: "⁗", Qscr: "\uD835\uDCAC", qscr: "\uD835\uDCC6", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "\uD835\uDD2F", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "\uD835\uDD63", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "\uD835\uDCC7", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "\uD835\uDD16", sfr: "\uD835\uDD30", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "\uD835\uDD4A", sopf: "\uD835\uDD64", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "\uD835\uDCAE", sscr: "\uD835\uDCC8", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "\t", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "\uD835\uDD17", tfr: "\uD835\uDD31", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "\uD835\uDD4B", topf: "\uD835\uDD65", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "\uD835\uDCAF", tscr: "\uD835\uDCC9", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "\uD835\uDD18", ufr: "\uD835\uDD32", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "\uD835\uDD4C", uopf: "\uD835\uDD66", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "\uD835\uDCB0", uscr: "\uD835\uDCCA", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "\uD835\uDD19", vfr: "\uD835\uDD33", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "\uD835\uDD4D", vopf: "\uD835\uDD67", vprop: "∝", vrtri: "⊳", Vscr: "\uD835\uDCB1", vscr: "\uD835\uDCCB", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "\uD835\uDD1A", wfr: "\uD835\uDD34", Wopf: "\uD835\uDD4E", wopf: "\uD835\uDD68", wp: "℘", wr: "≀", wreath: "≀", Wscr: "\uD835\uDCB2", wscr: "\uD835\uDCCC", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "\uD835\uDD1B", xfr: "\uD835\uDD35", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "\uD835\uDD4F", xopf: "\uD835\uDD69", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "\uD835\uDCB3", xscr: "\uD835\uDCCD", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "\uD835\uDD1C", yfr: "\uD835\uDD36", YIcy: "Ї", yicy: "ї", Yopf: "\uD835\uDD50", yopf: "\uD835\uDD6A", Yscr: "\uD835\uDCB4", yscr: "\uD835\uDCCE", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "\uD835\uDD37", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "\uD835\uDD6B", Zopf: "ℤ", Zscr: "\uD835\uDCB5", zscr: "\uD835\uDCCF", zwj: "‍", zwnj: "‌" };
});

// node_modules/entities/maps/legacy.json
var require_legacy = __commonJS((exports, module) => {
  module.exports = { Aacute: "Á", aacute: "á", Acirc: "Â", acirc: "â", acute: "´", AElig: "Æ", aelig: "æ", Agrave: "À", agrave: "à", amp: "&", AMP: "&", Aring: "Å", aring: "å", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", brvbar: "¦", Ccedil: "Ç", ccedil: "ç", cedil: "¸", cent: "¢", copy: "©", COPY: "©", curren: "¤", deg: "°", divide: "÷", Eacute: "É", eacute: "é", Ecirc: "Ê", ecirc: "ê", Egrave: "È", egrave: "è", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", frac12: "½", frac14: "¼", frac34: "¾", gt: ">", GT: ">", Iacute: "Í", iacute: "í", Icirc: "Î", icirc: "î", iexcl: "¡", Igrave: "Ì", igrave: "ì", iquest: "¿", Iuml: "Ï", iuml: "ï", laquo: "«", lt: "<", LT: "<", macr: "¯", micro: "µ", middot: "·", nbsp: " ", not: "¬", Ntilde: "Ñ", ntilde: "ñ", Oacute: "Ó", oacute: "ó", Ocirc: "Ô", ocirc: "ô", Ograve: "Ò", ograve: "ò", ordf: "ª", ordm: "º", Oslash: "Ø", oslash: "ø", Otilde: "Õ", otilde: "õ", Ouml: "Ö", ouml: "ö", para: "¶", plusmn: "±", pound: "£", quot: '"', QUOT: '"', raquo: "»", reg: "®", REG: "®", sect: "§", shy: "­", sup1: "¹", sup2: "²", sup3: "³", szlig: "ß", THORN: "Þ", thorn: "þ", times: "×", Uacute: "Ú", uacute: "ú", Ucirc: "Û", ucirc: "û", Ugrave: "Ù", ugrave: "ù", uml: "¨", Uuml: "Ü", uuml: "ü", Yacute: "Ý", yacute: "ý", yen: "¥", yuml: "ÿ" };
});

// node_modules/entities/maps/xml.json
var require_xml = __commonJS((exports, module) => {
  module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});

// node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS((exports, module) => {
  module.exports = Tokenizer;
  var decodeCodePoint = require_decode_codepoint();
  var entityMap = require_entities2();
  var legacyMap = require_legacy();
  var xmlMap = require_xml();
  var i = 0;
  var TEXT = i++;
  var BEFORE_TAG_NAME = i++;
  var IN_TAG_NAME = i++;
  var IN_SELF_CLOSING_TAG = i++;
  var BEFORE_CLOSING_TAG_NAME = i++;
  var IN_CLOSING_TAG_NAME = i++;
  var AFTER_CLOSING_TAG_NAME = i++;
  var BEFORE_ATTRIBUTE_NAME = i++;
  var IN_ATTRIBUTE_NAME = i++;
  var AFTER_ATTRIBUTE_NAME = i++;
  var BEFORE_ATTRIBUTE_VALUE = i++;
  var IN_ATTRIBUTE_VALUE_DQ = i++;
  var IN_ATTRIBUTE_VALUE_SQ = i++;
  var IN_ATTRIBUTE_VALUE_NQ = i++;
  var BEFORE_DECLARATION = i++;
  var IN_DECLARATION = i++;
  var IN_PROCESSING_INSTRUCTION = i++;
  var BEFORE_COMMENT = i++;
  var IN_COMMENT = i++;
  var AFTER_COMMENT_1 = i++;
  var AFTER_COMMENT_2 = i++;
  var BEFORE_CDATA_1 = i++;
  var BEFORE_CDATA_2 = i++;
  var BEFORE_CDATA_3 = i++;
  var BEFORE_CDATA_4 = i++;
  var BEFORE_CDATA_5 = i++;
  var BEFORE_CDATA_6 = i++;
  var IN_CDATA = i++;
  var AFTER_CDATA_1 = i++;
  var AFTER_CDATA_2 = i++;
  var BEFORE_SPECIAL = i++;
  var BEFORE_SPECIAL_END = i++;
  var BEFORE_SCRIPT_1 = i++;
  var BEFORE_SCRIPT_2 = i++;
  var BEFORE_SCRIPT_3 = i++;
  var BEFORE_SCRIPT_4 = i++;
  var BEFORE_SCRIPT_5 = i++;
  var AFTER_SCRIPT_1 = i++;
  var AFTER_SCRIPT_2 = i++;
  var AFTER_SCRIPT_3 = i++;
  var AFTER_SCRIPT_4 = i++;
  var AFTER_SCRIPT_5 = i++;
  var BEFORE_STYLE_1 = i++;
  var BEFORE_STYLE_2 = i++;
  var BEFORE_STYLE_3 = i++;
  var BEFORE_STYLE_4 = i++;
  var AFTER_STYLE_1 = i++;
  var AFTER_STYLE_2 = i++;
  var AFTER_STYLE_3 = i++;
  var AFTER_STYLE_4 = i++;
  var BEFORE_ENTITY = i++;
  var BEFORE_NUMERIC_ENTITY = i++;
  var IN_NAMED_ENTITY = i++;
  var IN_NUMERIC_ENTITY = i++;
  var IN_HEX_ENTITY = i++;
  var j = 0;
  var SPECIAL_NONE = j++;
  var SPECIAL_SCRIPT = j++;
  var SPECIAL_STYLE = j++;
  function whitespace(c) {
    return c === " " || c === `
` || c === "\t" || c === "\f" || c === "\r";
  }
  function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
      return function(c) {
        if (c === lower) {
          this._state = SUCCESS;
        } else {
          this._state = FAILURE;
          this._index--;
        }
      };
    } else {
      return function(c) {
        if (c === lower || c === upper) {
          this._state = SUCCESS;
        } else {
          this._state = FAILURE;
          this._index--;
        }
      };
    }
  }
  function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function(c) {
      if (c === lower || c === upper) {
        this._state = NEXT_STATE;
      } else {
        this._state = IN_TAG_NAME;
        this._index--;
      }
    };
  }
  function Tokenizer(options, cbs) {
    this._state = TEXT;
    this._buffer = "";
    this._sectionStart = 0;
    this._index = 0;
    this._bufferOffset = 0;
    this._baseState = TEXT;
    this._special = SPECIAL_NONE;
    this._cbs = cbs;
    this._running = true;
    this._ended = false;
    this._xmlMode = !!(options && options.xmlMode);
    this._decodeEntities = !!(options && options.decodeEntities);
  }
  Tokenizer.prototype._stateText = function(c) {
    if (c === "<") {
      if (this._index > this._sectionStart) {
        this._cbs.ontext(this._getSection());
      }
      this._state = BEFORE_TAG_NAME;
      this._sectionStart = this._index;
    } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
      if (this._index > this._sectionStart) {
        this._cbs.ontext(this._getSection());
      }
      this._baseState = TEXT;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeTagName = function(c) {
    if (c === "/") {
      this._state = BEFORE_CLOSING_TAG_NAME;
    } else if (c === "<") {
      this._cbs.ontext(this._getSection());
      this._sectionStart = this._index;
    } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
      this._state = TEXT;
    } else if (c === "!") {
      this._state = BEFORE_DECLARATION;
      this._sectionStart = this._index + 1;
    } else if (c === "?") {
      this._state = IN_PROCESSING_INSTRUCTION;
      this._sectionStart = this._index + 1;
    } else {
      this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInTagName = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._emitToken("onopentagname");
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateBeforeCloseingTagName = function(c) {
    if (whitespace(c))
      ;
    else if (c === ">") {
      this._state = TEXT;
    } else if (this._special !== SPECIAL_NONE) {
      if (c === "s" || c === "S") {
        this._state = BEFORE_SPECIAL_END;
      } else {
        this._state = TEXT;
        this._index--;
      }
    } else {
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInCloseingTagName = function(c) {
    if (c === ">" || whitespace(c)) {
      this._emitToken("onclosetag");
      this._state = AFTER_CLOSING_TAG_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateAfterCloseingTagName = function(c) {
    if (c === ">") {
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateBeforeAttributeName = function(c) {
    if (c === ">") {
      this._cbs.onopentagend();
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c === "/") {
      this._state = IN_SELF_CLOSING_TAG;
    } else if (!whitespace(c)) {
      this._state = IN_ATTRIBUTE_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInSelfClosingTag = function(c) {
    if (c === ">") {
      this._cbs.onselfclosingtag();
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInAttributeName = function(c) {
    if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
      this._cbs.onattribname(this._getSection());
      this._sectionStart = -1;
      this._state = AFTER_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateAfterAttributeName = function(c) {
    if (c === "=") {
      this._state = BEFORE_ATTRIBUTE_VALUE;
    } else if (c === "/" || c === ">") {
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    } else if (!whitespace(c)) {
      this._cbs.onattribend();
      this._state = IN_ATTRIBUTE_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeAttributeValue = function(c) {
    if (c === '"') {
      this._state = IN_ATTRIBUTE_VALUE_DQ;
      this._sectionStart = this._index + 1;
    } else if (c === "'") {
      this._state = IN_ATTRIBUTE_VALUE_SQ;
      this._sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
      this._state = IN_ATTRIBUTE_VALUE_NQ;
      this._sectionStart = this._index;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c) {
    if (c === '"') {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c) {
    if (c === "'") {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c) {
    if (whitespace(c) || c === ">") {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeDeclaration = function(c) {
    this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;
  };
  Tokenizer.prototype._stateInDeclaration = function(c) {
    if (c === ">") {
      this._cbs.ondeclaration(this._getSection());
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateInProcessingInstruction = function(c) {
    if (c === ">") {
      this._cbs.onprocessinginstruction(this._getSection());
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateBeforeComment = function(c) {
    if (c === "-") {
      this._state = IN_COMMENT;
      this._sectionStart = this._index + 1;
    } else {
      this._state = IN_DECLARATION;
    }
  };
  Tokenizer.prototype._stateInComment = function(c) {
    if (c === "-")
      this._state = AFTER_COMMENT_1;
  };
  Tokenizer.prototype._stateAfterComment1 = function(c) {
    if (c === "-") {
      this._state = AFTER_COMMENT_2;
    } else {
      this._state = IN_COMMENT;
    }
  };
  Tokenizer.prototype._stateAfterComment2 = function(c) {
    if (c === ">") {
      this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c !== "-") {
      this._state = IN_COMMENT;
    }
  };
  Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);
  Tokenizer.prototype._stateBeforeCdata6 = function(c) {
    if (c === "[") {
      this._state = IN_CDATA;
      this._sectionStart = this._index + 1;
    } else {
      this._state = IN_DECLARATION;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInCdata = function(c) {
    if (c === "]")
      this._state = AFTER_CDATA_1;
  };
  Tokenizer.prototype._stateAfterCdata1 = function(c) {
    if (c === "]")
      this._state = AFTER_CDATA_2;
    else
      this._state = IN_CDATA;
  };
  Tokenizer.prototype._stateAfterCdata2 = function(c) {
    if (c === ">") {
      this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c !== "]") {
      this._state = IN_CDATA;
    }
  };
  Tokenizer.prototype._stateBeforeSpecial = function(c) {
    if (c === "c" || c === "C") {
      this._state = BEFORE_SCRIPT_1;
    } else if (c === "t" || c === "T") {
      this._state = BEFORE_STYLE_1;
    } else {
      this._state = IN_TAG_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateBeforeSpecialEnd = function(c) {
    if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {
      this._state = AFTER_SCRIPT_1;
    } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {
      this._state = AFTER_STYLE_1;
    } else
      this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
  Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
  Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
  Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);
  Tokenizer.prototype._stateBeforeScript5 = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._special = SPECIAL_SCRIPT;
    }
    this._state = IN_TAG_NAME;
    this._index--;
  };
  Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
  Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
  Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
  Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
  Tokenizer.prototype._stateAfterScript5 = function(c) {
    if (c === ">" || whitespace(c)) {
      this._special = SPECIAL_NONE;
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index - 6;
      this._index--;
    } else
      this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
  Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
  Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);
  Tokenizer.prototype._stateBeforeStyle4 = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._special = SPECIAL_STYLE;
    }
    this._state = IN_TAG_NAME;
    this._index--;
  };
  Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
  Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
  Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
  Tokenizer.prototype._stateAfterStyle4 = function(c) {
    if (c === ">" || whitespace(c)) {
      this._special = SPECIAL_NONE;
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index - 5;
      this._index--;
    } else
      this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
  Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);
  Tokenizer.prototype._parseNamedEntityStrict = function() {
    if (this._sectionStart + 1 < this._index) {
      var entity = this._buffer.substring(this._sectionStart + 1, this._index), map = this._xmlMode ? xmlMap : entityMap;
      if (map.hasOwnProperty(entity)) {
        this._emitPartial(map[entity]);
        this._sectionStart = this._index + 1;
      }
    }
  };
  Tokenizer.prototype._parseLegacyEntity = function() {
    var start = this._sectionStart + 1, limit = this._index - start;
    if (limit > 6)
      limit = 6;
    while (limit >= 2) {
      var entity = this._buffer.substr(start, limit);
      if (legacyMap.hasOwnProperty(entity)) {
        this._emitPartial(legacyMap[entity]);
        this._sectionStart += limit + 1;
        return;
      } else {
        limit--;
      }
    }
  };
  Tokenizer.prototype._stateInNamedEntity = function(c) {
    if (c === ";") {
      this._parseNamedEntityStrict();
      if (this._sectionStart + 1 < this._index && !this._xmlMode) {
        this._parseLegacyEntity();
      }
      this._state = this._baseState;
    } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
      if (this._xmlMode)
        ;
      else if (this._sectionStart + 1 === this._index)
        ;
      else if (this._baseState !== TEXT) {
        if (c !== "=") {
          this._parseNamedEntityStrict();
        }
      } else {
        this._parseLegacyEntity();
      }
      this._state = this._baseState;
      this._index--;
    }
  };
  Tokenizer.prototype._decodeNumericEntity = function(offset, base) {
    var sectionStart = this._sectionStart + offset;
    if (sectionStart !== this._index) {
      var entity = this._buffer.substring(sectionStart, this._index);
      var parsed = parseInt(entity, base);
      this._emitPartial(decodeCodePoint(parsed));
      this._sectionStart = this._index;
    } else {
      this._sectionStart--;
    }
    this._state = this._baseState;
  };
  Tokenizer.prototype._stateInNumericEntity = function(c) {
    if (c === ";") {
      this._decodeNumericEntity(2, 10);
      this._sectionStart++;
    } else if (c < "0" || c > "9") {
      if (!this._xmlMode) {
        this._decodeNumericEntity(2, 10);
      } else {
        this._state = this._baseState;
      }
      this._index--;
    }
  };
  Tokenizer.prototype._stateInHexEntity = function(c) {
    if (c === ";") {
      this._decodeNumericEntity(3, 16);
      this._sectionStart++;
    } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
      if (!this._xmlMode) {
        this._decodeNumericEntity(3, 16);
      } else {
        this._state = this._baseState;
      }
      this._index--;
    }
  };
  Tokenizer.prototype._cleanup = function() {
    if (this._sectionStart < 0) {
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else if (this._running) {
      if (this._state === TEXT) {
        if (this._sectionStart !== this._index) {
          this._cbs.ontext(this._buffer.substr(this._sectionStart));
        }
        this._buffer = "";
        this._bufferOffset += this._index;
        this._index = 0;
      } else if (this._sectionStart === this._index) {
        this._buffer = "";
        this._bufferOffset += this._index;
        this._index = 0;
      } else {
        this._buffer = this._buffer.substr(this._sectionStart);
        this._index -= this._sectionStart;
        this._bufferOffset += this._sectionStart;
      }
      this._sectionStart = 0;
    }
  };
  Tokenizer.prototype.write = function(chunk) {
    if (this._ended)
      this._cbs.onerror(Error(".write() after done!"));
    this._buffer += chunk;
    this._parse();
  };
  Tokenizer.prototype._parse = function() {
    while (this._index < this._buffer.length && this._running) {
      var c = this._buffer.charAt(this._index);
      if (this._state === TEXT) {
        this._stateText(c);
      } else if (this._state === BEFORE_TAG_NAME) {
        this._stateBeforeTagName(c);
      } else if (this._state === IN_TAG_NAME) {
        this._stateInTagName(c);
      } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
        this._stateBeforeCloseingTagName(c);
      } else if (this._state === IN_CLOSING_TAG_NAME) {
        this._stateInCloseingTagName(c);
      } else if (this._state === AFTER_CLOSING_TAG_NAME) {
        this._stateAfterCloseingTagName(c);
      } else if (this._state === IN_SELF_CLOSING_TAG) {
        this._stateInSelfClosingTag(c);
      } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
        this._stateBeforeAttributeName(c);
      } else if (this._state === IN_ATTRIBUTE_NAME) {
        this._stateInAttributeName(c);
      } else if (this._state === AFTER_ATTRIBUTE_NAME) {
        this._stateAfterAttributeName(c);
      } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
        this._stateBeforeAttributeValue(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
        this._stateInAttributeValueDoubleQuotes(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
        this._stateInAttributeValueSingleQuotes(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
        this._stateInAttributeValueNoQuotes(c);
      } else if (this._state === BEFORE_DECLARATION) {
        this._stateBeforeDeclaration(c);
      } else if (this._state === IN_DECLARATION) {
        this._stateInDeclaration(c);
      } else if (this._state === IN_PROCESSING_INSTRUCTION) {
        this._stateInProcessingInstruction(c);
      } else if (this._state === BEFORE_COMMENT) {
        this._stateBeforeComment(c);
      } else if (this._state === IN_COMMENT) {
        this._stateInComment(c);
      } else if (this._state === AFTER_COMMENT_1) {
        this._stateAfterComment1(c);
      } else if (this._state === AFTER_COMMENT_2) {
        this._stateAfterComment2(c);
      } else if (this._state === BEFORE_CDATA_1) {
        this._stateBeforeCdata1(c);
      } else if (this._state === BEFORE_CDATA_2) {
        this._stateBeforeCdata2(c);
      } else if (this._state === BEFORE_CDATA_3) {
        this._stateBeforeCdata3(c);
      } else if (this._state === BEFORE_CDATA_4) {
        this._stateBeforeCdata4(c);
      } else if (this._state === BEFORE_CDATA_5) {
        this._stateBeforeCdata5(c);
      } else if (this._state === BEFORE_CDATA_6) {
        this._stateBeforeCdata6(c);
      } else if (this._state === IN_CDATA) {
        this._stateInCdata(c);
      } else if (this._state === AFTER_CDATA_1) {
        this._stateAfterCdata1(c);
      } else if (this._state === AFTER_CDATA_2) {
        this._stateAfterCdata2(c);
      } else if (this._state === BEFORE_SPECIAL) {
        this._stateBeforeSpecial(c);
      } else if (this._state === BEFORE_SPECIAL_END) {
        this._stateBeforeSpecialEnd(c);
      } else if (this._state === BEFORE_SCRIPT_1) {
        this._stateBeforeScript1(c);
      } else if (this._state === BEFORE_SCRIPT_2) {
        this._stateBeforeScript2(c);
      } else if (this._state === BEFORE_SCRIPT_3) {
        this._stateBeforeScript3(c);
      } else if (this._state === BEFORE_SCRIPT_4) {
        this._stateBeforeScript4(c);
      } else if (this._state === BEFORE_SCRIPT_5) {
        this._stateBeforeScript5(c);
      } else if (this._state === AFTER_SCRIPT_1) {
        this._stateAfterScript1(c);
      } else if (this._state === AFTER_SCRIPT_2) {
        this._stateAfterScript2(c);
      } else if (this._state === AFTER_SCRIPT_3) {
        this._stateAfterScript3(c);
      } else if (this._state === AFTER_SCRIPT_4) {
        this._stateAfterScript4(c);
      } else if (this._state === AFTER_SCRIPT_5) {
        this._stateAfterScript5(c);
      } else if (this._state === BEFORE_STYLE_1) {
        this._stateBeforeStyle1(c);
      } else if (this._state === BEFORE_STYLE_2) {
        this._stateBeforeStyle2(c);
      } else if (this._state === BEFORE_STYLE_3) {
        this._stateBeforeStyle3(c);
      } else if (this._state === BEFORE_STYLE_4) {
        this._stateBeforeStyle4(c);
      } else if (this._state === AFTER_STYLE_1) {
        this._stateAfterStyle1(c);
      } else if (this._state === AFTER_STYLE_2) {
        this._stateAfterStyle2(c);
      } else if (this._state === AFTER_STYLE_3) {
        this._stateAfterStyle3(c);
      } else if (this._state === AFTER_STYLE_4) {
        this._stateAfterStyle4(c);
      } else if (this._state === BEFORE_ENTITY) {
        this._stateBeforeEntity(c);
      } else if (this._state === BEFORE_NUMERIC_ENTITY) {
        this._stateBeforeNumericEntity(c);
      } else if (this._state === IN_NAMED_ENTITY) {
        this._stateInNamedEntity(c);
      } else if (this._state === IN_NUMERIC_ENTITY) {
        this._stateInNumericEntity(c);
      } else if (this._state === IN_HEX_ENTITY) {
        this._stateInHexEntity(c);
      } else {
        this._cbs.onerror(Error("unknown _state"), this._state);
      }
      this._index++;
    }
    this._cleanup();
  };
  Tokenizer.prototype.pause = function() {
    this._running = false;
  };
  Tokenizer.prototype.resume = function() {
    this._running = true;
    if (this._index < this._buffer.length) {
      this._parse();
    }
    if (this._ended) {
      this._finish();
    }
  };
  Tokenizer.prototype.end = function(chunk) {
    if (this._ended)
      this._cbs.onerror(Error(".end() after done!"));
    if (chunk)
      this.write(chunk);
    this._ended = true;
    if (this._running)
      this._finish();
  };
  Tokenizer.prototype._finish = function() {
    if (this._sectionStart < this._index) {
      this._handleTrailingData();
    }
    this._cbs.onend();
  };
  Tokenizer.prototype._handleTrailingData = function() {
    var data = this._buffer.substr(this._sectionStart);
    if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
      this._cbs.oncdata(data);
    } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
      this._cbs.oncomment(data);
    } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
      this._parseLegacyEntity();
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
      this._decodeNumericEntity(2, 10);
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
      this._decodeNumericEntity(3, 16);
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
      this._cbs.ontext(data);
    }
  };
  Tokenizer.prototype.reset = function() {
    Tokenizer.call(this, { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities }, this._cbs);
  };
  Tokenizer.prototype.getAbsoluteIndex = function() {
    return this._bufferOffset + this._index;
  };
  Tokenizer.prototype._getSection = function() {
    return this._buffer.substring(this._sectionStart, this._index);
  };
  Tokenizer.prototype._emitToken = function(name) {
    this._cbs[name](this._getSection());
    this._sectionStart = -1;
  };
  Tokenizer.prototype._emitPartial = function(value) {
    if (this._baseState !== TEXT) {
      this._cbs.onattribdata(value);
    } else {
      this._cbs.ontext(value);
    }
  };
});

// node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS((exports, module) => {
  var Tokenizer = require_Tokenizer();
  var formTags = {
    input: true,
    option: true,
    optgroup: true,
    select: true,
    button: true,
    datalist: true,
    textarea: true
  };
  var openImpliesClose = {
    tr: { tr: true, th: true, td: true },
    th: { th: true },
    td: { thead: true, th: true, td: true },
    body: { head: true, link: true, script: true },
    li: { li: true },
    p: { p: true },
    h1: { p: true },
    h2: { p: true },
    h3: { p: true },
    h4: { p: true },
    h5: { p: true },
    h6: { p: true },
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: { option: true },
    optgroup: { optgroup: true }
  };
  var voidElements = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
  var foreignContextElements = {
    __proto__: null,
    math: true,
    svg: true
  };
  var htmlIntegrationElements = {
    __proto__: null,
    mi: true,
    mo: true,
    mn: true,
    ms: true,
    mtext: true,
    "annotation-xml": true,
    foreignObject: true,
    desc: true,
    title: true
  };
  var re_nameEnd = /\s|\//;
  function Parser(cbs, options) {
    this._options = options || {};
    this._cbs = cbs || {};
    this._tagname = "";
    this._attribname = "";
    this._attribvalue = "";
    this._attribs = null;
    this._stack = [];
    this._foreignContext = [];
    this.startIndex = 0;
    this.endIndex = null;
    this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
    this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
    if (this._options.Tokenizer) {
      Tokenizer = this._options.Tokenizer;
    }
    this._tokenizer = new Tokenizer(this._options, this);
    if (this._cbs.onparserinit)
      this._cbs.onparserinit(this);
  }
  require_inherits()(Parser, __require("events").EventEmitter);
  Parser.prototype._updatePosition = function(initialOffset) {
    if (this.endIndex === null) {
      if (this._tokenizer._sectionStart <= initialOffset) {
        this.startIndex = 0;
      } else {
        this.startIndex = this._tokenizer._sectionStart - initialOffset;
      }
    } else
      this.startIndex = this.endIndex + 1;
    this.endIndex = this._tokenizer.getAbsoluteIndex();
  };
  Parser.prototype.ontext = function(data) {
    this._updatePosition(1);
    this.endIndex--;
    if (this._cbs.ontext)
      this._cbs.ontext(data);
  };
  Parser.prototype.onopentagname = function(name) {
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this._tagname = name;
    if (!this._options.xmlMode && name in openImpliesClose) {
      for (var el;(el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el))
        ;
    }
    if (this._options.xmlMode || !(name in voidElements)) {
      this._stack.push(name);
      if (name in foreignContextElements)
        this._foreignContext.push(true);
      else if (name in htmlIntegrationElements)
        this._foreignContext.push(false);
    }
    if (this._cbs.onopentagname)
      this._cbs.onopentagname(name);
    if (this._cbs.onopentag)
      this._attribs = {};
  };
  Parser.prototype.onopentagend = function() {
    this._updatePosition(1);
    if (this._attribs) {
      if (this._cbs.onopentag)
        this._cbs.onopentag(this._tagname, this._attribs);
      this._attribs = null;
    }
    if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
      this._cbs.onclosetag(this._tagname);
    }
    this._tagname = "";
  };
  Parser.prototype.onclosetag = function(name) {
    this._updatePosition(1);
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (name in foreignContextElements || name in htmlIntegrationElements) {
      this._foreignContext.pop();
    }
    if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
      var pos = this._stack.lastIndexOf(name);
      if (pos !== -1) {
        if (this._cbs.onclosetag) {
          pos = this._stack.length - pos;
          while (pos--)
            this._cbs.onclosetag(this._stack.pop());
        } else
          this._stack.length = pos;
      } else if (name === "p" && !this._options.xmlMode) {
        this.onopentagname(name);
        this._closeCurrentTag();
      }
    } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
      this.onopentagname(name);
      this._closeCurrentTag();
    }
  };
  Parser.prototype.onselfclosingtag = function() {
    if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
      this._closeCurrentTag();
    } else {
      this.onopentagend();
    }
  };
  Parser.prototype._closeCurrentTag = function() {
    var name = this._tagname;
    this.onopentagend();
    if (this._stack[this._stack.length - 1] === name) {
      if (this._cbs.onclosetag) {
        this._cbs.onclosetag(name);
      }
      this._stack.pop();
    }
  };
  Parser.prototype.onattribname = function(name) {
    if (this._lowerCaseAttributeNames) {
      name = name.toLowerCase();
    }
    this._attribname = name;
  };
  Parser.prototype.onattribdata = function(value) {
    this._attribvalue += value;
  };
  Parser.prototype.onattribend = function() {
    if (this._cbs.onattribute)
      this._cbs.onattribute(this._attribname, this._attribvalue);
    if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
      this._attribs[this._attribname] = this._attribvalue;
    }
    this._attribname = "";
    this._attribvalue = "";
  };
  Parser.prototype._getInstructionName = function(value) {
    var idx = value.search(re_nameEnd), name = idx < 0 ? value : value.substr(0, idx);
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  };
  Parser.prototype.ondeclaration = function(value) {
    if (this._cbs.onprocessinginstruction) {
      var name = this._getInstructionName(value);
      this._cbs.onprocessinginstruction("!" + name, "!" + value);
    }
  };
  Parser.prototype.onprocessinginstruction = function(value) {
    if (this._cbs.onprocessinginstruction) {
      var name = this._getInstructionName(value);
      this._cbs.onprocessinginstruction("?" + name, "?" + value);
    }
  };
  Parser.prototype.oncomment = function(value) {
    this._updatePosition(4);
    if (this._cbs.oncomment)
      this._cbs.oncomment(value);
    if (this._cbs.oncommentend)
      this._cbs.oncommentend();
  };
  Parser.prototype.oncdata = function(value) {
    this._updatePosition(1);
    if (this._options.xmlMode || this._options.recognizeCDATA) {
      if (this._cbs.oncdatastart)
        this._cbs.oncdatastart();
      if (this._cbs.ontext)
        this._cbs.ontext(value);
      if (this._cbs.oncdataend)
        this._cbs.oncdataend();
    } else {
      this.oncomment("[CDATA[" + value + "]]");
    }
  };
  Parser.prototype.onerror = function(err) {
    if (this._cbs.onerror)
      this._cbs.onerror(err);
  };
  Parser.prototype.onend = function() {
    if (this._cbs.onclosetag) {
      for (var i = this._stack.length;i > 0; this._cbs.onclosetag(this._stack[--i]))
        ;
    }
    if (this._cbs.onend)
      this._cbs.onend();
  };
  Parser.prototype.reset = function() {
    if (this._cbs.onreset)
      this._cbs.onreset();
    this._tokenizer.reset();
    this._tagname = "";
    this._attribname = "";
    this._attribs = null;
    this._stack = [];
    if (this._cbs.onparserinit)
      this._cbs.onparserinit(this);
  };
  Parser.prototype.parseComplete = function(data) {
    this.reset();
    this.end(data);
  };
  Parser.prototype.write = function(chunk) {
    this._tokenizer.write(chunk);
  };
  Parser.prototype.end = function(chunk) {
    this._tokenizer.end(chunk);
  };
  Parser.prototype.pause = function() {
    this._tokenizer.pause();
  };
  Parser.prototype.resume = function() {
    this._tokenizer.resume();
  };
  Parser.prototype.parseChunk = Parser.prototype.write;
  Parser.prototype.done = Parser.prototype.end;
  module.exports = Parser;
});

// node_modules/domelementtype/index.js
var require_domelementtype = __commonJS((exports, module) => {
  module.exports = {
    Text: "text",
    Directive: "directive",
    Comment: "comment",
    Script: "script",
    Style: "style",
    Tag: "tag",
    CDATA: "cdata",
    Doctype: "doctype",
    isTag: function(elem) {
      return elem.type === "tag" || elem.type === "script" || elem.type === "style";
    }
  };
});

// node_modules/domhandler/lib/node.js
var require_node2 = __commonJS((exports, module) => {
  var NodePrototype = module.exports = {
    get firstChild() {
      var children = this.children;
      return children && children[0] || null;
    },
    get lastChild() {
      var children = this.children;
      return children && children[children.length - 1] || null;
    },
    get nodeType() {
      return nodeTypes[this.type] || nodeTypes.element;
    }
  };
  var domLvl1 = {
    tagName: "name",
    childNodes: "children",
    parentNode: "parent",
    previousSibling: "prev",
    nextSibling: "next",
    nodeValue: "data"
  };
  var nodeTypes = {
    element: 1,
    text: 3,
    cdata: 4,
    comment: 8
  };
  Object.keys(domLvl1).forEach(function(key) {
    var shorthand = domLvl1[key];
    Object.defineProperty(NodePrototype, key, {
      get: function() {
        return this[shorthand] || null;
      },
      set: function(val) {
        this[shorthand] = val;
        return val;
      }
    });
  });
});

// node_modules/domhandler/lib/element.js
var require_element = __commonJS((exports, module) => {
  var NodePrototype = require_node2();
  var ElementPrototype = module.exports = Object.create(NodePrototype);
  var domLvl1 = {
    tagName: "name"
  };
  Object.keys(domLvl1).forEach(function(key) {
    var shorthand = domLvl1[key];
    Object.defineProperty(ElementPrototype, key, {
      get: function() {
        return this[shorthand] || null;
      },
      set: function(val) {
        this[shorthand] = val;
        return val;
      }
    });
  });
});

// node_modules/domhandler/index.js
var require_domhandler = __commonJS((exports, module) => {
  var ElementType = require_domelementtype();
  var re_whitespace = /\s+/g;
  var NodePrototype = require_node2();
  var ElementPrototype = require_element();
  function DomHandler(callback, options, elementCB) {
    if (typeof callback === "object") {
      elementCB = options;
      options = callback;
      callback = null;
    } else if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    this._callback = callback;
    this._options = options || defaultOpts;
    this._elementCB = elementCB;
    this.dom = [];
    this._done = false;
    this._tagStack = [];
    this._parser = this._parser || null;
  }
  var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false
  };
  DomHandler.prototype.onparserinit = function(parser) {
    this._parser = parser;
  };
  DomHandler.prototype.onreset = function() {
    DomHandler.call(this, this._callback, this._options, this._elementCB);
  };
  DomHandler.prototype.onend = function() {
    if (this._done)
      return;
    this._done = true;
    this._parser = null;
    this._handleCallback(null);
  };
  DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function(error) {
    if (typeof this._callback === "function") {
      this._callback(error, this.dom);
    } else {
      if (error)
        throw error;
    }
  };
  DomHandler.prototype.onclosetag = function() {
    var elem = this._tagStack.pop();
    if (this._options.withEndIndices && elem) {
      elem.endIndex = this._parser.endIndex;
    }
    if (this._elementCB)
      this._elementCB(elem);
  };
  DomHandler.prototype._createDomElement = function(properties) {
    if (!this._options.withDomLvl1)
      return properties;
    var element;
    if (properties.type === "tag") {
      element = Object.create(ElementPrototype);
    } else {
      element = Object.create(NodePrototype);
    }
    for (var key in properties) {
      if (properties.hasOwnProperty(key)) {
        element[key] = properties[key];
      }
    }
    return element;
  };
  DomHandler.prototype._addDomElement = function(element) {
    var parent = this._tagStack[this._tagStack.length - 1];
    var siblings = parent ? parent.children : this.dom;
    var previousSibling = siblings[siblings.length - 1];
    element.next = null;
    if (this._options.withStartIndices) {
      element.startIndex = this._parser.startIndex;
    }
    if (this._options.withEndIndices) {
      element.endIndex = this._parser.endIndex;
    }
    if (previousSibling) {
      element.prev = previousSibling;
      previousSibling.next = element;
    } else {
      element.prev = null;
    }
    siblings.push(element);
    element.parent = parent || null;
  };
  DomHandler.prototype.onopentag = function(name, attribs) {
    var properties = {
      type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
      name,
      attribs,
      children: []
    };
    var element = this._createDomElement(properties);
    this._addDomElement(element);
    this._tagStack.push(element);
  };
  DomHandler.prototype.ontext = function(data) {
    var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
    var lastTag;
    if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {
      if (normalize) {
        lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
      } else {
        lastTag.data += data;
      }
    } else {
      if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {
        if (normalize) {
          lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
        } else {
          lastTag.data += data;
        }
      } else {
        if (normalize) {
          data = data.replace(re_whitespace, " ");
        }
        var element = this._createDomElement({
          data,
          type: ElementType.Text
        });
        this._addDomElement(element);
      }
    }
  };
  DomHandler.prototype.oncomment = function(data) {
    var lastTag = this._tagStack[this._tagStack.length - 1];
    if (lastTag && lastTag.type === ElementType.Comment) {
      lastTag.data += data;
      return;
    }
    var properties = {
      data,
      type: ElementType.Comment
    };
    var element = this._createDomElement(properties);
    this._addDomElement(element);
    this._tagStack.push(element);
  };
  DomHandler.prototype.oncdatastart = function() {
    var properties = {
      children: [{
        data: "",
        type: ElementType.Text
      }],
      type: ElementType.CDATA
    };
    var element = this._createDomElement(properties);
    this._addDomElement(element);
    this._tagStack.push(element);
  };
  DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function() {
    this._tagStack.pop();
  };
  DomHandler.prototype.onprocessinginstruction = function(name, data) {
    var element = this._createDomElement({
      name,
      data,
      type: ElementType.Directive
    });
    this._addDomElement(element);
  };
  module.exports = DomHandler;
});

// node_modules/dom-serializer/node_modules/domelementtype/lib/index.js
var require_lib5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = undefined;
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType = exports.ElementType || (exports.ElementType = {}));
  function isTag(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
  }
  exports.isTag = isTag;
  exports.Root = ElementType.Root;
  exports.Text = ElementType.Text;
  exports.Directive = ElementType.Directive;
  exports.Comment = ElementType.Comment;
  exports.Script = ElementType.Script;
  exports.Style = ElementType.Style;
  exports.Tag = ElementType.Tag;
  exports.CDATA = ElementType.CDATA;
  exports.Doctype = ElementType.Doctype;
});

// node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json
var require_entities3 = __commonJS((exports, module) => {
  module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "\uD835\uDD04", afr: "\uD835\uDD1E", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "\uD835\uDD38", aopf: "\uD835\uDD52", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "\uD835\uDC9C", ascr: "\uD835\uDCB6", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "\uD835\uDD05", bfr: "\uD835\uDD1F", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "\uD835\uDD39", bopf: "\uD835\uDD53", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "\uD835\uDCB7", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "\uD835\uDD20", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "\uD835\uDD54", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "\uD835\uDC9E", cscr: "\uD835\uDCB8", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "\uD835\uDD07", dfr: "\uD835\uDD21", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "\uD835\uDD3B", dopf: "\uD835\uDD55", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "\uD835\uDC9F", dscr: "\uD835\uDCB9", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "\uD835\uDD08", efr: "\uD835\uDD22", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "\uD835\uDD3C", eopf: "\uD835\uDD56", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "\uD835\uDD09", ffr: "\uD835\uDD23", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "\uD835\uDD3D", fopf: "\uD835\uDD57", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "\uD835\uDCBB", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "\uD835\uDD0A", gfr: "\uD835\uDD24", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "\uD835\uDD3E", gopf: "\uD835\uDD58", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "\uD835\uDCA2", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "\uD835\uDD25", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "\uD835\uDD59", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "\uD835\uDCBD", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "\uD835\uDD26", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "\uD835\uDD40", iopf: "\uD835\uDD5A", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "\uD835\uDCBE", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "\uD835\uDD0D", jfr: "\uD835\uDD27", jmath: "ȷ", Jopf: "\uD835\uDD41", jopf: "\uD835\uDD5B", Jscr: "\uD835\uDCA5", jscr: "\uD835\uDCBF", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "\uD835\uDD0E", kfr: "\uD835\uDD28", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "\uD835\uDD42", kopf: "\uD835\uDD5C", Kscr: "\uD835\uDCA6", kscr: "\uD835\uDCC0", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "\uD835\uDD0F", lfr: "\uD835\uDD29", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "\uD835\uDD43", lopf: "\uD835\uDD5D", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "\uD835\uDCC1", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "\uD835\uDD10", mfr: "\uD835\uDD2A", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "\uD835\uDD44", mopf: "\uD835\uDD5E", mp: "∓", mscr: "\uD835\uDCC2", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: `
`, nexist: "∄", nexists: "∄", Nfr: "\uD835\uDD11", nfr: "\uD835\uDD2B", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "\uD835\uDD5F", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "\uD835\uDCA9", nscr: "\uD835\uDCC3", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "\uD835\uDD12", ofr: "\uD835\uDD2C", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "\uD835\uDD46", oopf: "\uD835\uDD60", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "\uD835\uDCAA", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "\uD835\uDD13", pfr: "\uD835\uDD2D", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "\uD835\uDD61", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "\uD835\uDCAB", pscr: "\uD835\uDCC5", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "\uD835\uDD14", qfr: "\uD835\uDD2E", qint: "⨌", qopf: "\uD835\uDD62", Qopf: "ℚ", qprime: "⁗", Qscr: "\uD835\uDCAC", qscr: "\uD835\uDCC6", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "\uD835\uDD2F", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "\uD835\uDD63", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "\uD835\uDCC7", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "\uD835\uDD16", sfr: "\uD835\uDD30", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "\uD835\uDD4A", sopf: "\uD835\uDD64", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "\uD835\uDCAE", sscr: "\uD835\uDCC8", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "\t", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "\uD835\uDD17", tfr: "\uD835\uDD31", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "\uD835\uDD4B", topf: "\uD835\uDD65", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "\uD835\uDCAF", tscr: "\uD835\uDCC9", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "\uD835\uDD18", ufr: "\uD835\uDD32", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "\uD835\uDD4C", uopf: "\uD835\uDD66", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "\uD835\uDCB0", uscr: "\uD835\uDCCA", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "\uD835\uDD19", vfr: "\uD835\uDD33", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "\uD835\uDD4D", vopf: "\uD835\uDD67", vprop: "∝", vrtri: "⊳", Vscr: "\uD835\uDCB1", vscr: "\uD835\uDCCB", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "\uD835\uDD1A", wfr: "\uD835\uDD34", Wopf: "\uD835\uDD4E", wopf: "\uD835\uDD68", wp: "℘", wr: "≀", wreath: "≀", Wscr: "\uD835\uDCB2", wscr: "\uD835\uDCCC", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "\uD835\uDD1B", xfr: "\uD835\uDD35", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "\uD835\uDD4F", xopf: "\uD835\uDD69", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "\uD835\uDCB3", xscr: "\uD835\uDCCD", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "\uD835\uDD1C", yfr: "\uD835\uDD36", YIcy: "Ї", yicy: "ї", Yopf: "\uD835\uDD50", yopf: "\uD835\uDD6A", Yscr: "\uD835\uDCB4", yscr: "\uD835\uDCCE", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "\uD835\uDD37", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "\uD835\uDD6B", Zopf: "ℤ", Zscr: "\uD835\uDCB5", zscr: "\uD835\uDCCF", zwj: "‍", zwnj: "‌" };
});

// node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json
var require_legacy2 = __commonJS((exports, module) => {
  module.exports = { Aacute: "Á", aacute: "á", Acirc: "Â", acirc: "â", acute: "´", AElig: "Æ", aelig: "æ", Agrave: "À", agrave: "à", amp: "&", AMP: "&", Aring: "Å", aring: "å", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", brvbar: "¦", Ccedil: "Ç", ccedil: "ç", cedil: "¸", cent: "¢", copy: "©", COPY: "©", curren: "¤", deg: "°", divide: "÷", Eacute: "É", eacute: "é", Ecirc: "Ê", ecirc: "ê", Egrave: "È", egrave: "è", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", frac12: "½", frac14: "¼", frac34: "¾", gt: ">", GT: ">", Iacute: "Í", iacute: "í", Icirc: "Î", icirc: "î", iexcl: "¡", Igrave: "Ì", igrave: "ì", iquest: "¿", Iuml: "Ï", iuml: "ï", laquo: "«", lt: "<", LT: "<", macr: "¯", micro: "µ", middot: "·", nbsp: " ", not: "¬", Ntilde: "Ñ", ntilde: "ñ", Oacute: "Ó", oacute: "ó", Ocirc: "Ô", ocirc: "ô", Ograve: "Ò", ograve: "ò", ordf: "ª", ordm: "º", Oslash: "Ø", oslash: "ø", Otilde: "Õ", otilde: "õ", Ouml: "Ö", ouml: "ö", para: "¶", plusmn: "±", pound: "£", quot: '"', QUOT: '"', raquo: "»", reg: "®", REG: "®", sect: "§", shy: "­", sup1: "¹", sup2: "²", sup3: "³", szlig: "ß", THORN: "Þ", thorn: "þ", times: "×", Uacute: "Ú", uacute: "ú", Ucirc: "Û", ucirc: "û", Ugrave: "Ù", ugrave: "ù", uml: "¨", Uuml: "Ü", uuml: "ü", Yacute: "Ý", yacute: "ý", yen: "¥", yuml: "ÿ" };
});

// node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json
var require_xml2 = __commonJS((exports, module) => {
  module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});

// node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json
var require_decode3 = __commonJS((exports, module) => {
  module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
});

// node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var decode_json_1 = __importDefault(require_decode3());
  var fromCodePoint = String.fromCodePoint || function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function decodeCodePoint(codePoint) {
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "�";
    }
    if (codePoint in decode_json_1.default) {
      codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
  }
  exports.default = decodeCodePoint;
});

// node_modules/dom-serializer/node_modules/entities/lib/decode.js
var require_decode4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = undefined;
  var entities_json_1 = __importDefault(require_entities3());
  var legacy_json_1 = __importDefault(require_legacy2());
  var xml_json_1 = __importDefault(require_xml2());
  var decode_codepoint_1 = __importDefault(require_decode_codepoint2());
  var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  exports.decodeXML = getStrictDecoder(xml_json_1.default);
  exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function(str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }
  var sorter = function(a, b) {
    return a < b ? 1 : -1;
  };
  exports.decodeHTML = function() {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0;i < keys.length; i++) {
      if (legacy[j] === keys[i]) {
        keys[i] += ";?";
        j++;
      } else {
        keys[i] += ";";
      }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
      if (str.substr(-1) !== ";")
        str += ";";
      return replace(str);
    }
    return function(str) {
      return String(str).replace(re, replacer);
    };
  }();
  function getReplacer(map) {
    return function replace(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);
        if (secondChar === "X" || secondChar === "x") {
          return decode_codepoint_1.default(parseInt(str.substr(3), 16));
        }
        return decode_codepoint_1.default(parseInt(str.substr(2), 10));
      }
      return map[str.slice(1, -1)] || str;
    };
  }
});

// node_modules/dom-serializer/node_modules/entities/lib/encode.js
var require_encode2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = undefined;
  var xml_json_1 = __importDefault(require_xml2());
  var inverseXML = getInverseObj(xml_json_1.default);
  var xmlReplacer = getInverseReplacer(inverseXML);
  exports.encodeXML = getASCIIEncoder(inverseXML);
  var entities_json_1 = __importDefault(require_entities3());
  var inverseHTML = getInverseObj(entities_json_1.default);
  var htmlReplacer = getInverseReplacer(inverseHTML);
  exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function(inverse, name) {
      inverse[obj[name]] = "&" + name + ";";
      return inverse;
    }, {});
  }
  function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse);_i < _a.length; _i++) {
      var k = _a[_i];
      if (k.length === 1) {
        single.push("\\" + k);
      } else {
        multiple.push(k);
      }
    }
    single.sort();
    for (var start = 0;start < single.length - 1; start++) {
      var end = start;
      while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
        end += 1;
      }
      var count = 1 + end - start;
      if (count < 3)
        continue;
      single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
  }
  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
  var getCodePoint = String.prototype.codePointAt != null ? function(str) {
    return str.codePointAt(0);
  } : function(c) {
    return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
  };
  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re) {
    return function(data) {
      return data.replace(re, function(name) {
        return inverse[name];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }
  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }
  exports.escape = escape;
  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }
  exports.escapeUTF8 = escapeUTF8;
  function getASCIIEncoder(obj) {
    return function(data) {
      return data.replace(reEscapeChars, function(c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
});

// node_modules/dom-serializer/node_modules/entities/lib/index.js
var require_lib6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = undefined;
  var decode_1 = require_decode4();
  var encode_1 = require_encode2();
  function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
  }
  exports.decode = decode;
  function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
  }
  exports.decodeStrict = decodeStrict;
  function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
  }
  exports.encode = encode;
  var encode_2 = require_encode2();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return encode_2.encodeXML;
  } });
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return encode_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return encode_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  var decode_2 = require_decode4();
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
});

// node_modules/dom-serializer/foreignNames.json
var require_foreignNames = __commonJS((exports, module) => {
  module.exports = {
    elementNames: {
      altglyph: "altGlyph",
      altglyphdef: "altGlyphDef",
      altglyphitem: "altGlyphItem",
      animatecolor: "animateColor",
      animatemotion: "animateMotion",
      animatetransform: "animateTransform",
      clippath: "clipPath",
      feblend: "feBlend",
      fecolormatrix: "feColorMatrix",
      fecomponenttransfer: "feComponentTransfer",
      fecomposite: "feComposite",
      feconvolvematrix: "feConvolveMatrix",
      fediffuselighting: "feDiffuseLighting",
      fedisplacementmap: "feDisplacementMap",
      fedistantlight: "feDistantLight",
      fedropshadow: "feDropShadow",
      feflood: "feFlood",
      fefunca: "feFuncA",
      fefuncb: "feFuncB",
      fefuncg: "feFuncG",
      fefuncr: "feFuncR",
      fegaussianblur: "feGaussianBlur",
      feimage: "feImage",
      femerge: "feMerge",
      femergenode: "feMergeNode",
      femorphology: "feMorphology",
      feoffset: "feOffset",
      fepointlight: "fePointLight",
      fespecularlighting: "feSpecularLighting",
      fespotlight: "feSpotLight",
      fetile: "feTile",
      feturbulence: "feTurbulence",
      foreignobject: "foreignObject",
      glyphref: "glyphRef",
      lineargradient: "linearGradient",
      radialgradient: "radialGradient",
      textpath: "textPath"
    },
    attributeNames: {
      definitionurl: "definitionURL",
      attributename: "attributeName",
      attributetype: "attributeType",
      basefrequency: "baseFrequency",
      baseprofile: "baseProfile",
      calcmode: "calcMode",
      clippathunits: "clipPathUnits",
      diffuseconstant: "diffuseConstant",
      edgemode: "edgeMode",
      filterunits: "filterUnits",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      limitingconeangle: "limitingConeAngle",
      markerheight: "markerHeight",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      numoctaves: "numOctaves",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      refx: "refX",
      refy: "refY",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stitchtiles: "stitchTiles",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textlength: "textLength",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      xchannelselector: "xChannelSelector",
      ychannelselector: "yChannelSelector",
      zoomandpan: "zoomAndPan"
    }
  };
});

// node_modules/dom-serializer/index.js
var require_dom_serializer = __commonJS((exports, module) => {
  var ElementType = require_lib5();
  var entities = require_lib6();
  var foreignNames = require_foreignNames();
  foreignNames.elementNames.__proto__ = null;
  foreignNames.attributeNames.__proto__ = null;
  var unencodedElements = {
    __proto__: null,
    style: true,
    script: true,
    xmp: true,
    iframe: true,
    noembed: true,
    noframes: true,
    plaintext: true,
    noscript: true
  };
  function formatAttrs(attributes, opts) {
    if (!attributes)
      return;
    var output = "";
    var value;
    for (var key in attributes) {
      value = attributes[key];
      if (output) {
        output += " ";
      }
      if (opts.xmlMode === "foreign") {
        key = foreignNames.attributeNames[key] || key;
      }
      output += key;
      if (value !== null && value !== "" || opts.xmlMode) {
        output += '="' + (opts.decodeEntities ? entities.encodeXML(value) : value.replace(/\"/g, "&quot;")) + '"';
      }
    }
    return output;
  }
  var singleTag = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
  var render = module.exports = function(dom, opts) {
    if (!Array.isArray(dom) && !dom.cheerio)
      dom = [dom];
    opts = opts || {};
    var output = "";
    for (var i = 0;i < dom.length; i++) {
      var elem = dom[i];
      if (elem.type === "root")
        output += render(elem.children, opts);
      else if (ElementType.isTag(elem))
        output += renderTag(elem, opts);
      else if (elem.type === ElementType.Directive)
        output += renderDirective(elem);
      else if (elem.type === ElementType.Comment)
        output += renderComment(elem);
      else if (elem.type === ElementType.CDATA)
        output += renderCdata(elem);
      else
        output += renderText(elem, opts);
    }
    return output;
  };
  var foreignModeIntegrationPoints = [
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ];
  function renderTag(elem, opts) {
    if (opts.xmlMode === "foreign") {
      elem.name = foreignNames.elementNames[elem.name] || elem.name;
      if (elem.parent && foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0)
        opts = Object.assign({}, opts, { xmlMode: false });
    }
    if (!opts.xmlMode && ["svg", "math"].indexOf(elem.name) >= 0) {
      opts = Object.assign({}, opts, { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttrs(elem.attribs, opts);
    if (attribs) {
      tag += " " + attribs;
    }
    if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children) {
        tag += render(elem.children, opts);
      }
      if (!singleTag[elem.name] || opts.xmlMode) {
        tag += "</" + elem.name + ">";
      }
    }
    return tag;
  }
  function renderDirective(elem) {
    return "<" + elem.data + ">";
  }
  function renderText(elem, opts) {
    var data = elem.data || "";
    if (opts.decodeEntities && !(elem.parent && (elem.parent.name in unencodedElements))) {
      data = entities.encodeXML(data);
    }
    return data;
  }
  function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
  }
  function renderComment(elem) {
    return "<!--" + elem.data + "-->";
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var ElementType = require_domelementtype();
  var getOuterHTML = require_dom_serializer();
  var isTag = ElementType.isTag;
  module.exports = {
    getInnerHTML,
    getOuterHTML,
    getText
  };
  function getInnerHTML(elem, opts) {
    return elem.children ? elem.children.map(function(elem2) {
      return getOuterHTML(elem2, opts);
    }).join("") : "";
  }
  function getText(elem) {
    if (Array.isArray(elem))
      return elem.map(getText).join("");
    if (isTag(elem))
      return elem.name === "br" ? `
` : getText(elem.children);
    if (elem.type === ElementType.CDATA)
      return getText(elem.children);
    if (elem.type === ElementType.Text)
      return elem.data;
    return "";
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS((exports) => {
  var getChildren = exports.getChildren = function(elem) {
    return elem.children;
  };
  var getParent = exports.getParent = function(elem) {
    return elem.parent;
  };
  exports.getSiblings = function(elem) {
    var parent = getParent(elem);
    return parent ? getChildren(parent) : [elem];
  };
  exports.getAttributeValue = function(elem, name) {
    return elem.attribs && elem.attribs[name];
  };
  exports.hasAttrib = function(elem, name) {
    return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
  };
  exports.getName = function(elem) {
    return elem.name;
  };
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS((exports) => {
  exports.removeElement = function(elem) {
    if (elem.prev)
      elem.prev.next = elem.next;
    if (elem.next)
      elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      childs.splice(childs.lastIndexOf(elem), 1);
    }
  };
  exports.replaceElement = function(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
    }
  };
  exports.appendChild = function(elem, child) {
    child.parent = elem;
    if (elem.children.push(child) !== 1) {
      var sibling = elem.children[elem.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
      child.next = null;
    }
  };
  exports.append = function(elem, next) {
    var { parent, next: currNext } = elem;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  };
  exports.prepend = function(elem, prev) {
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  };
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS((exports, module) => {
  var isTag = require_domelementtype().isTag;
  module.exports = {
    filter,
    find,
    findOneChild,
    findOne,
    existsOne,
    findAll
  };
  function filter(test, element, recurse, limit) {
    if (!Array.isArray(element))
      element = [element];
    if (typeof limit !== "number" || !isFinite(limit)) {
      limit = Infinity;
    }
    return find(test, element, recurse !== false, limit);
  }
  function find(test, elems, recurse, limit) {
    var result = [], childs;
    for (var i = 0, j = elems.length;i < j; i++) {
      if (test(elems[i])) {
        result.push(elems[i]);
        if (--limit <= 0)
          break;
      }
      childs = elems[i].children;
      if (recurse && childs && childs.length > 0) {
        childs = find(test, childs, recurse, limit);
        result = result.concat(childs);
        limit -= childs.length;
        if (limit <= 0)
          break;
      }
    }
    return result;
  }
  function findOneChild(test, elems) {
    for (var i = 0, l = elems.length;i < l; i++) {
      if (test(elems[i]))
        return elems[i];
    }
    return null;
  }
  function findOne(test, elems) {
    var elem = null;
    for (var i = 0, l = elems.length;i < l && !elem; i++) {
      if (!isTag(elems[i])) {
        continue;
      } else if (test(elems[i])) {
        elem = elems[i];
      } else if (elems[i].children.length > 0) {
        elem = findOne(test, elems[i].children);
      }
    }
    return elem;
  }
  function existsOne(test, elems) {
    for (var i = 0, l = elems.length;i < l; i++) {
      if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
        return true;
      }
    }
    return false;
  }
  function findAll(test, rootElems) {
    var result = [];
    var stack = rootElems.slice();
    while (stack.length) {
      var elem = stack.shift();
      if (!isTag(elem))
        continue;
      if (elem.children && elem.children.length > 0) {
        stack.unshift.apply(stack, elem.children);
      }
      if (test(elem))
        result.push(elem);
    }
    return result;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy3 = __commonJS((exports) => {
  var ElementType = require_domelementtype();
  var isTag = exports.isTag = ElementType.isTag;
  exports.testElement = function(options, element) {
    for (var key in options) {
      if (!options.hasOwnProperty(key))
        ;
      else if (key === "tag_name") {
        if (!isTag(element) || !options.tag_name(element.name)) {
          return false;
        }
      } else if (key === "tag_type") {
        if (!options.tag_type(element.type))
          return false;
      } else if (key === "tag_contains") {
        if (isTag(element) || !options.tag_contains(element.data)) {
          return false;
        }
      } else if (!element.attribs || !options[key](element.attribs[key])) {
        return false;
      }
    }
    return true;
  };
  var Checks = {
    tag_name: function(name) {
      if (typeof name === "function") {
        return function(elem) {
          return isTag(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return isTag;
      } else {
        return function(elem) {
          return isTag(elem) && elem.name === name;
        };
      }
    },
    tag_type: function(type) {
      if (typeof type === "function") {
        return function(elem) {
          return type(elem.type);
        };
      } else {
        return function(elem) {
          return elem.type === type;
        };
      }
    },
    tag_contains: function(data) {
      if (typeof data === "function") {
        return function(elem) {
          return !isTag(elem) && data(elem.data);
        };
      } else {
        return function(elem) {
          return !isTag(elem) && elem.data === data;
        };
      }
    }
  };
  function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
      return function(elem) {
        return elem.attribs && value(elem.attribs[attrib]);
      };
    } else {
      return function(elem) {
        return elem.attribs && elem.attribs[attrib] === value;
      };
    }
  }
  function combineFuncs(a, b) {
    return function(elem) {
      return a(elem) || b(elem);
    };
  }
  exports.getElements = function(options, element, recurse, limit) {
    var funcs = Object.keys(options).map(function(key) {
      var value = options[key];
      return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
  };
  exports.getElementById = function(id, element, recurse) {
    if (!Array.isArray(element))
      element = [element];
    return this.findOne(getAttribCheck("id", id), element, recurse !== false);
  };
  exports.getElementsByTagName = function(name, element, recurse, limit) {
    return this.filter(Checks.tag_name(name), element, recurse, limit);
  };
  exports.getElementsByTagType = function(type, element, recurse, limit) {
    return this.filter(Checks.tag_type(type), element, recurse, limit);
  };
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  exports.removeSubsets = function(nodes) {
    var idx = nodes.length, node, ancestor, replace;
    while (--idx > -1) {
      node = ancestor = nodes[idx];
      nodes[idx] = null;
      replace = true;
      while (ancestor) {
        if (nodes.indexOf(ancestor) > -1) {
          replace = false;
          nodes.splice(idx, 1);
          break;
        }
        ancestor = ancestor.parent;
      }
      if (replace) {
        nodes[idx] = node;
      }
    }
    return nodes;
  };
  var POSITION = {
    DISCONNECTED: 1,
    PRECEDING: 2,
    FOLLOWING: 4,
    CONTAINS: 8,
    CONTAINED_BY: 16
  };
  var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    var current, sharedParent, siblings, aSibling, bSibling, idx;
    if (nodeA === nodeB) {
      return 0;
    }
    current = nodeA;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = nodeB;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    idx = 0;
    while (aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return POSITION.DISCONNECTED;
    }
    sharedParent = aParents[idx - 1];
    siblings = sharedParent.children;
    aSibling = aParents[idx];
    bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
      }
      return POSITION.FOLLOWING;
    } else {
      if (sharedParent === nodeA) {
        return POSITION.PRECEDING | POSITION.CONTAINS;
      }
      return POSITION.PRECEDING;
    }
  };
  exports.uniqueSort = function(nodes) {
    var idx = nodes.length, node, position;
    nodes = nodes.slice();
    while (--idx > -1) {
      node = nodes[idx];
      position = nodes.indexOf(node);
      if (position > -1 && position < idx) {
        nodes.splice(idx, 1);
      }
    }
    nodes.sort(function(a, b) {
      var relative = comparePos(a, b);
      if (relative & POSITION.PRECEDING) {
        return -1;
      } else if (relative & POSITION.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  };
});

// node_modules/domutils/index.js
var require_domutils = __commonJS((exports, module) => {
  var DomUtils = exports;
  [
    require_stringify(),
    require_traversal(),
    require_manipulation(),
    require_querying(),
    require_legacy3(),
    require_helpers()
  ].forEach(function(ext) {
    Object.keys(ext).forEach(function(key) {
      DomUtils[key] = ext[key].bind(DomUtils);
    });
  });
});

// node_modules/htmlparser2/lib/FeedHandler.js
var require_FeedHandler = __commonJS((exports, module) => {
  var DomHandler = require_domhandler();
  var DomUtils = require_domutils();
  function FeedHandler(callback, options) {
    this.init(callback, options);
  }
  require_inherits()(FeedHandler, DomHandler);
  FeedHandler.prototype.init = DomHandler;
  function getElements(what, where) {
    return DomUtils.getElementsByTagName(what, where, true);
  }
  function getOneElement(what, where) {
    return DomUtils.getElementsByTagName(what, where, true, 1)[0];
  }
  function fetch2(what, where, recurse) {
    return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
  }
  function addConditionally(obj, prop, what, where, recurse) {
    var tmp = fetch2(what, where, recurse);
    if (tmp)
      obj[prop] = tmp;
  }
  var isValidFeed = function(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  };
  FeedHandler.prototype.onend = function() {
    var feed = {}, feedRoot = getOneElement(isValidFeed, this.dom), tmp, childs;
    if (feedRoot) {
      if (feedRoot.name === "feed") {
        childs = feedRoot.children;
        feed.type = "atom";
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href))
          feed.link = tmp;
        addConditionally(feed, "description", "subtitle", childs);
        if (tmp = fetch2("updated", childs))
          feed.updated = new Date(tmp);
        addConditionally(feed, "author", "email", childs, true);
        feed.items = getElements("entry", childs).map(function(item) {
          var entry = {}, tmp2;
          item = item.children;
          addConditionally(entry, "id", "id", item);
          addConditionally(entry, "title", "title", item);
          if ((tmp2 = getOneElement("link", item)) && (tmp2 = tmp2.attribs) && (tmp2 = tmp2.href))
            entry.link = tmp2;
          if (tmp2 = fetch2("summary", item) || fetch2("content", item))
            entry.description = tmp2;
          if (tmp2 = fetch2("updated", item))
            entry.pubDate = new Date(tmp2);
          return entry;
        });
      } else {
        childs = getOneElement("channel", feedRoot.children).children;
        feed.type = feedRoot.name.substr(0, 3);
        feed.id = "";
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        if (tmp = fetch2("lastBuildDate", childs))
          feed.updated = new Date(tmp);
        addConditionally(feed, "author", "managingEditor", childs, true);
        feed.items = getElements("item", feedRoot.children).map(function(item) {
          var entry = {}, tmp2;
          item = item.children;
          addConditionally(entry, "id", "guid", item);
          addConditionally(entry, "title", "title", item);
          addConditionally(entry, "link", "link", item);
          addConditionally(entry, "description", "description", item);
          if (tmp2 = fetch2("pubDate", item))
            entry.pubDate = new Date(tmp2);
          return entry;
        });
      }
    }
    this.dom = feed;
    DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
  };
  module.exports = FeedHandler;
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var _require = __require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = __require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  module.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports, module) => {
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/errors.js
var require_errors = __commonJS((exports, module) => {
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports.codes = codes;
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  module.exports = {
    getHighWaterMark
  };
});

// node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable2 = __commonJS((exports, module) => {
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = __require("stream");
  var Buffer2 = __require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy2();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex2();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex2();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex2 = __commonJS((exports, module) => {
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj)
      keys2.push(key);
    return keys2;
  };
  module.exports = Duplex;
  var Readable = require__stream_readable2();
  var Writable = require__stream_writable2();
  require_inherits()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer2().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  module.exports = eos;
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports, module) => {
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module.exports = createReadableStreamAsyncIterator;
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  }
  module.exports = from;
});

// node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable2 = __commonJS((exports, module) => {
  module.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = __require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = __require("util");
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy2();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex2();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex2();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder2().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === undefined) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform2 = __commonJS((exports, module) => {
  module.exports = Transform;
  var _require$codes = require_errors().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require__stream_duplex2();
  require_inherits()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough2 = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform2();
  require_inherits()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  }
  var _require$codes = require_errors().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === undefined)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  module.exports = pipeline;
});

// node_modules/readable-stream/readable.js
var require_readable2 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable2();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable2();
    exports.Duplex = require__stream_duplex2();
    exports.Transform = require__stream_transform2();
    exports.PassThrough = require__stream_passthrough2();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/htmlparser2/lib/WritableStream.js
var require_WritableStream = __commonJS((exports, module) => {
  module.exports = Stream;
  var Parser = require_Parser();
  var WritableStream = require_readable2().Writable;
  var StringDecoder = __require("string_decoder").StringDecoder;
  var Buffer2 = __require("buffer").Buffer;
  function Stream(cbs, options) {
    var parser = this._parser = new Parser(cbs, options);
    var decoder = this._decoder = new StringDecoder;
    WritableStream.call(this, { decodeStrings: false });
    this.once("finish", function() {
      parser.end(decoder.end());
    });
  }
  require_inherits()(Stream, WritableStream);
  Stream.prototype._write = function(chunk, encoding, cb) {
    if (chunk instanceof Buffer2)
      chunk = this._decoder.write(chunk);
    this._parser.write(chunk);
    cb();
  };
});

// node_modules/htmlparser2/lib/Stream.js
var require_Stream = __commonJS((exports, module) => {
  module.exports = Stream;
  var Parser = require_WritableStream();
  function Stream(options) {
    Parser.call(this, new Cbs(this), options);
  }
  require_inherits()(Stream, Parser);
  Stream.prototype.readable = true;
  function Cbs(scope) {
    this.scope = scope;
  }
  var EVENTS = require_lib7().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      Cbs.prototype["on" + name] = function() {
        this.scope.emit(name);
      };
    } else if (EVENTS[name] === 1) {
      Cbs.prototype["on" + name] = function(a) {
        this.scope.emit(name, a);
      };
    } else if (EVENTS[name] === 2) {
      Cbs.prototype["on" + name] = function(a, b) {
        this.scope.emit(name, a, b);
      };
    } else {
      throw Error("wrong number of arguments!");
    }
  });
});

// node_modules/htmlparser2/lib/ProxyHandler.js
var require_ProxyHandler = __commonJS((exports, module) => {
  module.exports = ProxyHandler;
  function ProxyHandler(cbs) {
    this._cbs = cbs || {};
  }
  var EVENTS = require_lib7().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function() {
        if (this._cbs[name])
          this._cbs[name]();
      };
    } else if (EVENTS[name] === 1) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function(a) {
        if (this._cbs[name])
          this._cbs[name](a);
      };
    } else if (EVENTS[name] === 2) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function(a, b) {
        if (this._cbs[name])
          this._cbs[name](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
});

// node_modules/htmlparser2/lib/CollectingHandler.js
var require_CollectingHandler = __commonJS((exports, module) => {
  module.exports = CollectingHandler;
  function CollectingHandler(cbs) {
    this._cbs = cbs || {};
    this.events = [];
  }
  var EVENTS = require_lib7().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function() {
        this.events.push([name]);
        if (this._cbs[name])
          this._cbs[name]();
      };
    } else if (EVENTS[name] === 1) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function(a) {
        this.events.push([name, a]);
        if (this._cbs[name])
          this._cbs[name](a);
      };
    } else if (EVENTS[name] === 2) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function(a, b) {
        this.events.push([name, a, b]);
        if (this._cbs[name])
          this._cbs[name](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
  CollectingHandler.prototype.onreset = function() {
    this.events = [];
    if (this._cbs.onreset)
      this._cbs.onreset();
  };
  CollectingHandler.prototype.restart = function() {
    if (this._cbs.onreset)
      this._cbs.onreset();
    for (var i = 0, len = this.events.length;i < len; i++) {
      if (this._cbs[this.events[i][0]]) {
        var num = this.events[i].length;
        if (num === 1) {
          this._cbs[this.events[i][0]]();
        } else if (num === 2) {
          this._cbs[this.events[i][0]](this.events[i][1]);
        } else {
          this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
        }
      }
    }
  };
});

// node_modules/htmlparser2/lib/index.js
var require_lib7 = __commonJS((exports, module) => {
  var Parser = require_Parser();
  var DomHandler = require_domhandler();
  function defineProp(name, value) {
    delete module.exports[name];
    module.exports[name] = value;
    return value;
  }
  module.exports = {
    Parser,
    Tokenizer: require_Tokenizer(),
    ElementType: require_domelementtype(),
    DomHandler,
    get FeedHandler() {
      return defineProp("FeedHandler", require_FeedHandler());
    },
    get Stream() {
      return defineProp("Stream", require_Stream());
    },
    get WritableStream() {
      return defineProp("WritableStream", require_WritableStream());
    },
    get ProxyHandler() {
      return defineProp("ProxyHandler", require_ProxyHandler());
    },
    get DomUtils() {
      return defineProp("DomUtils", require_domutils());
    },
    get CollectingHandler() {
      return defineProp("CollectingHandler", require_CollectingHandler());
    },
    DefaultHandler: DomHandler,
    get RssHandler() {
      return defineProp("RssHandler", this.FeedHandler);
    },
    parseDOM: function(data, options) {
      var handler = new DomHandler(options);
      new Parser(handler, options).end(data);
      return handler.dom;
    },
    parseFeed: function(feed, options) {
      var handler = new module.exports.FeedHandler(options);
      new Parser(handler, options).end(feed);
      return handler.dom;
    },
    createDomStream: function(cb, options, elementCb) {
      var handler = new DomHandler(cb, options, elementCb);
      return new Parser(handler, options);
    },
    EVENTS: {
      attribute: 2,
      cdatastart: 0,
      cdataend: 0,
      text: 1,
      processinginstruction: 2,
      comment: 1,
      commentend: 0,
      closetag: 1,
      opentag: 2,
      opentagname: 1,
      error: 1,
      end: 0
    }
  };
});

// node_modules/html-to-vdom/lib/parse-html.js
var require_parse_html = __commonJS((exports, module) => {
  var htmlparser = require_lib7();
  var parseHTML = function parseHTML(html) {
    var handler = new htmlparser.DomHandler;
    var parser = new htmlparser.Parser(handler, {
      lowerCaseAttributeNames: false
    });
    parser.parseComplete(html);
    return handler.dom;
  };
  module.exports = parseHTML;
});

// node_modules/html-to-vdom/lib/html-to-vdom.js
var require_html_to_vdom = __commonJS((exports, module) => {
  var createConverter = require_htmlparser_to_vdom();
  var parseHTML = require_parse_html();
  module.exports = function initializeHtmlToVdom(VTree, VText) {
    var htmlparserToVdom = createConverter(VTree, VText);
    return function convertHTML(options, html) {
      var noOptions = typeof html === "undefined" && typeof options === "string";
      var hasOptions = !noOptions;
      var htmlToConvert = noOptions ? options : html;
      var getVNodeKey = hasOptions ? options.getVNodeKey : undefined;
      var tags = parseHTML(htmlToConvert);
      var convertedHTML;
      if (tags.length > 1) {
        convertedHTML = tags.map(function(tag) {
          return htmlparserToVdom.convert(tag, getVNodeKey);
        });
      } else {
        convertedHTML = htmlparserToVdom.convert(tags[0], getVNodeKey);
      }
      return convertedHTML;
    };
  };
});

// node_modules/html-to-vdom/index.js
var require_html_to_vdom2 = __commonJS((exports, module) => {
  var convertHTML = require_html_to_vdom();
  module.exports = function initializeConverter(dependencies) {
    if (!dependencies.VNode || !dependencies.VText) {
      throw new Error("html-to-vdom needs to be initialized with VNode and VText");
    }
    return convertHTML(dependencies.VNode, dependencies.VText);
  };
});

// node_modules/virtual-dom/vnode/version.js
var require_version = __commonJS((exports, module) => {
  module.exports = "2";
});

// node_modules/virtual-dom/vnode/is-vnode.js
var require_is_vnode = __commonJS((exports, module) => {
  var version = require_version();
  module.exports = isVirtualNode;
  function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version;
  }
});

// node_modules/virtual-dom/vnode/is-widget.js
var require_is_widget = __commonJS((exports, module) => {
  module.exports = isWidget;
  function isWidget(w) {
    return w && w.type === "Widget";
  }
});

// node_modules/virtual-dom/vnode/is-thunk.js
var require_is_thunk = __commonJS((exports, module) => {
  module.exports = isThunk;
  function isThunk(t) {
    return t && t.type === "Thunk";
  }
});

// node_modules/virtual-dom/vnode/is-vhook.js
var require_is_vhook = __commonJS((exports, module) => {
  module.exports = isHook;
  function isHook(hook) {
    return hook && (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") || typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"));
  }
});

// node_modules/virtual-dom/vnode/vnode.js
var require_vnode = __commonJS((exports, module) => {
  var version = require_version();
  var isVNode = require_is_vnode();
  var isWidget = require_is_widget();
  var isThunk = require_is_thunk();
  var isVHook = require_is_vhook();
  module.exports = VirtualNode;
  var noProperties = {};
  var noChildren = [];
  function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName;
    this.properties = properties || noProperties;
    this.children = children || noChildren;
    this.key = key != null ? String(key) : undefined;
    this.namespace = typeof namespace === "string" ? namespace : null;
    var count = children && children.length || 0;
    var descendants = 0;
    var hasWidgets = false;
    var hasThunks = false;
    var descendantHooks = false;
    var hooks;
    for (var propName in properties) {
      if (properties.hasOwnProperty(propName)) {
        var property = properties[propName];
        if (isVHook(property) && property.unhook) {
          if (!hooks) {
            hooks = {};
          }
          hooks[propName] = property;
        }
      }
    }
    for (var i = 0;i < count; i++) {
      var child = children[i];
      if (isVNode(child)) {
        descendants += child.count || 0;
        if (!hasWidgets && child.hasWidgets) {
          hasWidgets = true;
        }
        if (!hasThunks && child.hasThunks) {
          hasThunks = true;
        }
        if (!descendantHooks && (child.hooks || child.descendantHooks)) {
          descendantHooks = true;
        }
      } else if (!hasWidgets && isWidget(child)) {
        if (typeof child.destroy === "function") {
          hasWidgets = true;
        }
      } else if (!hasThunks && isThunk(child)) {
        hasThunks = true;
      }
    }
    this.count = count + descendants;
    this.hasWidgets = hasWidgets;
    this.hasThunks = hasThunks;
    this.hooks = hooks;
    this.descendantHooks = descendantHooks;
  }
  VirtualNode.prototype.version = version;
  VirtualNode.prototype.type = "VirtualNode";
});

// node_modules/virtual-dom/vnode/vtext.js
var require_vtext = __commonJS((exports, module) => {
  var version = require_version();
  module.exports = VirtualText;
  function VirtualText(text) {
    this.text = String(text);
  }
  VirtualText.prototype.version = version;
  VirtualText.prototype.type = "VirtualText";
});

// node_modules/xmlbuilder2/lib/interfaces.js
var require_interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultBuilderOptions = {
    version: "1.0",
    encoding: undefined,
    standalone: undefined,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    convert: {
      att: "@",
      ins: "?",
      text: "#",
      cdata: "$",
      comment: "!"
    },
    defaultNamespace: {
      ele: undefined,
      att: undefined
    },
    namespaceAlias: {
      html: "http://www.w3.org/1999/xhtml",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/",
      mathml: "http://www.w3.org/1998/Math/MathML",
      svg: "http://www.w3.org/2000/svg",
      xlink: "http://www.w3.org/1999/xlink"
    },
    invalidCharReplacement: undefined
  };
  exports.XMLBuilderOptionKeys = new Set(Object.keys(exports.DefaultBuilderOptions));
  exports.DefaultXMLBuilderCBOptions = {
    format: "xml",
    wellFormed: false,
    prettyPrint: false,
    indent: "  ",
    newline: `
`,
    offset: 0,
    width: 0,
    allowEmptyTags: false,
    spaceBeforeSlash: false,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    convert: {
      att: "@",
      ins: "?",
      text: "#",
      cdata: "$",
      comment: "!"
    },
    defaultNamespace: {
      ele: undefined,
      att: undefined
    },
    namespaceAlias: {
      html: "http://www.w3.org/1999/xhtml",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/",
      mathml: "http://www.w3.org/1998/Math/MathML",
      svg: "http://www.w3.org/2000/svg",
      xlink: "http://www.w3.org/1999/xlink"
    }
  };
});

// node_modules/@oozcitak/util/lib/FixedSizeSet.js
var require_FixedSizeSet = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var FixedSizeSet = function() {
    function FixedSizeSet2(limit) {
      if (limit === undefined) {
        limit = 1000;
      }
      this._items = new Set;
      this._limit = limit;
    }
    FixedSizeSet2.prototype.add = function(item) {
      this._items.add(item);
      if (this._items.size > this._limit) {
        var it_1 = this._items.values().next();
        if (!it_1.done) {
          this._items.delete(it_1.value);
        }
      }
      return this;
    };
    FixedSizeSet2.prototype.delete = function(item) {
      return this._items.delete(item);
    };
    FixedSizeSet2.prototype.has = function(item) {
      return this._items.has(item);
    };
    FixedSizeSet2.prototype.clear = function() {
      this._items.clear();
    };
    Object.defineProperty(FixedSizeSet2.prototype, "size", {
      get: function() {
        return this._items.size;
      },
      enumerable: true,
      configurable: true
    });
    FixedSizeSet2.prototype.forEach = function(callback, thisArg) {
      var _this = this;
      this._items.forEach(function(e) {
        return callback.call(thisArg, e, e, _this);
      });
    };
    FixedSizeSet2.prototype.keys = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [5, __values(this._items.keys())];
          case 1:
            _a.sent();
            return [2];
        }
      });
    };
    FixedSizeSet2.prototype.values = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [5, __values(this._items.values())];
          case 1:
            _a.sent();
            return [2];
        }
      });
    };
    FixedSizeSet2.prototype.entries = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [5, __values(this._items.entries())];
          case 1:
            _a.sent();
            return [2];
        }
      });
    };
    FixedSizeSet2.prototype[Symbol.iterator] = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [5, __values(this._items)];
          case 1:
            _a.sent();
            return [2];
        }
      });
    };
    Object.defineProperty(FixedSizeSet2.prototype, Symbol.toStringTag, {
      get: function() {
        return "FixedSizeSet";
      },
      enumerable: true,
      configurable: true
    });
    return FixedSizeSet2;
  }();
  exports.FixedSizeSet = FixedSizeSet;
});

// node_modules/@oozcitak/util/lib/ObjectCache.js
var require_ObjectCache = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ObjectCache = function() {
    function ObjectCache2(limit) {
      if (limit === undefined) {
        limit = 1000;
      }
      this._items = new Map;
      this._limit = limit;
    }
    ObjectCache2.prototype.get = function(key) {
      return this._items.get(key);
    };
    ObjectCache2.prototype.set = function(key, value) {
      this._items.set(key, value);
      if (this._items.size > this._limit) {
        var it_1 = this._items.keys().next();
        if (!it_1.done) {
          this._items.delete(it_1.value);
        }
      }
    };
    ObjectCache2.prototype.delete = function(key) {
      return this._items.delete(key);
    };
    ObjectCache2.prototype.has = function(key) {
      return this._items.has(key);
    };
    ObjectCache2.prototype.clear = function() {
      this._items.clear();
    };
    Object.defineProperty(ObjectCache2.prototype, "size", {
      get: function() {
        return this._items.size;
      },
      enumerable: true,
      configurable: true
    });
    ObjectCache2.prototype.forEach = function(callback, thisArg) {
      this._items.forEach(function(v, k) {
        return callback.call(thisArg, k, v);
      });
    };
    ObjectCache2.prototype.keys = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [5, __values(this._items.keys())];
          case 1:
            _a.sent();
            return [2];
        }
      });
    };
    ObjectCache2.prototype.values = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [5, __values(this._items.values())];
          case 1:
            _a.sent();
            return [2];
        }
      });
    };
    ObjectCache2.prototype.entries = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [5, __values(this._items.entries())];
          case 1:
            _a.sent();
            return [2];
        }
      });
    };
    ObjectCache2.prototype[Symbol.iterator] = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [5, __values(this._items)];
          case 1:
            _a.sent();
            return [2];
        }
      });
    };
    Object.defineProperty(ObjectCache2.prototype, Symbol.toStringTag, {
      get: function() {
        return "ObjectCache";
      },
      enumerable: true,
      configurable: true
    });
    return ObjectCache2;
  }();
  exports.ObjectCache = ObjectCache;
});

// node_modules/@oozcitak/util/lib/CompareCache.js
var require_CompareCache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CompareCache = function() {
    function CompareCache2(limit) {
      if (limit === undefined) {
        limit = 1000;
      }
      this._items = new Map;
      this._limit = limit;
    }
    CompareCache2.prototype.check = function(objA, objB) {
      if (this._items.get(objA) === objB)
        return true;
      else if (this._items.get(objB) === objA)
        return false;
      var result = Math.random() < 0.5;
      if (result) {
        this._items.set(objA, objB);
      } else {
        this._items.set(objB, objA);
      }
      if (this._items.size > this._limit) {
        var it_1 = this._items.keys().next();
        if (!it_1.done) {
          this._items.delete(it_1.value);
        }
      }
      return result;
    };
    return CompareCache2;
  }();
  exports.CompareCache = CompareCache;
});

// node_modules/@oozcitak/util/lib/Lazy.js
var require_Lazy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var Lazy = function() {
    function Lazy2(initFunc) {
      this._initialized = false;
      this._value = undefined;
      this._initFunc = initFunc;
    }
    Object.defineProperty(Lazy2.prototype, "value", {
      get: function() {
        if (!this._initialized) {
          this._value = this._initFunc();
          this._initialized = true;
        }
        return this._value;
      },
      enumerable: true,
      configurable: true
    });
    return Lazy2;
  }();
  exports.Lazy = Lazy;
});

// node_modules/@oozcitak/util/lib/StringWalker.js
var require_StringWalker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var StringWalker = function() {
    function StringWalker2(input) {
      this._pointer = 0;
      this._chars = Array.from(input);
      this._length = this._chars.length;
    }
    Object.defineProperty(StringWalker2.prototype, "eof", {
      get: function() {
        return this._pointer >= this._length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StringWalker2.prototype, "length", {
      get: function() {
        return this._length;
      },
      enumerable: true,
      configurable: true
    });
    StringWalker2.prototype.codePoint = function() {
      if (this._codePoint === undefined) {
        if (this.eof) {
          this._codePoint = -1;
        } else {
          var cp = this._chars[this._pointer].codePointAt(0);
          if (cp !== undefined) {
            this._codePoint = cp;
          } else {
            this._codePoint = -1;
          }
        }
      }
      return this._codePoint;
    };
    StringWalker2.prototype.c = function() {
      if (this._c === undefined) {
        this._c = this.eof ? "" : this._chars[this._pointer];
      }
      return this._c;
    };
    StringWalker2.prototype.remaining = function() {
      if (this._remaining === undefined) {
        this._remaining = this.eof ? "" : this._chars.slice(this._pointer + 1).join("");
      }
      return this._remaining;
    };
    StringWalker2.prototype.substring = function() {
      if (this._substring === undefined) {
        this._substring = this.eof ? "" : this._chars.slice(this._pointer).join("");
      }
      return this._substring;
    };
    Object.defineProperty(StringWalker2.prototype, "pointer", {
      get: function() {
        return this._pointer;
      },
      set: function(val) {
        if (val === this._pointer)
          return;
        this._pointer = val;
        this._codePoint = undefined;
        this._c = undefined;
        this._remaining = undefined;
        this._substring = undefined;
      },
      enumerable: true,
      configurable: true
    });
    return StringWalker2;
  }();
  exports.StringWalker = StringWalker;
});

// node_modules/@oozcitak/util/lib/index.js
var require_lib8 = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var FixedSizeSet_1 = require_FixedSizeSet();
  exports.FixedSizeSet = FixedSizeSet_1.FixedSizeSet;
  var ObjectCache_1 = require_ObjectCache();
  exports.ObjectCache = ObjectCache_1.ObjectCache;
  var CompareCache_1 = require_CompareCache();
  exports.CompareCache = CompareCache_1.CompareCache;
  var Lazy_1 = require_Lazy();
  exports.Lazy = Lazy_1.Lazy;
  var StringWalker_1 = require_StringWalker();
  exports.StringWalker = StringWalker_1.StringWalker;
  function applyMixin(baseClass, mixinClass) {
    var overrides = [];
    for (var _i = 2;_i < arguments.length; _i++) {
      overrides[_i - 2] = arguments[_i];
    }
    Object.getOwnPropertyNames(mixinClass.prototype).forEach(function(name) {
      if (name !== "constructor") {
        if (overrides.indexOf(name) !== -1) {
          var orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
          if (orgPropDesc) {
            Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
          }
        }
        var propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
        if (propDesc) {
          Object.defineProperty(baseClass.prototype, name, propDesc);
        }
      }
    });
  }
  exports.applyMixin = applyMixin;
  function applyDefaults(obj, defaults, overwrite) {
    if (overwrite === undefined) {
      overwrite = false;
    }
    var result = clone(obj || {});
    forEachObject(defaults, function(key, val) {
      if (isPlainObject(val)) {
        result[key] = applyDefaults(result[key], val, overwrite);
      } else if (overwrite || result[key] === undefined) {
        result[key] = val;
      }
    });
    return result;
  }
  exports.applyDefaults = applyDefaults;
  function forEachArray(arr, callback, thisArg) {
    arr.forEach(callback, thisArg);
  }
  exports.forEachArray = forEachArray;
  function forEachObject(obj, callback, thisArg) {
    if (isMap(obj)) {
      obj.forEach(function(value, key2) {
        return callback.call(thisArg, key2, value);
      });
    } else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          callback.call(thisArg, key, obj[key]);
        }
      }
    }
  }
  exports.forEachObject = forEachObject;
  function arrayLength(obj) {
    if (isSet(obj)) {
      return obj.size;
    } else {
      return obj.length;
    }
  }
  exports.arrayLength = arrayLength;
  function objectLength(obj) {
    if (isMap(obj)) {
      return obj.size;
    } else {
      return Object.keys(obj).length;
    }
  }
  exports.objectLength = objectLength;
  function getObjectValue(obj, key) {
    if (isMap(obj)) {
      return obj.get(key);
    } else {
      return obj[key];
    }
  }
  exports.getObjectValue = getObjectValue;
  function removeObjectValue(obj, key) {
    if (isMap(obj)) {
      obj.delete(key);
    } else {
      delete obj[key];
    }
  }
  exports.removeObjectValue = removeObjectValue;
  function clone(obj) {
    var e_1, _a;
    if (isFunction(obj)) {
      return obj;
    } else if (isArray(obj)) {
      var result = [];
      try {
        for (var obj_1 = __values(obj), obj_1_1 = obj_1.next();!obj_1_1.done; obj_1_1 = obj_1.next()) {
          var item = obj_1_1.value;
          result.push(clone(item));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return))
            _a.call(obj_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result;
    } else if (isObject(obj)) {
      var result = {};
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          var val = obj[key];
          result[key] = clone(val);
        }
      }
      return result;
    } else {
      return obj;
    }
  }
  exports.clone = clone;
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNumber(x) {
    return typeof x === "number";
  }
  exports.isNumber = isNumber;
  function isString(x) {
    return typeof x === "string";
  }
  exports.isString = isString;
  function isFunction(x) {
    return !!x && Object.prototype.toString.call(x) === "[object Function]";
  }
  exports.isFunction = isFunction;
  function isObject(x) {
    var type = typeof x;
    return !!x && (type === "function" || type === "object");
  }
  exports.isObject = isObject;
  function isArray(x) {
    return Array.isArray(x);
  }
  exports.isArray = isArray;
  function isSet(x) {
    return x instanceof Set;
  }
  exports.isSet = isSet;
  function isMap(x) {
    return x instanceof Map;
  }
  exports.isMap = isMap;
  function isEmpty(x) {
    if (isArray(x)) {
      return !x.length;
    } else if (isSet(x)) {
      return !x.size;
    } else if (isMap(x)) {
      return !x.size;
    } else if (isObject(x)) {
      for (var key in x) {
        if (x.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  exports.isEmpty = isEmpty;
  function isPlainObject(x) {
    if (isObject(x)) {
      var proto = Object.getPrototypeOf(x);
      var ctor = proto.constructor;
      return proto && ctor && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    }
    return false;
  }
  exports.isPlainObject = isPlainObject;
  function isIterable(x) {
    return x && typeof x[Symbol.iterator] === "function";
  }
  exports.isIterable = isIterable;
  function getValue(obj) {
    if (isFunction(obj.valueOf)) {
      return obj.valueOf();
    } else {
      return obj;
    }
  }
  exports.getValue = getValue;
  function utf8Encode(input) {
    var bytes = new Uint8Array(input.length * 4);
    var byteIndex = 0;
    for (var i = 0;i < input.length; i++) {
      var char = input.charCodeAt(i);
      if (char < 128) {
        bytes[byteIndex++] = char;
        continue;
      } else if (char < 2048) {
        bytes[byteIndex++] = char >> 6 | 192;
      } else {
        if (char > 55295 && char < 56320) {
          if (++i >= input.length) {
            throw new Error("Incomplete surrogate pair.");
          }
          var c2 = input.charCodeAt(i);
          if (c2 < 56320 || c2 > 57343) {
            throw new Error("Invalid surrogate character.");
          }
          char = 65536 + ((char & 1023) << 10) + (c2 & 1023);
          bytes[byteIndex++] = char >> 18 | 240;
          bytes[byteIndex++] = char >> 12 & 63 | 128;
        } else {
          bytes[byteIndex++] = char >> 12 | 224;
        }
        bytes[byteIndex++] = char >> 6 & 63 | 128;
      }
      bytes[byteIndex++] = char & 63 | 128;
    }
    return bytes.subarray(0, byteIndex);
  }
  exports.utf8Encode = utf8Encode;
  function utf8Decode(bytes) {
    var result = "";
    var i = 0;
    while (i < bytes.length) {
      var c = bytes[i++];
      if (c > 127) {
        if (c > 191 && c < 224) {
          if (i >= bytes.length) {
            throw new Error("Incomplete 2-byte sequence.");
          }
          c = (c & 31) << 6 | bytes[i++] & 63;
        } else if (c > 223 && c < 240) {
          if (i + 1 >= bytes.length) {
            throw new Error("Incomplete 3-byte sequence.");
          }
          c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else if (c > 239 && c < 248) {
          if (i + 2 >= bytes.length) {
            throw new Error("Incomplete 4-byte sequence.");
          }
          c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else {
          throw new Error("Unknown multi-byte start.");
        }
      }
      if (c <= 65535) {
        result += String.fromCharCode(c);
      } else if (c <= 1114111) {
        c -= 65536;
        result += String.fromCharCode(c >> 10 | 55296);
        result += String.fromCharCode(c & 1023 | 56320);
      } else {
        throw new Error("Code point exceeds UTF-16 limit.");
      }
    }
    return result;
  }
  exports.utf8Decode = utf8Decode;
});

// node_modules/@oozcitak/dom/lib/dom/interfaces.js
var require_interfaces2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var BoundaryPosition;
  (function(BoundaryPosition2) {
    BoundaryPosition2[BoundaryPosition2["Before"] = 0] = "Before";
    BoundaryPosition2[BoundaryPosition2["Equal"] = 1] = "Equal";
    BoundaryPosition2[BoundaryPosition2["After"] = 2] = "After";
  })(BoundaryPosition = exports.BoundaryPosition || (exports.BoundaryPosition = {}));
  var EventPhase;
  (function(EventPhase2) {
    EventPhase2[EventPhase2["None"] = 0] = "None";
    EventPhase2[EventPhase2["Capturing"] = 1] = "Capturing";
    EventPhase2[EventPhase2["AtTarget"] = 2] = "AtTarget";
    EventPhase2[EventPhase2["Bubbling"] = 3] = "Bubbling";
  })(EventPhase = exports.EventPhase || (exports.EventPhase = {}));
  var NodeType;
  (function(NodeType2) {
    NodeType2[NodeType2["Element"] = 1] = "Element";
    NodeType2[NodeType2["Attribute"] = 2] = "Attribute";
    NodeType2[NodeType2["Text"] = 3] = "Text";
    NodeType2[NodeType2["CData"] = 4] = "CData";
    NodeType2[NodeType2["EntityReference"] = 5] = "EntityReference";
    NodeType2[NodeType2["Entity"] = 6] = "Entity";
    NodeType2[NodeType2["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    NodeType2[NodeType2["Comment"] = 8] = "Comment";
    NodeType2[NodeType2["Document"] = 9] = "Document";
    NodeType2[NodeType2["DocumentType"] = 10] = "DocumentType";
    NodeType2[NodeType2["DocumentFragment"] = 11] = "DocumentFragment";
    NodeType2[NodeType2["Notation"] = 12] = "Notation";
  })(NodeType = exports.NodeType || (exports.NodeType = {}));
  var Position;
  (function(Position2) {
    Position2[Position2["Disconnected"] = 1] = "Disconnected";
    Position2[Position2["Preceding"] = 2] = "Preceding";
    Position2[Position2["Following"] = 4] = "Following";
    Position2[Position2["Contains"] = 8] = "Contains";
    Position2[Position2["ContainedBy"] = 16] = "ContainedBy";
    Position2[Position2["ImplementationSpecific"] = 32] = "ImplementationSpecific";
  })(Position = exports.Position || (exports.Position = {}));
  var FilterResult;
  (function(FilterResult2) {
    FilterResult2[FilterResult2["Accept"] = 1] = "Accept";
    FilterResult2[FilterResult2["Reject"] = 2] = "Reject";
    FilterResult2[FilterResult2["Skip"] = 3] = "Skip";
  })(FilterResult = exports.FilterResult || (exports.FilterResult = {}));
  var WhatToShow;
  (function(WhatToShow2) {
    WhatToShow2[WhatToShow2["All"] = 4294967295] = "All";
    WhatToShow2[WhatToShow2["Element"] = 1] = "Element";
    WhatToShow2[WhatToShow2["Attribute"] = 2] = "Attribute";
    WhatToShow2[WhatToShow2["Text"] = 4] = "Text";
    WhatToShow2[WhatToShow2["CDataSection"] = 8] = "CDataSection";
    WhatToShow2[WhatToShow2["EntityReference"] = 16] = "EntityReference";
    WhatToShow2[WhatToShow2["Entity"] = 32] = "Entity";
    WhatToShow2[WhatToShow2["ProcessingInstruction"] = 64] = "ProcessingInstruction";
    WhatToShow2[WhatToShow2["Comment"] = 128] = "Comment";
    WhatToShow2[WhatToShow2["Document"] = 256] = "Document";
    WhatToShow2[WhatToShow2["DocumentType"] = 512] = "DocumentType";
    WhatToShow2[WhatToShow2["DocumentFragment"] = 1024] = "DocumentFragment";
    WhatToShow2[WhatToShow2["Notation"] = 2048] = "Notation";
  })(WhatToShow = exports.WhatToShow || (exports.WhatToShow = {}));
  var HowToCompare;
  (function(HowToCompare2) {
    HowToCompare2[HowToCompare2["StartToStart"] = 0] = "StartToStart";
    HowToCompare2[HowToCompare2["StartToEnd"] = 1] = "StartToEnd";
    HowToCompare2[HowToCompare2["EndToEnd"] = 2] = "EndToEnd";
    HowToCompare2[HowToCompare2["EndToStart"] = 3] = "EndToStart";
  })(HowToCompare = exports.HowToCompare || (exports.HowToCompare = {}));
});

// node_modules/@oozcitak/dom/lib/util/Guard.js
var require_Guard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var Guard = function() {
    function Guard2() {
    }
    Guard2.isNode = function(a) {
      return !!a && a._nodeType !== undefined;
    };
    Guard2.isDocumentNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Document;
    };
    Guard2.isDocumentTypeNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentType;
    };
    Guard2.isDocumentFragmentNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentFragment;
    };
    Guard2.isAttrNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Attribute;
    };
    Guard2.isCharacterDataNode = function(a) {
      if (!Guard2.isNode(a))
        return false;
      var type = a._nodeType;
      return type === interfaces_1.NodeType.Text || type === interfaces_1.NodeType.ProcessingInstruction || type === interfaces_1.NodeType.Comment || type === interfaces_1.NodeType.CData;
    };
    Guard2.isTextNode = function(a) {
      return Guard2.isNode(a) && (a._nodeType === interfaces_1.NodeType.Text || a._nodeType === interfaces_1.NodeType.CData);
    };
    Guard2.isExclusiveTextNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Text;
    };
    Guard2.isCDATASectionNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.CData;
    };
    Guard2.isCommentNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Comment;
    };
    Guard2.isProcessingInstructionNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.ProcessingInstruction;
    };
    Guard2.isElementNode = function(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Element;
    };
    Guard2.isCustomElementNode = function(a) {
      return Guard2.isElementNode(a) && a._customElementState === "custom";
    };
    Guard2.isShadowRoot = function(a) {
      return !!a && a.host !== undefined;
    };
    Guard2.isMouseEvent = function(a) {
      return !!a && a.screenX !== undefined && a.screenY != null;
    };
    Guard2.isSlotable = function(a) {
      return !!a && a._name !== undefined && a._assignedSlot !== undefined && (Guard2.isTextNode(a) || Guard2.isElementNode(a));
    };
    Guard2.isSlot = function(a) {
      return !!a && a._name !== undefined && a._assignedNodes !== undefined && Guard2.isElementNode(a);
    };
    Guard2.isWindow = function(a) {
      return !!a && a.navigator !== undefined;
    };
    Guard2.isEventListener = function(a) {
      return !!a && a.handleEvent !== undefined;
    };
    Guard2.isRegisteredObserver = function(a) {
      return !!a && a.observer !== undefined && a.options !== undefined;
    };
    Guard2.isTransientRegisteredObserver = function(a) {
      return !!a && a.source !== undefined && Guard2.isRegisteredObserver(a);
    };
    return Guard2;
  }();
  exports.Guard = Guard;
});

// node_modules/@oozcitak/dom/lib/util/Cast.js
var require_Cast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var Guard_1 = require_Guard();
  var Cast = function() {
    function Cast2() {
    }
    Cast2.asNode = function(a) {
      if (Guard_1.Guard.isNode(a)) {
        return a;
      } else {
        throw new Error("Invalid object. Node expected.");
      }
    };
    return Cast2;
  }();
  exports.Cast = Cast;
});

// node_modules/@oozcitak/dom/lib/util/EmptySet.js
var require_EmptySet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var EmptySet = function() {
    function EmptySet2() {
    }
    Object.defineProperty(EmptySet2.prototype, "size", {
      get: function() {
        return 0;
      },
      enumerable: true,
      configurable: true
    });
    EmptySet2.prototype.add = function(value) {
      throw new Error("Cannot add to an empty set.");
    };
    EmptySet2.prototype.clear = function() {
    };
    EmptySet2.prototype.delete = function(value) {
      return false;
    };
    EmptySet2.prototype.forEach = function(callbackfn, thisArg) {
    };
    EmptySet2.prototype.has = function(value) {
      return false;
    };
    EmptySet2.prototype[Symbol.iterator] = function() {
      return new EmptySetIterator;
    };
    EmptySet2.prototype.entries = function() {
      return new EmptySetIterator;
    };
    EmptySet2.prototype.keys = function() {
      return new EmptySetIterator;
    };
    EmptySet2.prototype.values = function() {
      return new EmptySetIterator;
    };
    Object.defineProperty(EmptySet2.prototype, Symbol.toStringTag, {
      get: function() {
        return "EmptySet";
      },
      enumerable: true,
      configurable: true
    });
    return EmptySet2;
  }();
  exports.EmptySet = EmptySet;
  var EmptySetIterator = function() {
    function EmptySetIterator2() {
    }
    EmptySetIterator2.prototype[Symbol.iterator] = function() {
      return this;
    };
    EmptySetIterator2.prototype.next = function() {
      return { done: true, value: null };
    };
    return EmptySetIterator2;
  }();
});

// node_modules/@oozcitak/dom/lib/util/index.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var Cast_1 = require_Cast();
  exports.Cast = Cast_1.Cast;
  var Guard_1 = require_Guard();
  exports.Guard = Guard_1.Guard;
  var EmptySet_1 = require_EmptySet();
  exports.EmptySet = EmptySet_1.EmptySet;
});

// node_modules/@oozcitak/dom/lib/serializer/LocalNameSet.js
var require_LocalNameSet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var LocalNameSet = function() {
    function LocalNameSet2() {
      this._items = {};
      this._nullItems = {};
    }
    LocalNameSet2.prototype.set = function(ns, localName) {
      if (ns === null) {
        this._nullItems[localName] = true;
      } else if (this._items[ns]) {
        this._items[ns][localName] = true;
      } else {
        this._items[ns] = {};
        this._items[ns][localName] = true;
      }
    };
    LocalNameSet2.prototype.has = function(ns, localName) {
      if (ns === null) {
        return this._nullItems[localName] === true;
      } else if (this._items[ns]) {
        return this._items[ns][localName] === true;
      } else {
        return false;
      }
    };
    return LocalNameSet2;
  }();
  exports.LocalNameSet = LocalNameSet;
});

// node_modules/@oozcitak/dom/lib/serializer/NamespacePrefixMap.js
var require_NamespacePrefixMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var NamespacePrefixMap = function() {
    function NamespacePrefixMap2() {
      this._items = {};
      this._nullItems = [];
    }
    NamespacePrefixMap2.prototype.copy = function() {
      var mapCopy = new NamespacePrefixMap2;
      for (var key in this._items) {
        mapCopy._items[key] = this._items[key].slice(0);
      }
      mapCopy._nullItems = this._nullItems.slice(0);
      return mapCopy;
    };
    NamespacePrefixMap2.prototype.get = function(preferredPrefix, ns) {
      var candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (candidatesList === null) {
        return null;
      }
      var prefix = null;
      for (var i = 0;i < candidatesList.length; i++) {
        prefix = candidatesList[i];
        if (prefix === preferredPrefix) {
          return prefix;
        }
      }
      return prefix;
    };
    NamespacePrefixMap2.prototype.has = function(prefix, ns) {
      var candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (candidatesList === null) {
        return false;
      }
      return candidatesList.indexOf(prefix) !== -1;
    };
    NamespacePrefixMap2.prototype.hasPrefix = function(prefix) {
      if (this._nullItems.indexOf(prefix) !== -1)
        return true;
      for (var key in this._items) {
        if (this._items[key].indexOf(prefix) !== -1)
          return true;
      }
      return false;
    };
    NamespacePrefixMap2.prototype.set = function(prefix, ns) {
      var candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (ns !== null && candidatesList === null) {
        this._items[ns] = [prefix];
      } else {
        candidatesList.push(prefix);
      }
    };
    return NamespacePrefixMap2;
  }();
  exports.NamespacePrefixMap = NamespacePrefixMap;
});

// node_modules/@oozcitak/dom/lib/dom/DOMException.js
var require_DOMException = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMException = function(_super) {
    __extends(DOMException2, _super);
    function DOMException2(name, message) {
      if (message === undefined) {
        message = "";
      }
      var _this = _super.call(this, message) || this;
      _this.name = name;
      return _this;
    }
    return DOMException2;
  }(Error);
  exports.DOMException = DOMException;
  var DOMStringSizeError = function(_super) {
    __extends(DOMStringSizeError2, _super);
    function DOMStringSizeError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "DOMStringSizeError", message) || this;
    }
    return DOMStringSizeError2;
  }(DOMException);
  exports.DOMStringSizeError = DOMStringSizeError;
  var WrongDocumentError = function(_super) {
    __extends(WrongDocumentError2, _super);
    function WrongDocumentError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "WrongDocumentError", "The object is in the wrong document. " + message) || this;
    }
    return WrongDocumentError2;
  }(DOMException);
  exports.WrongDocumentError = WrongDocumentError;
  var NoDataAllowedError = function(_super) {
    __extends(NoDataAllowedError2, _super);
    function NoDataAllowedError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "NoDataAllowedError", message) || this;
    }
    return NoDataAllowedError2;
  }(DOMException);
  exports.NoDataAllowedError = NoDataAllowedError;
  var NoModificationAllowedError = function(_super) {
    __extends(NoModificationAllowedError2, _super);
    function NoModificationAllowedError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "NoModificationAllowedError", "The object can not be modified. " + message) || this;
    }
    return NoModificationAllowedError2;
  }(DOMException);
  exports.NoModificationAllowedError = NoModificationAllowedError;
  var NotSupportedError = function(_super) {
    __extends(NotSupportedError2, _super);
    function NotSupportedError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "NotSupportedError", "The operation is not supported. " + message) || this;
    }
    return NotSupportedError2;
  }(DOMException);
  exports.NotSupportedError = NotSupportedError;
  var InUseAttributeError = function(_super) {
    __extends(InUseAttributeError2, _super);
    function InUseAttributeError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "InUseAttributeError", message) || this;
    }
    return InUseAttributeError2;
  }(DOMException);
  exports.InUseAttributeError = InUseAttributeError;
  var InvalidStateError = function(_super) {
    __extends(InvalidStateError2, _super);
    function InvalidStateError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "InvalidStateError", "The object is in an invalid state. " + message) || this;
    }
    return InvalidStateError2;
  }(DOMException);
  exports.InvalidStateError = InvalidStateError;
  var InvalidModificationError = function(_super) {
    __extends(InvalidModificationError2, _super);
    function InvalidModificationError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "InvalidModificationError", "The object can not be modified in this way. " + message) || this;
    }
    return InvalidModificationError2;
  }(DOMException);
  exports.InvalidModificationError = InvalidModificationError;
  var NamespaceError = function(_super) {
    __extends(NamespaceError2, _super);
    function NamespaceError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + message) || this;
    }
    return NamespaceError2;
  }(DOMException);
  exports.NamespaceError = NamespaceError;
  var InvalidAccessError = function(_super) {
    __extends(InvalidAccessError2, _super);
    function InvalidAccessError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "InvalidAccessError", "The object does not support the operation or argument. " + message) || this;
    }
    return InvalidAccessError2;
  }(DOMException);
  exports.InvalidAccessError = InvalidAccessError;
  var ValidationError = function(_super) {
    __extends(ValidationError2, _super);
    function ValidationError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "ValidationError", message) || this;
    }
    return ValidationError2;
  }(DOMException);
  exports.ValidationError = ValidationError;
  var TypeMismatchError = function(_super) {
    __extends(TypeMismatchError2, _super);
    function TypeMismatchError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "TypeMismatchError", message) || this;
    }
    return TypeMismatchError2;
  }(DOMException);
  exports.TypeMismatchError = TypeMismatchError;
  var SecurityError = function(_super) {
    __extends(SecurityError2, _super);
    function SecurityError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "SecurityError", "The operation is insecure. " + message) || this;
    }
    return SecurityError2;
  }(DOMException);
  exports.SecurityError = SecurityError;
  var NetworkError = function(_super) {
    __extends(NetworkError2, _super);
    function NetworkError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "NetworkError", "A network error occurred. " + message) || this;
    }
    return NetworkError2;
  }(DOMException);
  exports.NetworkError = NetworkError;
  var AbortError = function(_super) {
    __extends(AbortError2, _super);
    function AbortError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "AbortError", "The operation was aborted. " + message) || this;
    }
    return AbortError2;
  }(DOMException);
  exports.AbortError = AbortError;
  var URLMismatchError = function(_super) {
    __extends(URLMismatchError2, _super);
    function URLMismatchError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "URLMismatchError", "The given URL does not match another URL. " + message) || this;
    }
    return URLMismatchError2;
  }(DOMException);
  exports.URLMismatchError = URLMismatchError;
  var QuotaExceededError = function(_super) {
    __extends(QuotaExceededError2, _super);
    function QuotaExceededError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "QuotaExceededError", "The quota has been exceeded. " + message) || this;
    }
    return QuotaExceededError2;
  }(DOMException);
  exports.QuotaExceededError = QuotaExceededError;
  var TimeoutError = function(_super) {
    __extends(TimeoutError2, _super);
    function TimeoutError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "TimeoutError", "The operation timed out. " + message) || this;
    }
    return TimeoutError2;
  }(DOMException);
  exports.TimeoutError = TimeoutError;
  var InvalidNodeTypeError = function(_super) {
    __extends(InvalidNodeTypeError2, _super);
    function InvalidNodeTypeError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + message) || this;
    }
    return InvalidNodeTypeError2;
  }(DOMException);
  exports.InvalidNodeTypeError = InvalidNodeTypeError;
  var DataCloneError = function(_super) {
    __extends(DataCloneError2, _super);
    function DataCloneError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "DataCloneError", "The object can not be cloned. " + message) || this;
    }
    return DataCloneError2;
  }(DOMException);
  exports.DataCloneError = DataCloneError;
  var NotImplementedError = function(_super) {
    __extends(NotImplementedError2, _super);
    function NotImplementedError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "NotImplementedError", "The DOM method is not implemented by this module. " + message) || this;
    }
    return NotImplementedError2;
  }(DOMException);
  exports.NotImplementedError = NotImplementedError;
  var HierarchyRequestError = function(_super) {
    __extends(HierarchyRequestError2, _super);
    function HierarchyRequestError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "HierarchyRequestError", "The operation would yield an incorrect node tree. " + message) || this;
    }
    return HierarchyRequestError2;
  }(DOMException);
  exports.HierarchyRequestError = HierarchyRequestError;
  var NotFoundError = function(_super) {
    __extends(NotFoundError2, _super);
    function NotFoundError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "NotFoundError", "The object can not be found here. " + message) || this;
    }
    return NotFoundError2;
  }(DOMException);
  exports.NotFoundError = NotFoundError;
  var IndexSizeError = function(_super) {
    __extends(IndexSizeError2, _super);
    function IndexSizeError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "IndexSizeError", "The index is not in the allowed range. " + message) || this;
    }
    return IndexSizeError2;
  }(DOMException);
  exports.IndexSizeError = IndexSizeError;
  var SyntaxError2 = function(_super) {
    __extends(SyntaxError3, _super);
    function SyntaxError3(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "SyntaxError", "The string did not match the expected pattern. " + message) || this;
    }
    return SyntaxError3;
  }(DOMException);
  exports.SyntaxError = SyntaxError2;
  var InvalidCharacterError = function(_super) {
    __extends(InvalidCharacterError2, _super);
    function InvalidCharacterError2(message) {
      if (message === undefined) {
        message = "";
      }
      return _super.call(this, "InvalidCharacterError", "The string contains invalid characters. " + message) || this;
    }
    return InvalidCharacterError2;
  }(DOMException);
  exports.InvalidCharacterError = InvalidCharacterError;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/CodePoints.js
var require_CodePoints = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Surrogate = /[\uD800-\uDFFF]/;
  exports.ScalarValue = /[\uD800-\uDFFF]/;
  exports.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
  exports.ASCIICodePoint = /[\u0000-\u007F]/;
  exports.ASCIITabOrNewLine = /[\t\n\r]/;
  exports.ASCIIWhiteSpace = /[\t\n\f\r ]/;
  exports.C0Control = /[\u0000-\u001F]/;
  exports.C0ControlOrSpace = /[\u0000-\u001F ]/;
  exports.Control = /[\u0000-\u001F\u007F-\u009F]/;
  exports.ASCIIDigit = /[0-9]/;
  exports.ASCIIUpperHexDigit = /[0-9A-F]/;
  exports.ASCIILowerHexDigit = /[0-9a-f]/;
  exports.ASCIIHexDigit = /[0-9A-Fa-f]/;
  exports.ASCIIUpperAlpha = /[A-Z]/;
  exports.ASCIILowerAlpha = /[a-z]/;
  exports.ASCIIAlpha = /[A-Za-z]/;
  exports.ASCIIAlphanumeric = /[0-9A-Za-z]/;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/Base64.js
var require_Base64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CodePoints_1 = require_CodePoints();
  function forgivingBase64Encode(input) {
    return Buffer.from(input).toString("base64");
  }
  exports.forgivingBase64Encode = forgivingBase64Encode;
  function forgivingBase64Decode(input) {
    if (input === "")
      return "";
    input = input.replace(CodePoints_1.ASCIIWhiteSpace, "");
    if (input.length % 4 === 0) {
      if (input.endsWith("==")) {
        input = input.substr(0, input.length - 2);
      } else if (input.endsWith("=")) {
        input = input.substr(0, input.length - 1);
      }
    }
    if (input.length % 4 === 1)
      return null;
    if (!/[0-9A-Za-z+/]/.test(input))
      return null;
    return Buffer.from(input, "base64").toString("utf8");
  }
  exports.forgivingBase64Decode = forgivingBase64Decode;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/Byte.js
var require_Byte = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function isASCIIByte(byte) {
    return byte >= 0 && byte <= 127;
  }
  exports.isASCIIByte = isASCIIByte;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/ByteSequence.js
var require_ByteSequence = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function length(list) {
    return list.length;
  }
  exports.length = length;
  function byteLowercase(list) {
    for (let i = 0;i < list.length; i++) {
      const c = list[i];
      if (c >= 65 && c <= 90) {
        list[i] = c + 32;
      }
    }
  }
  exports.byteLowercase = byteLowercase;
  function byteUppercase(list) {
    for (let i = 0;i < list.length; i++) {
      const c = list[i];
      if (c >= 97 && c <= 122) {
        list[i] = c - 32;
      }
    }
  }
  exports.byteUppercase = byteUppercase;
  function byteCaseInsensitiveMatch(listA, listB) {
    if (listA.length !== listB.length)
      return false;
    for (let i = 0;i < listA.length; i++) {
      let a = listA[i];
      let b = listB[i];
      if (a >= 65 && a <= 90)
        a += 32;
      if (b >= 65 && b <= 90)
        b += 32;
      if (a !== b)
        return false;
    }
    return true;
  }
  exports.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
  function startsWith(listA, listB) {
    let i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      if (listA[i] !== listB[i])
        return false;
      i++;
    }
  }
  exports.startsWith = startsWith;
  function byteLessThan(listA, listB) {
    let i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      const a = listA[i];
      const b = listB[i];
      if (a < b)
        return true;
      else if (a > b)
        return false;
      i++;
    }
  }
  exports.byteLessThan = byteLessThan;
  function isomorphicDecode(list) {
    return String.fromCodePoint(...list);
  }
  exports.isomorphicDecode = isomorphicDecode;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/JSON.js
var require_JSON = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function parseJSONFromBytes(bytes) {
    const jsonText = util_1.utf8Decode(bytes);
    return JSON.parse.call(undefined, jsonText);
  }
  exports.parseJSONFromBytes = parseJSONFromBytes;
  function serializeJSONToBytes(value) {
    const jsonString = JSON.stringify.call(undefined, value);
    return util_1.utf8Encode(jsonString);
  }
  exports.serializeJSONToBytes = serializeJSONToBytes;
  function parseJSONIntoInfraValues(jsonText) {
    const jsValue = JSON.parse.call(undefined, jsonText);
    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
  }
  exports.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
  function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
    if (jsValue === null || util_1.isString(jsValue) || util_1.isNumber(jsValue))
      return jsValue;
    if (util_1.isArray(jsValue)) {
      const result = new Array;
      for (const jsValueAtIndex of jsValue) {
        result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
      }
      return result;
    } else if (util_1.isObject(jsValue)) {
      const result = new Map;
      for (const key in jsValue) {
        if (jsValue.hasOwnProperty(key)) {
          const jsValueAtKey = jsValue[key];
          result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
        }
      }
      return result;
    }
    return jsValue;
  }
  exports.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/List.js
var require_List = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function append(list, item) {
    list.push(item);
  }
  exports.append = append;
  function extend(listA, listB) {
    listA.push(...listB);
  }
  exports.extend = extend;
  function prepend(list, item) {
    list.unshift(item);
  }
  exports.prepend = prepend;
  function replace(list, conditionOrItem, newItem) {
    let i = 0;
    for (const oldItem of list) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list[i] = newItem;
        }
      } else if (oldItem === conditionOrItem) {
        list[i] = newItem;
        return;
      }
      i++;
    }
  }
  exports.replace = replace;
  function insert(list, item, index) {
    list.splice(index, 0, item);
  }
  exports.insert = insert;
  function remove(list, conditionOrItem) {
    let i = list.length;
    while (i--) {
      const oldItem = list[i];
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list.splice(i, 1);
        }
      } else if (oldItem === conditionOrItem) {
        list.splice(i, 1);
        return;
      }
    }
  }
  exports.remove = remove;
  function empty(list) {
    list.length = 0;
  }
  exports.empty = empty;
  function contains(list, conditionOrItem) {
    for (const oldItem of list) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          return true;
        }
      } else if (oldItem === conditionOrItem) {
        return true;
      }
    }
    return false;
  }
  exports.contains = contains;
  function size(list, condition) {
    if (condition === undefined) {
      return list.length;
    } else {
      let count = 0;
      for (const item of list) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  exports.size = size;
  function isEmpty(list) {
    return list.length === 0;
  }
  exports.isEmpty = isEmpty;
  function* forEach(list, condition) {
    if (condition === undefined) {
      yield* list;
    } else {
      for (const item of list) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  exports.forEach = forEach;
  function clone(list) {
    return new Array(...list);
  }
  exports.clone = clone;
  function sortInAscendingOrder(list, lessThanAlgo) {
    return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
  }
  exports.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(list, lessThanAlgo) {
    return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
  }
  exports.sortInDescendingOrder = sortInDescendingOrder;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/Map.js
var require_Map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function get(map, key) {
    return map.get(key);
  }
  exports.get = get;
  function set(map, key, val) {
    map.set(key, val);
  }
  exports.set = set;
  function remove(map, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      map.delete(conditionOrItem);
    } else {
      const toRemove = [];
      for (const item of map) {
        if (!!conditionOrItem.call(null, item)) {
          toRemove.push(item[0]);
        }
      }
      for (const key of toRemove) {
        map.delete(key);
      }
    }
  }
  exports.remove = remove;
  function contains(map, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      return map.has(conditionOrItem);
    } else {
      for (const item of map) {
        if (!!conditionOrItem.call(null, item)) {
          return true;
        }
      }
      return false;
    }
  }
  exports.contains = contains;
  function keys(map) {
    return new Set(map.keys());
  }
  exports.keys = keys;
  function values(map) {
    return [...map.values()];
  }
  exports.values = values;
  function size(map, condition) {
    if (condition === undefined) {
      return map.size;
    } else {
      let count = 0;
      for (const item of map) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  exports.size = size;
  function isEmpty(map) {
    return map.size === 0;
  }
  exports.isEmpty = isEmpty;
  function* forEach(map, condition) {
    if (condition === undefined) {
      yield* map;
    } else {
      for (const item of map) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  exports.forEach = forEach;
  function clone(map) {
    return new Map(map);
  }
  exports.clone = clone;
  function sortInAscendingOrder(map, lessThanAlgo) {
    const list = new Array(...map);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
    return new Map(list);
  }
  exports.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(map, lessThanAlgo) {
    const list = new Array(...map);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
    return new Map(list);
  }
  exports.sortInDescendingOrder = sortInDescendingOrder;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/Namespace.js
var require_Namespace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTML = "http://www.w3.org/1999/xhtml";
  exports.XML = "http://www.w3.org/XML/1998/namespace";
  exports.XMLNS = "http://www.w3.org/2000/xmlns/";
  exports.MathML = "http://www.w3.org/1998/Math/MathML";
  exports.SVG = "http://www.w3.org/2000/svg";
  exports.XLink = "http://www.w3.org/1999/xlink";
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/Queue.js
var require_Queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function enqueue(list, item) {
    list.push(item);
  }
  exports.enqueue = enqueue;
  function dequeue(list) {
    return list.shift() || null;
  }
  exports.dequeue = dequeue;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/Set.js
var require_Set = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function append(set, item) {
    set.add(item);
  }
  exports.append = append;
  function extend(setA, setB) {
    setB.forEach(setA.add, setA);
  }
  exports.extend = extend;
  function prepend(set, item) {
    const cloned = new Set(set);
    set.clear();
    set.add(item);
    cloned.forEach(set.add, set);
  }
  exports.prepend = prepend;
  function replace(set, conditionOrItem, newItem) {
    const newSet = new Set;
    for (const oldItem of set) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          newSet.add(newItem);
        } else {
          newSet.add(oldItem);
        }
      } else if (oldItem === conditionOrItem) {
        newSet.add(newItem);
      } else {
        newSet.add(oldItem);
      }
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  exports.replace = replace;
  function insert(set, item, index) {
    const newSet = new Set;
    let i = 0;
    for (const oldItem of set) {
      if (i === index)
        newSet.add(item);
      newSet.add(oldItem);
      i++;
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  exports.insert = insert;
  function remove(set, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      set.delete(conditionOrItem);
    } else {
      const toRemove = [];
      for (const item of set) {
        if (!!conditionOrItem.call(null, item)) {
          toRemove.push(item);
        }
      }
      for (const oldItem of toRemove) {
        set.delete(oldItem);
      }
    }
  }
  exports.remove = remove;
  function empty(set) {
    set.clear();
  }
  exports.empty = empty;
  function contains(set, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      return set.has(conditionOrItem);
    } else {
      for (const oldItem of set) {
        if (!!conditionOrItem.call(null, oldItem)) {
          return true;
        }
      }
    }
    return false;
  }
  exports.contains = contains;
  function size(set, condition) {
    if (condition === undefined) {
      return set.size;
    } else {
      let count = 0;
      for (const item of set) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  exports.size = size;
  function isEmpty(set) {
    return set.size === 0;
  }
  exports.isEmpty = isEmpty;
  function* forEach(set, condition) {
    if (condition === undefined) {
      yield* set;
    } else {
      for (const item of set) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  exports.forEach = forEach;
  function clone(set) {
    return new Set(set);
  }
  exports.clone = clone;
  function sortInAscendingOrder(set, lessThanAlgo) {
    const list = new Array(...set);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
    return new Set(list);
  }
  exports.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(set, lessThanAlgo) {
    const list = new Array(...set);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
    return new Set(list);
  }
  exports.sortInDescendingOrder = sortInDescendingOrder;
  function isSubsetOf(subset, superset) {
    for (const item of subset) {
      if (!superset.has(item))
        return false;
    }
    return true;
  }
  exports.isSubsetOf = isSubsetOf;
  function isSupersetOf(superset, subset) {
    return isSubsetOf(subset, superset);
  }
  exports.isSupersetOf = isSupersetOf;
  function intersection(setA, setB) {
    const newSet = new Set;
    for (const item of setA) {
      if (setB.has(item))
        newSet.add(item);
    }
    return newSet;
  }
  exports.intersection = intersection;
  function union(setA, setB) {
    const newSet = new Set(setA);
    setB.forEach(newSet.add, newSet);
    return newSet;
  }
  exports.union = union;
  function range(n, m) {
    const newSet = new Set;
    for (let i = n;i <= m; i++) {
      newSet.add(i);
    }
    return newSet;
  }
  exports.range = range;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/Stack.js
var require_Stack = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function push(list, item) {
    list.push(item);
  }
  exports.push = push;
  function pop(list) {
    return list.pop() || null;
  }
  exports.pop = pop;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/String.js
var require_String = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CodePoints_1 = require_CodePoints();
  var ByteSequence_1 = require_ByteSequence();
  var Byte_1 = require_Byte();
  var util_1 = require_lib8();
  function isCodeUnitPrefix(a, b) {
    let i = 0;
    while (true) {
      const aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
      const bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
      if (aCodeUnit === null)
        return true;
      if (aCodeUnit !== bCodeUnit)
        return false;
      i++;
    }
  }
  exports.isCodeUnitPrefix = isCodeUnitPrefix;
  function isCodeUnitLessThan(a, b) {
    if (isCodeUnitPrefix(b, a))
      return false;
    if (isCodeUnitPrefix(a, b))
      return true;
    for (let i = 0;i < Math.min(a.length, b.length); i++) {
      const aCodeUnit = a.charCodeAt(i);
      const bCodeUnit = b.charCodeAt(i);
      if (aCodeUnit === bCodeUnit)
        continue;
      return aCodeUnit < bCodeUnit;
    }
    return false;
  }
  exports.isCodeUnitLessThan = isCodeUnitLessThan;
  function isomorphicEncode(str) {
    const codePoints = Array.from(str);
    const bytes = new Uint8Array(codePoints.length);
    let i = 0;
    for (const codePoint of str) {
      const byte = codePoint.codePointAt(0);
      console.assert(byte !== undefined && byte <= 255, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
      if (byte !== undefined && byte <= 255) {
        bytes[i++] = byte;
      }
    }
    return bytes;
  }
  exports.isomorphicEncode = isomorphicEncode;
  function isASCIIString(str) {
    return /^[\u0000-\u007F]*$/.test(str);
  }
  exports.isASCIIString = isASCIIString;
  function asciiLowercase(str) {
    let result = "";
    for (const c of str) {
      const code = c.codePointAt(0);
      if (code !== undefined && code >= 65 && code <= 90) {
        result += String.fromCodePoint(code + 32);
      } else {
        result += c;
      }
    }
    return result;
  }
  exports.asciiLowercase = asciiLowercase;
  function asciiUppercase(str) {
    let result = "";
    for (const c of str) {
      const code = c.codePointAt(0);
      if (code !== undefined && code >= 97 && code <= 122) {
        result += String.fromCodePoint(code - 32);
      } else {
        result += c;
      }
    }
    return result;
  }
  exports.asciiUppercase = asciiUppercase;
  function asciiCaseInsensitiveMatch(a, b) {
    return asciiLowercase(a) === asciiLowercase(b);
  }
  exports.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
  function asciiEncode(str) {
    console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
    return isomorphicEncode(str);
  }
  exports.asciiEncode = asciiEncode;
  function asciiDecode(bytes) {
    for (const byte of bytes) {
      console.assert(Byte_1.isASCIIByte(byte), "asciiDecode requires an ASCII byte sequence.");
    }
    return ByteSequence_1.isomorphicDecode(bytes);
  }
  exports.asciiDecode = asciiDecode;
  function stripNewlines(str) {
    return str.replace(/[\n\r]/g, "");
  }
  exports.stripNewlines = stripNewlines;
  function normalizeNewlines(str) {
    return str.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
  }
  exports.normalizeNewlines = normalizeNewlines;
  function stripLeadingAndTrailingASCIIWhitespace(str) {
    return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
  }
  exports.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
  function stripAndCollapseASCIIWhitespace(str) {
    return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
  }
  exports.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
  function collectASequenceOfCodePoints(condition, input, options) {
    if (!util_1.isArray(input))
      return collectASequenceOfCodePoints(condition, Array.from(input), options);
    let result = "";
    while (options.position < input.length && !!condition.call(null, input[options.position])) {
      result += input[options.position];
      options.position++;
    }
    return result;
  }
  exports.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
  function skipASCIIWhitespace(input, options) {
    collectASequenceOfCodePoints((str) => CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
  }
  exports.skipASCIIWhitespace = skipASCIIWhitespace;
  function strictlySplit(input, delimiter) {
    if (!util_1.isArray(input))
      return strictlySplit(Array.from(input), delimiter);
    const options = { position: 0 };
    const tokens = [];
    let token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
    tokens.push(token);
    while (options.position < input.length) {
      console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
      options.position++;
      token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
      tokens.push(token);
    }
    return tokens;
  }
  exports.strictlySplit = strictlySplit;
  function splitAStringOnASCIIWhitespace(input) {
    if (!util_1.isArray(input))
      return splitAStringOnASCIIWhitespace(Array.from(input));
    const options = { position: 0 };
    const tokens = [];
    skipASCIIWhitespace(input, options);
    while (options.position < input.length) {
      const token = collectASequenceOfCodePoints((str) => !CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
      tokens.push(token);
      skipASCIIWhitespace(input, options);
    }
    return tokens;
  }
  exports.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
  function splitAStringOnCommas(input) {
    if (!util_1.isArray(input))
      return splitAStringOnCommas(Array.from(input));
    const options = { position: 0 };
    const tokens = [];
    while (options.position < input.length) {
      const token = collectASequenceOfCodePoints((str) => str !== ",", input, options);
      tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
      if (options.position < input.length) {
        console.assert(input[options.position] === ",", "splitAStringOnCommas found no delimiter in input string.");
        options.position++;
      }
    }
    return tokens;
  }
  exports.splitAStringOnCommas = splitAStringOnCommas;
  function concatenate(list, separator = "") {
    if (list.length === 0)
      return "";
    return list.join(separator);
  }
  exports.concatenate = concatenate;
});

// node_modules/xmlbuilder2/node_modules/@oozcitak/infra/lib/index.js
var require_lib9 = __commonJS((exports) => {
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var base64 = __importStar(require_Base64());
  exports.base64 = base64;
  var byte = __importStar(require_Byte());
  exports.byte = byte;
  var byteSequence = __importStar(require_ByteSequence());
  exports.byteSequence = byteSequence;
  var codePoint = __importStar(require_CodePoints());
  exports.codePoint = codePoint;
  var json = __importStar(require_JSON());
  exports.json = json;
  var list = __importStar(require_List());
  exports.list = list;
  var map = __importStar(require_Map());
  exports.map = map;
  var namespace = __importStar(require_Namespace());
  exports.namespace = namespace;
  var queue = __importStar(require_Queue());
  exports.queue = queue;
  var set = __importStar(require_Set());
  exports.set = set;
  var stack = __importStar(require_Stack());
  exports.stack = stack;
  var string = __importStar(require_String());
  exports.string = string;
});

// node_modules/@oozcitak/infra/lib/CodePoints.js
var require_CodePoints2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Surrogate = /[\uD800-\uDFFF]/;
  exports.ScalarValue = /[\uD800-\uDFFF]/;
  exports.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
  exports.ASCIICodePoint = /[\u0000-\u007F]/;
  exports.ASCIITabOrNewLine = /[\t\n\r]/;
  exports.ASCIIWhiteSpace = /[\t\n\f\r ]/;
  exports.C0Control = /[\u0000-\u001F]/;
  exports.C0ControlOrSpace = /[\u0000-\u001F ]/;
  exports.Control = /[\u0000-\u001F\u007F-\u009F]/;
  exports.ASCIIDigit = /[0-9]/;
  exports.ASCIIUpperHexDigit = /[0-9A-F]/;
  exports.ASCIILowerHexDigit = /[0-9a-f]/;
  exports.ASCIIHexDigit = /[0-9A-Fa-f]/;
  exports.ASCIIUpperAlpha = /[A-Z]/;
  exports.ASCIILowerAlpha = /[a-z]/;
  exports.ASCIIAlpha = /[A-Za-z]/;
  exports.ASCIIAlphanumeric = /[0-9A-Za-z]/;
});

// node_modules/@oozcitak/infra/lib/Base64.js
var require_Base642 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CodePoints_1 = require_CodePoints2();
  function forgivingBase64Encode(input) {
    return Buffer.from(input).toString("base64");
  }
  exports.forgivingBase64Encode = forgivingBase64Encode;
  function forgivingBase64Decode(input) {
    if (input === "")
      return "";
    input = input.replace(CodePoints_1.ASCIIWhiteSpace, "");
    if (input.length % 4 === 0) {
      if (input.endsWith("==")) {
        input = input.substr(0, input.length - 2);
      } else if (input.endsWith("=")) {
        input = input.substr(0, input.length - 1);
      }
    }
    if (input.length % 4 === 1)
      return null;
    if (!/[0-9A-Za-z+/]/.test(input))
      return null;
    return Buffer.from(input, "base64").toString("utf8");
  }
  exports.forgivingBase64Decode = forgivingBase64Decode;
});

// node_modules/@oozcitak/infra/lib/Byte.js
var require_Byte2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function isASCIIByte(byte) {
    return byte >= 0 && byte <= 127;
  }
  exports.isASCIIByte = isASCIIByte;
});

// node_modules/@oozcitak/infra/lib/ByteSequence.js
var require_ByteSequence2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  function length(list) {
    return list.length;
  }
  exports.length = length;
  function byteLowercase(list) {
    for (var i = 0;i < list.length; i++) {
      var c = list[i];
      if (c >= 65 && c <= 90) {
        list[i] = c + 32;
      }
    }
  }
  exports.byteLowercase = byteLowercase;
  function byteUppercase(list) {
    for (var i = 0;i < list.length; i++) {
      var c = list[i];
      if (c >= 97 && c <= 122) {
        list[i] = c - 32;
      }
    }
  }
  exports.byteUppercase = byteUppercase;
  function byteCaseInsensitiveMatch(listA, listB) {
    if (listA.length !== listB.length)
      return false;
    for (var i = 0;i < listA.length; i++) {
      var a = listA[i];
      var b = listB[i];
      if (a >= 65 && a <= 90)
        a += 32;
      if (b >= 65 && b <= 90)
        b += 32;
      if (a !== b)
        return false;
    }
    return true;
  }
  exports.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
  function startsWith(listA, listB) {
    var i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      if (listA[i] !== listB[i])
        return false;
      i++;
    }
  }
  exports.startsWith = startsWith;
  function byteLessThan(listA, listB) {
    var i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      var a = listA[i];
      var b = listB[i];
      if (a < b)
        return true;
      else if (a > b)
        return false;
      i++;
    }
  }
  exports.byteLessThan = byteLessThan;
  function isomorphicDecode(list) {
    return String.fromCodePoint.apply(String, __spread(list));
  }
  exports.isomorphicDecode = isomorphicDecode;
});

// node_modules/@oozcitak/infra/lib/JSON.js
var require_JSON2 = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function parseJSONFromBytes(bytes) {
    var jsonText = util_1.utf8Decode(bytes);
    return JSON.parse.call(undefined, jsonText);
  }
  exports.parseJSONFromBytes = parseJSONFromBytes;
  function serializeJSONToBytes(value) {
    var jsonString = JSON.stringify.call(undefined, value);
    return util_1.utf8Encode(jsonString);
  }
  exports.serializeJSONToBytes = serializeJSONToBytes;
  function parseJSONIntoInfraValues(jsonText) {
    var jsValue = JSON.parse.call(undefined, jsonText);
    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
  }
  exports.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
  function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
    var e_1, _a;
    if (jsValue === null || util_1.isString(jsValue) || util_1.isNumber(jsValue))
      return jsValue;
    if (util_1.isArray(jsValue)) {
      var result = new Array;
      try {
        for (var jsValue_1 = __values(jsValue), jsValue_1_1 = jsValue_1.next();!jsValue_1_1.done; jsValue_1_1 = jsValue_1.next()) {
          var jsValueAtIndex = jsValue_1_1.value;
          result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (jsValue_1_1 && !jsValue_1_1.done && (_a = jsValue_1.return))
            _a.call(jsValue_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result;
    } else if (util_1.isObject(jsValue)) {
      var result = new Map;
      for (var key in jsValue) {
        if (jsValue.hasOwnProperty(key)) {
          var jsValueAtKey = jsValue[key];
          result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
        }
      }
      return result;
    }
    return jsValue;
  }
  exports.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;
});

// node_modules/@oozcitak/infra/lib/List.js
var require_List2 = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function append(list, item) {
    list.push(item);
  }
  exports.append = append;
  function extend(listA, listB) {
    listA.push.apply(listA, __spread(listB));
  }
  exports.extend = extend;
  function prepend(list, item) {
    list.unshift(item);
  }
  exports.prepend = prepend;
  function replace(list, conditionOrItem, newItem) {
    var e_1, _a;
    var i = 0;
    try {
      for (var list_1 = __values(list), list_1_1 = list_1.next();!list_1_1.done; list_1_1 = list_1.next()) {
        var oldItem = list_1_1.value;
        if (util_1.isFunction(conditionOrItem)) {
          if (!!conditionOrItem.call(null, oldItem)) {
            list[i] = newItem;
          }
        } else if (oldItem === conditionOrItem) {
          list[i] = newItem;
          return;
        }
        i++;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (list_1_1 && !list_1_1.done && (_a = list_1.return))
          _a.call(list_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  exports.replace = replace;
  function insert(list, item, index) {
    list.splice(index, 0, item);
  }
  exports.insert = insert;
  function remove(list, conditionOrItem) {
    var i = list.length;
    while (i--) {
      var oldItem = list[i];
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list.splice(i, 1);
        }
      } else if (oldItem === conditionOrItem) {
        list.splice(i, 1);
        return;
      }
    }
  }
  exports.remove = remove;
  function empty(list) {
    list.length = 0;
  }
  exports.empty = empty;
  function contains(list, conditionOrItem) {
    var e_2, _a;
    try {
      for (var list_2 = __values(list), list_2_1 = list_2.next();!list_2_1.done; list_2_1 = list_2.next()) {
        var oldItem = list_2_1.value;
        if (util_1.isFunction(conditionOrItem)) {
          if (!!conditionOrItem.call(null, oldItem)) {
            return true;
          }
        } else if (oldItem === conditionOrItem) {
          return true;
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (list_2_1 && !list_2_1.done && (_a = list_2.return))
          _a.call(list_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return false;
  }
  exports.contains = contains;
  function size(list, condition) {
    var e_3, _a;
    if (condition === undefined) {
      return list.length;
    } else {
      var count = 0;
      try {
        for (var list_3 = __values(list), list_3_1 = list_3.next();!list_3_1.done; list_3_1 = list_3.next()) {
          var item = list_3_1.value;
          if (!!condition.call(null, item)) {
            count++;
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (list_3_1 && !list_3_1.done && (_a = list_3.return))
            _a.call(list_3);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return count;
    }
  }
  exports.size = size;
  function isEmpty(list) {
    return list.length === 0;
  }
  exports.isEmpty = isEmpty;
  function forEach(list, condition) {
    var list_4, list_4_1, item, e_4_1;
    var e_4, _a;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!(condition === undefined))
            return [3, 2];
          return [5, __values(list)];
        case 1:
          _b.sent();
          return [3, 9];
        case 2:
          _b.trys.push([2, 7, 8, 9]);
          list_4 = __values(list), list_4_1 = list_4.next();
          _b.label = 3;
        case 3:
          if (!!list_4_1.done)
            return [3, 6];
          item = list_4_1.value;
          if (!!!condition.call(null, item))
            return [3, 5];
          return [4, item];
        case 4:
          _b.sent();
          _b.label = 5;
        case 5:
          list_4_1 = list_4.next();
          return [3, 3];
        case 6:
          return [3, 9];
        case 7:
          e_4_1 = _b.sent();
          e_4 = { error: e_4_1 };
          return [3, 9];
        case 8:
          try {
            if (list_4_1 && !list_4_1.done && (_a = list_4.return))
              _a.call(list_4);
          } finally {
            if (e_4)
              throw e_4.error;
          }
          return [7];
        case 9:
          return [2];
      }
    });
  }
  exports.forEach = forEach;
  function clone(list) {
    return new (Array.bind.apply(Array, __spread([undefined], list)));
  }
  exports.clone = clone;
  function sortInAscendingOrder(list, lessThanAlgo) {
    return list.sort(function(itemA, itemB) {
      return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
  }
  exports.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(list, lessThanAlgo) {
    return list.sort(function(itemA, itemB) {
      return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
  }
  exports.sortInDescendingOrder = sortInDescendingOrder;
});

// node_modules/@oozcitak/infra/lib/Map.js
var require_Map2 = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function get(map, key) {
    return map.get(key);
  }
  exports.get = get;
  function set(map, key, val) {
    map.set(key, val);
  }
  exports.set = set;
  function remove(map, conditionOrItem) {
    var e_1, _a, e_2, _b;
    if (!util_1.isFunction(conditionOrItem)) {
      map.delete(conditionOrItem);
    } else {
      var toRemove = [];
      try {
        for (var map_1 = __values(map), map_1_1 = map_1.next();!map_1_1.done; map_1_1 = map_1.next()) {
          var item = map_1_1.value;
          if (!!conditionOrItem.call(null, item)) {
            toRemove.push(item[0]);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (map_1_1 && !map_1_1.done && (_a = map_1.return))
            _a.call(map_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      try {
        for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next();!toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {
          var key = toRemove_1_1.value;
          map.delete(key);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return))
            _b.call(toRemove_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  }
  exports.remove = remove;
  function contains(map, conditionOrItem) {
    var e_3, _a;
    if (!util_1.isFunction(conditionOrItem)) {
      return map.has(conditionOrItem);
    } else {
      try {
        for (var map_2 = __values(map), map_2_1 = map_2.next();!map_2_1.done; map_2_1 = map_2.next()) {
          var item = map_2_1.value;
          if (!!conditionOrItem.call(null, item)) {
            return true;
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (map_2_1 && !map_2_1.done && (_a = map_2.return))
            _a.call(map_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return false;
    }
  }
  exports.contains = contains;
  function keys(map) {
    return new Set(map.keys());
  }
  exports.keys = keys;
  function values(map) {
    return __spread(map.values());
  }
  exports.values = values;
  function size(map, condition) {
    var e_4, _a;
    if (condition === undefined) {
      return map.size;
    } else {
      var count = 0;
      try {
        for (var map_3 = __values(map), map_3_1 = map_3.next();!map_3_1.done; map_3_1 = map_3.next()) {
          var item = map_3_1.value;
          if (!!condition.call(null, item)) {
            count++;
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (map_3_1 && !map_3_1.done && (_a = map_3.return))
            _a.call(map_3);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return count;
    }
  }
  exports.size = size;
  function isEmpty(map) {
    return map.size === 0;
  }
  exports.isEmpty = isEmpty;
  function forEach(map, condition) {
    var map_4, map_4_1, item, e_5_1;
    var e_5, _a;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!(condition === undefined))
            return [3, 2];
          return [5, __values(map)];
        case 1:
          _b.sent();
          return [3, 9];
        case 2:
          _b.trys.push([2, 7, 8, 9]);
          map_4 = __values(map), map_4_1 = map_4.next();
          _b.label = 3;
        case 3:
          if (!!map_4_1.done)
            return [3, 6];
          item = map_4_1.value;
          if (!!!condition.call(null, item))
            return [3, 5];
          return [4, item];
        case 4:
          _b.sent();
          _b.label = 5;
        case 5:
          map_4_1 = map_4.next();
          return [3, 3];
        case 6:
          return [3, 9];
        case 7:
          e_5_1 = _b.sent();
          e_5 = { error: e_5_1 };
          return [3, 9];
        case 8:
          try {
            if (map_4_1 && !map_4_1.done && (_a = map_4.return))
              _a.call(map_4);
          } finally {
            if (e_5)
              throw e_5.error;
          }
          return [7];
        case 9:
          return [2];
      }
    });
  }
  exports.forEach = forEach;
  function clone(map) {
    return new Map(map);
  }
  exports.clone = clone;
  function sortInAscendingOrder(map, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([undefined], map)));
    list.sort(function(itemA, itemB) {
      return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
    return new Map(list);
  }
  exports.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(map, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([undefined], map)));
    list.sort(function(itemA, itemB) {
      return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
    return new Map(list);
  }
  exports.sortInDescendingOrder = sortInDescendingOrder;
});

// node_modules/@oozcitak/infra/lib/Namespace.js
var require_Namespace2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTML = "http://www.w3.org/1999/xhtml";
  exports.XML = "http://www.w3.org/XML/1998/namespace";
  exports.XMLNS = "http://www.w3.org/2000/xmlns/";
  exports.MathML = "http://www.w3.org/1998/Math/MathML";
  exports.SVG = "http://www.w3.org/2000/svg";
  exports.XLink = "http://www.w3.org/1999/xlink";
});

// node_modules/@oozcitak/infra/lib/Queue.js
var require_Queue2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function enqueue(list, item) {
    list.push(item);
  }
  exports.enqueue = enqueue;
  function dequeue(list) {
    return list.shift() || null;
  }
  exports.dequeue = dequeue;
});

// node_modules/@oozcitak/infra/lib/Set.js
var require_Set2 = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function append(set, item) {
    set.add(item);
  }
  exports.append = append;
  function extend(setA, setB) {
    setB.forEach(setA.add, setA);
  }
  exports.extend = extend;
  function prepend(set, item) {
    var cloned = new Set(set);
    set.clear();
    set.add(item);
    cloned.forEach(set.add, set);
  }
  exports.prepend = prepend;
  function replace(set, conditionOrItem, newItem) {
    var e_1, _a;
    var newSet = new Set;
    try {
      for (var set_1 = __values(set), set_1_1 = set_1.next();!set_1_1.done; set_1_1 = set_1.next()) {
        var oldItem = set_1_1.value;
        if (util_1.isFunction(conditionOrItem)) {
          if (!!conditionOrItem.call(null, oldItem)) {
            newSet.add(newItem);
          } else {
            newSet.add(oldItem);
          }
        } else if (oldItem === conditionOrItem) {
          newSet.add(newItem);
        } else {
          newSet.add(oldItem);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (set_1_1 && !set_1_1.done && (_a = set_1.return))
          _a.call(set_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  exports.replace = replace;
  function insert(set, item, index) {
    var e_2, _a;
    var newSet = new Set;
    var i = 0;
    try {
      for (var set_2 = __values(set), set_2_1 = set_2.next();!set_2_1.done; set_2_1 = set_2.next()) {
        var oldItem = set_2_1.value;
        if (i === index)
          newSet.add(item);
        newSet.add(oldItem);
        i++;
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (set_2_1 && !set_2_1.done && (_a = set_2.return))
          _a.call(set_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  exports.insert = insert;
  function remove(set, conditionOrItem) {
    var e_3, _a, e_4, _b;
    if (!util_1.isFunction(conditionOrItem)) {
      set.delete(conditionOrItem);
    } else {
      var toRemove = [];
      try {
        for (var set_3 = __values(set), set_3_1 = set_3.next();!set_3_1.done; set_3_1 = set_3.next()) {
          var item = set_3_1.value;
          if (!!conditionOrItem.call(null, item)) {
            toRemove.push(item);
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (set_3_1 && !set_3_1.done && (_a = set_3.return))
            _a.call(set_3);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      try {
        for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next();!toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {
          var oldItem = toRemove_1_1.value;
          set.delete(oldItem);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return))
            _b.call(toRemove_1);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    }
  }
  exports.remove = remove;
  function empty(set) {
    set.clear();
  }
  exports.empty = empty;
  function contains(set, conditionOrItem) {
    var e_5, _a;
    if (!util_1.isFunction(conditionOrItem)) {
      return set.has(conditionOrItem);
    } else {
      try {
        for (var set_4 = __values(set), set_4_1 = set_4.next();!set_4_1.done; set_4_1 = set_4.next()) {
          var oldItem = set_4_1.value;
          if (!!conditionOrItem.call(null, oldItem)) {
            return true;
          }
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (set_4_1 && !set_4_1.done && (_a = set_4.return))
            _a.call(set_4);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
    }
    return false;
  }
  exports.contains = contains;
  function size(set, condition) {
    var e_6, _a;
    if (condition === undefined) {
      return set.size;
    } else {
      var count = 0;
      try {
        for (var set_5 = __values(set), set_5_1 = set_5.next();!set_5_1.done; set_5_1 = set_5.next()) {
          var item = set_5_1.value;
          if (!!condition.call(null, item)) {
            count++;
          }
        }
      } catch (e_6_1) {
        e_6 = { error: e_6_1 };
      } finally {
        try {
          if (set_5_1 && !set_5_1.done && (_a = set_5.return))
            _a.call(set_5);
        } finally {
          if (e_6)
            throw e_6.error;
        }
      }
      return count;
    }
  }
  exports.size = size;
  function isEmpty(set) {
    return set.size === 0;
  }
  exports.isEmpty = isEmpty;
  function forEach(set, condition) {
    var set_6, set_6_1, item, e_7_1;
    var e_7, _a;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!(condition === undefined))
            return [3, 2];
          return [5, __values(set)];
        case 1:
          _b.sent();
          return [3, 9];
        case 2:
          _b.trys.push([2, 7, 8, 9]);
          set_6 = __values(set), set_6_1 = set_6.next();
          _b.label = 3;
        case 3:
          if (!!set_6_1.done)
            return [3, 6];
          item = set_6_1.value;
          if (!!!condition.call(null, item))
            return [3, 5];
          return [4, item];
        case 4:
          _b.sent();
          _b.label = 5;
        case 5:
          set_6_1 = set_6.next();
          return [3, 3];
        case 6:
          return [3, 9];
        case 7:
          e_7_1 = _b.sent();
          e_7 = { error: e_7_1 };
          return [3, 9];
        case 8:
          try {
            if (set_6_1 && !set_6_1.done && (_a = set_6.return))
              _a.call(set_6);
          } finally {
            if (e_7)
              throw e_7.error;
          }
          return [7];
        case 9:
          return [2];
      }
    });
  }
  exports.forEach = forEach;
  function clone(set) {
    return new Set(set);
  }
  exports.clone = clone;
  function sortInAscendingOrder(set, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([undefined], set)));
    list.sort(function(itemA, itemB) {
      return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
    return new Set(list);
  }
  exports.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(set, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([undefined], set)));
    list.sort(function(itemA, itemB) {
      return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
    return new Set(list);
  }
  exports.sortInDescendingOrder = sortInDescendingOrder;
  function isSubsetOf(subset, superset) {
    var e_8, _a;
    try {
      for (var subset_1 = __values(subset), subset_1_1 = subset_1.next();!subset_1_1.done; subset_1_1 = subset_1.next()) {
        var item = subset_1_1.value;
        if (!superset.has(item))
          return false;
      }
    } catch (e_8_1) {
      e_8 = { error: e_8_1 };
    } finally {
      try {
        if (subset_1_1 && !subset_1_1.done && (_a = subset_1.return))
          _a.call(subset_1);
      } finally {
        if (e_8)
          throw e_8.error;
      }
    }
    return true;
  }
  exports.isSubsetOf = isSubsetOf;
  function isSupersetOf(superset, subset) {
    return isSubsetOf(subset, superset);
  }
  exports.isSupersetOf = isSupersetOf;
  function intersection(setA, setB) {
    var e_9, _a;
    var newSet = new Set;
    try {
      for (var setA_1 = __values(setA), setA_1_1 = setA_1.next();!setA_1_1.done; setA_1_1 = setA_1.next()) {
        var item = setA_1_1.value;
        if (setB.has(item))
          newSet.add(item);
      }
    } catch (e_9_1) {
      e_9 = { error: e_9_1 };
    } finally {
      try {
        if (setA_1_1 && !setA_1_1.done && (_a = setA_1.return))
          _a.call(setA_1);
      } finally {
        if (e_9)
          throw e_9.error;
      }
    }
    return newSet;
  }
  exports.intersection = intersection;
  function union(setA, setB) {
    var newSet = new Set(setA);
    setB.forEach(newSet.add, newSet);
    return newSet;
  }
  exports.union = union;
  function range(n, m) {
    var newSet = new Set;
    for (var i = n;i <= m; i++) {
      newSet.add(i);
    }
    return newSet;
  }
  exports.range = range;
});

// node_modules/@oozcitak/infra/lib/Stack.js
var require_Stack2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function push(list, item) {
    list.push(item);
  }
  exports.push = push;
  function pop(list) {
    return list.pop() || null;
  }
  exports.pop = pop;
});

// node_modules/@oozcitak/infra/lib/String.js
var require_String2 = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var CodePoints_1 = require_CodePoints2();
  var ByteSequence_1 = require_ByteSequence2();
  var Byte_1 = require_Byte2();
  var util_1 = require_lib8();
  function isCodeUnitPrefix(a, b) {
    var i = 0;
    while (true) {
      var aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
      var bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
      if (aCodeUnit === null)
        return true;
      if (aCodeUnit !== bCodeUnit)
        return false;
      i++;
    }
  }
  exports.isCodeUnitPrefix = isCodeUnitPrefix;
  function isCodeUnitLessThan(a, b) {
    if (isCodeUnitPrefix(b, a))
      return false;
    if (isCodeUnitPrefix(a, b))
      return true;
    for (var i = 0;i < Math.min(a.length, b.length); i++) {
      var aCodeUnit = a.charCodeAt(i);
      var bCodeUnit = b.charCodeAt(i);
      if (aCodeUnit === bCodeUnit)
        continue;
      return aCodeUnit < bCodeUnit;
    }
    return false;
  }
  exports.isCodeUnitLessThan = isCodeUnitLessThan;
  function isomorphicEncode(str) {
    var e_1, _a;
    var codePoints = Array.from(str);
    var bytes = new Uint8Array(codePoints.length);
    var i = 0;
    try {
      for (var str_1 = __values(str), str_1_1 = str_1.next();!str_1_1.done; str_1_1 = str_1.next()) {
        var codePoint = str_1_1.value;
        var byte = codePoint.codePointAt(0);
        console.assert(byte !== undefined && byte <= 255, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
        if (byte !== undefined && byte <= 255) {
          bytes[i++] = byte;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (str_1_1 && !str_1_1.done && (_a = str_1.return))
          _a.call(str_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return bytes;
  }
  exports.isomorphicEncode = isomorphicEncode;
  function isASCIIString(str) {
    return /^[\u0000-\u007F]*$/.test(str);
  }
  exports.isASCIIString = isASCIIString;
  function asciiLowercase(str) {
    var e_2, _a;
    var result = "";
    try {
      for (var str_2 = __values(str), str_2_1 = str_2.next();!str_2_1.done; str_2_1 = str_2.next()) {
        var c = str_2_1.value;
        var code = c.codePointAt(0);
        if (code !== undefined && code >= 65 && code <= 90) {
          result += String.fromCodePoint(code + 32);
        } else {
          result += c;
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (str_2_1 && !str_2_1.done && (_a = str_2.return))
          _a.call(str_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return result;
  }
  exports.asciiLowercase = asciiLowercase;
  function asciiUppercase(str) {
    var e_3, _a;
    var result = "";
    try {
      for (var str_3 = __values(str), str_3_1 = str_3.next();!str_3_1.done; str_3_1 = str_3.next()) {
        var c = str_3_1.value;
        var code = c.codePointAt(0);
        if (code !== undefined && code >= 97 && code <= 122) {
          result += String.fromCodePoint(code - 32);
        } else {
          result += c;
        }
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (str_3_1 && !str_3_1.done && (_a = str_3.return))
          _a.call(str_3);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    return result;
  }
  exports.asciiUppercase = asciiUppercase;
  function asciiCaseInsensitiveMatch(a, b) {
    return asciiLowercase(a) === asciiLowercase(b);
  }
  exports.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
  function asciiEncode(str) {
    console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
    return isomorphicEncode(str);
  }
  exports.asciiEncode = asciiEncode;
  function asciiDecode(bytes) {
    var e_4, _a;
    try {
      for (var bytes_1 = __values(bytes), bytes_1_1 = bytes_1.next();!bytes_1_1.done; bytes_1_1 = bytes_1.next()) {
        var byte = bytes_1_1.value;
        console.assert(Byte_1.isASCIIByte(byte), "asciiDecode requires an ASCII byte sequence.");
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (bytes_1_1 && !bytes_1_1.done && (_a = bytes_1.return))
          _a.call(bytes_1);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    return ByteSequence_1.isomorphicDecode(bytes);
  }
  exports.asciiDecode = asciiDecode;
  function stripNewlines(str) {
    return str.replace(/[\n\r]/g, "");
  }
  exports.stripNewlines = stripNewlines;
  function normalizeNewlines(str) {
    return str.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
  }
  exports.normalizeNewlines = normalizeNewlines;
  function stripLeadingAndTrailingASCIIWhitespace(str) {
    return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
  }
  exports.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
  function stripAndCollapseASCIIWhitespace(str) {
    return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
  }
  exports.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
  function collectASequenceOfCodePoints(condition, input, options) {
    if (!util_1.isArray(input))
      return collectASequenceOfCodePoints(condition, Array.from(input), options);
    var result = "";
    while (options.position < input.length && !!condition.call(null, input[options.position])) {
      result += input[options.position];
      options.position++;
    }
    return result;
  }
  exports.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
  function skipASCIIWhitespace(input, options) {
    collectASequenceOfCodePoints(function(str) {
      return CodePoints_1.ASCIIWhiteSpace.test(str);
    }, input, options);
  }
  exports.skipASCIIWhitespace = skipASCIIWhitespace;
  function strictlySplit(input, delimiter) {
    if (!util_1.isArray(input))
      return strictlySplit(Array.from(input), delimiter);
    var options = { position: 0 };
    var tokens = [];
    var token = collectASequenceOfCodePoints(function(str) {
      return delimiter !== str;
    }, input, options);
    tokens.push(token);
    while (options.position < input.length) {
      console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
      options.position++;
      token = collectASequenceOfCodePoints(function(str) {
        return delimiter !== str;
      }, input, options);
      tokens.push(token);
    }
    return tokens;
  }
  exports.strictlySplit = strictlySplit;
  function splitAStringOnASCIIWhitespace(input) {
    if (!util_1.isArray(input))
      return splitAStringOnASCIIWhitespace(Array.from(input));
    var options = { position: 0 };
    var tokens = [];
    skipASCIIWhitespace(input, options);
    while (options.position < input.length) {
      var token = collectASequenceOfCodePoints(function(str) {
        return !CodePoints_1.ASCIIWhiteSpace.test(str);
      }, input, options);
      tokens.push(token);
      skipASCIIWhitespace(input, options);
    }
    return tokens;
  }
  exports.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
  function splitAStringOnCommas(input) {
    if (!util_1.isArray(input))
      return splitAStringOnCommas(Array.from(input));
    var options = { position: 0 };
    var tokens = [];
    while (options.position < input.length) {
      var token = collectASequenceOfCodePoints(function(str) {
        return str !== ",";
      }, input, options);
      tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
      if (options.position < input.length) {
        console.assert(input[options.position] === ",", "splitAStringOnCommas found no delimiter in input string.");
        options.position++;
      }
    }
    return tokens;
  }
  exports.splitAStringOnCommas = splitAStringOnCommas;
  function concatenate(list, separator) {
    if (separator === undefined) {
      separator = "";
    }
    if (list.length === 0)
      return "";
    return list.join(separator);
  }
  exports.concatenate = concatenate;
});

// node_modules/@oozcitak/infra/lib/index.js
var require_lib10 = __commonJS((exports) => {
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var base64 = __importStar(require_Base642());
  exports.base64 = base64;
  var byte = __importStar(require_Byte2());
  exports.byte = byte;
  var byteSequence = __importStar(require_ByteSequence2());
  exports.byteSequence = byteSequence;
  var codePoint = __importStar(require_CodePoints2());
  exports.codePoint = codePoint;
  var json = __importStar(require_JSON2());
  exports.json = json;
  var list = __importStar(require_List2());
  exports.list = list;
  var map = __importStar(require_Map2());
  exports.map = map;
  var namespace = __importStar(require_Namespace2());
  exports.namespace = namespace;
  var queue = __importStar(require_Queue2());
  exports.queue = queue;
  var set = __importStar(require_Set2());
  exports.set = set;
  var stack = __importStar(require_Stack2());
  exports.stack = stack;
  var string = __importStar(require_String2());
  exports.string = string;
});

// node_modules/@oozcitak/dom/lib/algorithm/WebIDLAlgorithm.js
var require_WebIDLAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function idl_defineConst(o, name, value) {
    Object.defineProperty(o, name, { writable: false, enumerable: true, configurable: false, value });
  }
  exports.idl_defineConst = idl_defineConst;
});

// node_modules/@oozcitak/dom/lib/dom/DOMImplementationImpl.js
var require_DOMImplementationImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var infra_1 = require_lib10();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var DOMImplementationImpl = function() {
    function DOMImplementationImpl2(document2) {
      this._associatedDocument = document2 || DOMImpl_1.dom.window.document;
    }
    DOMImplementationImpl2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
      algorithm_1.namespace_validate(qualifiedName);
      return algorithm_1.create_documentType(this._associatedDocument, qualifiedName, publicId, systemId);
    };
    DOMImplementationImpl2.prototype.createDocument = function(namespace, qualifiedName, doctype) {
      if (doctype === undefined) {
        doctype = null;
      }
      var document2 = algorithm_1.create_xmlDocument();
      var element = null;
      if (qualifiedName) {
        element = algorithm_1.document_internalCreateElementNS(document2, namespace, qualifiedName);
      }
      if (doctype)
        document2.appendChild(doctype);
      if (element)
        document2.appendChild(element);
      document2._origin = this._associatedDocument._origin;
      if (namespace === infra_1.namespace.HTML)
        document2._contentType = "application/xhtml+xml";
      else if (namespace === infra_1.namespace.SVG)
        document2._contentType = "image/svg+xml";
      else
        document2._contentType = "application/xml";
      return document2;
    };
    DOMImplementationImpl2.prototype.createHTMLDocument = function(title) {
      var doc = algorithm_1.create_document();
      doc._type = "html";
      doc._contentType = "text/html";
      doc.appendChild(algorithm_1.create_documentType(doc, "html", "", ""));
      var htmlElement = algorithm_1.element_createAnElement(doc, "html", infra_1.namespace.HTML);
      doc.appendChild(htmlElement);
      var headElement = algorithm_1.element_createAnElement(doc, "head", infra_1.namespace.HTML);
      htmlElement.appendChild(headElement);
      if (title !== undefined) {
        var titleElement = algorithm_1.element_createAnElement(doc, "title", infra_1.namespace.HTML);
        headElement.appendChild(titleElement);
        var textElement = algorithm_1.create_text(doc, title);
        titleElement.appendChild(textElement);
      }
      var bodyElement = algorithm_1.element_createAnElement(doc, "body", infra_1.namespace.HTML);
      htmlElement.appendChild(bodyElement);
      doc._origin = this._associatedDocument._origin;
      return doc;
    };
    DOMImplementationImpl2.prototype.hasFeature = function() {
      return true;
    };
    DOMImplementationImpl2._create = function(document2) {
      return new DOMImplementationImpl2(document2);
    };
    return DOMImplementationImpl2;
  }();
  exports.DOMImplementationImpl = DOMImplementationImpl;
  WebIDLAlgorithm_1.idl_defineConst(DOMImplementationImpl.prototype, "_ID", "@oozcitak/dom");
});

// node_modules/@oozcitak/dom/lib/dom/EventTargetImpl.js
var require_EventTargetImpl = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMException_1 = require_DOMException();
  var util_1 = require_util2();
  var algorithm_1 = require_algorithm();
  var EventTargetImpl = function() {
    function EventTargetImpl2() {
    }
    Object.defineProperty(EventTargetImpl2.prototype, "_eventListenerList", {
      get: function() {
        return this.__eventListenerList || (this.__eventListenerList = []);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventTargetImpl2.prototype, "_eventHandlerMap", {
      get: function() {
        return this.__eventHandlerMap || (this.__eventHandlerMap = {});
      },
      enumerable: true,
      configurable: true
    });
    EventTargetImpl2.prototype.addEventListener = function(type, callback, options) {
      if (options === undefined) {
        options = { passive: false, once: false, capture: false };
      }
      var _a = __read(algorithm_1.eventTarget_flattenMore(options), 3), capture = _a[0], passive = _a[1], once = _a[2];
      var listenerCallback;
      if (!callback) {
        return;
      } else if (util_1.Guard.isEventListener(callback)) {
        listenerCallback = callback;
      } else {
        listenerCallback = { handleEvent: callback };
      }
      algorithm_1.eventTarget_addEventListener(this, {
        type,
        callback: listenerCallback,
        capture,
        passive,
        once,
        removed: false
      });
    };
    EventTargetImpl2.prototype.removeEventListener = function(type, callback, options) {
      if (options === undefined) {
        options = { capture: false };
      }
      var capture = algorithm_1.eventTarget_flatten(options);
      if (!callback)
        return;
      for (var i = 0;i < this._eventListenerList.length; i++) {
        var entry = this._eventListenerList[i];
        if (entry.type !== type || entry.capture !== capture)
          continue;
        if (util_1.Guard.isEventListener(callback) && entry.callback === callback) {
          algorithm_1.eventTarget_removeEventListener(this, entry, i);
          break;
        } else if (callback && entry.callback.handleEvent === callback) {
          algorithm_1.eventTarget_removeEventListener(this, entry, i);
          break;
        }
      }
    };
    EventTargetImpl2.prototype.dispatchEvent = function(event) {
      if (event._dispatchFlag || !event._initializedFlag) {
        throw new DOMException_1.InvalidStateError;
      }
      event._isTrusted = false;
      return algorithm_1.event_dispatch(event, this);
    };
    EventTargetImpl2.prototype._getTheParent = function(event) {
      return null;
    };
    return EventTargetImpl2;
  }();
  exports.EventTargetImpl = EventTargetImpl;
});

// node_modules/@oozcitak/dom/lib/dom/WindowImpl.js
var require_WindowImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var EventTargetImpl_1 = require_EventTargetImpl();
  var util_1 = require_lib8();
  var algorithm_1 = require_algorithm();
  var WindowImpl = function(_super) {
    __extends(WindowImpl2, _super);
    function WindowImpl2() {
      var _this = _super.call(this) || this;
      _this._signalSlots = new Set;
      _this._mutationObserverMicrotaskQueued = false;
      _this._mutationObservers = new Set;
      _this._iteratorList = new util_1.FixedSizeSet;
      _this._associatedDocument = algorithm_1.create_document();
      return _this;
    }
    Object.defineProperty(WindowImpl2.prototype, "document", {
      get: function() {
        return this._associatedDocument;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WindowImpl2.prototype, "event", {
      get: function() {
        return this._currentEvent;
      },
      enumerable: true,
      configurable: true
    });
    WindowImpl2._create = function() {
      return new WindowImpl2;
    };
    return WindowImpl2;
  }(EventTargetImpl_1.EventTargetImpl);
  exports.WindowImpl = WindowImpl;
});

// node_modules/@oozcitak/url/lib/interfaces.js
var require_interfaces3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ParserState;
  (function(ParserState2) {
    ParserState2[ParserState2["SchemeStart"] = 0] = "SchemeStart";
    ParserState2[ParserState2["Scheme"] = 1] = "Scheme";
    ParserState2[ParserState2["NoScheme"] = 2] = "NoScheme";
    ParserState2[ParserState2["SpecialRelativeOrAuthority"] = 3] = "SpecialRelativeOrAuthority";
    ParserState2[ParserState2["PathOrAuthority"] = 4] = "PathOrAuthority";
    ParserState2[ParserState2["Relative"] = 5] = "Relative";
    ParserState2[ParserState2["RelativeSlash"] = 6] = "RelativeSlash";
    ParserState2[ParserState2["SpecialAuthoritySlashes"] = 7] = "SpecialAuthoritySlashes";
    ParserState2[ParserState2["SpecialAuthorityIgnoreSlashes"] = 8] = "SpecialAuthorityIgnoreSlashes";
    ParserState2[ParserState2["Authority"] = 9] = "Authority";
    ParserState2[ParserState2["Host"] = 10] = "Host";
    ParserState2[ParserState2["Hostname"] = 11] = "Hostname";
    ParserState2[ParserState2["Port"] = 12] = "Port";
    ParserState2[ParserState2["File"] = 13] = "File";
    ParserState2[ParserState2["FileSlash"] = 14] = "FileSlash";
    ParserState2[ParserState2["FileHost"] = 15] = "FileHost";
    ParserState2[ParserState2["PathStart"] = 16] = "PathStart";
    ParserState2[ParserState2["Path"] = 17] = "Path";
    ParserState2[ParserState2["CannotBeABaseURLPath"] = 18] = "CannotBeABaseURLPath";
    ParserState2[ParserState2["Query"] = 19] = "Query";
    ParserState2[ParserState2["Fragment"] = 20] = "Fragment";
  })(ParserState = exports.ParserState || (exports.ParserState = {}));
  exports.OpaqueOrigin = ["", "", null, null];
});

// node_modules/@oozcitak/url/lib/URLAlgorithm.js
var require_URLAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  var interfaces_1 = require_interfaces3();
  var infra_1 = require_lib10();
  var url_1 = __require("url");
  var _validationErrorCallback;
  var _defaultPorts = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var _c0ControlPercentEncodeSet = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var _fragmentPercentEncodeSet = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var _pathPercentEncodeSet = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var _userInfoPercentEncodeSet = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var _urlCodePoints = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/;
  var _forbiddenHostCodePoint = /[\0\t\f\r #%/:?@\[\\\]]/;
  function setValidationErrorCallback(validationErrorCallback) {
    _validationErrorCallback = validationErrorCallback;
  }
  exports.setValidationErrorCallback = setValidationErrorCallback;
  function validationError(message) {
    if (_validationErrorCallback !== undefined) {
      _validationErrorCallback.call(null, "Validation Error: " + message);
    }
  }
  function newURL() {
    return {
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,
      _cannotBeABaseURLFlag: false,
      _blobURLEntry: null
    };
  }
  exports.newURL = newURL;
  function isSpecialScheme(scheme) {
    return scheme in _defaultPorts;
  }
  exports.isSpecialScheme = isSpecialScheme;
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  exports.isSpecial = isSpecial;
  function defaultPort(scheme) {
    return _defaultPorts[scheme] || null;
  }
  exports.defaultPort = defaultPort;
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  exports.includesCredentials = includesCredentials;
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url._cannotBeABaseURLFlag || url.scheme === "file";
  }
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  function urlSerializer(url, excludeFragmentFlag) {
    var e_1, _a;
    if (excludeFragmentFlag === undefined) {
      excludeFragmentFlag = false;
    }
    var output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (includesCredentials(url)) {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += hostSerializer(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url._cannotBeABaseURLFlag) {
      output += url.path[0];
    } else {
      try {
        for (var _b = __values(url.path), _c = _b.next();!_c.done; _c = _b.next()) {
          var str = _c.value;
          output += "/" + str;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragmentFlag && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  }
  exports.urlSerializer = urlSerializer;
  function hostSerializer(host) {
    if (util_1.isNumber(host)) {
      return iPv4Serializer(host);
    } else if (util_1.isArray(host)) {
      return "[" + iPv6Serializer(host) + "]";
    } else {
      return host;
    }
  }
  exports.hostSerializer = hostSerializer;
  function iPv4Serializer(address) {
    var output = "";
    var n = address;
    for (var i = 1;i <= 4; i++) {
      output = (n % 256).toString() + output;
      if (i !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  }
  exports.iPv4Serializer = iPv4Serializer;
  function iPv6Serializer(address) {
    var output = "";
    var compress = null;
    var lastIndex = -1;
    var count = 0;
    var lastCount = 0;
    for (var i = 0;i < 8; i++) {
      if (address[i] !== 0)
        continue;
      count = 1;
      for (var j = i + 1;j < 8; j++) {
        if (address[j] !== 0)
          break;
        count++;
        continue;
      }
      if (count > lastCount) {
        lastCount = count;
        lastIndex = i;
      }
    }
    if (lastCount > 1)
      compress = lastIndex;
    var ignore0 = false;
    for (var pieceIndex = 0;pieceIndex < 8; pieceIndex++) {
      if (ignore0 && address[pieceIndex] === 0)
        continue;
      if (ignore0)
        ignore0 = false;
      if (compress === pieceIndex) {
        output += pieceIndex === 0 ? "::" : ":";
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7)
        output += ":";
    }
    return output;
  }
  exports.iPv6Serializer = iPv6Serializer;
  function urlParser(input, baseURL, encodingOverride) {
    var url = basicURLParser(input, baseURL, encodingOverride);
    if (url === null)
      return null;
    if (url.scheme !== "blob")
      return url;
    var entry = resolveABlobURL(url);
    if (entry !== null) {
      url._blobURLEntry = entry;
    } else {
      url._blobURLEntry = null;
    }
    return url;
  }
  exports.urlParser = urlParser;
  function basicURLParser(input, baseURL, encodingOverride, url, stateOverride) {
    var e_2, _a, e_3, _b;
    if (url === undefined) {
      url = newURL();
      var leadingControlOrSpace = /^[\u0000-\u001F\u0020]+/;
      var trailingControlOrSpace = /[\u0000-\u001F\u0020]+$/;
      if (leadingControlOrSpace.test(input) || trailingControlOrSpace.test(input)) {
        validationError("Input string contains leading or trailing control characters or space.");
      }
      input = input.replace(leadingControlOrSpace, "");
      input = input.replace(trailingControlOrSpace, "");
    }
    var tabOrNewline = /[\u0009\u000A\u000D]/g;
    if (tabOrNewline.test(input)) {
      validationError("Input string contains tab or newline characters.");
    }
    input = input.replace(tabOrNewline, "");
    var state = stateOverride === undefined ? interfaces_1.ParserState.SchemeStart : stateOverride;
    if (baseURL === undefined)
      baseURL = null;
    var encoding = encodingOverride === undefined || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
    var buffer = "";
    var atFlag = false;
    var arrayFlag = false;
    var passwordTokenSeenFlag = false;
    var EOF = "";
    var walker = new util_1.StringWalker(input);
    while (true) {
      switch (state) {
        case interfaces_1.ParserState.SchemeStart:
          if (infra_1.codePoint.ASCIIAlpha.test(walker.c())) {
            buffer += walker.c().toLowerCase();
            state = interfaces_1.ParserState.Scheme;
          } else if (stateOverride === undefined) {
            state = interfaces_1.ParserState.NoScheme;
            walker.pointer--;
          } else {
            validationError("Invalid scheme start character.");
            return null;
          }
          break;
        case interfaces_1.ParserState.Scheme:
          if (infra_1.codePoint.ASCIIAlphanumeric.test(walker.c()) || walker.c() === "+" || walker.c() === "-" || walker.c() === ".") {
            buffer += walker.c().toLowerCase();
          } else if (walker.c() === ":") {
            if (stateOverride !== undefined) {
              if (isSpecialScheme(url.scheme) && !isSpecialScheme(buffer))
                return url;
              if (!isSpecialScheme(url.scheme) && isSpecialScheme(buffer))
                return url;
              if ((includesCredentials(url) || url.port !== null) && buffer === "file")
                return url;
              if (url.scheme === "file" && (url.host === "" || url.host === null))
                return url;
            }
            url.scheme = buffer;
            if (stateOverride !== undefined) {
              if (url.port === defaultPort(url.scheme)) {
                url.port = null;
              }
              return url;
            }
            buffer = "";
            if (url.scheme === "file") {
              if (!walker.remaining().startsWith("//")) {
                validationError("Invalid file URL scheme, '//' expected.");
              }
              state = interfaces_1.ParserState.File;
            } else if (isSpecial(url) && baseURL !== null && baseURL.scheme === url.scheme) {
              state = interfaces_1.ParserState.SpecialRelativeOrAuthority;
            } else if (isSpecial(url)) {
              state = interfaces_1.ParserState.SpecialAuthoritySlashes;
            } else if (walker.remaining().startsWith("/")) {
              state = interfaces_1.ParserState.PathOrAuthority;
              walker.pointer++;
            } else {
              url._cannotBeABaseURLFlag = true;
              url.path.push("");
              state = interfaces_1.ParserState.CannotBeABaseURLPath;
            }
          } else if (stateOverride === undefined) {
            buffer = "";
            state = interfaces_1.ParserState.NoScheme;
            walker.pointer = 0;
            continue;
          } else {
            validationError("Invalid input string.");
            return null;
          }
          break;
        case interfaces_1.ParserState.NoScheme:
          if (baseURL === null || baseURL._cannotBeABaseURLFlag && walker.c() !== "#") {
            validationError("Invalid input string.");
            return null;
          } else if (baseURL._cannotBeABaseURLFlag && walker.c() === "#") {
            url.scheme = baseURL.scheme;
            url.path = infra_1.list.clone(baseURL.path);
            url.query = baseURL.query;
            url.fragment = "";
            url._cannotBeABaseURLFlag = true;
            state = interfaces_1.ParserState.Fragment;
          } else if (baseURL.scheme !== "file") {
            state = interfaces_1.ParserState.Relative;
            walker.pointer--;
          } else {
            state = interfaces_1.ParserState.File;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialRelativeOrAuthority:
          if (walker.c() === "/" && walker.remaining().startsWith("/")) {
            state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer++;
          } else {
            validationError("Invalid input string.");
            state = interfaces_1.ParserState.Relative;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.PathOrAuthority:
          if (walker.c() === "/") {
            state = interfaces_1.ParserState.Authority;
          } else {
            state = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.Relative:
          if (baseURL === null) {
            throw new Error("Invalid parser state. Base URL is null.");
          }
          url.scheme = baseURL.scheme;
          switch (walker.c()) {
            case EOF:
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = baseURL.query;
              break;
            case "/":
              state = interfaces_1.ParserState.RelativeSlash;
              break;
            case "?":
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = "";
              state = interfaces_1.ParserState.Query;
              break;
            case "#":
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = baseURL.query;
              url.fragment = "";
              state = interfaces_1.ParserState.Fragment;
              break;
            default:
              if (isSpecial(url) && walker.c() === "\\") {
                validationError("Invalid input string.");
                state = interfaces_1.ParserState.RelativeSlash;
              } else {
                url.username = baseURL.username;
                url.password = baseURL.password;
                url.host = baseURL.host;
                url.port = baseURL.port;
                url.path = infra_1.list.clone(baseURL.path);
                if (url.path.length !== 0)
                  url.path.splice(url.path.length - 1, 1);
                state = interfaces_1.ParserState.Path;
                walker.pointer--;
              }
              break;
          }
          break;
        case interfaces_1.ParserState.RelativeSlash:
          if (isSpecial(url) && (walker.c() === "/" || walker.c() === "\\")) {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
          } else if (walker.c() === "/") {
            state = interfaces_1.ParserState.Authority;
          } else {
            if (baseURL === null) {
              throw new Error("Invalid parser state. Base URL is null.");
            }
            url.username = baseURL.username;
            url.password = baseURL.password;
            url.host = baseURL.host;
            url.port = baseURL.port;
            state = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialAuthoritySlashes:
          if (walker.c() === "/" && walker.remaining().startsWith("/")) {
            state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer++;
          } else {
            validationError("Expected '//'.");
            state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes:
          if (walker.c() !== "/" && walker.c() !== "\\") {
            state = interfaces_1.ParserState.Authority;
            walker.pointer--;
          } else {
            validationError("Unexpected '/' or '\\'.");
          }
          break;
        case interfaces_1.ParserState.Authority:
          if (walker.c() === "@") {
            validationError("Unexpected '@'.");
            if (atFlag)
              buffer = "%40" + buffer;
            atFlag = true;
            try {
              for (var buffer_1 = (e_2 = undefined, __values(buffer)), buffer_1_1 = buffer_1.next();!buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                var codePoint = buffer_1_1.value;
                if (codePoint === ":" && !passwordTokenSeenFlag) {
                  passwordTokenSeenFlag = true;
                  continue;
                }
                var encodedCodePoints = utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
                if (passwordTokenSeenFlag) {
                  url.password += encodedCodePoints;
                } else {
                  url.username += encodedCodePoints;
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
                  _a.call(buffer_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
            buffer = "";
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
            if (atFlag && buffer === "") {
              validationError("Invalid input string.");
              return null;
            }
            walker.pointer -= buffer.length + 1;
            buffer = "";
            state = interfaces_1.ParserState.Host;
          } else {
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.Host:
        case interfaces_1.ParserState.Hostname:
          if (stateOverride !== undefined && url.scheme === "file") {
            walker.pointer--;
            state = interfaces_1.ParserState.FileHost;
          } else if (walker.c() === ":" && !arrayFlag) {
            if (buffer === "") {
              validationError("Invalid input string.");
              return null;
            }
            var host = hostParser(buffer, !isSpecial(url));
            if (host === null)
              return null;
            url.host = host;
            buffer = "";
            state = interfaces_1.ParserState.Port;
            if (stateOverride === interfaces_1.ParserState.Hostname)
              return url;
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
            walker.pointer--;
            if (isSpecial(url) && buffer === "") {
              validationError("Invalid input string.");
              return null;
            } else if (stateOverride !== undefined && buffer === "" && (includesCredentials(url) || url.port !== null)) {
              validationError("Invalid input string.");
              return url;
            }
            var host = hostParser(buffer, !isSpecial(url));
            if (host === null)
              return null;
            url.host = host;
            buffer = "";
            state = interfaces_1.ParserState.PathStart;
            if (stateOverride !== undefined)
              return url;
          } else {
            if (walker.c() === "[")
              arrayFlag = true;
            if (walker.c() === "]")
              arrayFlag = false;
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.Port:
          if (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            buffer += walker.c();
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\" || stateOverride) {
            if (buffer !== "") {
              if (buffer !== "") {
                var port = parseInt(buffer, 10);
                if (port > Math.pow(2, 16) - 1) {
                  validationError("Invalid port number.");
                  return null;
                }
                url.port = port === defaultPort(url.scheme) ? null : port;
                buffer = "";
              }
            }
            if (stateOverride !== undefined) {
              return url;
            }
            state = interfaces_1.ParserState.PathStart;
            walker.pointer--;
          } else {
            validationError("Invalid input string.");
            return null;
          }
          break;
        case interfaces_1.ParserState.File:
          url.scheme = "file";
          if (walker.c() === "/" || walker.c() === "\\") {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state = interfaces_1.ParserState.FileSlash;
          } else if (baseURL !== null && baseURL.scheme === "file") {
            switch (walker.c()) {
              case EOF:
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = baseURL.query;
                break;
              case "?":
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = "";
                state = interfaces_1.ParserState.Query;
                break;
              case "#":
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = baseURL.query;
                url.fragment = "";
                state = interfaces_1.ParserState.Fragment;
                break;
              default:
                if (!startsWithAWindowsDriveLetter(walker.substring())) {
                  url.host = baseURL.host;
                  url.path = infra_1.list.clone(baseURL.path);
                  shorten(url);
                } else {
                  validationError("Unexpected windows drive letter in input string.");
                }
                state = interfaces_1.ParserState.Path;
                walker.pointer--;
                break;
            }
          } else {
            state = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.FileSlash:
          if (walker.c() === "/" || walker.c() === "\\") {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state = interfaces_1.ParserState.FileHost;
          } else {
            if (baseURL !== null && baseURL.scheme === "file" && !startsWithAWindowsDriveLetter(walker.substring())) {
              if (isNormalizedWindowsDriveLetter(baseURL.path[0])) {
                url.path.push(baseURL.path[0]);
              } else {
                url.host = baseURL.host;
              }
            }
            state = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.FileHost:
          if (walker.c() === EOF || walker.c() === "/" || walker.c() === "\\" || walker.c() === "?" || walker.c() === "#") {
            walker.pointer--;
            if (stateOverride === undefined && isWindowsDriveLetter(buffer)) {
              validationError("Unexpected windows drive letter in input string.");
              state = interfaces_1.ParserState.Path;
            } else if (buffer === "") {
              url.host = "";
              if (stateOverride !== undefined)
                return url;
              state = interfaces_1.ParserState.PathStart;
            } else {
              var host = hostParser(buffer, !isSpecial(url));
              if (host === null)
                return null;
              if (host === "localhost")
                host = "";
              url.host = host;
              if (stateOverride !== undefined)
                return url;
              buffer = "";
              state = interfaces_1.ParserState.PathStart;
            }
          } else {
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.PathStart:
          if (isSpecial(url)) {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state = interfaces_1.ParserState.Path;
            if (walker.c() !== "/" && walker.c() !== "\\")
              walker.pointer--;
          } else if (stateOverride === undefined && walker.c() === "?") {
            url.query = "";
            state = interfaces_1.ParserState.Query;
          } else if (stateOverride === undefined && walker.c() === "#") {
            url.fragment = "";
            state = interfaces_1.ParserState.Fragment;
          } else if (walker.c() !== EOF) {
            state = interfaces_1.ParserState.Path;
            if (walker.c() !== "/")
              walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.Path:
          if (walker.c() === EOF || walker.c() === "/" || isSpecial(url) && walker.c() === "\\" || stateOverride === undefined && (walker.c() === "?" || walker.c() === "#")) {
            if (isSpecial(url) && walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            if (isDoubleDotPathSegment(buffer)) {
              shorten(url);
              if (walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
                url.path.push("");
              }
            } else if (isSingleDotPathSegment(buffer) && walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
              url.path.push("");
            } else if (!isSingleDotPathSegment(buffer)) {
              if (url.scheme === "file" && url.path.length === 0 && isWindowsDriveLetter(buffer)) {
                if (url.host !== null && url.host !== "") {
                  validationError("Invalid input string.");
                  url.host = "";
                }
                var bufferCodePoints = Array.from(buffer);
                buffer = bufferCodePoints.slice(0, 1) + ":" + bufferCodePoints.slice(2);
              }
              url.path.push(buffer);
            }
            buffer = "";
            if (url.scheme === "file" && (walker.c() === EOF || walker.c() === "?" || walker.c() === "#")) {
              while (url.path.length > 1 && url.path[0] === "") {
                validationError("Invalid input string.");
                url.path.splice(0, 1);
              }
            }
            if (walker.c() === "?") {
              url.query = "";
              state = interfaces_1.ParserState.Query;
            }
            if (walker.c() === "#") {
              url.fragment = "";
              state = interfaces_1.ParserState.Fragment;
            }
          } else {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            buffer += utf8PercentEncode(walker.c(), _pathPercentEncodeSet);
          }
          break;
        case interfaces_1.ParserState.CannotBeABaseURLPath:
          if (walker.c() === "?") {
            url.query = "";
            state = interfaces_1.ParserState.Query;
          } else if (walker.c() === "#") {
            url.fragment = "";
            state = interfaces_1.ParserState.Fragment;
          } else {
            if (walker.c() !== EOF && !_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            if (walker.c() !== EOF) {
              url.path[0] += utf8PercentEncode(walker.c(), _c0ControlPercentEncodeSet);
            }
          }
          break;
        case interfaces_1.ParserState.Query:
          if (encoding !== "UTF-8" && (!isSpecial(url) || url.scheme === "ws" || url.scheme === "wss")) {
            encoding = "UTF-8";
          }
          if (stateOverride === undefined && walker.c() === "#") {
            url.fragment = "";
            state = interfaces_1.ParserState.Fragment;
          } else if (walker.c() !== EOF) {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            if (encoding.toUpperCase() !== "UTF-8") {
              throw new Error("Only UTF-8 encoding is supported.");
            }
            var bytes = util_1.utf8Encode(walker.c());
            if (bytes.length >= 3 && bytes[0] === 38 && bytes[1] === 35 && bytes[bytes.length - 1] === 59) {
              bytes = bytes.subarray(2, bytes.length - 1);
              url.query += "%26%23" + infra_1.byteSequence.isomorphicDecode(bytes) + "%3B";
            } else {
              try {
                for (var bytes_1 = (e_3 = undefined, __values(bytes)), bytes_1_1 = bytes_1.next();!bytes_1_1.done; bytes_1_1 = bytes_1.next()) {
                  var byte = bytes_1_1.value;
                  if (byte < 33 || byte > 126 || byte === 34 || byte === 35 || byte === 60 || byte === 62 || byte === 39 && isSpecial(url)) {
                    url.query += percentEncode(byte);
                  } else {
                    url.query += String.fromCharCode(byte);
                  }
                }
              } catch (e_3_1) {
                e_3 = { error: e_3_1 };
              } finally {
                try {
                  if (bytes_1_1 && !bytes_1_1.done && (_b = bytes_1.return))
                    _b.call(bytes_1);
                } finally {
                  if (e_3)
                    throw e_3.error;
                }
              }
            }
          }
          break;
        case interfaces_1.ParserState.Fragment:
          if (walker.c() === EOF) {
          } else if (walker.c() === "\x00") {
            validationError("NULL character in input string.");
          } else {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Unexpected character in fragment string.");
            }
            if (walker.c() === "%" && !/^[A-Za-z0-9][A-Za-z0-9]/.test(walker.remaining())) {
              validationError("Unexpected character in fragment string.");
            }
            url.fragment += utf8PercentEncode(walker.c(), _fragmentPercentEncodeSet);
          }
          break;
      }
      if (walker.eof)
        break;
      else
        walker.pointer++;
    }
    return url;
  }
  exports.basicURLParser = basicURLParser;
  function setTheUsername(url, username) {
    var e_4, _a;
    var result = "";
    try {
      for (var username_1 = __values(username), username_1_1 = username_1.next();!username_1_1.done; username_1_1 = username_1.next()) {
        var codePoint = username_1_1.value;
        result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (username_1_1 && !username_1_1.done && (_a = username_1.return))
          _a.call(username_1);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    url.username = result;
  }
  exports.setTheUsername = setTheUsername;
  function setThePassword(url, password) {
    var e_5, _a;
    var result = "";
    try {
      for (var password_1 = __values(password), password_1_1 = password_1.next();!password_1_1.done; password_1_1 = password_1.next()) {
        var codePoint = password_1_1.value;
        result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
      }
    } catch (e_5_1) {
      e_5 = { error: e_5_1 };
    } finally {
      try {
        if (password_1_1 && !password_1_1.done && (_a = password_1.return))
          _a.call(password_1);
      } finally {
        if (e_5)
          throw e_5.error;
      }
    }
    url.password = result;
  }
  exports.setThePassword = setThePassword;
  function isSingleDotPathSegment(str) {
    return str === "." || str.toLowerCase() === "%2e";
  }
  exports.isSingleDotPathSegment = isSingleDotPathSegment;
  function isDoubleDotPathSegment(str) {
    var lowerStr = str.toLowerCase();
    return lowerStr === ".." || lowerStr === ".%2e" || lowerStr === "%2e." || lowerStr === "%2e%2e";
  }
  exports.isDoubleDotPathSegment = isDoubleDotPathSegment;
  function shorten(url) {
    var path = url.path;
    if (path.length === 0)
      return;
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0]))
      return;
    url.path.splice(url.path.length - 1, 1);
  }
  exports.shorten = shorten;
  function isNormalizedWindowsDriveLetter(str) {
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && str[1] === ":";
  }
  exports.isNormalizedWindowsDriveLetter = isNormalizedWindowsDriveLetter;
  function isWindowsDriveLetter(str) {
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && (str[1] === ":" || str[1] === "|");
  }
  exports.isWindowsDriveLetter = isWindowsDriveLetter;
  function startsWithAWindowsDriveLetter(str) {
    return str.length >= 2 && isWindowsDriveLetter(str) && (str.length === 2 || (str[2] === "/" || str[2] === "\\" || str[2] === "?" || str[2] === "#"));
  }
  exports.startsWithAWindowsDriveLetter = startsWithAWindowsDriveLetter;
  function hostParser(input, isNotSpecial) {
    if (isNotSpecial === undefined) {
      isNotSpecial = false;
    }
    if (input.startsWith("[")) {
      if (!input.endsWith("]")) {
        validationError("Expected ']' after '['.");
        return null;
      }
      return iPv6Parser(input.substring(1, input.length - 1));
    }
    if (isNotSpecial) {
      return opaqueHostParser(input);
    }
    var domain = util_1.utf8Decode(stringPercentDecode(input));
    var asciiDomain = domainToASCII(domain);
    if (asciiDomain === null) {
      validationError("Invalid domain.");
      return null;
    }
    if (_forbiddenHostCodePoint.test(asciiDomain)) {
      validationError("Invalid domain.");
      return null;
    }
    var ipv4Host = iPv4Parser(asciiDomain);
    if (ipv4Host === null || util_1.isNumber(ipv4Host))
      return ipv4Host;
    return asciiDomain;
  }
  exports.hostParser = hostParser;
  function iPv4NumberParser(input, validationErrorFlag) {
    if (validationErrorFlag === undefined) {
      validationErrorFlag = { value: false };
    }
    var R = 10;
    if (input.startsWith("0x") || input.startsWith("0X")) {
      validationErrorFlag.value = true;
      input = input.substr(2);
      R = 16;
    } else if (input.length >= 2 && input[0] === "0") {
      validationErrorFlag.value = true;
      input = input.substr(1);
      R = 8;
    }
    if (input === "")
      return 0;
    var radixRDigits = R === 10 ? /^[0-9]+$/ : R === 16 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/;
    if (!radixRDigits.test(input))
      return null;
    return parseInt(input, R);
  }
  exports.iPv4NumberParser = iPv4NumberParser;
  function iPv4Parser(input) {
    var e_6, _a, e_7, _b;
    var validationErrorFlag = { value: false };
    var parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      validationErrorFlag.value = true;
      if (parts.length > 1)
        parts.pop();
    }
    if (parts.length > 4)
      return input;
    var numbers = [];
    try {
      for (var parts_1 = __values(parts), parts_1_1 = parts_1.next();!parts_1_1.done; parts_1_1 = parts_1.next()) {
        var part = parts_1_1.value;
        if (part === "")
          return input;
        var n = iPv4NumberParser(part, validationErrorFlag);
        if (n === null)
          return input;
        numbers.push(n);
      }
    } catch (e_6_1) {
      e_6 = { error: e_6_1 };
    } finally {
      try {
        if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return))
          _a.call(parts_1);
      } finally {
        if (e_6)
          throw e_6.error;
      }
    }
    if (validationErrorFlag.value)
      validationError("Invalid IP v4 address.");
    for (var i = 0;i < numbers.length; i++) {
      var item = numbers[i];
      if (item > 255) {
        validationError("Invalid IP v4 address.");
        if (i < numbers.length - 1)
          return null;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      validationError("Invalid IP v4 address.");
      return null;
    }
    var ipv4 = numbers[numbers.length - 1];
    numbers.pop();
    var counter = 0;
    try {
      for (var numbers_1 = __values(numbers), numbers_1_1 = numbers_1.next();!numbers_1_1.done; numbers_1_1 = numbers_1.next()) {
        var n = numbers_1_1.value;
        ipv4 += n * Math.pow(256, 3 - counter);
        counter++;
      }
    } catch (e_7_1) {
      e_7 = { error: e_7_1 };
    } finally {
      try {
        if (numbers_1_1 && !numbers_1_1.done && (_b = numbers_1.return))
          _b.call(numbers_1);
      } finally {
        if (e_7)
          throw e_7.error;
      }
    }
    return ipv4;
  }
  exports.iPv4Parser = iPv4Parser;
  function iPv6Parser(input) {
    var _a;
    var EOF = "";
    var address = [0, 0, 0, 0, 0, 0, 0, 0];
    var pieceIndex = 0;
    var compress = null;
    var walker = new util_1.StringWalker(input);
    if (walker.c() === ":") {
      if (!walker.remaining().startsWith(":")) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      walker.pointer += 2;
      pieceIndex += 1;
      compress = pieceIndex;
    }
    while (walker.c() !== EOF) {
      if (pieceIndex === 8) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      if (walker.c() === ":") {
        if (compress !== null) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        walker.pointer++;
        pieceIndex++;
        compress = pieceIndex;
        continue;
      }
      var value = 0;
      var length = 0;
      while (length < 4 && infra_1.codePoint.ASCIIHexDigit.test(walker.c())) {
        value = value * 16 + parseInt(walker.c(), 16);
        walker.pointer++;
        length++;
      }
      if (walker.c() === ".") {
        if (length === 0) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        walker.pointer -= length;
        if (pieceIndex > 6) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        var numbersSeen = 0;
        while (walker.c() !== EOF) {
          var ipv4Piece = null;
          if (numbersSeen > 0) {
            if (walker.c() === "." && numbersSeen < 4) {
              walker.pointer++;
            } else {
              validationError("Invalid IP v6 address.");
              return null;
            }
          }
          if (!infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          while (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            var number = parseInt(walker.c(), 10);
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              validationError("Invalid IP v6 address.");
              return null;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              validationError("Invalid IP v6 address.");
              return null;
            }
            walker.pointer++;
          }
          if (ipv4Piece === null) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          numbersSeen++;
          if (numbersSeen === 2 || numbersSeen === 4)
            pieceIndex++;
        }
        if (numbersSeen !== 4) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        break;
      } else if (walker.c() === ":") {
        walker.pointer++;
        if (walker.c() === EOF) {
          validationError("Invalid IP v6 address.");
          return null;
        }
      } else if (walker.c() !== EOF) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      address[pieceIndex] = value;
      pieceIndex++;
    }
    if (compress !== null) {
      var swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        _a = __read([address[compress + swaps - 1], address[pieceIndex]], 2), address[pieceIndex] = _a[0], address[compress + swaps - 1] = _a[1];
        pieceIndex--;
        swaps--;
      }
    } else if (compress === null && pieceIndex !== 8) {
      validationError("Invalid IP v6 address.");
      return null;
    }
    return address;
  }
  exports.iPv6Parser = iPv6Parser;
  function opaqueHostParser(input) {
    var e_8, _a;
    var forbiddenChars = /[\x00\t\f\r #/:?@\[\\\]]/;
    if (forbiddenChars.test(input)) {
      validationError("Invalid host string.");
      return null;
    }
    var output = "";
    try {
      for (var input_1 = __values(input), input_1_1 = input_1.next();!input_1_1.done; input_1_1 = input_1.next()) {
        var codePoint = input_1_1.value;
        output += utf8PercentEncode(codePoint, _c0ControlPercentEncodeSet);
      }
    } catch (e_8_1) {
      e_8 = { error: e_8_1 };
    } finally {
      try {
        if (input_1_1 && !input_1_1.done && (_a = input_1.return))
          _a.call(input_1);
      } finally {
        if (e_8)
          throw e_8.error;
      }
    }
    return output;
  }
  exports.opaqueHostParser = opaqueHostParser;
  function resolveABlobURL(url) {
    return null;
  }
  exports.resolveABlobURL = resolveABlobURL;
  function percentEncode(value) {
    return "%" + ("00" + value.toString(16).toUpperCase()).slice(-2);
  }
  exports.percentEncode = percentEncode;
  function percentDecode(input) {
    var isHexDigit = function(byte2) {
      return byte2 >= 48 && byte2 <= 57 || byte2 >= 65 && byte2 <= 70 || byte2 >= 97 && byte2 <= 102;
    };
    var output = new Uint8Array(input.length);
    var n = 0;
    for (var i = 0;i < input.length; i++) {
      var byte = input[i];
      if (byte !== 37) {
        output[n] = byte;
        n++;
      } else if (byte === 37 && i >= input.length - 2) {
        output[n] = byte;
        n++;
      } else if (byte === 37 && (!isHexDigit(input[i + 1]) || !isHexDigit(input[i + 2]))) {
        output[n] = byte;
        n++;
      } else {
        var bytePoint = parseInt(util_1.utf8Decode(Uint8Array.of(input[i + 1], input[i + 2])), 16);
        output[n] = bytePoint;
        n++;
        i += 2;
      }
    }
    return output.subarray(0, n);
  }
  exports.percentDecode = percentDecode;
  function stringPercentDecode(input) {
    return percentDecode(util_1.utf8Encode(input));
  }
  exports.stringPercentDecode = stringPercentDecode;
  function utf8PercentEncode(codePoint, percentEncodeSet) {
    var e_9, _a;
    if (!percentEncodeSet.test(codePoint))
      return codePoint;
    var bytes = util_1.utf8Encode(codePoint);
    var result = "";
    try {
      for (var bytes_2 = __values(bytes), bytes_2_1 = bytes_2.next();!bytes_2_1.done; bytes_2_1 = bytes_2.next()) {
        var byte = bytes_2_1.value;
        result += percentEncode(byte);
      }
    } catch (e_9_1) {
      e_9 = { error: e_9_1 };
    } finally {
      try {
        if (bytes_2_1 && !bytes_2_1.done && (_a = bytes_2.return))
          _a.call(bytes_2);
      } finally {
        if (e_9)
          throw e_9.error;
      }
    }
    return result;
  }
  exports.utf8PercentEncode = utf8PercentEncode;
  function hostEquals(hostA, hostB) {
    return hostA === hostB;
  }
  exports.hostEquals = hostEquals;
  function urlEquals(urlA, urlB, excludeFragmentsFlag) {
    if (excludeFragmentsFlag === undefined) {
      excludeFragmentsFlag = false;
    }
    return urlSerializer(urlA, excludeFragmentsFlag) === urlSerializer(urlB, excludeFragmentsFlag);
  }
  exports.urlEquals = urlEquals;
  function urlEncodedStringParser(input) {
    return urlEncodedParser(util_1.utf8Encode(input));
  }
  exports.urlEncodedStringParser = urlEncodedStringParser;
  function urlEncodedParser(input) {
    var e_10, _a, e_11, _b;
    var sequences = [];
    var currentSequence = [];
    try {
      for (var input_2 = __values(input), input_2_1 = input_2.next();!input_2_1.done; input_2_1 = input_2.next()) {
        var byte = input_2_1.value;
        if (byte === 38) {
          sequences.push(Uint8Array.from(currentSequence));
          currentSequence = [];
        } else {
          currentSequence.push(byte);
        }
      }
    } catch (e_10_1) {
      e_10 = { error: e_10_1 };
    } finally {
      try {
        if (input_2_1 && !input_2_1.done && (_a = input_2.return))
          _a.call(input_2);
      } finally {
        if (e_10)
          throw e_10.error;
      }
    }
    if (currentSequence.length !== 0) {
      sequences.push(Uint8Array.from(currentSequence));
    }
    var output = [];
    try {
      for (var sequences_1 = __values(sequences), sequences_1_1 = sequences_1.next();!sequences_1_1.done; sequences_1_1 = sequences_1.next()) {
        var bytes = sequences_1_1.value;
        if (bytes.length === 0)
          continue;
        var index = bytes.indexOf(61);
        var name = index !== -1 ? bytes.slice(0, index) : bytes;
        var value = index !== -1 ? bytes.slice(index + 1) : new Uint8Array;
        for (var i = 0;i < name.length; i++)
          if (name[i] === 43)
            name[i] = 32;
        for (var i = 0;i < value.length; i++)
          if (value[i] === 43)
            value[i] = 32;
        var nameString = util_1.utf8Decode(name);
        var valueString = util_1.utf8Decode(value);
        output.push([nameString, valueString]);
      }
    } catch (e_11_1) {
      e_11 = { error: e_11_1 };
    } finally {
      try {
        if (sequences_1_1 && !sequences_1_1.done && (_b = sequences_1.return))
          _b.call(sequences_1);
      } finally {
        if (e_11)
          throw e_11.error;
      }
    }
    return output;
  }
  exports.urlEncodedParser = urlEncodedParser;
  function urlEncodedByteSerializer(input) {
    var e_12, _a;
    var output = "";
    try {
      for (var input_3 = __values(input), input_3_1 = input_3.next();!input_3_1.done; input_3_1 = input_3.next()) {
        var byte = input_3_1.value;
        if (byte === 32) {
          output += "+";
        } else if (byte === 42 || byte === 45 || byte === 46 || byte >= 48 && byte <= 57 || byte >= 65 && byte <= 90 || byte === 95 || byte >= 97 && byte <= 122) {
          output += String.fromCodePoint(byte);
        } else {
          output += percentEncode(byte);
        }
      }
    } catch (e_12_1) {
      e_12 = { error: e_12_1 };
    } finally {
      try {
        if (input_3_1 && !input_3_1.done && (_a = input_3.return))
          _a.call(input_3);
      } finally {
        if (e_12)
          throw e_12.error;
      }
    }
    return output;
  }
  exports.urlEncodedByteSerializer = urlEncodedByteSerializer;
  function urlEncodedSerializer(tuples, encodingOverride) {
    var e_13, _a;
    var encoding = encodingOverride === undefined || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
    if (encoding.toUpperCase() !== "UTF-8") {
      throw new Error("Only UTF-8 encoding is supported.");
    }
    var output = "";
    try {
      for (var tuples_1 = __values(tuples), tuples_1_1 = tuples_1.next();!tuples_1_1.done; tuples_1_1 = tuples_1.next()) {
        var tuple = tuples_1_1.value;
        var name = urlEncodedByteSerializer(util_1.utf8Encode(tuple[0]));
        var value = tuple[1];
        value = urlEncodedByteSerializer(util_1.utf8Encode(value));
        if (output !== "")
          output += "&";
        output += name + "=" + value;
      }
    } catch (e_13_1) {
      e_13 = { error: e_13_1 };
    } finally {
      try {
        if (tuples_1_1 && !tuples_1_1.done && (_a = tuples_1.return))
          _a.call(tuples_1);
      } finally {
        if (e_13)
          throw e_13.error;
      }
    }
    return output;
  }
  exports.urlEncodedSerializer = urlEncodedSerializer;
  function origin(url) {
    switch (url.scheme) {
      case "blob":
        if (url._blobURLEntry !== null) {
        }
        var parsedURL = basicURLParser(url.path[0]);
        if (parsedURL === null)
          return interfaces_1.OpaqueOrigin;
        else
          return origin(parsedURL);
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return [url.scheme, url.host === null ? "" : url.host, url.port, null];
      case "file":
        return interfaces_1.OpaqueOrigin;
      default:
        return interfaces_1.OpaqueOrigin;
    }
  }
  exports.origin = origin;
  function domainToASCII(domain, beStrict) {
    if (beStrict === undefined) {
      beStrict = false;
    }
    var result = url_1.domainToASCII(domain);
    if (result === "") {
      validationError("Invalid domain name.");
      return null;
    }
    return result;
  }
  exports.domainToASCII = domainToASCII;
  function domainToUnicode(domain, beStrict) {
    if (beStrict === undefined) {
      beStrict = false;
    }
    var result = url_1.domainToUnicode(domain);
    if (result === "") {
      validationError("Invalid domain name.");
    }
    return result;
  }
  exports.domainToUnicode = domainToUnicode;
  function asciiSerializationOfAnOrigin(origin2) {
    if (origin2[0] === "" && origin2[1] === "" && origin2[2] === null && origin2[3] === null) {
      return "null";
    }
    var result = origin2[0] + "://" + hostSerializer(origin2[1]);
    if (origin2[2] !== null)
      result += ":" + origin2[2].toString();
    return result;
  }
  exports.asciiSerializationOfAnOrigin = asciiSerializationOfAnOrigin;
});

// node_modules/@oozcitak/dom/lib/dom/NodeImpl.js
var require_NodeImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var EventTargetImpl_1 = require_EventTargetImpl();
  var util_1 = require_util2();
  var DOMException_1 = require_DOMException();
  var algorithm_1 = require_algorithm();
  var URLAlgorithm_1 = require_URLAlgorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var NodeImpl = function(_super) {
    __extends(NodeImpl2, _super);
    function NodeImpl2() {
      var _this = _super.call(this) || this;
      _this._parent = null;
      _this._firstChild = null;
      _this._lastChild = null;
      _this._previousSibling = null;
      _this._nextSibling = null;
      return _this;
    }
    Object.defineProperty(NodeImpl2.prototype, "_childNodes", {
      get: function() {
        return this.__childNodes || (this.__childNodes = algorithm_1.create_nodeList(this));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "_nodeDocument", {
      get: function() {
        return this._nodeDocumentOverride || DOMImpl_1.dom.window._associatedDocument;
      },
      set: function(val) {
        this._nodeDocumentOverride = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "_registeredObserverList", {
      get: function() {
        return this.__registeredObserverList || (this.__registeredObserverList = []);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "nodeType", {
      get: function() {
        return this._nodeType;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "nodeName", {
      get: function() {
        if (util_1.Guard.isElementNode(this)) {
          return this._htmlUppercasedQualifiedName;
        } else if (util_1.Guard.isAttrNode(this)) {
          return this._qualifiedName;
        } else if (util_1.Guard.isExclusiveTextNode(this)) {
          return "#text";
        } else if (util_1.Guard.isCDATASectionNode(this)) {
          return "#cdata-section";
        } else if (util_1.Guard.isProcessingInstructionNode(this)) {
          return this._target;
        } else if (util_1.Guard.isCommentNode(this)) {
          return "#comment";
        } else if (util_1.Guard.isDocumentNode(this)) {
          return "#document";
        } else if (util_1.Guard.isDocumentTypeNode(this)) {
          return this._name;
        } else if (util_1.Guard.isDocumentFragmentNode(this)) {
          return "#document-fragment";
        } else {
          return "";
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "baseURI", {
      get: function() {
        return URLAlgorithm_1.urlSerializer(this._nodeDocument._URL);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "isConnected", {
      get: function() {
        return util_1.Guard.isElementNode(this) && algorithm_1.shadowTree_isConnected(this);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "ownerDocument", {
      get: function() {
        if (this._nodeType === interfaces_1.NodeType.Document)
          return null;
        else
          return this._nodeDocument;
      },
      enumerable: true,
      configurable: true
    });
    NodeImpl2.prototype.getRootNode = function(options) {
      return algorithm_1.tree_rootNode(this, !!options && options.composed);
    };
    Object.defineProperty(NodeImpl2.prototype, "parentNode", {
      get: function() {
        if (this._nodeType === interfaces_1.NodeType.Attribute) {
          return null;
        } else {
          return this._parent;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "parentElement", {
      get: function() {
        if (this._parent && util_1.Guard.isElementNode(this._parent)) {
          return this._parent;
        } else {
          return null;
        }
      },
      enumerable: true,
      configurable: true
    });
    NodeImpl2.prototype.hasChildNodes = function() {
      return this._firstChild !== null;
    };
    Object.defineProperty(NodeImpl2.prototype, "childNodes", {
      get: function() {
        return this._childNodes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "firstChild", {
      get: function() {
        return this._firstChild;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "lastChild", {
      get: function() {
        return this._lastChild;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "previousSibling", {
      get: function() {
        return this._previousSibling;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "nextSibling", {
      get: function() {
        return this._nextSibling;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "nodeValue", {
      get: function() {
        if (util_1.Guard.isAttrNode(this)) {
          return this._value;
        } else if (util_1.Guard.isCharacterDataNode(this)) {
          return this._data;
        } else {
          return null;
        }
      },
      set: function(value) {
        if (value === null) {
          value = "";
        }
        if (util_1.Guard.isAttrNode(this)) {
          algorithm_1.attr_setAnExistingAttributeValue(this, value);
        } else if (util_1.Guard.isCharacterDataNode(this)) {
          algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeImpl2.prototype, "textContent", {
      get: function() {
        if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
          return algorithm_1.text_descendantTextContent(this);
        } else if (util_1.Guard.isAttrNode(this)) {
          return this._value;
        } else if (util_1.Guard.isCharacterDataNode(this)) {
          return this._data;
        } else {
          return null;
        }
      },
      set: function(value) {
        if (value === null) {
          value = "";
        }
        if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
          algorithm_1.node_stringReplaceAll(value, this);
        } else if (util_1.Guard.isAttrNode(this)) {
          algorithm_1.attr_setAnExistingAttributeValue(this, value);
        } else if (util_1.Guard.isCharacterDataNode(this)) {
          algorithm_1.characterData_replaceData(this, 0, algorithm_1.tree_nodeLength(this), value);
        }
      },
      enumerable: true,
      configurable: true
    });
    NodeImpl2.prototype.normalize = function() {
      var e_1, _a, e_2, _b;
      var descendantNodes = [];
      var node = algorithm_1.tree_getFirstDescendantNode(this, false, false, function(e) {
        return util_1.Guard.isExclusiveTextNode(e);
      });
      while (node !== null) {
        descendantNodes.push(node);
        node = algorithm_1.tree_getNextDescendantNode(this, node, false, false, function(e) {
          return util_1.Guard.isExclusiveTextNode(e);
        });
      }
      for (var i = 0;i < descendantNodes.length; i++) {
        var node_1 = descendantNodes[i];
        if (node_1._parent === null)
          continue;
        var length = algorithm_1.tree_nodeLength(node_1);
        if (length === 0) {
          algorithm_1.mutation_remove(node_1, node_1._parent);
          continue;
        }
        var textSiblings = [];
        var data = "";
        try {
          for (var _c = (e_1 = undefined, __values(algorithm_1.text_contiguousExclusiveTextNodes(node_1))), _d = _c.next();!_d.done; _d = _c.next()) {
            var sibling = _d.value;
            textSiblings.push(sibling);
            data += sibling._data;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return))
              _a.call(_c);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        algorithm_1.characterData_replaceData(node_1, length, 0, data);
        if (DOMImpl_1.dom.rangeList.size !== 0) {
          var currentNode = node_1._nextSibling;
          while (currentNode !== null && util_1.Guard.isExclusiveTextNode(currentNode)) {
            var cn = currentNode;
            var index = algorithm_1.tree_index(cn);
            try {
              for (var _e = (e_2 = undefined, __values(DOMImpl_1.dom.rangeList)), _f = _e.next();!_f.done; _f = _e.next()) {
                var range = _f.value;
                if (range._start[0] === cn) {
                  range._start[0] = node_1;
                  range._start[1] += length;
                }
                if (range._end[0] === cn) {
                  range._end[0] = node_1;
                  range._end[1] += length;
                }
                if (range._start[0] === cn._parent && range._start[1] === index) {
                  range._start[0] = node_1;
                  range._start[1] = length;
                }
                if (range._end[0] === cn._parent && range._end[1] === index) {
                  range._end[0] = node_1;
                  range._end[1] = length;
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_f && !_f.done && (_b = _e.return))
                  _b.call(_e);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
            length += algorithm_1.tree_nodeLength(currentNode);
            currentNode = currentNode._nextSibling;
          }
        }
        for (var i_1 = 0;i_1 < textSiblings.length; i_1++) {
          var sibling = textSiblings[i_1];
          if (sibling._parent === null)
            continue;
          algorithm_1.mutation_remove(sibling, sibling._parent);
        }
      }
    };
    NodeImpl2.prototype.cloneNode = function(deep) {
      if (deep === undefined) {
        deep = false;
      }
      if (util_1.Guard.isShadowRoot(this))
        throw new DOMException_1.NotSupportedError;
      return algorithm_1.node_clone(this, null, deep);
    };
    NodeImpl2.prototype.isEqualNode = function(node) {
      if (node === undefined) {
        node = null;
      }
      return node !== null && algorithm_1.node_equals(this, node);
    };
    NodeImpl2.prototype.isSameNode = function(node) {
      if (node === undefined) {
        node = null;
      }
      return this === node;
    };
    NodeImpl2.prototype.compareDocumentPosition = function(other) {
      if (other === this)
        return 0;
      var node1 = other;
      var node2 = this;
      var attr1 = null;
      var attr2 = null;
      if (util_1.Guard.isAttrNode(node1)) {
        attr1 = node1;
        node1 = attr1._element;
      }
      if (util_1.Guard.isAttrNode(node2)) {
        attr2 = node2;
        node2 = attr2._element;
        if (attr1 && node1 && node1 === node2) {
          for (var i = 0;i < node2._attributeList.length; i++) {
            var attr = node2._attributeList[i];
            if (algorithm_1.node_equals(attr, attr1)) {
              return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Preceding;
            } else if (algorithm_1.node_equals(attr, attr2)) {
              return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Following;
            }
          }
        }
      }
      if (node1 === null || node2 === null || algorithm_1.tree_rootNode(node1) !== algorithm_1.tree_rootNode(node2)) {
        return interfaces_1.Position.Disconnected | interfaces_1.Position.ImplementationSpecific | (DOMImpl_1.dom.compareCache.check(this, other) ? interfaces_1.Position.Preceding : interfaces_1.Position.Following);
      }
      if (!attr1 && algorithm_1.tree_isAncestorOf(node2, node1) || attr2 && node1 === node2) {
        return interfaces_1.Position.Contains | interfaces_1.Position.Preceding;
      }
      if (!attr2 && algorithm_1.tree_isDescendantOf(node2, node1) || attr1 && node1 === node2) {
        return interfaces_1.Position.ContainedBy | interfaces_1.Position.Following;
      }
      if (algorithm_1.tree_isPreceding(node2, node1))
        return interfaces_1.Position.Preceding;
      return interfaces_1.Position.Following;
    };
    NodeImpl2.prototype.contains = function(other) {
      if (other === null)
        return false;
      return algorithm_1.tree_isDescendantOf(this, other, true);
    };
    NodeImpl2.prototype.lookupPrefix = function(namespace) {
      if (!namespace)
        return null;
      if (util_1.Guard.isElementNode(this)) {
        return algorithm_1.node_locateANamespacePrefix(this, namespace);
      } else if (util_1.Guard.isDocumentNode(this)) {
        if (this.documentElement === null) {
          return null;
        } else {
          return algorithm_1.node_locateANamespacePrefix(this.documentElement, namespace);
        }
      } else if (util_1.Guard.isDocumentTypeNode(this) || util_1.Guard.isDocumentFragmentNode(this)) {
        return null;
      } else if (util_1.Guard.isAttrNode(this)) {
        if (this._element === null) {
          return null;
        } else {
          return algorithm_1.node_locateANamespacePrefix(this._element, namespace);
        }
      } else {
        if (this._parent !== null && util_1.Guard.isElementNode(this._parent)) {
          return algorithm_1.node_locateANamespacePrefix(this._parent, namespace);
        } else {
          return null;
        }
      }
    };
    NodeImpl2.prototype.lookupNamespaceURI = function(prefix) {
      return algorithm_1.node_locateANamespace(this, prefix || null);
    };
    NodeImpl2.prototype.isDefaultNamespace = function(namespace) {
      if (!namespace)
        namespace = null;
      var defaultNamespace = algorithm_1.node_locateANamespace(this, null);
      return defaultNamespace === namespace;
    };
    NodeImpl2.prototype.insertBefore = function(newChild, refChild) {
      return algorithm_1.mutation_preInsert(newChild, this, refChild);
    };
    NodeImpl2.prototype.appendChild = function(newChild) {
      return algorithm_1.mutation_append(newChild, this);
    };
    NodeImpl2.prototype.replaceChild = function(newChild, oldChild) {
      return algorithm_1.mutation_replace(oldChild, newChild, this);
    };
    NodeImpl2.prototype.removeChild = function(oldChild) {
      return algorithm_1.mutation_preRemove(oldChild, this);
    };
    NodeImpl2.prototype._getTheParent = function(event) {
      if (util_1.Guard.isSlotable(this) && algorithm_1.shadowTree_isAssigned(this)) {
        return this._assignedSlot;
      } else {
        return this._parent;
      }
    };
    NodeImpl2.ELEMENT_NODE = 1;
    NodeImpl2.ATTRIBUTE_NODE = 2;
    NodeImpl2.TEXT_NODE = 3;
    NodeImpl2.CDATA_SECTION_NODE = 4;
    NodeImpl2.ENTITY_REFERENCE_NODE = 5;
    NodeImpl2.ENTITY_NODE = 6;
    NodeImpl2.PROCESSING_INSTRUCTION_NODE = 7;
    NodeImpl2.COMMENT_NODE = 8;
    NodeImpl2.DOCUMENT_NODE = 9;
    NodeImpl2.DOCUMENT_TYPE_NODE = 10;
    NodeImpl2.DOCUMENT_FRAGMENT_NODE = 11;
    NodeImpl2.NOTATION_NODE = 12;
    NodeImpl2.DOCUMENT_POSITION_DISCONNECTED = 1;
    NodeImpl2.DOCUMENT_POSITION_PRECEDING = 2;
    NodeImpl2.DOCUMENT_POSITION_FOLLOWING = 4;
    NodeImpl2.DOCUMENT_POSITION_CONTAINS = 8;
    NodeImpl2.DOCUMENT_POSITION_CONTAINED_BY = 16;
    NodeImpl2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
    return NodeImpl2;
  }(EventTargetImpl_1.EventTargetImpl);
  exports.NodeImpl = NodeImpl;
  NodeImpl.prototype._children = new util_1.EmptySet;
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ELEMENT_NODE", 1);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ATTRIBUTE_NODE", 2);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "TEXT_NODE", 3);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "CDATA_SECTION_NODE", 4);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ENTITY_REFERENCE_NODE", 5);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ENTITY_NODE", 6);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "PROCESSING_INSTRUCTION_NODE", 7);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "COMMENT_NODE", 8);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_NODE", 9);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_TYPE_NODE", 10);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_FRAGMENT_NODE", 11);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "NOTATION_NODE", 12);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_DISCONNECTED", 1);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_PRECEDING", 2);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_FOLLOWING", 4);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINS", 8);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 16);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 32);
});

// node_modules/@oozcitak/dom/lib/dom/DocumentImpl.js
var require_DocumentImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var DOMException_1 = require_DOMException();
  var NodeImpl_1 = require_NodeImpl();
  var util_1 = require_util2();
  var util_2 = require_lib8();
  var infra_1 = require_lib10();
  var URLAlgorithm_1 = require_URLAlgorithm();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var DocumentImpl = function(_super) {
    __extends(DocumentImpl2, _super);
    function DocumentImpl2() {
      var _this = _super.call(this) || this;
      _this._children = new Set;
      _this._encoding = {
        name: "UTF-8",
        labels: ["unicode-1-1-utf-8", "utf-8", "utf8"]
      };
      _this._contentType = "application/xml";
      _this._URL = {
        scheme: "about",
        username: "",
        password: "",
        host: null,
        port: null,
        path: ["blank"],
        query: null,
        fragment: null,
        _cannotBeABaseURLFlag: true,
        _blobURLEntry: null
      };
      _this._origin = null;
      _this._type = "xml";
      _this._mode = "no-quirks";
      _this._documentElement = null;
      _this._hasNamespaces = false;
      _this._nodeDocumentOverwrite = null;
      return _this;
    }
    Object.defineProperty(DocumentImpl2.prototype, "_nodeDocument", {
      get: function() {
        return this._nodeDocumentOverwrite || this;
      },
      set: function(val) {
        this._nodeDocumentOverwrite = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "implementation", {
      get: function() {
        return this._implementation || (this._implementation = algorithm_1.create_domImplementation(this));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "URL", {
      get: function() {
        return URLAlgorithm_1.urlSerializer(this._URL);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "documentURI", {
      get: function() {
        return this.URL;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "origin", {
      get: function() {
        return "null";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "compatMode", {
      get: function() {
        return this._mode === "quirks" ? "BackCompat" : "CSS1Compat";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "characterSet", {
      get: function() {
        return this._encoding.name;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "charset", {
      get: function() {
        return this._encoding.name;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "inputEncoding", {
      get: function() {
        return this._encoding.name;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "contentType", {
      get: function() {
        return this._contentType;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "doctype", {
      get: function() {
        var e_1, _a;
        try {
          for (var _b = __values(this._children), _c = _b.next();!_c.done; _c = _b.next()) {
            var child = _c.value;
            if (util_1.Guard.isDocumentTypeNode(child))
              return child;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "documentElement", {
      get: function() {
        return this._documentElement;
      },
      enumerable: true,
      configurable: true
    });
    DocumentImpl2.prototype.getElementsByTagName = function(qualifiedName) {
      return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    };
    DocumentImpl2.prototype.getElementsByTagNameNS = function(namespace, localName) {
      return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    };
    DocumentImpl2.prototype.getElementsByClassName = function(classNames) {
      return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    };
    DocumentImpl2.prototype.createElement = function(localName, options) {
      if (!algorithm_1.xml_isName(localName))
        throw new DOMException_1.InvalidCharacterError;
      if (this._type === "html")
        localName = localName.toLowerCase();
      var is = null;
      if (options !== undefined) {
        if (util_2.isString(options)) {
          is = options;
        } else {
          is = options.is;
        }
      }
      var namespace = this._type === "html" || this._contentType === "application/xhtml+xml" ? infra_1.namespace.HTML : null;
      return algorithm_1.element_createAnElement(this, localName, namespace, null, is, true);
    };
    DocumentImpl2.prototype.createElementNS = function(namespace, qualifiedName, options) {
      return algorithm_1.document_internalCreateElementNS(this, namespace, qualifiedName, options);
    };
    DocumentImpl2.prototype.createDocumentFragment = function() {
      return algorithm_1.create_documentFragment(this);
    };
    DocumentImpl2.prototype.createTextNode = function(data) {
      return algorithm_1.create_text(this, data);
    };
    DocumentImpl2.prototype.createCDATASection = function(data) {
      if (this._type === "html")
        throw new DOMException_1.NotSupportedError;
      if (data.indexOf("]]>") !== -1)
        throw new DOMException_1.InvalidCharacterError;
      return algorithm_1.create_cdataSection(this, data);
    };
    DocumentImpl2.prototype.createComment = function(data) {
      return algorithm_1.create_comment(this, data);
    };
    DocumentImpl2.prototype.createProcessingInstruction = function(target, data) {
      if (!algorithm_1.xml_isName(target))
        throw new DOMException_1.InvalidCharacterError;
      if (data.indexOf("?>") !== -1)
        throw new DOMException_1.InvalidCharacterError;
      return algorithm_1.create_processingInstruction(this, target, data);
    };
    DocumentImpl2.prototype.importNode = function(node, deep) {
      if (deep === undefined) {
        deep = false;
      }
      if (util_1.Guard.isDocumentNode(node) || util_1.Guard.isShadowRoot(node))
        throw new DOMException_1.NotSupportedError;
      return algorithm_1.node_clone(node, this, deep);
    };
    DocumentImpl2.prototype.adoptNode = function(node) {
      if (util_1.Guard.isDocumentNode(node))
        throw new DOMException_1.NotSupportedError;
      if (util_1.Guard.isShadowRoot(node))
        throw new DOMException_1.HierarchyRequestError;
      algorithm_1.document_adopt(node, this);
      return node;
    };
    DocumentImpl2.prototype.createAttribute = function(localName) {
      if (!algorithm_1.xml_isName(localName))
        throw new DOMException_1.InvalidCharacterError;
      if (this._type === "html") {
        localName = localName.toLowerCase();
      }
      var attr = algorithm_1.create_attr(this, localName);
      return attr;
    };
    DocumentImpl2.prototype.createAttributeNS = function(namespace, qualifiedName) {
      var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
      var attr = algorithm_1.create_attr(this, localName);
      attr._namespace = ns;
      attr._namespacePrefix = prefix;
      return attr;
    };
    DocumentImpl2.prototype.createEvent = function(eventInterface) {
      return algorithm_1.event_createLegacyEvent(eventInterface);
    };
    DocumentImpl2.prototype.createRange = function() {
      var range = algorithm_1.create_range();
      range._start = [this, 0];
      range._end = [this, 0];
      return range;
    };
    DocumentImpl2.prototype.createNodeIterator = function(root, whatToShow, filter) {
      if (whatToShow === undefined) {
        whatToShow = interfaces_1.WhatToShow.All;
      }
      if (filter === undefined) {
        filter = null;
      }
      var iterator = algorithm_1.create_nodeIterator(root, root, true);
      iterator._whatToShow = whatToShow;
      iterator._iteratorCollection = algorithm_1.create_nodeList(root);
      if (util_2.isFunction(filter)) {
        iterator._filter = algorithm_1.create_nodeFilter();
        iterator._filter.acceptNode = filter;
      } else {
        iterator._filter = filter;
      }
      return iterator;
    };
    DocumentImpl2.prototype.createTreeWalker = function(root, whatToShow, filter) {
      if (whatToShow === undefined) {
        whatToShow = interfaces_1.WhatToShow.All;
      }
      if (filter === undefined) {
        filter = null;
      }
      var walker = algorithm_1.create_treeWalker(root, root);
      walker._whatToShow = whatToShow;
      if (util_2.isFunction(filter)) {
        walker._filter = algorithm_1.create_nodeFilter();
        walker._filter.acceptNode = filter;
      } else {
        walker._filter = filter;
      }
      return walker;
    };
    DocumentImpl2.prototype._getTheParent = function(event) {
      if (event._type === "load") {
        return null;
      } else {
        return DOMImpl_1.dom.window;
      }
    };
    DocumentImpl2.prototype.getElementById = function(elementId) {
      throw new Error("Mixin: NonElementParentNode not implemented.");
    };
    Object.defineProperty(DocumentImpl2.prototype, "children", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "firstElementChild", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "lastElementChild", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentImpl2.prototype, "childElementCount", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    DocumentImpl2.prototype.prepend = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ParentNode not implemented.");
    };
    DocumentImpl2.prototype.append = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ParentNode not implemented.");
    };
    DocumentImpl2.prototype.querySelector = function(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    };
    DocumentImpl2.prototype.querySelectorAll = function(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    };
    return DocumentImpl2;
  }(NodeImpl_1.NodeImpl);
  exports.DocumentImpl = DocumentImpl;
  WebIDLAlgorithm_1.idl_defineConst(DocumentImpl.prototype, "_nodeType", interfaces_1.NodeType.Document);
});

// node_modules/@oozcitak/dom/lib/dom/XMLDocumentImpl.js
var require_XMLDocumentImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var DocumentImpl_1 = require_DocumentImpl();
  var XMLDocumentImpl = function(_super) {
    __extends(XMLDocumentImpl2, _super);
    function XMLDocumentImpl2() {
      return _super.call(this) || this;
    }
    return XMLDocumentImpl2;
  }(DocumentImpl_1.DocumentImpl);
  exports.XMLDocumentImpl = XMLDocumentImpl;
});

// node_modules/@oozcitak/dom/lib/dom/AbortControllerImpl.js
var require_AbortControllerImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var algorithm_1 = require_algorithm();
  var AbortControllerImpl = function() {
    function AbortControllerImpl2() {
      this._signal = algorithm_1.create_abortSignal();
    }
    Object.defineProperty(AbortControllerImpl2.prototype, "signal", {
      get: function() {
        return this._signal;
      },
      enumerable: true,
      configurable: true
    });
    AbortControllerImpl2.prototype.abort = function() {
      algorithm_1.abort_signalAbort(this._signal);
    };
    return AbortControllerImpl2;
  }();
  exports.AbortControllerImpl = AbortControllerImpl;
});

// node_modules/@oozcitak/dom/lib/dom/AbortSignalImpl.js
var require_AbortSignalImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var EventTargetImpl_1 = require_EventTargetImpl();
  var algorithm_1 = require_algorithm();
  var AbortSignalImpl = function(_super) {
    __extends(AbortSignalImpl2, _super);
    function AbortSignalImpl2() {
      var _this = _super.call(this) || this;
      _this._abortedFlag = false;
      _this._abortAlgorithms = new Set;
      return _this;
    }
    Object.defineProperty(AbortSignalImpl2.prototype, "aborted", {
      get: function() {
        return this._abortedFlag;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbortSignalImpl2.prototype, "onabort", {
      get: function() {
        return algorithm_1.event_getterEventHandlerIDLAttribute(this, "onabort");
      },
      set: function(val) {
        algorithm_1.event_setterEventHandlerIDLAttribute(this, "onabort", val);
      },
      enumerable: true,
      configurable: true
    });
    AbortSignalImpl2._create = function() {
      return new AbortSignalImpl2;
    };
    return AbortSignalImpl2;
  }(EventTargetImpl_1.EventTargetImpl);
  exports.AbortSignalImpl = AbortSignalImpl;
});

// node_modules/@oozcitak/dom/lib/dom/DocumentTypeImpl.js
var require_DocumentTypeImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var NodeImpl_1 = require_NodeImpl();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var DocumentTypeImpl = function(_super) {
    __extends(DocumentTypeImpl2, _super);
    function DocumentTypeImpl2(name, publicId, systemId) {
      var _this = _super.call(this) || this;
      _this._name = "";
      _this._publicId = "";
      _this._systemId = "";
      _this._name = name;
      _this._publicId = publicId;
      _this._systemId = systemId;
      return _this;
    }
    Object.defineProperty(DocumentTypeImpl2.prototype, "name", {
      get: function() {
        return this._name;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentTypeImpl2.prototype, "publicId", {
      get: function() {
        return this._publicId;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentTypeImpl2.prototype, "systemId", {
      get: function() {
        return this._systemId;
      },
      enumerable: true,
      configurable: true
    });
    DocumentTypeImpl2.prototype.before = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    DocumentTypeImpl2.prototype.after = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    DocumentTypeImpl2.prototype.replaceWith = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    DocumentTypeImpl2.prototype.remove = function() {
      throw new Error("Mixin: ChildNode not implemented.");
    };
    DocumentTypeImpl2._create = function(document2, name, publicId, systemId) {
      if (publicId === undefined) {
        publicId = "";
      }
      if (systemId === undefined) {
        systemId = "";
      }
      var node = new DocumentTypeImpl2(name, publicId, systemId);
      node._nodeDocument = document2;
      return node;
    };
    return DocumentTypeImpl2;
  }(NodeImpl_1.NodeImpl);
  exports.DocumentTypeImpl = DocumentTypeImpl;
  WebIDLAlgorithm_1.idl_defineConst(DocumentTypeImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentType);
});

// node_modules/@oozcitak/dom/lib/dom/ElementImpl.js
var require_ElementImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var NodeImpl_1 = require_NodeImpl();
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib10();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var ElementImpl = function(_super) {
    __extends(ElementImpl2, _super);
    function ElementImpl2() {
      var _this = _super.call(this) || this;
      _this._children = new Set;
      _this._namespace = null;
      _this._namespacePrefix = null;
      _this._localName = "";
      _this._customElementState = "undefined";
      _this._customElementDefinition = null;
      _this._is = null;
      _this._shadowRoot = null;
      _this._attributeList = algorithm_1.create_namedNodeMap(_this);
      _this._attributeChangeSteps = [];
      _this._name = "";
      _this._assignedSlot = null;
      return _this;
    }
    Object.defineProperty(ElementImpl2.prototype, "namespaceURI", {
      get: function() {
        return this._namespace;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "prefix", {
      get: function() {
        return this._namespacePrefix;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "localName", {
      get: function() {
        return this._localName;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "tagName", {
      get: function() {
        return this._htmlUppercasedQualifiedName;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "id", {
      get: function() {
        return algorithm_1.element_getAnAttributeValue(this, "id");
      },
      set: function(value) {
        algorithm_1.element_setAnAttributeValue(this, "id", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "className", {
      get: function() {
        return algorithm_1.element_getAnAttributeValue(this, "class");
      },
      set: function(value) {
        algorithm_1.element_setAnAttributeValue(this, "class", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "classList", {
      get: function() {
        var attr = algorithm_1.element_getAnAttributeByName("class", this);
        if (attr === null) {
          attr = algorithm_1.create_attr(this._nodeDocument, "class");
        }
        return algorithm_1.create_domTokenList(this, attr);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "slot", {
      get: function() {
        return algorithm_1.element_getAnAttributeValue(this, "slot");
      },
      set: function(value) {
        algorithm_1.element_setAnAttributeValue(this, "slot", value);
      },
      enumerable: true,
      configurable: true
    });
    ElementImpl2.prototype.hasAttributes = function() {
      return this._attributeList.length !== 0;
    };
    Object.defineProperty(ElementImpl2.prototype, "attributes", {
      get: function() {
        return this._attributeList;
      },
      enumerable: true,
      configurable: true
    });
    ElementImpl2.prototype.getAttributeNames = function() {
      var e_1, _a;
      var names = [];
      try {
        for (var _b = __values(this._attributeList), _c = _b.next();!_c.done; _c = _b.next()) {
          var attr = _c.value;
          names.push(attr._qualifiedName);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return names;
    };
    ElementImpl2.prototype.getAttribute = function(qualifiedName) {
      var attr = algorithm_1.element_getAnAttributeByName(qualifiedName, this);
      return attr ? attr._value : null;
    };
    ElementImpl2.prototype.getAttributeNS = function(namespace, localName) {
      var attr = algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
      return attr ? attr._value : null;
    };
    ElementImpl2.prototype.setAttribute = function(qualifiedName, value) {
      if (!algorithm_1.xml_isName(qualifiedName))
        throw new DOMException_1.InvalidCharacterError;
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      var attribute = null;
      for (var i = 0;i < this._attributeList.length; i++) {
        var attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          attribute = attr;
          break;
        }
      }
      if (attribute === null) {
        attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
        attribute._value = value;
        algorithm_1.element_append(attribute, this);
        return;
      }
      algorithm_1.element_change(attribute, this, value);
    };
    ElementImpl2.prototype.setAttributeNS = function(namespace, qualifiedName, value) {
      var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
      algorithm_1.element_setAnAttributeValue(this, localName, value, prefix, ns);
    };
    ElementImpl2.prototype.removeAttribute = function(qualifiedName) {
      algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
    };
    ElementImpl2.prototype.removeAttributeNS = function(namespace, localName) {
      algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    };
    ElementImpl2.prototype.hasAttribute = function(qualifiedName) {
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      for (var i = 0;i < this._attributeList.length; i++) {
        var attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          return true;
        }
      }
      return false;
    };
    ElementImpl2.prototype.toggleAttribute = function(qualifiedName, force) {
      if (!algorithm_1.xml_isName(qualifiedName))
        throw new DOMException_1.InvalidCharacterError;
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      var attribute = null;
      for (var i = 0;i < this._attributeList.length; i++) {
        var attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          attribute = attr;
          break;
        }
      }
      if (attribute === null) {
        if (force === undefined || force === true) {
          attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
          attribute._value = "";
          algorithm_1.element_append(attribute, this);
          return true;
        }
        return false;
      } else if (force === undefined || force === false) {
        algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
        return false;
      }
      return true;
    };
    ElementImpl2.prototype.hasAttributeNS = function(namespace, localName) {
      var ns = namespace || null;
      for (var i = 0;i < this._attributeList.length; i++) {
        var attr = this._attributeList[i];
        if (attr._namespace === ns && attr._localName === localName) {
          return true;
        }
      }
      return false;
    };
    ElementImpl2.prototype.getAttributeNode = function(qualifiedName) {
      return algorithm_1.element_getAnAttributeByName(qualifiedName, this);
    };
    ElementImpl2.prototype.getAttributeNodeNS = function(namespace, localName) {
      return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    };
    ElementImpl2.prototype.setAttributeNode = function(attr) {
      return algorithm_1.element_setAnAttribute(attr, this);
    };
    ElementImpl2.prototype.setAttributeNodeNS = function(attr) {
      return algorithm_1.element_setAnAttribute(attr, this);
    };
    ElementImpl2.prototype.removeAttributeNode = function(attr) {
      var found = false;
      for (var i = 0;i < this._attributeList.length; i++) {
        var attribute = this._attributeList[i];
        if (attribute === attr) {
          found = true;
          break;
        }
      }
      if (!found)
        throw new DOMException_1.NotFoundError;
      algorithm_1.element_remove(attr, this);
      return attr;
    };
    ElementImpl2.prototype.attachShadow = function(init) {
      if (this._namespace !== infra_1.namespace.HTML)
        throw new DOMException_1.NotSupportedError;
      if (!algorithm_1.customElement_isValidCustomElementName(this._localName) && !algorithm_1.customElement_isValidShadowHostName(this._localName))
        throw new DOMException_1.NotSupportedError;
      if (algorithm_1.customElement_isValidCustomElementName(this._localName) || this._is !== null) {
        var definition = algorithm_1.customElement_lookUpACustomElementDefinition(this._nodeDocument, this._namespace, this._localName, this._is);
        if (definition !== null && definition.disableShadow === true) {
          throw new DOMException_1.NotSupportedError;
        }
      }
      if (this._shadowRoot !== null)
        throw new DOMException_1.NotSupportedError;
      var shadow = algorithm_1.create_shadowRoot(this._nodeDocument, this);
      shadow._mode = init.mode;
      this._shadowRoot = shadow;
      return shadow;
    };
    Object.defineProperty(ElementImpl2.prototype, "shadowRoot", {
      get: function() {
        var shadow = this._shadowRoot;
        if (shadow === null || shadow.mode === "closed")
          return null;
        else
          return shadow;
      },
      enumerable: true,
      configurable: true
    });
    ElementImpl2.prototype.closest = function(selectors) {
      throw new DOMException_1.NotImplementedError;
    };
    ElementImpl2.prototype.matches = function(selectors) {
      throw new DOMException_1.NotImplementedError;
    };
    ElementImpl2.prototype.webkitMatchesSelector = function(selectors) {
      return this.matches(selectors);
    };
    ElementImpl2.prototype.getElementsByTagName = function(qualifiedName) {
      return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    };
    ElementImpl2.prototype.getElementsByTagNameNS = function(namespace, localName) {
      return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    };
    ElementImpl2.prototype.getElementsByClassName = function(classNames) {
      return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    };
    ElementImpl2.prototype.insertAdjacentElement = function(where, element) {
      return algorithm_1.element_insertAdjacent(this, where, element);
    };
    ElementImpl2.prototype.insertAdjacentText = function(where, data) {
      var text = algorithm_1.create_text(this._nodeDocument, data);
      algorithm_1.element_insertAdjacent(this, where, text);
    };
    Object.defineProperty(ElementImpl2.prototype, "_qualifiedName", {
      get: function() {
        return this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "_htmlUppercasedQualifiedName", {
      get: function() {
        var qualifiedName = this._qualifiedName;
        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
          qualifiedName = qualifiedName.toUpperCase();
        }
        return qualifiedName;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "children", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "firstElementChild", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "lastElementChild", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "childElementCount", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    ElementImpl2.prototype.prepend = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ParentNode not implemented.");
    };
    ElementImpl2.prototype.append = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ParentNode not implemented.");
    };
    ElementImpl2.prototype.querySelector = function(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    };
    ElementImpl2.prototype.querySelectorAll = function(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    };
    Object.defineProperty(ElementImpl2.prototype, "previousElementSibling", {
      get: function() {
        throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ElementImpl2.prototype, "nextElementSibling", {
      get: function() {
        throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    ElementImpl2.prototype.before = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    ElementImpl2.prototype.after = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    ElementImpl2.prototype.replaceWith = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    ElementImpl2.prototype.remove = function() {
      throw new Error("Mixin: ChildNode not implemented.");
    };
    Object.defineProperty(ElementImpl2.prototype, "assignedSlot", {
      get: function() {
        throw new Error("Mixin: Slotable not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    ElementImpl2._create = function(document2, localName, namespace, namespacePrefix) {
      if (namespace === undefined) {
        namespace = null;
      }
      if (namespacePrefix === undefined) {
        namespacePrefix = null;
      }
      var node = new ElementImpl2;
      node._localName = localName;
      node._namespace = namespace;
      node._namespacePrefix = namespacePrefix;
      node._nodeDocument = document2;
      return node;
    };
    return ElementImpl2;
  }(NodeImpl_1.NodeImpl);
  exports.ElementImpl = ElementImpl;
  WebIDLAlgorithm_1.idl_defineConst(ElementImpl.prototype, "_nodeType", interfaces_1.NodeType.Element);
});

// node_modules/@oozcitak/dom/lib/dom/DocumentFragmentImpl.js
var require_DocumentFragmentImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var NodeImpl_1 = require_NodeImpl();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var DocumentFragmentImpl = function(_super) {
    __extends(DocumentFragmentImpl2, _super);
    function DocumentFragmentImpl2(host) {
      if (host === undefined) {
        host = null;
      }
      var _this = _super.call(this) || this;
      _this._children = new Set;
      _this._host = host;
      return _this;
    }
    DocumentFragmentImpl2.prototype.getElementById = function(elementId) {
      throw new Error("Mixin: NonElementParentNode not implemented.");
    };
    Object.defineProperty(DocumentFragmentImpl2.prototype, "children", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl2.prototype, "firstElementChild", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl2.prototype, "lastElementChild", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl2.prototype, "childElementCount", {
      get: function() {
        throw new Error("Mixin: ParentNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    DocumentFragmentImpl2.prototype.prepend = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ParentNode not implemented.");
    };
    DocumentFragmentImpl2.prototype.append = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ParentNode not implemented.");
    };
    DocumentFragmentImpl2.prototype.querySelector = function(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    };
    DocumentFragmentImpl2.prototype.querySelectorAll = function(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    };
    DocumentFragmentImpl2._create = function(document2, host) {
      if (host === undefined) {
        host = null;
      }
      var node = new DocumentFragmentImpl2(host);
      node._nodeDocument = document2;
      return node;
    };
    return DocumentFragmentImpl2;
  }(NodeImpl_1.NodeImpl);
  exports.DocumentFragmentImpl = DocumentFragmentImpl;
  WebIDLAlgorithm_1.idl_defineConst(DocumentFragmentImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentFragment);
});

// node_modules/@oozcitak/dom/lib/dom/ShadowRootImpl.js
var require_ShadowRootImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
  var util_1 = require_lib8();
  var algorithm_1 = require_algorithm();
  var ShadowRootImpl = function(_super) {
    __extends(ShadowRootImpl2, _super);
    function ShadowRootImpl2(host, mode) {
      var _this = _super.call(this) || this;
      _this._host = host;
      _this._mode = mode;
      return _this;
    }
    Object.defineProperty(ShadowRootImpl2.prototype, "mode", {
      get: function() {
        return this._mode;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ShadowRootImpl2.prototype, "host", {
      get: function() {
        return this._host;
      },
      enumerable: true,
      configurable: true
    });
    ShadowRootImpl2.prototype._getTheParent = function(event) {
      if (!event._composedFlag && !util_1.isEmpty(event._path) && algorithm_1.tree_rootNode(event._path[0].invocationTarget) === this) {
        return null;
      } else {
        return this._host;
      }
    };
    ShadowRootImpl2._create = function(document2, host) {
      return new ShadowRootImpl2(host, "closed");
    };
    return ShadowRootImpl2;
  }(DocumentFragmentImpl_1.DocumentFragmentImpl);
  exports.ShadowRootImpl = ShadowRootImpl;
});

// node_modules/@oozcitak/dom/lib/dom/AttrImpl.js
var require_AttrImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var NodeImpl_1 = require_NodeImpl();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var AttrImpl = function(_super) {
    __extends(AttrImpl2, _super);
    function AttrImpl2(localName) {
      var _this = _super.call(this) || this;
      _this._namespace = null;
      _this._namespacePrefix = null;
      _this._element = null;
      _this._value = "";
      _this._localName = localName;
      return _this;
    }
    Object.defineProperty(AttrImpl2.prototype, "ownerElement", {
      get: function() {
        return this._element;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AttrImpl2.prototype, "namespaceURI", {
      get: function() {
        return this._namespace;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AttrImpl2.prototype, "prefix", {
      get: function() {
        return this._namespacePrefix;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AttrImpl2.prototype, "localName", {
      get: function() {
        return this._localName;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AttrImpl2.prototype, "name", {
      get: function() {
        return this._qualifiedName;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AttrImpl2.prototype, "value", {
      get: function() {
        return this._value;
      },
      set: function(value) {
        algorithm_1.attr_setAnExistingAttributeValue(this, value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AttrImpl2.prototype, "_qualifiedName", {
      get: function() {
        return this._namespacePrefix !== null ? this._namespacePrefix + ":" + this._localName : this._localName;
      },
      enumerable: true,
      configurable: true
    });
    AttrImpl2._create = function(document2, localName) {
      var node = new AttrImpl2(localName);
      node._nodeDocument = document2;
      return node;
    };
    return AttrImpl2;
  }(NodeImpl_1.NodeImpl);
  exports.AttrImpl = AttrImpl;
  WebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, "_nodeType", interfaces_1.NodeType.Attribute);
  WebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, "specified", true);
});

// node_modules/@oozcitak/dom/lib/dom/CharacterDataImpl.js
var require_CharacterDataImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var NodeImpl_1 = require_NodeImpl();
  var algorithm_1 = require_algorithm();
  var CharacterDataImpl = function(_super) {
    __extends(CharacterDataImpl2, _super);
    function CharacterDataImpl2(data) {
      var _this = _super.call(this) || this;
      _this._data = data;
      return _this;
    }
    Object.defineProperty(CharacterDataImpl2.prototype, "data", {
      get: function() {
        return this._data;
      },
      set: function(value) {
        algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CharacterDataImpl2.prototype, "length", {
      get: function() {
        return this._data.length;
      },
      enumerable: true,
      configurable: true
    });
    CharacterDataImpl2.prototype.substringData = function(offset, count) {
      return algorithm_1.characterData_substringData(this, offset, count);
    };
    CharacterDataImpl2.prototype.appendData = function(data) {
      return algorithm_1.characterData_replaceData(this, this._data.length, 0, data);
    };
    CharacterDataImpl2.prototype.insertData = function(offset, data) {
      algorithm_1.characterData_replaceData(this, offset, 0, data);
    };
    CharacterDataImpl2.prototype.deleteData = function(offset, count) {
      algorithm_1.characterData_replaceData(this, offset, count, "");
    };
    CharacterDataImpl2.prototype.replaceData = function(offset, count, data) {
      algorithm_1.characterData_replaceData(this, offset, count, data);
    };
    Object.defineProperty(CharacterDataImpl2.prototype, "previousElementSibling", {
      get: function() {
        throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CharacterDataImpl2.prototype, "nextElementSibling", {
      get: function() {
        throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    CharacterDataImpl2.prototype.before = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    CharacterDataImpl2.prototype.after = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    CharacterDataImpl2.prototype.replaceWith = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      throw new Error("Mixin: ChildNode not implemented.");
    };
    CharacterDataImpl2.prototype.remove = function() {
      throw new Error("Mixin: ChildNode not implemented.");
    };
    return CharacterDataImpl2;
  }(NodeImpl_1.NodeImpl);
  exports.CharacterDataImpl = CharacterDataImpl;
});

// node_modules/@oozcitak/dom/lib/dom/TextImpl.js
var require_TextImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var CharacterDataImpl_1 = require_CharacterDataImpl();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var TextImpl = function(_super) {
    __extends(TextImpl2, _super);
    function TextImpl2(data) {
      if (data === undefined) {
        data = "";
      }
      var _this = _super.call(this, data) || this;
      _this._name = "";
      _this._assignedSlot = null;
      return _this;
    }
    Object.defineProperty(TextImpl2.prototype, "wholeText", {
      get: function() {
        var e_1, _a;
        var text = "";
        try {
          for (var _b = __values(algorithm_1.text_contiguousTextNodes(this, true)), _c = _b.next();!_c.done; _c = _b.next()) {
            var node = _c.value;
            text = text + node._data;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return text;
      },
      enumerable: true,
      configurable: true
    });
    TextImpl2.prototype.splitText = function(offset) {
      return algorithm_1.text_split(this, offset);
    };
    Object.defineProperty(TextImpl2.prototype, "assignedSlot", {
      get: function() {
        throw new Error("Mixin: Slotable not implemented.");
      },
      enumerable: true,
      configurable: true
    });
    TextImpl2._create = function(document2, data) {
      if (data === undefined) {
        data = "";
      }
      var node = new TextImpl2(data);
      node._nodeDocument = document2;
      return node;
    };
    return TextImpl2;
  }(CharacterDataImpl_1.CharacterDataImpl);
  exports.TextImpl = TextImpl;
  WebIDLAlgorithm_1.idl_defineConst(TextImpl.prototype, "_nodeType", interfaces_1.NodeType.Text);
});

// node_modules/@oozcitak/dom/lib/dom/CDATASectionImpl.js
var require_CDATASectionImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var TextImpl_1 = require_TextImpl();
  var interfaces_1 = require_interfaces2();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var CDATASectionImpl = function(_super) {
    __extends(CDATASectionImpl2, _super);
    function CDATASectionImpl2(data) {
      return _super.call(this, data) || this;
    }
    CDATASectionImpl2._create = function(document2, data) {
      if (data === undefined) {
        data = "";
      }
      var node = new CDATASectionImpl2(data);
      node._nodeDocument = document2;
      return node;
    };
    return CDATASectionImpl2;
  }(TextImpl_1.TextImpl);
  exports.CDATASectionImpl = CDATASectionImpl;
  WebIDLAlgorithm_1.idl_defineConst(CDATASectionImpl.prototype, "_nodeType", interfaces_1.NodeType.CData);
});

// node_modules/@oozcitak/dom/lib/dom/CommentImpl.js
var require_CommentImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var CharacterDataImpl_1 = require_CharacterDataImpl();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var CommentImpl = function(_super) {
    __extends(CommentImpl2, _super);
    function CommentImpl2(data) {
      if (data === undefined) {
        data = "";
      }
      return _super.call(this, data) || this;
    }
    CommentImpl2._create = function(document2, data) {
      if (data === undefined) {
        data = "";
      }
      var node = new CommentImpl2(data);
      node._nodeDocument = document2;
      return node;
    };
    return CommentImpl2;
  }(CharacterDataImpl_1.CharacterDataImpl);
  exports.CommentImpl = CommentImpl;
  WebIDLAlgorithm_1.idl_defineConst(CommentImpl.prototype, "_nodeType", interfaces_1.NodeType.Comment);
});

// node_modules/@oozcitak/dom/lib/dom/ProcessingInstructionImpl.js
var require_ProcessingInstructionImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var CharacterDataImpl_1 = require_CharacterDataImpl();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var ProcessingInstructionImpl = function(_super) {
    __extends(ProcessingInstructionImpl2, _super);
    function ProcessingInstructionImpl2(target, data) {
      var _this = _super.call(this, data) || this;
      _this._target = target;
      return _this;
    }
    Object.defineProperty(ProcessingInstructionImpl2.prototype, "target", {
      get: function() {
        return this._target;
      },
      enumerable: true,
      configurable: true
    });
    ProcessingInstructionImpl2._create = function(document2, target, data) {
      var node = new ProcessingInstructionImpl2(target, data);
      node._nodeDocument = document2;
      return node;
    };
    return ProcessingInstructionImpl2;
  }(CharacterDataImpl_1.CharacterDataImpl);
  exports.ProcessingInstructionImpl = ProcessingInstructionImpl;
  WebIDLAlgorithm_1.idl_defineConst(ProcessingInstructionImpl.prototype, "_nodeType", interfaces_1.NodeType.ProcessingInstruction);
});

// node_modules/@oozcitak/dom/lib/dom/HTMLCollectionImpl.js
var require_HTMLCollectionImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var infra_1 = require_lib10();
  var algorithm_1 = require_algorithm();
  var util_1 = require_util2();
  var util_2 = require_lib8();
  var HTMLCollectionImpl = function() {
    function HTMLCollectionImpl2(root, filter) {
      this._live = true;
      this._root = root;
      this._filter = filter;
      return new Proxy(this, this);
    }
    Object.defineProperty(HTMLCollectionImpl2.prototype, "length", {
      get: function() {
        var _this = this;
        var count = 0;
        var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function(e) {
          return util_1.Guard.isElementNode(e) && _this._filter(e);
        });
        while (node !== null) {
          count++;
          node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function(e) {
            return util_1.Guard.isElementNode(e) && _this._filter(e);
          });
        }
        return count;
      },
      enumerable: true,
      configurable: true
    });
    HTMLCollectionImpl2.prototype.item = function(index) {
      var _this = this;
      var i = 0;
      var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function(e) {
        return util_1.Guard.isElementNode(e) && _this._filter(e);
      });
      while (node !== null) {
        if (i === index)
          return node;
        else
          i++;
        node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function(e) {
          return util_1.Guard.isElementNode(e) && _this._filter(e);
        });
      }
      return null;
    };
    HTMLCollectionImpl2.prototype.namedItem = function(key) {
      var _this = this;
      if (key === "")
        return null;
      var ele = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function(e) {
        return util_1.Guard.isElementNode(e) && _this._filter(e);
      });
      while (ele != null) {
        if (ele._uniqueIdentifier === key) {
          return ele;
        } else if (ele._namespace === infra_1.namespace.HTML) {
          for (var i = 0;i < ele._attributeList.length; i++) {
            var attr = ele._attributeList[i];
            if (attr._localName === "name" && attr._namespace === null && attr._namespacePrefix === null && attr._value === key)
              return ele;
          }
        }
        ele = algorithm_1.tree_getNextDescendantNode(this._root, ele, false, false, function(e) {
          return util_1.Guard.isElementNode(e) && _this._filter(e);
        });
      }
      return null;
    };
    HTMLCollectionImpl2.prototype[Symbol.iterator] = function() {
      var root = this._root;
      var filter = this._filter;
      var currentNode = algorithm_1.tree_getFirstDescendantNode(root, false, false, function(e) {
        return util_1.Guard.isElementNode(e) && filter(e);
      });
      return {
        next: function() {
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            currentNode = algorithm_1.tree_getNextDescendantNode(root, currentNode, false, false, function(e) {
              return util_1.Guard.isElementNode(e) && filter(e);
            });
            return result;
          }
        }
      };
    };
    HTMLCollectionImpl2.prototype.get = function(target, key, receiver) {
      if (!util_2.isString(key) || HTMLCollectionImpl2.reservedNames.indexOf(key) !== -1) {
        return Reflect.get(target, key, receiver);
      }
      var index = Number(key);
      if (isNaN(index)) {
        return target.namedItem(key) || undefined;
      } else {
        return target.item(index) || undefined;
      }
    };
    HTMLCollectionImpl2.prototype.set = function(target, key, value, receiver) {
      if (!util_2.isString(key) || HTMLCollectionImpl2.reservedNames.indexOf(key) !== -1) {
        return Reflect.set(target, key, value, receiver);
      }
      var index = Number(key);
      var node = isNaN(index) ? target.namedItem(key) || undefined : target.item(index) || undefined;
      if (node && node._parent) {
        algorithm_1.mutation_replace(node, value, node._parent);
        return true;
      } else {
        return false;
      }
    };
    HTMLCollectionImpl2._create = function(root, filter) {
      if (filter === undefined) {
        filter = function() {
          return true;
        };
      }
      return new HTMLCollectionImpl2(root, filter);
    };
    HTMLCollectionImpl2.reservedNames = [
      "_root",
      "_live",
      "_filter",
      "length",
      "item",
      "namedItem",
      "get",
      "set"
    ];
    return HTMLCollectionImpl2;
  }();
  exports.HTMLCollectionImpl = HTMLCollectionImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NodeListImpl.js
var require_NodeListImpl = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_lib8();
  var algorithm_1 = require_algorithm();
  var NodeListImpl = function() {
    function NodeListImpl2(root) {
      this._live = true;
      this._filter = null;
      this._length = 0;
      this._root = root;
      return new Proxy(this, this);
    }
    Object.defineProperty(NodeListImpl2.prototype, "length", {
      get: function() {
        return this._root._children.size;
      },
      enumerable: true,
      configurable: true
    });
    NodeListImpl2.prototype.item = function(index) {
      if (index < 0 || index > this.length - 1)
        return null;
      if (index < this.length / 2) {
        var i = 0;
        var node = this._root._firstChild;
        while (node !== null && i !== index) {
          node = node._nextSibling;
          i++;
        }
        return node;
      } else {
        var i = this.length - 1;
        var node = this._root._lastChild;
        while (node !== null && i !== index) {
          node = node._previousSibling;
          i--;
        }
        return node;
      }
    };
    NodeListImpl2.prototype.keys = function() {
      var _a;
      return _a = {}, _a[Symbol.iterator] = function() {
        var index = 0;
        return {
          next: function() {
            if (index === this.length) {
              return { done: true, value: null };
            } else {
              return { done: false, value: index++ };
            }
          }.bind(this)
        };
      }.bind(this), _a;
    };
    NodeListImpl2.prototype.values = function() {
      var _a;
      return _a = {}, _a[Symbol.iterator] = function() {
        var it = this[Symbol.iterator]();
        return {
          next: function() {
            return it.next();
          }
        };
      }.bind(this), _a;
    };
    NodeListImpl2.prototype.entries = function() {
      var _a;
      return _a = {}, _a[Symbol.iterator] = function() {
        var it = this[Symbol.iterator]();
        var index = 0;
        return {
          next: function() {
            var itResult = it.next();
            if (itResult.done) {
              return { done: true, value: null };
            } else {
              return { done: false, value: [index++, itResult.value] };
            }
          }
        };
      }.bind(this), _a;
    };
    NodeListImpl2.prototype[Symbol.iterator] = function() {
      return this._root._children[Symbol.iterator]();
    };
    NodeListImpl2.prototype.forEach = function(callback, thisArg) {
      var e_1, _a;
      if (thisArg === undefined) {
        thisArg = DOMImpl_1.dom.window;
      }
      var index = 0;
      try {
        for (var _b = __values(this._root._children), _c = _b.next();!_c.done; _c = _b.next()) {
          var node = _c.value;
          callback.call(thisArg, node, index++, this);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    NodeListImpl2.prototype.get = function(target, key, receiver) {
      if (!util_1.isString(key)) {
        return Reflect.get(target, key, receiver);
      }
      var index = Number(key);
      if (isNaN(index)) {
        return Reflect.get(target, key, receiver);
      }
      return target.item(index) || undefined;
    };
    NodeListImpl2.prototype.set = function(target, key, value, receiver) {
      if (!util_1.isString(key)) {
        return Reflect.set(target, key, value, receiver);
      }
      var index = Number(key);
      if (isNaN(index)) {
        return Reflect.set(target, key, value, receiver);
      }
      var node = target.item(index) || undefined;
      if (!node)
        return false;
      if (node._parent) {
        algorithm_1.mutation_replace(node, value, node._parent);
        return true;
      } else {
        return false;
      }
    };
    NodeListImpl2._create = function(root) {
      return new NodeListImpl2(root);
    };
    return NodeListImpl2;
  }();
  exports.NodeListImpl = NodeListImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NodeListStaticImpl.js
var require_NodeListStaticImpl = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_lib8();
  var NodeListStaticImpl = function() {
    function NodeListStaticImpl2(root) {
      this._live = false;
      this._items = [];
      this._length = 0;
      this._root = root;
      this._items = [];
      this._filter = function(node) {
        return true;
      };
      return new Proxy(this, this);
    }
    Object.defineProperty(NodeListStaticImpl2.prototype, "length", {
      get: function() {
        return this._items.length;
      },
      enumerable: true,
      configurable: true
    });
    NodeListStaticImpl2.prototype.item = function(index) {
      if (index < 0 || index > this.length - 1)
        return null;
      return this._items[index];
    };
    NodeListStaticImpl2.prototype.keys = function() {
      var _a;
      return _a = {}, _a[Symbol.iterator] = function() {
        var index = 0;
        return {
          next: function() {
            if (index === this.length) {
              return { done: true, value: null };
            } else {
              return { done: false, value: index++ };
            }
          }.bind(this)
        };
      }.bind(this), _a;
    };
    NodeListStaticImpl2.prototype.values = function() {
      var _a;
      return _a = {}, _a[Symbol.iterator] = function() {
        var it = this[Symbol.iterator]();
        return {
          next: function() {
            return it.next();
          }
        };
      }.bind(this), _a;
    };
    NodeListStaticImpl2.prototype.entries = function() {
      var _a;
      return _a = {}, _a[Symbol.iterator] = function() {
        var it = this[Symbol.iterator]();
        var index = 0;
        return {
          next: function() {
            var itResult = it.next();
            if (itResult.done) {
              return { done: true, value: null };
            } else {
              return { done: false, value: [index++, itResult.value] };
            }
          }
        };
      }.bind(this), _a;
    };
    NodeListStaticImpl2.prototype[Symbol.iterator] = function() {
      var it = this._items[Symbol.iterator]();
      return {
        next: function() {
          return it.next();
        }
      };
    };
    NodeListStaticImpl2.prototype.forEach = function(callback, thisArg) {
      var e_1, _a;
      if (thisArg === undefined) {
        thisArg = DOMImpl_1.dom.window;
      }
      var index = 0;
      try {
        for (var _b = __values(this._items), _c = _b.next();!_c.done; _c = _b.next()) {
          var node = _c.value;
          callback.call(thisArg, node, index++, this);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    NodeListStaticImpl2.prototype.get = function(target, key, receiver) {
      if (!util_1.isString(key)) {
        return Reflect.get(target, key, receiver);
      }
      var index = Number(key);
      if (isNaN(index)) {
        return Reflect.get(target, key, receiver);
      }
      return target._items[index] || undefined;
    };
    NodeListStaticImpl2.prototype.set = function(target, key, value, receiver) {
      if (!util_1.isString(key)) {
        return Reflect.set(target, key, value, receiver);
      }
      var index = Number(key);
      if (isNaN(index)) {
        return Reflect.set(target, key, value, receiver);
      }
      if (index >= 0 && index < target._items.length) {
        target._items[index] = value;
        return true;
      } else {
        return false;
      }
    };
    NodeListStaticImpl2._create = function(root, items) {
      var list = new NodeListStaticImpl2(root);
      list._items = items;
      return list;
    };
    return NodeListStaticImpl2;
  }();
  exports.NodeListStaticImpl = NodeListStaticImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NamedNodeMapImpl.js
var require_NamedNodeMapImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMException_1 = require_DOMException();
  var algorithm_1 = require_algorithm();
  var NamedNodeMapImpl = function(_super) {
    __extends(NamedNodeMapImpl2, _super);
    function NamedNodeMapImpl2(element) {
      var _this = _super.call(this) || this;
      _this._element = element;
      Object.setPrototypeOf(_this, NamedNodeMapImpl2.prototype);
      return _this;
    }
    NamedNodeMapImpl2.prototype._asArray = function() {
      return this;
    };
    NamedNodeMapImpl2.prototype.item = function(index) {
      return this[index] || null;
    };
    NamedNodeMapImpl2.prototype.getNamedItem = function(qualifiedName) {
      return algorithm_1.element_getAnAttributeByName(qualifiedName, this._element);
    };
    NamedNodeMapImpl2.prototype.getNamedItemNS = function(namespace, localName) {
      return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace || "", localName, this._element);
    };
    NamedNodeMapImpl2.prototype.setNamedItem = function(attr) {
      return algorithm_1.element_setAnAttribute(attr, this._element);
    };
    NamedNodeMapImpl2.prototype.setNamedItemNS = function(attr) {
      return algorithm_1.element_setAnAttribute(attr, this._element);
    };
    NamedNodeMapImpl2.prototype.removeNamedItem = function(qualifiedName) {
      var attr = algorithm_1.element_removeAnAttributeByName(qualifiedName, this._element);
      if (attr === null)
        throw new DOMException_1.NotFoundError;
      return attr;
    };
    NamedNodeMapImpl2.prototype.removeNamedItemNS = function(namespace, localName) {
      var attr = algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace || "", localName, this._element);
      if (attr === null)
        throw new DOMException_1.NotFoundError;
      return attr;
    };
    NamedNodeMapImpl2._create = function(element) {
      return new NamedNodeMapImpl2(element);
    };
    return NamedNodeMapImpl2;
  }(Array);
  exports.NamedNodeMapImpl = NamedNodeMapImpl;
});

// node_modules/@oozcitak/dom/lib/dom/AbstractRangeImpl.js
var require_AbstractRangeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var AbstractRangeImpl = function() {
    function AbstractRangeImpl2() {
    }
    Object.defineProperty(AbstractRangeImpl2.prototype, "_startNode", {
      get: function() {
        return this._start[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "_startOffset", {
      get: function() {
        return this._start[1];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "_endNode", {
      get: function() {
        return this._end[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "_endOffset", {
      get: function() {
        return this._end[1];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "_collapsed", {
      get: function() {
        return this._start[0] === this._end[0] && this._start[1] === this._end[1];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "startContainer", {
      get: function() {
        return this._startNode;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "startOffset", {
      get: function() {
        return this._startOffset;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "endContainer", {
      get: function() {
        return this._endNode;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "endOffset", {
      get: function() {
        return this._endOffset;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractRangeImpl2.prototype, "collapsed", {
      get: function() {
        return this._collapsed;
      },
      enumerable: true,
      configurable: true
    });
    return AbstractRangeImpl2;
  }();
  exports.AbstractRangeImpl = AbstractRangeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/RangeImpl.js
var require_RangeImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var AbstractRangeImpl_1 = require_AbstractRangeImpl();
  var DOMException_1 = require_DOMException();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var util_1 = require_util2();
  var RangeImpl = function(_super) {
    __extends(RangeImpl2, _super);
    function RangeImpl2() {
      var _this = _super.call(this) || this;
      var doc = DOMImpl_1.dom.window._associatedDocument;
      _this._start = [doc, 0];
      _this._end = [doc, 0];
      DOMImpl_1.dom.rangeList.add(_this);
      return _this;
    }
    Object.defineProperty(RangeImpl2.prototype, "commonAncestorContainer", {
      get: function() {
        var container = this._start[0];
        while (!algorithm_1.tree_isAncestorOf(this._end[0], container, true)) {
          if (container._parent === null) {
            throw new Error("Parent node  is null.");
          }
          container = container._parent;
        }
        return container;
      },
      enumerable: true,
      configurable: true
    });
    RangeImpl2.prototype.setStart = function(node, offset) {
      algorithm_1.range_setTheStart(this, node, offset);
    };
    RangeImpl2.prototype.setEnd = function(node, offset) {
      algorithm_1.range_setTheEnd(this, node, offset);
    };
    RangeImpl2.prototype.setStartBefore = function(node) {
      var parent = node._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError;
      algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node));
    };
    RangeImpl2.prototype.setStartAfter = function(node) {
      var parent = node._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError;
      algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node) + 1);
    };
    RangeImpl2.prototype.setEndBefore = function(node) {
      var parent = node._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError;
      algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node));
    };
    RangeImpl2.prototype.setEndAfter = function(node) {
      var parent = node._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError;
      algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node) + 1);
    };
    RangeImpl2.prototype.collapse = function(toStart) {
      if (toStart) {
        this._end = this._start;
      } else {
        this._start = this._end;
      }
    };
    RangeImpl2.prototype.selectNode = function(node) {
      algorithm_1.range_select(node, this);
    };
    RangeImpl2.prototype.selectNodeContents = function(node) {
      if (util_1.Guard.isDocumentTypeNode(node))
        throw new DOMException_1.InvalidNodeTypeError;
      var length = algorithm_1.tree_nodeLength(node);
      this._start = [node, 0];
      this._end = [node, length];
    };
    RangeImpl2.prototype.compareBoundaryPoints = function(how, sourceRange) {
      if (how !== interfaces_1.HowToCompare.StartToStart && how !== interfaces_1.HowToCompare.StartToEnd && how !== interfaces_1.HowToCompare.EndToEnd && how !== interfaces_1.HowToCompare.EndToStart)
        throw new DOMException_1.NotSupportedError;
      if (algorithm_1.range_root(this) !== algorithm_1.range_root(sourceRange))
        throw new DOMException_1.WrongDocumentError;
      var thisPoint;
      var otherPoint;
      switch (how) {
        case interfaces_1.HowToCompare.StartToStart:
          thisPoint = this._start;
          otherPoint = sourceRange._start;
          break;
        case interfaces_1.HowToCompare.StartToEnd:
          thisPoint = this._end;
          otherPoint = sourceRange._start;
          break;
        case interfaces_1.HowToCompare.EndToEnd:
          thisPoint = this._end;
          otherPoint = sourceRange._end;
          break;
        case interfaces_1.HowToCompare.EndToStart:
          thisPoint = this._start;
          otherPoint = sourceRange._end;
          break;
        default:
          throw new DOMException_1.NotSupportedError;
      }
      var position = algorithm_1.boundaryPoint_position(thisPoint, otherPoint);
      if (position === interfaces_1.BoundaryPosition.Before) {
        return -1;
      } else if (position === interfaces_1.BoundaryPosition.After) {
        return 1;
      } else {
        return 0;
      }
    };
    RangeImpl2.prototype.deleteContents = function() {
      var e_1, _a, e_2, _b;
      if (algorithm_1.range_collapsed(this))
        return;
      var originalStartNode = this._startNode;
      var originalStartOffset = this._startOffset;
      var originalEndNode = this._endNode;
      var originalEndOffset = this._endOffset;
      if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
        algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
        return;
      }
      var nodesToRemove = [];
      try {
        for (var _c = __values(algorithm_1.range_getContainedNodes(this)), _d = _c.next();!_d.done; _d = _c.next()) {
          var node = _d.value;
          var parent = node._parent;
          if (parent !== null && algorithm_1.range_isContained(parent, this)) {
            continue;
          }
          nodesToRemove.push(node);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var newNode;
      var newOffset;
      if (algorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        newNode = originalStartNode;
        newOffset = originalStartOffset;
      } else {
        var referenceNode = originalStartNode;
        while (referenceNode._parent !== null && !algorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent, true)) {
          referenceNode = referenceNode._parent;
        }
        if (referenceNode._parent === null) {
          throw new Error("Parent node is null.");
        }
        newNode = referenceNode._parent;
        newOffset = algorithm_1.tree_index(referenceNode) + 1;
      }
      if (util_1.Guard.isCharacterDataNode(originalStartNode)) {
        algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, algorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, "");
      }
      try {
        for (var nodesToRemove_1 = __values(nodesToRemove), nodesToRemove_1_1 = nodesToRemove_1.next();!nodesToRemove_1_1.done; nodesToRemove_1_1 = nodesToRemove_1.next()) {
          var node = nodesToRemove_1_1.value;
          if (node._parent) {
            algorithm_1.mutation_remove(node, node._parent);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (nodesToRemove_1_1 && !nodesToRemove_1_1.done && (_b = nodesToRemove_1.return))
            _b.call(nodesToRemove_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      if (util_1.Guard.isCharacterDataNode(originalEndNode)) {
        algorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, "");
      }
      this._start = [newNode, newOffset];
      this._end = [newNode, newOffset];
    };
    RangeImpl2.prototype.extractContents = function() {
      return algorithm_1.range_extract(this);
    };
    RangeImpl2.prototype.cloneContents = function() {
      return algorithm_1.range_cloneTheContents(this);
    };
    RangeImpl2.prototype.insertNode = function(node) {
      return algorithm_1.range_insert(node, this);
    };
    RangeImpl2.prototype.surroundContents = function(newParent) {
      var e_3, _a;
      try {
        for (var _b = __values(algorithm_1.range_getPartiallyContainedNodes(this)), _c = _b.next();!_c.done; _c = _b.next()) {
          var node = _c.value;
          if (!util_1.Guard.isTextNode(node)) {
            throw new DOMException_1.InvalidStateError;
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      if (util_1.Guard.isDocumentNode(newParent) || util_1.Guard.isDocumentTypeNode(newParent) || util_1.Guard.isDocumentFragmentNode(newParent)) {
        throw new DOMException_1.InvalidNodeTypeError;
      }
      var fragment = algorithm_1.range_extract(this);
      if (newParent._children.size !== 0) {
        algorithm_1.mutation_replaceAll(null, newParent);
      }
      algorithm_1.range_insert(newParent, this);
      algorithm_1.mutation_append(fragment, newParent);
      algorithm_1.range_select(newParent, this);
    };
    RangeImpl2.prototype.cloneRange = function() {
      return algorithm_1.create_range(this._start, this._end);
    };
    RangeImpl2.prototype.detach = function() {
      DOMImpl_1.dom.rangeList.delete(this);
    };
    RangeImpl2.prototype.isPointInRange = function(node, offset) {
      if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {
        return false;
      }
      if (util_1.Guard.isDocumentTypeNode(node))
        throw new DOMException_1.InvalidNodeTypeError;
      if (offset > algorithm_1.tree_nodeLength(node))
        throw new DOMException_1.IndexSizeError;
      var bp = [node, offset];
      if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before || algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
        return false;
      }
      return true;
    };
    RangeImpl2.prototype.comparePoint = function(node, offset) {
      if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this))
        throw new DOMException_1.WrongDocumentError;
      if (util_1.Guard.isDocumentTypeNode(node))
        throw new DOMException_1.InvalidNodeTypeError;
      if (offset > algorithm_1.tree_nodeLength(node))
        throw new DOMException_1.IndexSizeError;
      var bp = [node, offset];
      if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before) {
        return -1;
      } else if (algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
        return 1;
      } else {
        return 0;
      }
    };
    RangeImpl2.prototype.intersectsNode = function(node) {
      if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {
        return false;
      }
      var parent = node._parent;
      if (parent === null)
        return true;
      var offset = algorithm_1.tree_index(node);
      if (algorithm_1.boundaryPoint_position([parent, offset], this._end) === interfaces_1.BoundaryPosition.Before && algorithm_1.boundaryPoint_position([parent, offset + 1], this._start) === interfaces_1.BoundaryPosition.After) {
        return true;
      }
      return false;
    };
    RangeImpl2.prototype.toString = function() {
      var e_4, _a;
      var s = "";
      if (this._startNode === this._endNode && util_1.Guard.isTextNode(this._startNode)) {
        return this._startNode._data.substring(this._startOffset, this._endOffset);
      }
      if (util_1.Guard.isTextNode(this._startNode)) {
        s += this._startNode._data.substring(this._startOffset);
      }
      try {
        for (var _b = __values(algorithm_1.range_getContainedNodes(this)), _c = _b.next();!_c.done; _c = _b.next()) {
          var child = _c.value;
          if (util_1.Guard.isTextNode(child)) {
            s += child._data;
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      if (util_1.Guard.isTextNode(this._endNode)) {
        s += this._endNode._data.substring(0, this._endOffset);
      }
      return s;
    };
    RangeImpl2._create = function(start, end) {
      var range = new RangeImpl2;
      if (start)
        range._start = start;
      if (end)
        range._end = end;
      return range;
    };
    RangeImpl2.START_TO_START = 0;
    RangeImpl2.START_TO_END = 1;
    RangeImpl2.END_TO_END = 2;
    RangeImpl2.END_TO_START = 3;
    return RangeImpl2;
  }(AbstractRangeImpl_1.AbstractRangeImpl);
  exports.RangeImpl = RangeImpl;
  WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "START_TO_START", 0);
  WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "START_TO_END", 1);
  WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "END_TO_END", 2);
  WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "END_TO_START", 3);
});

// node_modules/@oozcitak/dom/lib/dom/TraverserImpl.js
var require_TraverserImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var TraverserImpl = function() {
    function TraverserImpl2(root) {
      this._activeFlag = false;
      this._root = root;
      this._whatToShow = interfaces_1.WhatToShow.All;
      this._filter = null;
    }
    Object.defineProperty(TraverserImpl2.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TraverserImpl2.prototype, "whatToShow", {
      get: function() {
        return this._whatToShow;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TraverserImpl2.prototype, "filter", {
      get: function() {
        return this._filter;
      },
      enumerable: true,
      configurable: true
    });
    return TraverserImpl2;
  }();
  exports.TraverserImpl = TraverserImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NodeIteratorImpl.js
var require_NodeIteratorImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var TraverserImpl_1 = require_TraverserImpl();
  var algorithm_1 = require_algorithm();
  var NodeIteratorImpl = function(_super) {
    __extends(NodeIteratorImpl2, _super);
    function NodeIteratorImpl2(root, reference, pointerBeforeReference) {
      var _this = _super.call(this, root) || this;
      _this._iteratorCollection = undefined;
      _this._reference = reference;
      _this._pointerBeforeReference = pointerBeforeReference;
      algorithm_1.nodeIterator_iteratorList().add(_this);
      return _this;
    }
    Object.defineProperty(NodeIteratorImpl2.prototype, "referenceNode", {
      get: function() {
        return this._reference;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NodeIteratorImpl2.prototype, "pointerBeforeReferenceNode", {
      get: function() {
        return this._pointerBeforeReference;
      },
      enumerable: true,
      configurable: true
    });
    NodeIteratorImpl2.prototype.nextNode = function() {
      return algorithm_1.nodeIterator_traverse(this, true);
    };
    NodeIteratorImpl2.prototype.previousNode = function() {
      return algorithm_1.nodeIterator_traverse(this, false);
    };
    NodeIteratorImpl2.prototype.detach = function() {
      algorithm_1.nodeIterator_iteratorList().delete(this);
    };
    NodeIteratorImpl2._create = function(root, reference, pointerBeforeReference) {
      return new NodeIteratorImpl2(root, reference, pointerBeforeReference);
    };
    return NodeIteratorImpl2;
  }(TraverserImpl_1.TraverserImpl);
  exports.NodeIteratorImpl = NodeIteratorImpl;
});

// node_modules/@oozcitak/dom/lib/dom/TreeWalkerImpl.js
var require_TreeWalkerImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var TraverserImpl_1 = require_TraverserImpl();
  var algorithm_1 = require_algorithm();
  var TreeWalkerImpl = function(_super) {
    __extends(TreeWalkerImpl2, _super);
    function TreeWalkerImpl2(root, current) {
      var _this = _super.call(this, root) || this;
      _this._current = current;
      return _this;
    }
    Object.defineProperty(TreeWalkerImpl2.prototype, "currentNode", {
      get: function() {
        return this._current;
      },
      set: function(value) {
        this._current = value;
      },
      enumerable: true,
      configurable: true
    });
    TreeWalkerImpl2.prototype.parentNode = function() {
      var node = this._current;
      while (node !== null && node !== this._root) {
        node = node._parent;
        if (node !== null && algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {
          this._current = node;
          return node;
        }
      }
      return null;
    };
    TreeWalkerImpl2.prototype.firstChild = function() {
      return algorithm_1.treeWalker_traverseChildren(this, true);
    };
    TreeWalkerImpl2.prototype.lastChild = function() {
      return algorithm_1.treeWalker_traverseChildren(this, false);
    };
    TreeWalkerImpl2.prototype.nextSibling = function() {
      return algorithm_1.treeWalker_traverseSiblings(this, true);
    };
    TreeWalkerImpl2.prototype.previousNode = function() {
      var node = this._current;
      while (node !== this._root) {
        var sibling = node._previousSibling;
        while (sibling) {
          node = sibling;
          var result = algorithm_1.traversal_filter(this, node);
          while (result !== interfaces_1.FilterResult.Reject && node._lastChild) {
            node = node._lastChild;
            result = algorithm_1.traversal_filter(this, node);
          }
          if (result === interfaces_1.FilterResult.Accept) {
            this._current = node;
            return node;
          }
          sibling = node._previousSibling;
        }
        if (node === this._root || node._parent === null) {
          return null;
        }
        node = node._parent;
        if (algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {
          this._current = node;
          return node;
        }
      }
      return null;
    };
    TreeWalkerImpl2.prototype.previousSibling = function() {
      return algorithm_1.treeWalker_traverseSiblings(this, false);
    };
    TreeWalkerImpl2.prototype.nextNode = function() {
      var node = this._current;
      var result = interfaces_1.FilterResult.Accept;
      while (true) {
        while (result !== interfaces_1.FilterResult.Reject && node._firstChild) {
          node = node._firstChild;
          result = algorithm_1.traversal_filter(this, node);
          if (result === interfaces_1.FilterResult.Accept) {
            this._current = node;
            return node;
          }
        }
        var sibling = null;
        var temporary = node;
        while (temporary !== null) {
          if (temporary === this._root) {
            return null;
          }
          sibling = temporary._nextSibling;
          if (sibling !== null) {
            node = sibling;
            break;
          }
          temporary = temporary._parent;
        }
        result = algorithm_1.traversal_filter(this, node);
        if (result === interfaces_1.FilterResult.Accept) {
          this._current = node;
          return node;
        }
      }
    };
    TreeWalkerImpl2._create = function(root, current) {
      return new TreeWalkerImpl2(root, current);
    };
    return TreeWalkerImpl2;
  }(TraverserImpl_1.TraverserImpl);
  exports.TreeWalkerImpl = TreeWalkerImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NodeFilterImpl.js
var require_NodeFilterImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var NodeFilterImpl = function() {
    function NodeFilterImpl2() {
    }
    NodeFilterImpl2.prototype.acceptNode = function(node) {
      return interfaces_1.FilterResult.Accept;
    };
    NodeFilterImpl2._create = function() {
      return new NodeFilterImpl2;
    };
    NodeFilterImpl2.FILTER_ACCEPT = 1;
    NodeFilterImpl2.FILTER_REJECT = 2;
    NodeFilterImpl2.FILTER_SKIP = 3;
    NodeFilterImpl2.SHOW_ALL = 4294967295;
    NodeFilterImpl2.SHOW_ELEMENT = 1;
    NodeFilterImpl2.SHOW_ATTRIBUTE = 2;
    NodeFilterImpl2.SHOW_TEXT = 4;
    NodeFilterImpl2.SHOW_CDATA_SECTION = 8;
    NodeFilterImpl2.SHOW_ENTITY_REFERENCE = 16;
    NodeFilterImpl2.SHOW_ENTITY = 32;
    NodeFilterImpl2.SHOW_PROCESSING_INSTRUCTION = 64;
    NodeFilterImpl2.SHOW_COMMENT = 128;
    NodeFilterImpl2.SHOW_DOCUMENT = 256;
    NodeFilterImpl2.SHOW_DOCUMENT_TYPE = 512;
    NodeFilterImpl2.SHOW_DOCUMENT_FRAGMENT = 1024;
    NodeFilterImpl2.SHOW_NOTATION = 2048;
    return NodeFilterImpl2;
  }();
  exports.NodeFilterImpl = NodeFilterImpl;
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_ACCEPT", 1);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_REJECT", 2);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_SKIP", 3);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ALL", 4294967295);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ELEMENT", 1);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ATTRIBUTE", 2);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_TEXT", 4);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_CDATA_SECTION", 8);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ENTITY_REFERENCE", 16);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ENTITY", 32);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_PROCESSING_INSTRUCTION", 64);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_COMMENT", 128);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT", 256);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT_TYPE", 512);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT_FRAGMENT", 1024);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_NOTATION", 2048);
});

// node_modules/@oozcitak/dom/lib/dom/MutationRecordImpl.js
var require_MutationRecordImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MutationRecordImpl = function() {
    function MutationRecordImpl2(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
      this._type = type;
      this._target = target;
      this._addedNodes = addedNodes;
      this._removedNodes = removedNodes;
      this._previousSibling = previousSibling;
      this._nextSibling = nextSibling;
      this._attributeName = attributeName;
      this._attributeNamespace = attributeNamespace;
      this._oldValue = oldValue;
    }
    Object.defineProperty(MutationRecordImpl2.prototype, "type", {
      get: function() {
        return this._type;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MutationRecordImpl2.prototype, "target", {
      get: function() {
        return this._target;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MutationRecordImpl2.prototype, "addedNodes", {
      get: function() {
        return this._addedNodes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MutationRecordImpl2.prototype, "removedNodes", {
      get: function() {
        return this._removedNodes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MutationRecordImpl2.prototype, "previousSibling", {
      get: function() {
        return this._previousSibling;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MutationRecordImpl2.prototype, "nextSibling", {
      get: function() {
        return this._nextSibling;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MutationRecordImpl2.prototype, "attributeName", {
      get: function() {
        return this._attributeName;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MutationRecordImpl2.prototype, "attributeNamespace", {
      get: function() {
        return this._attributeNamespace;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MutationRecordImpl2.prototype, "oldValue", {
      get: function() {
        return this._oldValue;
      },
      enumerable: true,
      configurable: true
    });
    MutationRecordImpl2._create = function(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
      return new MutationRecordImpl2(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
    };
    return MutationRecordImpl2;
  }();
  exports.MutationRecordImpl = MutationRecordImpl;
});

// node_modules/@oozcitak/dom/lib/dom/DOMTokenListImpl.js
var require_DOMTokenListImpl = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib10();
  var algorithm_1 = require_algorithm();
  var DOMTokenListImpl = function() {
    function DOMTokenListImpl2(element, attribute) {
      this._element = element;
      this._attribute = attribute;
      this._tokenSet = new Set;
      var localName = attribute._localName;
      var value = algorithm_1.element_getAnAttributeValue(element, localName);
      var thisObj = this;
      function updateTokenSet(element2, localName2, oldValue, value2, namespace) {
        if (localName2 === thisObj._attribute._localName && namespace === null) {
          if (!value2)
            thisObj._tokenSet.clear();
          else
            thisObj._tokenSet = algorithm_1.orderedSet_parse(value2);
        }
      }
      this._element._attributeChangeSteps.push(updateTokenSet);
      if (DOMImpl_1.dom.features.steps) {
        algorithm_1.dom_runAttributeChangeSteps(element, localName, value, value, null);
      }
    }
    Object.defineProperty(DOMTokenListImpl2.prototype, "length", {
      get: function() {
        return this._tokenSet.size;
      },
      enumerable: true,
      configurable: true
    });
    DOMTokenListImpl2.prototype.item = function(index) {
      var e_1, _a;
      var i = 0;
      try {
        for (var _b = __values(this._tokenSet), _c = _b.next();!_c.done; _c = _b.next()) {
          var token = _c.value;
          if (i === index)
            return token;
          i++;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return null;
    };
    DOMTokenListImpl2.prototype.contains = function(token) {
      return this._tokenSet.has(token);
    };
    DOMTokenListImpl2.prototype.add = function() {
      var e_2, _a;
      var tokens = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        tokens[_i] = arguments[_i];
      }
      try {
        for (var tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next();!tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
          var token = tokens_1_1.value;
          if (token === "") {
            throw new DOMException_1.SyntaxError("Cannot add an empty token.");
          } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
          } else {
            this._tokenSet.add(token);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (tokens_1_1 && !tokens_1_1.done && (_a = tokens_1.return))
            _a.call(tokens_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      algorithm_1.tokenList_updateSteps(this);
    };
    DOMTokenListImpl2.prototype.remove = function() {
      var e_3, _a;
      var tokens = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        tokens[_i] = arguments[_i];
      }
      try {
        for (var tokens_2 = __values(tokens), tokens_2_1 = tokens_2.next();!tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
          var token = tokens_2_1.value;
          if (token === "") {
            throw new DOMException_1.SyntaxError("Cannot remove an empty token.");
          } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
          } else {
            this._tokenSet.delete(token);
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (tokens_2_1 && !tokens_2_1.done && (_a = tokens_2.return))
            _a.call(tokens_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      algorithm_1.tokenList_updateSteps(this);
    };
    DOMTokenListImpl2.prototype.toggle = function(token, force) {
      if (force === undefined) {
        force = undefined;
      }
      if (token === "") {
        throw new DOMException_1.SyntaxError("Cannot toggle an empty token.");
      } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
        throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
      }
      if (this._tokenSet.has(token)) {
        if (force === undefined || force === false) {
          this._tokenSet.delete(token);
          algorithm_1.tokenList_updateSteps(this);
          return false;
        }
        return true;
      }
      if (force === undefined || force === true) {
        this._tokenSet.add(token);
        algorithm_1.tokenList_updateSteps(this);
        return true;
      }
      return false;
    };
    DOMTokenListImpl2.prototype.replace = function(token, newToken) {
      if (token === "" || newToken === "") {
        throw new DOMException_1.SyntaxError("Cannot replace an empty token.");
      } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token) || infra_1.codePoint.ASCIIWhiteSpace.test(newToken)) {
        throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
      }
      if (!this._tokenSet.has(token))
        return false;
      infra_1.set.replace(this._tokenSet, token, newToken);
      algorithm_1.tokenList_updateSteps(this);
      return true;
    };
    DOMTokenListImpl2.prototype.supports = function(token) {
      return algorithm_1.tokenList_validationSteps(this, token);
    };
    Object.defineProperty(DOMTokenListImpl2.prototype, "value", {
      get: function() {
        return algorithm_1.tokenList_serializeSteps(this);
      },
      set: function(value) {
        algorithm_1.element_setAnAttributeValue(this._element, this._attribute._localName, value);
      },
      enumerable: true,
      configurable: true
    });
    DOMTokenListImpl2.prototype[Symbol.iterator] = function() {
      var it = this._tokenSet[Symbol.iterator]();
      return {
        next: function() {
          return it.next();
        }
      };
    };
    DOMTokenListImpl2._create = function(element, attribute) {
      return new DOMTokenListImpl2(element, attribute);
    };
    return DOMTokenListImpl2;
  }();
  exports.DOMTokenListImpl = DOMTokenListImpl;
});

// node_modules/@oozcitak/dom/lib/algorithm/CreateAlgorithm.js
var require_CreateAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImplementationImpl_1 = require_DOMImplementationImpl();
  var WindowImpl_1 = require_WindowImpl();
  var XMLDocumentImpl_1 = require_XMLDocumentImpl();
  var DocumentImpl_1 = require_DocumentImpl();
  var AbortControllerImpl_1 = require_AbortControllerImpl();
  var AbortSignalImpl_1 = require_AbortSignalImpl();
  var DocumentTypeImpl_1 = require_DocumentTypeImpl();
  var ElementImpl_1 = require_ElementImpl();
  var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
  var ShadowRootImpl_1 = require_ShadowRootImpl();
  var AttrImpl_1 = require_AttrImpl();
  var TextImpl_1 = require_TextImpl();
  var CDATASectionImpl_1 = require_CDATASectionImpl();
  var CommentImpl_1 = require_CommentImpl();
  var ProcessingInstructionImpl_1 = require_ProcessingInstructionImpl();
  var HTMLCollectionImpl_1 = require_HTMLCollectionImpl();
  var NodeListImpl_1 = require_NodeListImpl();
  var NodeListStaticImpl_1 = require_NodeListStaticImpl();
  var NamedNodeMapImpl_1 = require_NamedNodeMapImpl();
  var RangeImpl_1 = require_RangeImpl();
  var NodeIteratorImpl_1 = require_NodeIteratorImpl();
  var TreeWalkerImpl_1 = require_TreeWalkerImpl();
  var NodeFilterImpl_1 = require_NodeFilterImpl();
  var MutationRecordImpl_1 = require_MutationRecordImpl();
  var DOMTokenListImpl_1 = require_DOMTokenListImpl();
  function create_domImplementation(document2) {
    return DOMImplementationImpl_1.DOMImplementationImpl._create(document2);
  }
  exports.create_domImplementation = create_domImplementation;
  function create_window() {
    return WindowImpl_1.WindowImpl._create();
  }
  exports.create_window = create_window;
  function create_xmlDocument() {
    return new XMLDocumentImpl_1.XMLDocumentImpl;
  }
  exports.create_xmlDocument = create_xmlDocument;
  function create_document() {
    return new DocumentImpl_1.DocumentImpl;
  }
  exports.create_document = create_document;
  function create_abortController() {
    return new AbortControllerImpl_1.AbortControllerImpl;
  }
  exports.create_abortController = create_abortController;
  function create_abortSignal() {
    return AbortSignalImpl_1.AbortSignalImpl._create();
  }
  exports.create_abortSignal = create_abortSignal;
  function create_documentType(document2, name, publicId, systemId) {
    return DocumentTypeImpl_1.DocumentTypeImpl._create(document2, name, publicId, systemId);
  }
  exports.create_documentType = create_documentType;
  function create_element(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  exports.create_element = create_element;
  function create_htmlElement(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  exports.create_htmlElement = create_htmlElement;
  function create_htmlUnknownElement(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  exports.create_htmlUnknownElement = create_htmlUnknownElement;
  function create_documentFragment(document2) {
    return DocumentFragmentImpl_1.DocumentFragmentImpl._create(document2);
  }
  exports.create_documentFragment = create_documentFragment;
  function create_shadowRoot(document2, host) {
    return ShadowRootImpl_1.ShadowRootImpl._create(document2, host);
  }
  exports.create_shadowRoot = create_shadowRoot;
  function create_attr(document2, localName) {
    return AttrImpl_1.AttrImpl._create(document2, localName);
  }
  exports.create_attr = create_attr;
  function create_text(document2, data) {
    return TextImpl_1.TextImpl._create(document2, data);
  }
  exports.create_text = create_text;
  function create_cdataSection(document2, data) {
    return CDATASectionImpl_1.CDATASectionImpl._create(document2, data);
  }
  exports.create_cdataSection = create_cdataSection;
  function create_comment(document2, data) {
    return CommentImpl_1.CommentImpl._create(document2, data);
  }
  exports.create_comment = create_comment;
  function create_processingInstruction(document2, target, data) {
    return ProcessingInstructionImpl_1.ProcessingInstructionImpl._create(document2, target, data);
  }
  exports.create_processingInstruction = create_processingInstruction;
  function create_htmlCollection(root, filter) {
    if (filter === undefined) {
      filter = function() {
        return true;
      };
    }
    return HTMLCollectionImpl_1.HTMLCollectionImpl._create(root, filter);
  }
  exports.create_htmlCollection = create_htmlCollection;
  function create_nodeList(root) {
    return NodeListImpl_1.NodeListImpl._create(root);
  }
  exports.create_nodeList = create_nodeList;
  function create_nodeListStatic(root, items) {
    return NodeListStaticImpl_1.NodeListStaticImpl._create(root, items);
  }
  exports.create_nodeListStatic = create_nodeListStatic;
  function create_namedNodeMap(element) {
    return NamedNodeMapImpl_1.NamedNodeMapImpl._create(element);
  }
  exports.create_namedNodeMap = create_namedNodeMap;
  function create_range(start, end) {
    return RangeImpl_1.RangeImpl._create(start, end);
  }
  exports.create_range = create_range;
  function create_nodeIterator(root, reference, pointerBeforeReference) {
    return NodeIteratorImpl_1.NodeIteratorImpl._create(root, reference, pointerBeforeReference);
  }
  exports.create_nodeIterator = create_nodeIterator;
  function create_treeWalker(root, current) {
    return TreeWalkerImpl_1.TreeWalkerImpl._create(root, current);
  }
  exports.create_treeWalker = create_treeWalker;
  function create_nodeFilter() {
    return NodeFilterImpl_1.NodeFilterImpl._create();
  }
  exports.create_nodeFilter = create_nodeFilter;
  function create_mutationRecord(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
    return MutationRecordImpl_1.MutationRecordImpl._create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
  }
  exports.create_mutationRecord = create_mutationRecord;
  function create_domTokenList(element, attribute) {
    return DOMTokenListImpl_1.DOMTokenListImpl._create(element, attribute);
  }
  exports.create_domTokenList = create_domTokenList;
});

// node_modules/@oozcitak/dom/lib/dom/DOMImpl.js
var require_DOMImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var DOMImpl = function() {
    function DOMImpl2() {
      this._features = {
        mutationObservers: true,
        customElements: true,
        slots: true,
        steps: true
      };
      this._window = null;
      this._compareCache = new util_1.CompareCache;
      this._rangeList = new util_1.FixedSizeSet;
    }
    DOMImpl2.prototype.setFeatures = function(features) {
      if (features === undefined)
        features = true;
      if (util_1.isObject(features)) {
        for (var key in features) {
          this._features[key] = features[key] || false;
        }
      } else {
        for (var key in this._features) {
          this._features[key] = features;
        }
      }
    };
    Object.defineProperty(DOMImpl2.prototype, "features", {
      get: function() {
        return this._features;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DOMImpl2.prototype, "window", {
      get: function() {
        if (this._window === null) {
          this._window = CreateAlgorithm_1.create_window();
        }
        return this._window;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DOMImpl2.prototype, "compareCache", {
      get: function() {
        return this._compareCache;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DOMImpl2.prototype, "rangeList", {
      get: function() {
        return this._rangeList;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DOMImpl2, "instance", {
      get: function() {
        if (!DOMImpl2._instance) {
          DOMImpl2._instance = new DOMImpl2;
        }
        return DOMImpl2._instance;
      },
      enumerable: true,
      configurable: true
    });
    return DOMImpl2;
  }();
  exports.dom = DOMImpl.instance;
});

// node_modules/@oozcitak/dom/lib/dom/EventImpl.js
var require_EventImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var algorithm_1 = require_algorithm();
  var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
  var EventImpl = function() {
    function EventImpl2(type, eventInit) {
      this._target = null;
      this._relatedTarget = null;
      this._touchTargetList = [];
      this._path = [];
      this._currentTarget = null;
      this._eventPhase = interfaces_1.EventPhase.None;
      this._stopPropagationFlag = false;
      this._stopImmediatePropagationFlag = false;
      this._canceledFlag = false;
      this._inPassiveListenerFlag = false;
      this._composedFlag = false;
      this._initializedFlag = false;
      this._dispatchFlag = false;
      this._isTrusted = false;
      this._bubbles = false;
      this._cancelable = false;
      this._type = type;
      if (eventInit) {
        this._bubbles = eventInit.bubbles || false;
        this._cancelable = eventInit.cancelable || false;
        this._composedFlag = eventInit.composed || false;
      }
      this._initializedFlag = true;
      this._timeStamp = new Date().getTime();
    }
    Object.defineProperty(EventImpl2.prototype, "type", {
      get: function() {
        return this._type;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventImpl2.prototype, "target", {
      get: function() {
        return this._target;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventImpl2.prototype, "srcElement", {
      get: function() {
        return this._target;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventImpl2.prototype, "currentTarget", {
      get: function() {
        return this._currentTarget;
      },
      enumerable: true,
      configurable: true
    });
    EventImpl2.prototype.composedPath = function() {
      var composedPath = [];
      var path = this._path;
      if (path.length === 0)
        return composedPath;
      var currentTarget = this._currentTarget;
      if (currentTarget === null) {
        throw new Error("Event currentTarget is null.");
      }
      composedPath.push(currentTarget);
      var currentTargetIndex = 0;
      var currentTargetHiddenSubtreeLevel = 0;
      var index = path.length - 1;
      while (index >= 0) {
        if (path[index].rootOfClosedTree) {
          currentTargetHiddenSubtreeLevel++;
        }
        if (path[index].invocationTarget === currentTarget) {
          currentTargetIndex = index;
          break;
        }
        if (path[index].slotInClosedTree) {
          currentTargetHiddenSubtreeLevel--;
        }
        index--;
      }
      var currentHiddenLevel = currentTargetHiddenSubtreeLevel;
      var maxHiddenLevel = currentTargetHiddenSubtreeLevel;
      index = currentTargetIndex - 1;
      while (index >= 0) {
        if (path[index].rootOfClosedTree) {
          currentHiddenLevel++;
        }
        if (currentHiddenLevel <= maxHiddenLevel) {
          composedPath.unshift(path[index].invocationTarget);
        }
        if (path[index].slotInClosedTree) {
          currentHiddenLevel--;
          if (currentHiddenLevel < maxHiddenLevel) {
            maxHiddenLevel = currentHiddenLevel;
          }
        }
        index--;
      }
      currentHiddenLevel = currentTargetHiddenSubtreeLevel;
      maxHiddenLevel = currentTargetHiddenSubtreeLevel;
      index = currentTargetIndex + 1;
      while (index < path.length) {
        if (path[index].slotInClosedTree) {
          currentHiddenLevel++;
        }
        if (currentHiddenLevel <= maxHiddenLevel) {
          composedPath.push(path[index].invocationTarget);
        }
        if (path[index].rootOfClosedTree) {
          currentHiddenLevel--;
          if (currentHiddenLevel < maxHiddenLevel) {
            maxHiddenLevel = currentHiddenLevel;
          }
        }
        index++;
      }
      return composedPath;
    };
    Object.defineProperty(EventImpl2.prototype, "eventPhase", {
      get: function() {
        return this._eventPhase;
      },
      enumerable: true,
      configurable: true
    });
    EventImpl2.prototype.stopPropagation = function() {
      this._stopPropagationFlag = true;
    };
    Object.defineProperty(EventImpl2.prototype, "cancelBubble", {
      get: function() {
        return this._stopPropagationFlag;
      },
      set: function(value) {
        if (value)
          this.stopPropagation();
      },
      enumerable: true,
      configurable: true
    });
    EventImpl2.prototype.stopImmediatePropagation = function() {
      this._stopPropagationFlag = true;
      this._stopImmediatePropagationFlag = true;
    };
    Object.defineProperty(EventImpl2.prototype, "bubbles", {
      get: function() {
        return this._bubbles;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventImpl2.prototype, "cancelable", {
      get: function() {
        return this._cancelable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventImpl2.prototype, "returnValue", {
      get: function() {
        return !this._canceledFlag;
      },
      set: function(value) {
        if (!value) {
          algorithm_1.event_setTheCanceledFlag(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    EventImpl2.prototype.preventDefault = function() {
      algorithm_1.event_setTheCanceledFlag(this);
    };
    Object.defineProperty(EventImpl2.prototype, "defaultPrevented", {
      get: function() {
        return this._canceledFlag;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventImpl2.prototype, "composed", {
      get: function() {
        return this._composedFlag;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventImpl2.prototype, "isTrusted", {
      get: function() {
        return this._isTrusted;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventImpl2.prototype, "timeStamp", {
      get: function() {
        return this._timeStamp;
      },
      enumerable: true,
      configurable: true
    });
    EventImpl2.prototype.initEvent = function(type, bubbles, cancelable) {
      if (bubbles === undefined) {
        bubbles = false;
      }
      if (cancelable === undefined) {
        cancelable = false;
      }
      if (this._dispatchFlag)
        return;
      algorithm_1.event_initialize(this, type, bubbles, cancelable);
    };
    EventImpl2.NONE = 0;
    EventImpl2.CAPTURING_PHASE = 1;
    EventImpl2.AT_TARGET = 2;
    EventImpl2.BUBBLING_PHASE = 3;
    return EventImpl2;
  }();
  exports.EventImpl = EventImpl;
  WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "NONE", 0);
  WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "CAPTURING_PHASE", 1);
  WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "AT_TARGET", 2);
  WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "BUBBLING_PHASE", 3);
});

// node_modules/@oozcitak/dom/lib/dom/CustomEventImpl.js
var require_CustomEventImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var EventImpl_1 = require_EventImpl();
  var algorithm_1 = require_algorithm();
  var CustomEventImpl = function(_super) {
    __extends(CustomEventImpl2, _super);
    function CustomEventImpl2(type, eventInit) {
      var _this = _super.call(this, type, eventInit) || this;
      _this._detail = null;
      _this._detail = eventInit && eventInit.detail || null;
      return _this;
    }
    Object.defineProperty(CustomEventImpl2.prototype, "detail", {
      get: function() {
        return this._detail;
      },
      enumerable: true,
      configurable: true
    });
    CustomEventImpl2.prototype.initCustomEvent = function(type, bubbles, cancelable, detail) {
      if (bubbles === undefined) {
        bubbles = false;
      }
      if (cancelable === undefined) {
        cancelable = false;
      }
      if (detail === undefined) {
        detail = null;
      }
      if (this._dispatchFlag)
        return;
      algorithm_1.event_initialize(this, type, bubbles, cancelable);
      this._detail = detail;
    };
    return CustomEventImpl2;
  }(EventImpl_1.EventImpl);
  exports.CustomEventImpl = CustomEventImpl;
});

// node_modules/@oozcitak/dom/lib/algorithm/TreeAlgorithm.js
var require_TreeAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var interfaces_1 = require_interfaces2();
  function _getNextDescendantNode(root, node, shadow) {
    if (shadow === undefined) {
      shadow = false;
    }
    if (shadow && util_1.Guard.isElementNode(node) && util_1.Guard.isShadowRoot(node.shadowRoot)) {
      if (node.shadowRoot._firstChild)
        return node.shadowRoot._firstChild;
    }
    if (node._firstChild)
      return node._firstChild;
    if (node === root)
      return null;
    if (node._nextSibling)
      return node._nextSibling;
    var parent = node._parent;
    while (parent && parent !== root) {
      if (parent._nextSibling)
        return parent._nextSibling;
      parent = parent._parent;
    }
    return null;
  }
  function _emptyIterator() {
    var _a;
    return _a = {}, _a[Symbol.iterator] = function() {
      return {
        next: function() {
          return { done: true, value: null };
        }
      };
    }, _a;
  }
  function tree_getFirstDescendantNode(node, self2, shadow, filter) {
    if (self2 === undefined) {
      self2 = false;
    }
    if (shadow === undefined) {
      shadow = false;
    }
    var firstNode = self2 ? node : _getNextDescendantNode(node, node, shadow);
    while (firstNode && filter && !filter(firstNode)) {
      firstNode = _getNextDescendantNode(node, firstNode, shadow);
    }
    return firstNode;
  }
  exports.tree_getFirstDescendantNode = tree_getFirstDescendantNode;
  function tree_getNextDescendantNode(node, currentNode, self2, shadow, filter) {
    if (self2 === undefined) {
      self2 = false;
    }
    if (shadow === undefined) {
      shadow = false;
    }
    var nextNode = _getNextDescendantNode(node, currentNode, shadow);
    while (nextNode && filter && !filter(nextNode)) {
      nextNode = _getNextDescendantNode(node, nextNode, shadow);
    }
    return nextNode;
  }
  exports.tree_getNextDescendantNode = tree_getNextDescendantNode;
  function tree_getDescendantNodes(node, self2, shadow, filter) {
    var _a;
    if (self2 === undefined) {
      self2 = false;
    }
    if (shadow === undefined) {
      shadow = false;
    }
    if (!self2 && node._children.size === 0) {
      return _emptyIterator();
    }
    return _a = {}, _a[Symbol.iterator] = function() {
      var currentNode = self2 ? node : _getNextDescendantNode(node, node, shadow);
      return {
        next: function() {
          while (currentNode && filter && !filter(currentNode)) {
            currentNode = _getNextDescendantNode(node, currentNode, shadow);
          }
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            currentNode = _getNextDescendantNode(node, currentNode, shadow);
            return result;
          }
        }
      };
    }, _a;
  }
  exports.tree_getDescendantNodes = tree_getDescendantNodes;
  function tree_getDescendantElements(node, self2, shadow, filter) {
    var _a;
    if (self2 === undefined) {
      self2 = false;
    }
    if (shadow === undefined) {
      shadow = false;
    }
    if (!self2 && node._children.size === 0) {
      return _emptyIterator();
    }
    return _a = {}, _a[Symbol.iterator] = function() {
      var it = tree_getDescendantNodes(node, self2, shadow, function(e) {
        return util_1.Guard.isElementNode(e);
      })[Symbol.iterator]();
      var currentNode = it.next().value;
      return {
        next: function() {
          while (currentNode && filter && !filter(currentNode)) {
            currentNode = it.next().value;
          }
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            currentNode = it.next().value;
            return result;
          }
        }
      };
    }, _a;
  }
  exports.tree_getDescendantElements = tree_getDescendantElements;
  function tree_getSiblingNodes(node, self2, filter) {
    var _a;
    if (self2 === undefined) {
      self2 = false;
    }
    if (!node._parent || node._parent._children.size === 0) {
      return _emptyIterator();
    }
    return _a = {}, _a[Symbol.iterator] = function() {
      var currentNode = node._parent ? node._parent._firstChild : null;
      return {
        next: function() {
          while (currentNode && (filter && !filter(currentNode) || !self2 && currentNode === node)) {
            currentNode = currentNode._nextSibling;
          }
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            currentNode = currentNode._nextSibling;
            return result;
          }
        }
      };
    }, _a;
  }
  exports.tree_getSiblingNodes = tree_getSiblingNodes;
  function tree_getFirstAncestorNode(node, self2, filter) {
    if (self2 === undefined) {
      self2 = false;
    }
    var firstNode = self2 ? node : node._parent;
    while (firstNode && filter && !filter(firstNode)) {
      firstNode = firstNode._parent;
    }
    return firstNode;
  }
  exports.tree_getFirstAncestorNode = tree_getFirstAncestorNode;
  function tree_getNextAncestorNode(node, currentNode, self2, filter) {
    if (self2 === undefined) {
      self2 = false;
    }
    var nextNode = currentNode._parent;
    while (nextNode && filter && !filter(nextNode)) {
      nextNode = nextNode._parent;
    }
    return nextNode;
  }
  exports.tree_getNextAncestorNode = tree_getNextAncestorNode;
  function tree_getAncestorNodes(node, self2, filter) {
    var _a;
    if (self2 === undefined) {
      self2 = false;
    }
    if (!self2 && !node._parent) {
      return _emptyIterator();
    }
    return _a = {}, _a[Symbol.iterator] = function() {
      var currentNode = tree_getFirstAncestorNode(node, self2, filter);
      return {
        next: function() {
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            currentNode = tree_getNextAncestorNode(node, currentNode, self2, filter);
            return result;
          }
        }
      };
    }, _a;
  }
  exports.tree_getAncestorNodes = tree_getAncestorNodes;
  function tree_getCommonAncestor(nodeA, nodeB) {
    if (nodeA === nodeB) {
      return nodeA._parent;
    }
    var parentsA = [];
    var parentsB = [];
    var pA = tree_getFirstAncestorNode(nodeA, true);
    while (pA !== null) {
      parentsA.push(pA);
      pA = tree_getNextAncestorNode(nodeA, pA, true);
    }
    var pB = tree_getFirstAncestorNode(nodeB, true);
    while (pB !== null) {
      parentsB.push(pB);
      pB = tree_getNextAncestorNode(nodeB, pB, true);
    }
    var pos1 = parentsA.length;
    var pos2 = parentsB.length;
    var parent = null;
    for (var i = Math.min(pos1, pos2);i > 0; i--) {
      var parent1 = parentsA[--pos1];
      var parent2 = parentsB[--pos2];
      if (parent1 !== parent2) {
        break;
      }
      parent = parent1;
    }
    return parent;
  }
  exports.tree_getCommonAncestor = tree_getCommonAncestor;
  function tree_getFollowingNode(root, node) {
    if (node._firstChild) {
      return node._firstChild;
    } else if (node._nextSibling) {
      return node._nextSibling;
    } else {
      while (true) {
        var parent = node._parent;
        if (parent === null || parent === root) {
          return null;
        } else if (parent._nextSibling) {
          return parent._nextSibling;
        } else {
          node = parent;
        }
      }
    }
  }
  exports.tree_getFollowingNode = tree_getFollowingNode;
  function tree_getPrecedingNode(root, node) {
    if (node === root) {
      return null;
    }
    if (node._previousSibling) {
      node = node._previousSibling;
      if (node._lastChild) {
        return node._lastChild;
      } else {
        return node;
      }
    } else {
      return node._parent;
    }
  }
  exports.tree_getPrecedingNode = tree_getPrecedingNode;
  function tree_isConstrained(node) {
    var e_1, _a, e_2, _b, e_3, _c;
    switch (node._nodeType) {
      case interfaces_1.NodeType.Document:
        var hasDocType = false;
        var hasElement = false;
        try {
          for (var _d = __values(node._children), _e = _d.next();!_e.done; _e = _d.next()) {
            var childNode = _e.value;
            switch (childNode._nodeType) {
              case interfaces_1.NodeType.ProcessingInstruction:
              case interfaces_1.NodeType.Comment:
                break;
              case interfaces_1.NodeType.DocumentType:
                if (hasDocType || hasElement)
                  return false;
                hasDocType = true;
                break;
              case interfaces_1.NodeType.Element:
                if (hasElement)
                  return false;
                hasElement = true;
                break;
              default:
                return false;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_e && !_e.done && (_a = _d.return))
              _a.call(_d);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        break;
      case interfaces_1.NodeType.DocumentFragment:
      case interfaces_1.NodeType.Element:
        try {
          for (var _f = __values(node._children), _g = _f.next();!_g.done; _g = _f.next()) {
            var childNode = _g.value;
            switch (childNode._nodeType) {
              case interfaces_1.NodeType.Element:
              case interfaces_1.NodeType.Text:
              case interfaces_1.NodeType.ProcessingInstruction:
              case interfaces_1.NodeType.CData:
              case interfaces_1.NodeType.Comment:
                break;
              default:
                return false;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_g && !_g.done && (_b = _f.return))
              _b.call(_f);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        break;
      case interfaces_1.NodeType.DocumentType:
      case interfaces_1.NodeType.Text:
      case interfaces_1.NodeType.ProcessingInstruction:
      case interfaces_1.NodeType.CData:
      case interfaces_1.NodeType.Comment:
        return !node.hasChildNodes();
    }
    try {
      for (var _h = __values(node._children), _j = _h.next();!_j.done; _j = _h.next()) {
        var childNode = _j.value;
        if (!tree_isConstrained(childNode))
          return false;
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (_j && !_j.done && (_c = _h.return))
          _c.call(_h);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    return true;
  }
  exports.tree_isConstrained = tree_isConstrained;
  function tree_nodeLength(node) {
    if (util_1.Guard.isDocumentTypeNode(node)) {
      return 0;
    } else if (util_1.Guard.isCharacterDataNode(node)) {
      return node._data.length;
    } else {
      return node._children.size;
    }
  }
  exports.tree_nodeLength = tree_nodeLength;
  function tree_isEmpty(node) {
    return tree_nodeLength(node) === 0;
  }
  exports.tree_isEmpty = tree_isEmpty;
  function tree_rootNode(node, shadow) {
    if (shadow === undefined) {
      shadow = false;
    }
    if (shadow) {
      var root = tree_rootNode(node, false);
      if (util_1.Guard.isShadowRoot(root))
        return tree_rootNode(root._host, true);
      else
        return root;
    } else {
      if (!node._parent)
        return node;
      else
        return tree_rootNode(node._parent);
    }
  }
  exports.tree_rootNode = tree_rootNode;
  function tree_isDescendantOf(node, other, self2, shadow) {
    if (self2 === undefined) {
      self2 = false;
    }
    if (shadow === undefined) {
      shadow = false;
    }
    var child = tree_getFirstDescendantNode(node, self2, shadow);
    while (child !== null) {
      if (child === other) {
        return true;
      }
      child = tree_getNextDescendantNode(node, child, self2, shadow);
    }
    return false;
  }
  exports.tree_isDescendantOf = tree_isDescendantOf;
  function tree_isAncestorOf(node, other, self2, shadow) {
    if (self2 === undefined) {
      self2 = false;
    }
    if (shadow === undefined) {
      shadow = false;
    }
    var ancestor = self2 ? node : shadow && util_1.Guard.isShadowRoot(node) ? node._host : node._parent;
    while (ancestor !== null) {
      if (ancestor === other)
        return true;
      ancestor = shadow && util_1.Guard.isShadowRoot(ancestor) ? ancestor._host : ancestor._parent;
    }
    return false;
  }
  exports.tree_isAncestorOf = tree_isAncestorOf;
  function tree_isHostIncludingAncestorOf(node, other, self2) {
    if (self2 === undefined) {
      self2 = false;
    }
    if (tree_isAncestorOf(node, other, self2))
      return true;
    var root = tree_rootNode(node);
    if (util_1.Guard.isDocumentFragmentNode(root) && root._host !== null && tree_isHostIncludingAncestorOf(root._host, other, self2))
      return true;
    return false;
  }
  exports.tree_isHostIncludingAncestorOf = tree_isHostIncludingAncestorOf;
  function tree_isSiblingOf(node, other, self2) {
    if (self2 === undefined) {
      self2 = false;
    }
    if (node === other) {
      if (self2)
        return true;
    } else {
      return node._parent !== null && node._parent === other._parent;
    }
    return false;
  }
  exports.tree_isSiblingOf = tree_isSiblingOf;
  function tree_isPreceding(node, other) {
    var nodePos = tree_treePosition(node);
    var otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
      return false;
    else if (tree_rootNode(node) !== tree_rootNode(other))
      return false;
    else
      return otherPos < nodePos;
  }
  exports.tree_isPreceding = tree_isPreceding;
  function tree_isFollowing(node, other) {
    var nodePos = tree_treePosition(node);
    var otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
      return false;
    else if (tree_rootNode(node) !== tree_rootNode(other))
      return false;
    else
      return otherPos > nodePos;
  }
  exports.tree_isFollowing = tree_isFollowing;
  function tree_isParentOf(node, other) {
    return node._parent === other;
  }
  exports.tree_isParentOf = tree_isParentOf;
  function tree_isChildOf(node, other) {
    return other._parent === node;
  }
  exports.tree_isChildOf = tree_isChildOf;
  function tree_previousSibling(node) {
    return node._previousSibling;
  }
  exports.tree_previousSibling = tree_previousSibling;
  function tree_nextSibling(node) {
    return node._nextSibling;
  }
  exports.tree_nextSibling = tree_nextSibling;
  function tree_firstChild(node) {
    return node._firstChild;
  }
  exports.tree_firstChild = tree_firstChild;
  function tree_lastChild(node) {
    return node._lastChild;
  }
  exports.tree_lastChild = tree_lastChild;
  function tree_treePosition(node) {
    var root = tree_rootNode(node);
    var pos = 0;
    var childNode = tree_getFirstDescendantNode(root);
    while (childNode !== null) {
      pos++;
      if (childNode === node)
        return pos;
      childNode = tree_getNextDescendantNode(root, childNode);
    }
    return -1;
  }
  exports.tree_treePosition = tree_treePosition;
  function tree_index(node) {
    var n = 0;
    while (node._previousSibling !== null) {
      n++;
      node = node._previousSibling;
    }
    return n;
  }
  exports.tree_index = tree_index;
  function tree_retarget(a, b) {
    while (true) {
      if (!a || !util_1.Guard.isNode(a)) {
        return a;
      }
      var rootOfA = tree_rootNode(a);
      if (!util_1.Guard.isShadowRoot(rootOfA)) {
        return a;
      }
      if (b && util_1.Guard.isNode(b) && tree_isAncestorOf(rootOfA, b, true, true)) {
        return a;
      }
      a = rootOfA.host;
    }
  }
  exports.tree_retarget = tree_retarget;
});

// node_modules/@oozcitak/dom/lib/algorithm/MutationObserverAlgorithm.js
var require_MutationObserverAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var infra_1 = require_lib10();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var EventAlgorithm_1 = require_EventAlgorithm();
  function observer_queueAMutationObserverMicrotask() {
    var window2 = DOMImpl_1.dom.window;
    if (window2._mutationObserverMicrotaskQueued)
      return;
    window2._mutationObserverMicrotaskQueued = true;
    Promise.resolve().then(function() {
      observer_notifyMutationObservers();
    });
  }
  exports.observer_queueAMutationObserverMicrotask = observer_queueAMutationObserverMicrotask;
  function observer_notifyMutationObservers() {
    var e_1, _a, e_2, _b;
    var window2 = DOMImpl_1.dom.window;
    window2._mutationObserverMicrotaskQueued = false;
    var notifySet = infra_1.set.clone(window2._mutationObservers);
    var signalSet = infra_1.set.clone(window2._signalSlots);
    infra_1.set.empty(window2._signalSlots);
    var _loop_1 = function(mo2) {
      var records = infra_1.list.clone(mo2._recordQueue);
      infra_1.list.empty(mo2._recordQueue);
      for (var i = 0;i < mo2._nodeList.length; i++) {
        var node = mo2._nodeList[i];
        infra_1.list.remove(node._registeredObserverList, function(observer) {
          return util_1.Guard.isTransientRegisteredObserver(observer) && observer.observer === mo2;
        });
      }
      if (!infra_1.list.isEmpty(records)) {
        try {
          mo2._callback.call(mo2, records, mo2);
        } catch (err) {
        }
      }
    };
    try {
      for (var notifySet_1 = __values(notifySet), notifySet_1_1 = notifySet_1.next();!notifySet_1_1.done; notifySet_1_1 = notifySet_1.next()) {
        var mo = notifySet_1_1.value;
        _loop_1(mo);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (notifySet_1_1 && !notifySet_1_1.done && (_a = notifySet_1.return))
          _a.call(notifySet_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      try {
        for (var signalSet_1 = __values(signalSet), signalSet_1_1 = signalSet_1.next();!signalSet_1_1.done; signalSet_1_1 = signalSet_1.next()) {
          var slot = signalSet_1_1.value;
          EventAlgorithm_1.event_fireAnEvent("slotchange", slot, undefined, { bubbles: true });
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (signalSet_1_1 && !signalSet_1_1.done && (_b = signalSet_1.return))
            _b.call(signalSet_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  }
  exports.observer_notifyMutationObservers = observer_notifyMutationObservers;
  function observer_queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {
    var e_3, _a;
    var interestedObservers = new Map;
    var node = TreeAlgorithm_1.tree_getFirstAncestorNode(target, true);
    while (node !== null) {
      for (var i = 0;i < node._registeredObserverList.length; i++) {
        var registered = node._registeredObserverList[i];
        var options = registered.options;
        if (node !== target && !options.subtree)
          continue;
        if (type === "attributes" && !options.attributes)
          continue;
        if (type === "attributes" && options.attributeFilter && (!options.attributeFilter.indexOf(name || "") || namespace !== null))
          continue;
        if (type === "characterData" && !options.characterData)
          continue;
        if (type === "childList" && !options.childList)
          continue;
        var mo = registered.observer;
        if (!interestedObservers.has(mo)) {
          interestedObservers.set(mo, null);
        }
        if (type === "attributes" && options.attributeOldValue || type === "characterData" && options.characterDataOldValue) {
          interestedObservers.set(mo, oldValue);
        }
      }
      node = TreeAlgorithm_1.tree_getNextAncestorNode(target, node, true);
    }
    try {
      for (var interestedObservers_1 = __values(interestedObservers), interestedObservers_1_1 = interestedObservers_1.next();!interestedObservers_1_1.done; interestedObservers_1_1 = interestedObservers_1.next()) {
        var _b = __read(interestedObservers_1_1.value, 2), observer = _b[0], mappedOldValue = _b[1];
        var record = CreateAlgorithm_1.create_mutationRecord(type, target, CreateAlgorithm_1.create_nodeListStatic(target, addedNodes), CreateAlgorithm_1.create_nodeListStatic(target, removedNodes), previousSibling, nextSibling, name, namespace, mappedOldValue);
        var queue = observer._recordQueue;
        queue.push(record);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (interestedObservers_1_1 && !interestedObservers_1_1.done && (_a = interestedObservers_1.return))
          _a.call(interestedObservers_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    observer_queueAMutationObserverMicrotask();
  }
  exports.observer_queueMutationRecord = observer_queueMutationRecord;
  function observer_queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {
    observer_queueMutationRecord("childList", target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);
  }
  exports.observer_queueTreeMutationRecord = observer_queueTreeMutationRecord;
  function observer_queueAttributeMutationRecord(target, name, namespace, oldValue) {
    observer_queueMutationRecord("attributes", target, name, namespace, oldValue, [], [], null, null);
  }
  exports.observer_queueAttributeMutationRecord = observer_queueAttributeMutationRecord;
});

// node_modules/@oozcitak/dom/lib/algorithm/ShadowTreeAlgorithm.js
var require_ShadowTreeAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var util_2 = require_lib8();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
  function shadowTree_signalASlotChange(slot) {
    var window2 = DOMImpl_1.dom.window;
    window2._signalSlots.add(slot);
    MutationObserverAlgorithm_1.observer_queueAMutationObserverMicrotask();
  }
  exports.shadowTree_signalASlotChange = shadowTree_signalASlotChange;
  function shadowTree_isConnected(element) {
    return util_1.Guard.isDocumentNode(TreeAlgorithm_1.tree_rootNode(element, true));
  }
  exports.shadowTree_isConnected = shadowTree_isConnected;
  function shadowTree_isAssigned(slotable) {
    return slotable._assignedSlot !== null;
  }
  exports.shadowTree_isAssigned = shadowTree_isAssigned;
  function shadowTree_findASlot(slotable, openFlag) {
    if (openFlag === undefined) {
      openFlag = false;
    }
    var node = util_1.Cast.asNode(slotable);
    var parent = node._parent;
    if (parent === null)
      return null;
    var shadow = parent._shadowRoot || null;
    if (shadow === null)
      return null;
    if (openFlag && shadow._mode !== "open")
      return null;
    var child = TreeAlgorithm_1.tree_getFirstDescendantNode(shadow, false, true, function(e) {
      return util_1.Guard.isSlot(e);
    });
    while (child !== null) {
      if (child._name === slotable._name)
        return child;
      child = TreeAlgorithm_1.tree_getNextDescendantNode(shadow, child, false, true, function(e) {
        return util_1.Guard.isSlot(e);
      });
    }
    return null;
  }
  exports.shadowTree_findASlot = shadowTree_findASlot;
  function shadowTree_findSlotables(slot) {
    var e_1, _a;
    var result = [];
    var root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root))
      return result;
    var host = root._host;
    try {
      for (var _b = __values(host._children), _c = _b.next();!_c.done; _c = _b.next()) {
        var slotable = _c.value;
        if (util_1.Guard.isSlotable(slotable)) {
          var foundSlot = shadowTree_findASlot(slotable);
          if (foundSlot === slot) {
            result.push(slotable);
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return result;
  }
  exports.shadowTree_findSlotables = shadowTree_findSlotables;
  function shadowTree_findFlattenedSlotables(slot) {
    var e_2, _a, e_3, _b;
    var result = [];
    var root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root))
      return result;
    var slotables = shadowTree_findSlotables(slot);
    if (util_2.isEmpty(slotables)) {
      try {
        for (var _c = __values(slot._children), _d = _c.next();!_d.done; _d = _c.next()) {
          var slotable = _d.value;
          if (util_1.Guard.isSlotable(slotable)) {
            slotables.push(slotable);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    try {
      for (var slotables_1 = __values(slotables), slotables_1_1 = slotables_1.next();!slotables_1_1.done; slotables_1_1 = slotables_1.next()) {
        var node = slotables_1_1.value;
        if (util_1.Guard.isSlot(node) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(node))) {
          var temporaryResult = shadowTree_findFlattenedSlotables(node);
          result.push.apply(result, __spread(temporaryResult));
        } else {
          result.push(node);
        }
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (slotables_1_1 && !slotables_1_1.done && (_b = slotables_1.return))
          _b.call(slotables_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    return result;
  }
  exports.shadowTree_findFlattenedSlotables = shadowTree_findFlattenedSlotables;
  function shadowTree_assignSlotables(slot) {
    var e_4, _a;
    var slotables = shadowTree_findSlotables(slot);
    if (slotables.length === slot._assignedNodes.length) {
      var nodesIdentical = true;
      for (var i = 0;i < slotables.length; i++) {
        if (slotables[i] !== slot._assignedNodes[i]) {
          nodesIdentical = false;
          break;
        }
      }
      if (!nodesIdentical) {
        shadowTree_signalASlotChange(slot);
      }
    }
    slot._assignedNodes = slotables;
    try {
      for (var slotables_2 = __values(slotables), slotables_2_1 = slotables_2.next();!slotables_2_1.done; slotables_2_1 = slotables_2.next()) {
        var slotable = slotables_2_1.value;
        slotable._assignedSlot = slot;
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (slotables_2_1 && !slotables_2_1.done && (_a = slotables_2.return))
          _a.call(slotables_2);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
  }
  exports.shadowTree_assignSlotables = shadowTree_assignSlotables;
  function shadowTree_assignSlotablesForATree(root) {
    var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(root, true, false, function(e) {
      return util_1.Guard.isSlot(e);
    });
    while (descendant !== null) {
      shadowTree_assignSlotables(descendant);
      descendant = TreeAlgorithm_1.tree_getNextDescendantNode(root, descendant, true, false, function(e) {
        return util_1.Guard.isSlot(e);
      });
    }
  }
  exports.shadowTree_assignSlotablesForATree = shadowTree_assignSlotablesForATree;
  function shadowTree_assignASlot(slotable) {
    var slot = shadowTree_findASlot(slotable);
    if (slot !== null) {
      shadowTree_assignSlotables(slot);
    }
  }
  exports.shadowTree_assignASlot = shadowTree_assignASlot;
});

// node_modules/@oozcitak/dom/lib/algorithm/DOMAlgorithm.js
var require_DOMAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var util_1 = require_util2();
  var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
  var supportedTokens = new Map;
  function dom_runRemovingSteps(removedNode, oldParent) {
  }
  exports.dom_runRemovingSteps = dom_runRemovingSteps;
  function dom_runCloningSteps(copy, node, document2, cloneChildrenFlag) {
  }
  exports.dom_runCloningSteps = dom_runCloningSteps;
  function dom_runAdoptingSteps(node, oldDocument) {
  }
  exports.dom_runAdoptingSteps = dom_runAdoptingSteps;
  function dom_runAttributeChangeSteps(element, localName, oldValue, value, namespace) {
    var e_1, _a;
    if (DOMImpl_1.dom.features.slots) {
      updateASlotablesName.call(element, element, localName, oldValue, value, namespace);
      updateASlotsName.call(element, element, localName, oldValue, value, namespace);
    }
    updateAnElementID.call(element, element, localName, value, namespace);
    try {
      for (var _b = __values(element._attributeChangeSteps), _c = _b.next();!_c.done; _c = _b.next()) {
        var step = _c.value;
        step.call(element, element, localName, oldValue, value, namespace);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  exports.dom_runAttributeChangeSteps = dom_runAttributeChangeSteps;
  function dom_runInsertionSteps(insertedNode) {
  }
  exports.dom_runInsertionSteps = dom_runInsertionSteps;
  function dom_runNodeIteratorPreRemovingSteps(nodeIterator, toBeRemoved) {
    removeNodeIterator.call(nodeIterator, nodeIterator, toBeRemoved);
  }
  exports.dom_runNodeIteratorPreRemovingSteps = dom_runNodeIteratorPreRemovingSteps;
  function dom_hasSupportedTokens(attributeName) {
    return supportedTokens.has(attributeName);
  }
  exports.dom_hasSupportedTokens = dom_hasSupportedTokens;
  function dom_getSupportedTokens(attributeName) {
    return supportedTokens.get(attributeName) || new Set;
  }
  exports.dom_getSupportedTokens = dom_getSupportedTokens;
  function dom_runEventConstructingSteps(event) {
  }
  exports.dom_runEventConstructingSteps = dom_runEventConstructingSteps;
  function dom_runChildTextContentChangeSteps(parent) {
  }
  exports.dom_runChildTextContentChangeSteps = dom_runChildTextContentChangeSteps;
  function removeNodeIterator(nodeIterator, toBeRemovedNode) {
    if (toBeRemovedNode === nodeIterator._root || !TreeAlgorithm_1.tree_isAncestorOf(nodeIterator._reference, toBeRemovedNode, true)) {
      return;
    }
    if (nodeIterator._pointerBeforeReference) {
      while (true) {
        var nextNode = TreeAlgorithm_1.tree_getFollowingNode(nodeIterator._root, toBeRemovedNode);
        if (nextNode !== null && TreeAlgorithm_1.tree_isDescendantOf(nodeIterator._root, nextNode, true) && !TreeAlgorithm_1.tree_isDescendantOf(toBeRemovedNode, nextNode, true)) {
          nodeIterator._reference = nextNode;
          return;
        } else if (nextNode === null) {
          nodeIterator._pointerBeforeReference = false;
          return;
        }
      }
    }
    if (toBeRemovedNode._previousSibling === null) {
      if (toBeRemovedNode._parent !== null) {
        nodeIterator._reference = toBeRemovedNode._parent;
      }
    } else {
      var referenceNode = toBeRemovedNode._previousSibling;
      var childNode = TreeAlgorithm_1.tree_getFirstDescendantNode(toBeRemovedNode._previousSibling, true, false);
      while (childNode !== null) {
        if (childNode !== null) {
          referenceNode = childNode;
        }
        childNode = TreeAlgorithm_1.tree_getNextDescendantNode(toBeRemovedNode._previousSibling, childNode, true, false);
      }
      nodeIterator._reference = referenceNode;
    }
  }
  function updateASlotsName(element, localName, oldValue, value, namespace) {
    if (util_1.Guard.isSlot(element) && localName === "name" && namespace === null) {
      if (value === oldValue)
        return;
      if (value === null && oldValue === "")
        return;
      if (value === "" && oldValue === null)
        return;
      if (value === null || value === "") {
        element._name = "";
      } else {
        element._name = value;
      }
      ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(element));
    }
  }
  function updateASlotablesName(element, localName, oldValue, value, namespace) {
    if (util_1.Guard.isSlotable(element) && localName === "slot" && namespace === null) {
      if (value === oldValue)
        return;
      if (value === null && oldValue === "")
        return;
      if (value === "" && oldValue === null)
        return;
      if (value === null || value === "") {
        element._name = "";
      } else {
        element._name = value;
      }
      if (ShadowTreeAlgorithm_1.shadowTree_isAssigned(element)) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotables(element._assignedSlot);
      }
      ShadowTreeAlgorithm_1.shadowTree_assignASlot(element);
    }
  }
  function updateAnElementID(element, localName, value, namespace) {
    if (localName === "id" && namespace === null) {
      if (!value)
        element._uniqueIdentifier = undefined;
      else
        element._uniqueIdentifier = value;
    }
  }
});

// node_modules/@oozcitak/dom/lib/algorithm/EventAlgorithm.js
var require_EventAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var util_1 = require_util2();
  var CustomEventImpl_1 = require_CustomEventImpl();
  var EventImpl_1 = require_EventImpl();
  var DOMException_1 = require_DOMException();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  function event_setTheCanceledFlag(event) {
    if (event._cancelable && !event._inPassiveListenerFlag) {
      event._canceledFlag = true;
    }
  }
  exports.event_setTheCanceledFlag = event_setTheCanceledFlag;
  function event_initialize(event, type, bubbles, cancelable) {
    event._initializedFlag = true;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    event._canceledFlag = false;
    event._isTrusted = false;
    event._target = null;
    event._type = type;
    event._bubbles = bubbles;
    event._cancelable = cancelable;
  }
  exports.event_initialize = event_initialize;
  function event_createAnEvent(eventInterface, realm) {
    if (realm === undefined) {
      realm = undefined;
    }
    if (realm === undefined)
      realm = null;
    var dictionary = {};
    var event = event_innerEventCreationSteps(eventInterface, realm, new Date, dictionary);
    event._isTrusted = true;
    return event;
  }
  exports.event_createAnEvent = event_createAnEvent;
  function event_innerEventCreationSteps(eventInterface, realm, time, dictionary) {
    var event = new eventInterface("");
    event._initializedFlag = true;
    event._timeStamp = time.getTime();
    Object.assign(event, dictionary);
    if (DOMImpl_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runEventConstructingSteps(event);
    }
    return event;
  }
  exports.event_innerEventCreationSteps = event_innerEventCreationSteps;
  function event_dispatch(event, target, legacyTargetOverrideFlag, legacyOutputDidListenersThrowFlag) {
    var e_1, _a, e_2, _b;
    if (legacyTargetOverrideFlag === undefined) {
      legacyTargetOverrideFlag = false;
    }
    if (legacyOutputDidListenersThrowFlag === undefined) {
      legacyOutputDidListenersThrowFlag = { value: false };
    }
    var clearTargets = false;
    event._dispatchFlag = true;
    var targetOverride = target;
    if (legacyTargetOverrideFlag) {
      var doc = target._associatedDocument;
      if (util_1.Guard.isDocumentNode(doc)) {
        targetOverride = doc;
      }
    }
    var activationTarget = null;
    var relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, target);
    if (target !== relatedTarget || target === event._relatedTarget) {
      var touchTargets = [];
      try {
        for (var _c = __values(event._touchTargetList), _d = _c.next();!_d.done; _d = _c.next()) {
          var touchTarget = _d.value;
          touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, target));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      event_appendToAnEventPath(event, target, targetOverride, relatedTarget, touchTargets, false);
      var isActivationEvent = util_1.Guard.isMouseEvent(event) && event._type === "click";
      if (isActivationEvent && target._activationBehavior !== undefined) {
        activationTarget = target;
      }
      var slotable = util_1.Guard.isSlotable(target) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(target) ? target : null;
      var slotInClosedTree = false;
      var parent = target._getTheParent(event);
      while (parent !== null && util_1.Guard.isNode(parent)) {
        if (slotable !== null) {
          if (!util_1.Guard.isSlot(parent)) {
            throw new Error("Parent node of a slotable should be a slot.");
          }
          slotable = null;
          var root = TreeAlgorithm_1.tree_rootNode(parent, true);
          if (util_1.Guard.isShadowRoot(root) && root._mode === "closed") {
            slotInClosedTree = true;
          }
        }
        if (util_1.Guard.isSlotable(parent) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(parent)) {
          slotable = parent;
        }
        relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, parent);
        touchTargets = [];
        try {
          for (var _e = (e_2 = undefined, __values(event._touchTargetList)), _f = _e.next();!_f.done; _f = _e.next()) {
            var touchTarget = _f.value;
            touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, parent));
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_f && !_f.done && (_b = _e.return))
              _b.call(_e);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        if (util_1.Guard.isWindow(parent) || util_1.Guard.isNode(parent) && util_1.Guard.isNode(target) && TreeAlgorithm_1.tree_isAncestorOf(TreeAlgorithm_1.tree_rootNode(target, true), parent, true, true)) {
          if (isActivationEvent && event._bubbles && activationTarget === null && parent._activationBehavior) {
            activationTarget = parent;
          }
          event_appendToAnEventPath(event, parent, null, relatedTarget, touchTargets, slotInClosedTree);
        } else if (parent === relatedTarget) {
          parent = null;
        } else {
          target = parent;
          if (isActivationEvent && activationTarget === null && target._activationBehavior) {
            activationTarget = target;
          }
          event_appendToAnEventPath(event, parent, target, relatedTarget, touchTargets, slotInClosedTree);
        }
        if (parent !== null) {
          parent = parent._getTheParent(event);
        }
        slotInClosedTree = false;
      }
      var clearTargetsStruct = null;
      var path = event._path;
      for (var i = path.length - 1;i >= 0; i--) {
        var struct = path[i];
        if (struct.shadowAdjustedTarget !== null) {
          clearTargetsStruct = struct;
          break;
        }
      }
      if (clearTargetsStruct !== null) {
        if (util_1.Guard.isNode(clearTargetsStruct.shadowAdjustedTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.shadowAdjustedTarget, true))) {
          clearTargets = true;
        } else if (util_1.Guard.isNode(clearTargetsStruct.relatedTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.relatedTarget, true))) {
          clearTargets = true;
        } else {
          for (var j = 0;j < clearTargetsStruct.touchTargetList.length; j++) {
            var struct = clearTargetsStruct.touchTargetList[j];
            if (util_1.Guard.isNode(struct) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(struct, true))) {
              clearTargets = true;
              break;
            }
          }
        }
      }
      if (activationTarget !== null && activationTarget._legacyPreActivationBehavior !== undefined) {
        activationTarget._legacyPreActivationBehavior(event);
      }
      for (var i = path.length - 1;i >= 0; i--) {
        var struct = path[i];
        if (struct.shadowAdjustedTarget !== null) {
          event._eventPhase = interfaces_1.EventPhase.AtTarget;
        } else {
          event._eventPhase = interfaces_1.EventPhase.Capturing;
        }
        event_invoke(struct, event, "capturing", legacyOutputDidListenersThrowFlag);
      }
      for (var i = 0;i < path.length; i++) {
        var struct = path[i];
        if (struct.shadowAdjustedTarget !== null) {
          event._eventPhase = interfaces_1.EventPhase.AtTarget;
        } else {
          if (!event._bubbles)
            continue;
          event._eventPhase = interfaces_1.EventPhase.Bubbling;
        }
        event_invoke(struct, event, "bubbling", legacyOutputDidListenersThrowFlag);
      }
    }
    event._eventPhase = interfaces_1.EventPhase.None;
    event._currentTarget = null;
    event._path = [];
    event._dispatchFlag = false;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    if (clearTargets) {
      event._target = null;
      event._relatedTarget = null;
      event._touchTargetList = [];
    }
    if (activationTarget !== null) {
      if (!event._canceledFlag && activationTarget._activationBehavior !== undefined) {
        activationTarget._activationBehavior(event);
      } else if (activationTarget._legacyCanceledActivationBehavior !== undefined) {
        activationTarget._legacyCanceledActivationBehavior(event);
      }
    }
    return !event._canceledFlag;
  }
  exports.event_dispatch = event_dispatch;
  function event_appendToAnEventPath(event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, slotInClosedTree) {
    var invocationTargetInShadowTree = false;
    if (util_1.Guard.isNode(invocationTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(invocationTarget))) {
      invocationTargetInShadowTree = true;
    }
    var rootOfClosedTree = false;
    if (util_1.Guard.isShadowRoot(invocationTarget) && invocationTarget._mode === "closed") {
      rootOfClosedTree = true;
    }
    event._path.push({
      invocationTarget,
      invocationTargetInShadowTree,
      shadowAdjustedTarget,
      relatedTarget,
      touchTargetList: touchTargets,
      rootOfClosedTree,
      slotInClosedTree
    });
  }
  exports.event_appendToAnEventPath = event_appendToAnEventPath;
  function event_invoke(struct, event, phase, legacyOutputDidListenersThrowFlag) {
    if (legacyOutputDidListenersThrowFlag === undefined) {
      legacyOutputDidListenersThrowFlag = { value: false };
    }
    var path = event._path;
    var index = -1;
    for (var i = 0;i < path.length; i++) {
      if (path[i] === struct) {
        index = i;
        break;
      }
    }
    if (index !== -1) {
      var item = path[index];
      if (item.shadowAdjustedTarget !== null) {
        event._target = item.shadowAdjustedTarget;
      } else if (index > 0) {
        item = path[index - 1];
        if (item.shadowAdjustedTarget !== null) {
          event._target = item.shadowAdjustedTarget;
        }
      }
    }
    event._relatedTarget = struct.relatedTarget;
    event._touchTargetList = struct.touchTargetList;
    if (event._stopPropagationFlag)
      return;
    event._currentTarget = struct.invocationTarget;
    var currentTarget = event._currentTarget;
    var targetListeners = currentTarget._eventListenerList;
    var listeners = new (Array.bind.apply(Array, __spread([undefined], targetListeners)));
    var found = event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
    if (!found && event._isTrusted) {
      var originalEventType = event._type;
      if (originalEventType === "animationend") {
        event._type = "webkitAnimationEnd";
      } else if (originalEventType === "animationiteration") {
        event._type = "webkitAnimationIteration";
      } else if (originalEventType === "animationstart") {
        event._type = "webkitAnimationStart";
      } else if (originalEventType === "transitionend") {
        event._type = "webkitTransitionEnd";
      }
      event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
      event._type = originalEventType;
    }
  }
  exports.event_invoke = event_invoke;
  function event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag) {
    if (legacyOutputDidListenersThrowFlag === undefined) {
      legacyOutputDidListenersThrowFlag = { value: false };
    }
    var found = false;
    for (var i = 0;i < listeners.length; i++) {
      var listener = listeners[i];
      if (!listener.removed) {
        if (event._type !== listener.type)
          continue;
        found = true;
        if (phase === "capturing" && !listener.capture)
          continue;
        if (phase === "bubbling" && listener.capture)
          continue;
        if (listener.once && event._currentTarget !== null) {
          var impl = event._currentTarget;
          var index = -1;
          for (var i_1 = 0;i_1 < impl._eventListenerList.length; i_1++) {
            if (impl._eventListenerList[i_1] === listener) {
              index = i_1;
              break;
            }
          }
          if (index !== -1) {
            impl._eventListenerList.splice(index, 1);
          }
        }
        var globalObject = undefined;
        var currentEvent = undefined;
        if (util_1.Guard.isWindow(globalObject)) {
          currentEvent = globalObject._currentEvent;
          if (struct.invocationTargetInShadowTree === false) {
            globalObject._currentEvent = event;
          }
        }
        if (listener.passive)
          event._inPassiveListenerFlag = true;
        try {
          listener.callback.handleEvent.call(event._currentTarget, event);
        } catch (err) {
          legacyOutputDidListenersThrowFlag.value = true;
        }
        if (listener.passive)
          event._inPassiveListenerFlag = false;
        if (util_1.Guard.isWindow(globalObject)) {
          globalObject._currentEvent = currentEvent;
        }
        if (event._stopImmediatePropagationFlag)
          return found;
      }
    }
    return found;
  }
  exports.event_innerInvoke = event_innerInvoke;
  function event_fireAnEvent(e, target, eventConstructor, idlAttributes, legacyTargetOverrideFlag) {
    if (eventConstructor === undefined) {
      eventConstructor = EventImpl_1.EventImpl;
    }
    var event = event_createAnEvent(eventConstructor);
    event._type = e;
    if (idlAttributes) {
      for (var key in idlAttributes) {
        var idlObj = event;
        idlObj[key] = idlAttributes[key];
      }
    }
    return event_dispatch(event, target, legacyTargetOverrideFlag);
  }
  exports.event_fireAnEvent = event_fireAnEvent;
  function event_createLegacyEvent(eventInterface) {
    var constructor = null;
    switch (eventInterface.toLowerCase()) {
      case "beforeunloadevent":
        break;
      case "compositionevent":
        break;
      case "customevent":
        constructor = CustomEventImpl_1.CustomEventImpl;
        break;
      case "devicemotionevent":
        break;
      case "deviceorientationevent":
        break;
      case "dragevent":
        break;
      case "event":
      case "events":
        constructor = EventImpl_1.EventImpl;
        break;
      case "focusevent":
        break;
      case "hashchangeevent":
        break;
      case "htmlevents":
        break;
      case "keyboardevent":
        break;
      case "messageevent":
        break;
      case "mouseevent":
        break;
      case "mouseevents":
        break;
      case "storageevent":
        break;
      case "svgevents":
        break;
      case "textevent":
        break;
      case "touchevent":
        break;
      case "uievent":
        break;
      case "uievents":
        break;
    }
    if (constructor === null) {
      throw new DOMException_1.NotSupportedError("Event constructor not found for interface " + eventInterface + ".");
    }
    var event = new constructor("");
    event._type = "";
    event._timeStamp = new Date().getTime();
    event._isTrusted = false;
    event._initializedFlag = false;
    return event;
  }
  exports.event_createLegacyEvent = event_createLegacyEvent;
  function event_getterEventHandlerIDLAttribute(thisObj, name) {
    var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null)
      return null;
    return event_getTheCurrentValueOfAnEventHandler(eventTarget, name);
  }
  exports.event_getterEventHandlerIDLAttribute = event_getterEventHandlerIDLAttribute;
  function event_setterEventHandlerIDLAttribute(thisObj, name, value) {
    var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null)
      return;
    if (value === null) {
      event_deactivateAnEventHandler(eventTarget, name);
    } else {
      var handlerMap = eventTarget._eventHandlerMap;
      var eventHandler = handlerMap["onabort"];
      if (eventHandler !== undefined) {
        eventHandler.value = value;
      }
      event_activateAnEventHandler(eventTarget, name);
    }
  }
  exports.event_setterEventHandlerIDLAttribute = event_setterEventHandlerIDLAttribute;
  function event_determineTheTargetOfAnEventHandler(eventTarget, name) {
    return null;
  }
  exports.event_determineTheTargetOfAnEventHandler = event_determineTheTargetOfAnEventHandler;
  function event_getTheCurrentValueOfAnEventHandler(eventTarget, name) {
    return null;
  }
  exports.event_getTheCurrentValueOfAnEventHandler = event_getTheCurrentValueOfAnEventHandler;
  function event_activateAnEventHandler(eventTarget, name) {
  }
  exports.event_activateAnEventHandler = event_activateAnEventHandler;
  function event_deactivateAnEventHandler(eventTarget, name) {
  }
  exports.event_deactivateAnEventHandler = event_deactivateAnEventHandler;
});

// node_modules/@oozcitak/dom/lib/algorithm/AbortAlgorithm.js
var require_AbortAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EventAlgorithm_1 = require_EventAlgorithm();
  function abort_add(algorithm, signal) {
    if (signal._abortedFlag)
      return;
    signal._abortAlgorithms.add(algorithm);
  }
  exports.abort_add = abort_add;
  function abort_remove(algorithm, signal) {
    signal._abortAlgorithms.delete(algorithm);
  }
  exports.abort_remove = abort_remove;
  function abort_signalAbort(signal) {
    var e_1, _a;
    if (signal._abortedFlag)
      return;
    signal._abortedFlag = true;
    try {
      for (var _b = __values(signal._abortAlgorithms), _c = _b.next();!_c.done; _c = _b.next()) {
        var algorithm = _c.value;
        algorithm.call(signal);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    signal._abortAlgorithms.clear();
    EventAlgorithm_1.event_fireAnEvent("abort", signal);
  }
  exports.abort_signalAbort = abort_signalAbort;
});

// node_modules/@oozcitak/dom/lib/algorithm/CustomElementAlgorithm.js
var require_CustomElementAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var PotentialCustomElementName = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/;
  var NamesWithHyphen = new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  var ElementNames = new Set([
    "article",
    "aside",
    "blockquote",
    "body",
    "div",
    "footer",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "main",
    "nav",
    "p",
    "section",
    "span"
  ]);
  var VoidElementNames = new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var ShadowHostNames = new Set([
    "article",
    "aside",
    "blockquote",
    "body",
    "div",
    "footer",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "main",
    "nav",
    "p",
    "section",
    "span"
  ]);
  function customElement_isValidCustomElementName(name) {
    if (!PotentialCustomElementName.test(name))
      return false;
    if (NamesWithHyphen.has(name))
      return false;
    return true;
  }
  exports.customElement_isValidCustomElementName = customElement_isValidCustomElementName;
  function customElement_isValidElementName(name) {
    return ElementNames.has(name);
  }
  exports.customElement_isValidElementName = customElement_isValidElementName;
  function customElement_isVoidElementName(name) {
    return VoidElementNames.has(name);
  }
  exports.customElement_isVoidElementName = customElement_isVoidElementName;
  function customElement_isValidShadowHostName(name) {
    return ShadowHostNames.has(name);
  }
  exports.customElement_isValidShadowHostName = customElement_isValidShadowHostName;
  function customElement_enqueueACustomElementUpgradeReaction(element, definition) {
  }
  exports.customElement_enqueueACustomElementUpgradeReaction = customElement_enqueueACustomElementUpgradeReaction;
  function customElement_enqueueACustomElementCallbackReaction(element, callbackName, args) {
  }
  exports.customElement_enqueueACustomElementCallbackReaction = customElement_enqueueACustomElementCallbackReaction;
  function customElement_upgrade(definition, element) {
  }
  exports.customElement_upgrade = customElement_upgrade;
  function customElement_tryToUpgrade(element) {
  }
  exports.customElement_tryToUpgrade = customElement_tryToUpgrade;
  function customElement_lookUpACustomElementDefinition(document2, namespace, localName, is) {
    return null;
  }
  exports.customElement_lookUpACustomElementDefinition = customElement_lookUpACustomElementDefinition;
});

// node_modules/@oozcitak/dom/lib/algorithm/TraversalAlgorithm.js
var require_TraversalAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var DOMException_1 = require_DOMException();
  function traversal_filter(traverser, node) {
    if (traverser._activeFlag) {
      throw new DOMException_1.InvalidStateError;
    }
    var n = node._nodeType - 1;
    var mask = 1 << n;
    if ((traverser.whatToShow & mask) === 0) {
      return interfaces_1.FilterResult.Skip;
    }
    if (!traverser.filter) {
      return interfaces_1.FilterResult.Accept;
    }
    traverser._activeFlag = true;
    var result = interfaces_1.FilterResult.Reject;
    try {
      result = traverser.filter.acceptNode(node);
    } catch (err) {
      traverser._activeFlag = false;
      throw err;
    }
    traverser._activeFlag = false;
    return result;
  }
  exports.traversal_filter = traversal_filter;
});

// node_modules/@oozcitak/dom/lib/algorithm/NodeIteratorAlgorithm.js
var require_NodeIteratorAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var interfaces_1 = require_interfaces2();
  var TraversalAlgorithm_1 = require_TraversalAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  function nodeIterator_traverse(iterator, forward) {
    var node = iterator._reference;
    var beforeNode = iterator._pointerBeforeReference;
    while (true) {
      if (forward) {
        if (!beforeNode) {
          var nextNode = TreeAlgorithm_1.tree_getFollowingNode(iterator._root, node);
          if (nextNode) {
            node = nextNode;
          } else {
            return null;
          }
        } else {
          beforeNode = false;
        }
      } else {
        if (beforeNode) {
          var prevNode = TreeAlgorithm_1.tree_getPrecedingNode(iterator.root, node);
          if (prevNode) {
            node = prevNode;
          } else {
            return null;
          }
        } else {
          beforeNode = true;
        }
      }
      var result = TraversalAlgorithm_1.traversal_filter(iterator, node);
      if (result === interfaces_1.FilterResult.Accept) {
        break;
      }
    }
    iterator._reference = node;
    iterator._pointerBeforeReference = beforeNode;
    return node;
  }
  exports.nodeIterator_traverse = nodeIterator_traverse;
  function nodeIterator_iteratorList() {
    return DOMImpl_1.dom.window._iteratorList;
  }
  exports.nodeIterator_iteratorList = nodeIterator_iteratorList;
});

// node_modules/@oozcitak/dom/lib/algorithm/XMLAlgorithm.js
var require_XMLAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function xml_isName(name) {
    for (var i = 0;i < name.length; i++) {
      var n = name.charCodeAt(i);
      if (n >= 97 && n <= 122 || n >= 65 && n <= 90 || n === 58 || n === 95 || n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) {
        continue;
      } else if (i !== 0 && (n === 45 || n === 46 || n >= 48 && n <= 57 || n === 183 || n >= 768 && n <= 879 || n >= 8255 && n <= 8256)) {
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < name.length - 1) {
        var n2 = name.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 983039) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports.xml_isName = xml_isName;
  function xml_isQName(name) {
    var colonFound = false;
    for (var i = 0;i < name.length; i++) {
      var n = name.charCodeAt(i);
      if (n >= 97 && n <= 122 || n >= 65 && n <= 90 || n === 95 || n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) {
        continue;
      } else if (i !== 0 && (n === 45 || n === 46 || n >= 48 && n <= 57 || n === 183 || n >= 768 && n <= 879 || n >= 8255 && n <= 8256)) {
        continue;
      } else if (i !== 0 && n === 58) {
        if (colonFound)
          return false;
        if (i === name.length - 1)
          return false;
        colonFound = true;
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < name.length - 1) {
        var n2 = name.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 983039) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports.xml_isQName = xml_isQName;
  function xml_isLegalChar(chars) {
    for (var i = 0;i < chars.length; i++) {
      var n = chars.charCodeAt(i);
      if (n === 9 || n === 10 || n === 13 || n >= 32 && n <= 55295 || n >= 57344 && n <= 65533) {
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < chars.length - 1) {
        var n2 = chars.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 1114111) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports.xml_isLegalChar = xml_isLegalChar;
  function xml_isPubidChar(chars) {
    for (var i = 0;i < chars.length; i++) {
      var n = chars.charCodeAt(i);
      if (n >= 97 && n <= 122 || n >= 65 && n <= 90 || n >= 39 && n <= 59 || n === 32 || n === 13 || n === 10 || n >= 35 && n <= 37 || n === 33 || n === 61 || n === 63 || n === 64 || n === 95) {
        continue;
      } else {
        return false;
      }
    }
    return true;
  }
  exports.xml_isPubidChar = xml_isPubidChar;
});

// node_modules/@oozcitak/dom/lib/algorithm/NamespaceAlgorithm.js
var require_NamespaceAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib10();
  var XMLAlgorithm_1 = require_XMLAlgorithm();
  function namespace_validate(qualifiedName) {
    if (!XMLAlgorithm_1.xml_isName(qualifiedName))
      throw new DOMException_1.InvalidCharacterError("Invalid XML name: " + qualifiedName);
    if (!XMLAlgorithm_1.xml_isQName(qualifiedName))
      throw new DOMException_1.InvalidCharacterError("Invalid XML qualified name: " + qualifiedName + ".");
  }
  exports.namespace_validate = namespace_validate;
  function namespace_validateAndExtract(namespace, qualifiedName) {
    if (!namespace)
      namespace = null;
    namespace_validate(qualifiedName);
    var parts = qualifiedName.split(":");
    var prefix = parts.length === 2 ? parts[0] : null;
    var localName = parts.length === 2 ? parts[1] : qualifiedName;
    if (prefix && namespace === null)
      throw new DOMException_1.NamespaceError("Qualified name includes a prefix but the namespace is null.");
    if (prefix === "xml" && namespace !== infra_1.namespace.XML)
      throw new DOMException_1.NamespaceError('Qualified name includes the "xml" prefix but the namespace is not the XML namespace.');
    if (namespace !== infra_1.namespace.XMLNS && (prefix === "xmlns" || qualifiedName === "xmlns"))
      throw new DOMException_1.NamespaceError('Qualified name includes the "xmlns" prefix but the namespace is not the XMLNS namespace.');
    if (namespace === infra_1.namespace.XMLNS && (prefix !== "xmlns" && qualifiedName !== "xmlns"))
      throw new DOMException_1.NamespaceError('Qualified name does not include the "xmlns" prefix but the namespace is the XMLNS namespace.');
    return [namespace, prefix, localName];
  }
  exports.namespace_validateAndExtract = namespace_validateAndExtract;
  function namespace_extractQName(qualifiedName) {
    namespace_validate(qualifiedName);
    var parts = qualifiedName.split(":");
    var prefix = parts.length === 2 ? parts[0] : null;
    var localName = parts.length === 2 ? parts[1] : qualifiedName;
    return [prefix, localName];
  }
  exports.namespace_extractQName = namespace_extractQName;
});

// node_modules/@oozcitak/dom/lib/algorithm/DocumentAlgorithm.js
var require_DocumentAlgorithm = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var util_2 = require_lib8();
  var ElementImpl_1 = require_ElementImpl();
  var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var NamespaceAlgorithm_1 = require_NamespaceAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var ElementAlgorithm_1 = require_ElementAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  function document_elementInterface(name, namespace) {
    return ElementImpl_1.ElementImpl;
  }
  exports.document_elementInterface = document_elementInterface;
  function document_internalCreateElementNS(document2, namespace, qualifiedName, options) {
    var _a = __read(NamespaceAlgorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
    var is = null;
    if (options !== undefined) {
      if (util_2.isString(options)) {
        is = options;
      } else {
        is = options.is;
      }
    }
    return ElementAlgorithm_1.element_createAnElement(document2, localName, ns, prefix, is, true);
  }
  exports.document_internalCreateElementNS = document_internalCreateElementNS;
  function document_adopt(node, document2) {
    var e_1, _a;
    if (node._nodeDocument === document2 && node._parent === null) {
      return;
    }
    var oldDocument = node._nodeDocument;
    if (node._parent)
      MutationAlgorithm_1.mutation_remove(node, node._parent);
    if (document2 !== oldDocument) {
      var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, true);
      while (inclusiveDescendant !== null) {
        inclusiveDescendant._nodeDocument = document2;
        if (util_1.Guard.isElementNode(inclusiveDescendant)) {
          try {
            for (var _b = (e_1 = undefined, __values(inclusiveDescendant._attributeList._asArray())), _c = _b.next();!_c.done; _c = _b.next()) {
              var attr = _c.value;
              attr._nodeDocument = document2;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isElementNode(inclusiveDescendant) && inclusiveDescendant._customElementState === "custom") {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "adoptedCallback", [oldDocument, document2]);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          DOMAlgorithm_1.dom_runAdoptingSteps(inclusiveDescendant, oldDocument);
        }
        inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, inclusiveDescendant, true, true);
      }
    }
  }
  exports.document_adopt = document_adopt;
});

// node_modules/@oozcitak/dom/lib/algorithm/MutationAlgorithm.js
var require_MutationAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var DOMException_1 = require_DOMException();
  var interfaces_1 = require_interfaces2();
  var util_1 = require_util2();
  var util_2 = require_lib8();
  var infra_1 = require_lib10();
  var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var NodeIteratorAlgorithm_1 = require_NodeIteratorAlgorithm();
  var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
  var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var DocumentAlgorithm_1 = require_DocumentAlgorithm();
  function mutation_ensurePreInsertionValidity(node, parent, child) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var parentNodeType = parent._nodeType;
    var nodeNodeType = node._nodeType;
    var childNodeType = child ? child._nodeType : null;
    if (parentNodeType !== interfaces_1.NodeType.Document && parentNodeType !== interfaces_1.NodeType.DocumentFragment && parentNodeType !== interfaces_1.NodeType.Element)
      throw new DOMException_1.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + parent.nodeName + ".");
    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true))
      throw new DOMException_1.HierarchyRequestError("The node to be inserted cannot be an inclusive ancestor of parent node. Node is " + node.nodeName + ", parent node is " + parent.nodeName + ".");
    if (child !== null && child._parent !== parent)
      throw new DOMException_1.NotFoundError("The reference child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    if (nodeNodeType !== interfaces_1.NodeType.DocumentFragment && nodeNodeType !== interfaces_1.NodeType.DocumentType && nodeNodeType !== interfaces_1.NodeType.Element && nodeNodeType !== interfaces_1.NodeType.Text && nodeNodeType !== interfaces_1.NodeType.ProcessingInstruction && nodeNodeType !== interfaces_1.NodeType.CData && nodeNodeType !== interfaces_1.NodeType.Comment)
      throw new DOMException_1.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + node.nodeName + ".");
    if (nodeNodeType === interfaces_1.NodeType.Text && parentNodeType === interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + node.nodeName + ".");
    if (nodeNodeType === interfaces_1.NodeType.DocumentType && parentNodeType !== interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + parent.nodeName + ".");
    if (parentNodeType === interfaces_1.NodeType.Document) {
      if (nodeNodeType === interfaces_1.NodeType.DocumentFragment) {
        var eleCount = 0;
        try {
          for (var _e = __values(node._children), _f = _e.next();!_f.done; _f = _e.next()) {
            var childNode = _f.value;
            if (childNode._nodeType === interfaces_1.NodeType.Element)
              eleCount++;
            else if (childNode._nodeType === interfaces_1.NodeType.Text)
              throw new DOMException_1.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + childNode.nodeName + ".");
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_f && !_f.done && (_a = _e.return))
              _a.call(_e);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (eleCount > 1) {
          throw new DOMException_1.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + eleCount + " element nodes.");
        } else if (eleCount === 1) {
          try {
            for (var _g = __values(parent._children), _h = _g.next();!_h.done; _h = _g.next()) {
              var ele = _h.value;
              if (ele._nodeType === interfaces_1.NodeType.Element)
                throw new DOMException_1.HierarchyRequestError("The document node already has a document element node.");
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_h && !_h.done && (_b = _g.return))
                _b.call(_g);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          if (child) {
            if (childNodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
            var doctypeChild = child._nextSibling;
            while (doctypeChild) {
              if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
              doctypeChild = doctypeChild._nextSibling;
            }
          }
        }
      } else if (nodeNodeType === interfaces_1.NodeType.Element) {
        try {
          for (var _j = __values(parent._children), _k = _j.next();!_k.done; _k = _j.next()) {
            var ele = _k.value;
            if (ele._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError("Document already has a document element node. Node is " + node.nodeName + ".");
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_k && !_k.done && (_c = _j.return))
              _c.call(_j);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        if (child) {
          if (childNodeType === interfaces_1.NodeType.DocumentType)
            throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
          var doctypeChild = child._nextSibling;
          while (doctypeChild) {
            if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
            doctypeChild = doctypeChild._nextSibling;
          }
        }
      } else if (nodeNodeType === interfaces_1.NodeType.DocumentType) {
        try {
          for (var _l = __values(parent._children), _m = _l.next();!_m.done; _m = _l.next()) {
            var ele = _m.value;
            if (ele._nodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError("Document already has a document type node. Node is " + node.nodeName + ".");
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_m && !_m.done && (_d = _l.return))
              _d.call(_l);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        if (child) {
          var elementChild = child._previousSibling;
          while (elementChild) {
            if (elementChild._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
            elementChild = elementChild._previousSibling;
          }
        } else {
          var elementChild = parent._firstChild;
          while (elementChild) {
            if (elementChild._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
            elementChild = elementChild._nextSibling;
          }
        }
      }
    }
  }
  exports.mutation_ensurePreInsertionValidity = mutation_ensurePreInsertionValidity;
  function mutation_preInsert(node, parent, child) {
    mutation_ensurePreInsertionValidity(node, parent, child);
    var referenceChild = child;
    if (referenceChild === node)
      referenceChild = node._nextSibling;
    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    mutation_insert(node, parent, referenceChild);
    return node;
  }
  exports.mutation_preInsert = mutation_preInsert;
  function mutation_insert(node, parent, child, suppressObservers) {
    var e_5, _a;
    if (child === null && node._nodeType !== interfaces_1.NodeType.DocumentFragment) {
      mutation_insert_single(node, parent, suppressObservers);
      return;
    }
    var count = node._nodeType === interfaces_1.NodeType.DocumentFragment ? node._children.size : 1;
    if (child !== null) {
      if (DOMImpl_1.dom.rangeList.size !== 0) {
        var index_1 = TreeAlgorithm_1.tree_index(child);
        try {
          for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next();!_c.done; _c = _b.next()) {
            var range = _c.value;
            if (range._start[0] === parent && range._start[1] > index_1) {
              range._start[1] += count;
            }
            if (range._end[0] === parent && range._end[1] > index_1) {
              range._end[1] += count;
            }
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
      }
    }
    var nodes = node._nodeType === interfaces_1.NodeType.DocumentFragment ? new (Array.bind.apply(Array, __spread([undefined], node._children))) : [node];
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
      while (node._firstChild) {
        mutation_remove(node._firstChild, node, true);
      }
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(node, [], nodes, null, null);
      }
    }
    var previousSibling = child ? child._previousSibling : parent._lastChild;
    var index = child === null ? -1 : TreeAlgorithm_1.tree_index(child);
    for (var i = 0;i < nodes.length; i++) {
      var node_1 = nodes[i];
      if (util_1.Guard.isElementNode(node_1)) {
        if (util_1.Guard.isDocumentNode(parent)) {
          parent._documentElement = node_1;
        }
        if (!node_1._nodeDocument._hasNamespaces && (node_1._namespace !== null || node_1._namespacePrefix !== null)) {
          node_1._nodeDocument._hasNamespaces = true;
        }
      }
      node_1._parent = parent;
      if (child === null) {
        infra_1.set.append(parent._children, node_1);
      } else {
        infra_1.set.insert(parent._children, node_1, index);
        index++;
      }
      if (parent._firstChild === null) {
        node_1._previousSibling = null;
        node_1._nextSibling = null;
        parent._firstChild = node_1;
        parent._lastChild = node_1;
      } else {
        var prev = child ? child._previousSibling : parent._lastChild;
        var next = child ? child : null;
        node_1._previousSibling = prev;
        node_1._nextSibling = next;
        if (prev)
          prev._nextSibling = node_1;
        if (next)
          next._previousSibling = node_1;
        if (!prev)
          parent._firstChild = node_1;
        if (!next)
          parent._lastChild = node_1;
      }
      if (DOMImpl_1.dom.features.slots) {
        if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node_1)) {
          ShadowTreeAlgorithm_1.shadowTree_assignASlot(node_1);
        }
      }
      if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node_1)) {
          DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
        }
      }
      if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
          ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
        }
      }
      if (DOMImpl_1.dom.features.slots) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node_1));
      }
      var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node_1, true, true);
      while (inclusiveDescendant !== null) {
        if (DOMImpl_1.dom.features.steps) {
          DOMAlgorithm_1.dom_runInsertionSteps(inclusiveDescendant);
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isElementNode(inclusiveDescendant) && ShadowTreeAlgorithm_1.shadowTree_isConnected(inclusiveDescendant)) {
            if (util_1.Guard.isCustomElementNode(inclusiveDescendant)) {
              CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "connectedCallback", []);
            } else {
              CustomElementAlgorithm_1.customElement_tryToUpgrade(inclusiveDescendant);
            }
          }
        }
        inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node_1, inclusiveDescendant, true, true);
      }
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, [], previousSibling, child);
      }
    }
  }
  exports.mutation_insert = mutation_insert;
  function mutation_insert_single(node, parent, suppressObservers) {
    var previousSibling = parent._lastChild;
    if (util_1.Guard.isElementNode(node)) {
      if (util_1.Guard.isDocumentNode(parent)) {
        parent._documentElement = node;
      }
      if (!node._nodeDocument._hasNamespaces && (node._namespace !== null || node._namespacePrefix !== null)) {
        node._nodeDocument._hasNamespaces = true;
      }
    }
    node._parent = parent;
    parent._children.add(node);
    if (parent._firstChild === null) {
      node._previousSibling = null;
      node._nextSibling = null;
      parent._firstChild = node;
      parent._lastChild = node;
    } else {
      var prev = parent._lastChild;
      node._previousSibling = prev;
      node._nextSibling = null;
      if (prev)
        prev._nextSibling = node;
      if (!prev)
        parent._firstChild = node;
      parent._lastChild = node;
    }
    if (DOMImpl_1.dom.features.slots) {
      if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node)) {
        ShadowTreeAlgorithm_1.shadowTree_assignASlot(node);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node)) {
        DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
        ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node));
    }
    if (DOMImpl_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runInsertionSteps(node);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isElementNode(node) && ShadowTreeAlgorithm_1.shadowTree_isConnected(node)) {
        if (util_1.Guard.isCustomElementNode(node)) {
          CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, "connectedCallback", []);
        } else {
          CustomElementAlgorithm_1.customElement_tryToUpgrade(node);
        }
      }
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [node], [], previousSibling, null);
      }
    }
  }
  function mutation_append(node, parent) {
    return mutation_preInsert(node, parent, null);
  }
  exports.mutation_append = mutation_append;
  function mutation_replace(child, node, parent) {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d;
    if (parent._nodeType !== interfaces_1.NodeType.Document && parent._nodeType !== interfaces_1.NodeType.DocumentFragment && parent._nodeType !== interfaces_1.NodeType.Element)
      throw new DOMException_1.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + parent.nodeName + ".");
    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true))
      throw new DOMException_1.HierarchyRequestError("The node to be inserted cannot be an ancestor of parent node. Node is " + node.nodeName + ", parent node is " + parent.nodeName + ".");
    if (child._parent !== parent)
      throw new DOMException_1.NotFoundError("The reference child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    if (node._nodeType !== interfaces_1.NodeType.DocumentFragment && node._nodeType !== interfaces_1.NodeType.DocumentType && node._nodeType !== interfaces_1.NodeType.Element && node._nodeType !== interfaces_1.NodeType.Text && node._nodeType !== interfaces_1.NodeType.ProcessingInstruction && node._nodeType !== interfaces_1.NodeType.CData && node._nodeType !== interfaces_1.NodeType.Comment)
      throw new DOMException_1.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + node.nodeName + ".");
    if (node._nodeType === interfaces_1.NodeType.Text && parent._nodeType === interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + node.nodeName + ".");
    if (node._nodeType === interfaces_1.NodeType.DocumentType && parent._nodeType !== interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + parent.nodeName + ".");
    if (parent._nodeType === interfaces_1.NodeType.Document) {
      if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        var eleCount = 0;
        try {
          for (var _e = __values(node._children), _f = _e.next();!_f.done; _f = _e.next()) {
            var childNode = _f.value;
            if (childNode._nodeType === interfaces_1.NodeType.Element)
              eleCount++;
            else if (childNode._nodeType === interfaces_1.NodeType.Text)
              throw new DOMException_1.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + childNode.nodeName + ".");
          }
        } catch (e_6_1) {
          e_6 = { error: e_6_1 };
        } finally {
          try {
            if (_f && !_f.done && (_a = _e.return))
              _a.call(_e);
          } finally {
            if (e_6)
              throw e_6.error;
          }
        }
        if (eleCount > 1) {
          throw new DOMException_1.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + eleCount + " element nodes.");
        } else if (eleCount === 1) {
          try {
            for (var _g = __values(parent._children), _h = _g.next();!_h.done; _h = _g.next()) {
              var ele = _h.value;
              if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
                throw new DOMException_1.HierarchyRequestError("The document node already has a document element node.");
            }
          } catch (e_7_1) {
            e_7 = { error: e_7_1 };
          } finally {
            try {
              if (_h && !_h.done && (_b = _g.return))
                _b.call(_g);
            } finally {
              if (e_7)
                throw e_7.error;
            }
          }
          var doctypeChild = child._nextSibling;
          while (doctypeChild) {
            if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
            doctypeChild = doctypeChild._nextSibling;
          }
        }
      } else if (node._nodeType === interfaces_1.NodeType.Element) {
        try {
          for (var _j = __values(parent._children), _k = _j.next();!_k.done; _k = _j.next()) {
            var ele = _k.value;
            if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
              throw new DOMException_1.HierarchyRequestError("Document already has a document element node. Node is " + node.nodeName + ".");
          }
        } catch (e_8_1) {
          e_8 = { error: e_8_1 };
        } finally {
          try {
            if (_k && !_k.done && (_c = _j.return))
              _c.call(_j);
          } finally {
            if (e_8)
              throw e_8.error;
          }
        }
        var doctypeChild = child._nextSibling;
        while (doctypeChild) {
          if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
            throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
          doctypeChild = doctypeChild._nextSibling;
        }
      } else if (node._nodeType === interfaces_1.NodeType.DocumentType) {
        try {
          for (var _l = __values(parent._children), _m = _l.next();!_m.done; _m = _l.next()) {
            var ele = _m.value;
            if (ele._nodeType === interfaces_1.NodeType.DocumentType && ele !== child)
              throw new DOMException_1.HierarchyRequestError("Document already has a document type node. Node is " + node.nodeName + ".");
          }
        } catch (e_9_1) {
          e_9 = { error: e_9_1 };
        } finally {
          try {
            if (_m && !_m.done && (_d = _l.return))
              _d.call(_l);
          } finally {
            if (e_9)
              throw e_9.error;
          }
        }
        var elementChild = child._previousSibling;
        while (elementChild) {
          if (elementChild._nodeType === interfaces_1.NodeType.Element)
            throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
          elementChild = elementChild._previousSibling;
        }
      }
    }
    var referenceChild = child._nextSibling;
    if (referenceChild === node)
      referenceChild = node._nextSibling;
    var previousSibling = child._previousSibling;
    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    var removedNodes = [];
    if (child._parent !== null) {
      removedNodes.push(child);
      mutation_remove(child, child._parent, true);
    }
    var nodes = [];
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
      nodes = Array.from(node._children);
    } else {
      nodes.push(node);
    }
    mutation_insert(node, parent, referenceChild, true);
    if (DOMImpl_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, removedNodes, previousSibling, referenceChild);
    }
    return child;
  }
  exports.mutation_replace = mutation_replace;
  function mutation_replaceAll(node, parent) {
    var e_10, _a;
    if (node !== null) {
      DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    }
    var removedNodes = Array.from(parent._children);
    var addedNodes = [];
    if (node && node._nodeType === interfaces_1.NodeType.DocumentFragment) {
      addedNodes = Array.from(node._children);
    } else if (node !== null) {
      addedNodes.push(node);
    }
    try {
      for (var removedNodes_1 = __values(removedNodes), removedNodes_1_1 = removedNodes_1.next();!removedNodes_1_1.done; removedNodes_1_1 = removedNodes_1.next()) {
        var childNode = removedNodes_1_1.value;
        mutation_remove(childNode, parent, true);
      }
    } catch (e_10_1) {
      e_10 = { error: e_10_1 };
    } finally {
      try {
        if (removedNodes_1_1 && !removedNodes_1_1.done && (_a = removedNodes_1.return))
          _a.call(removedNodes_1);
      } finally {
        if (e_10)
          throw e_10.error;
      }
    }
    if (node !== null) {
      mutation_insert(node, parent, null, true);
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, addedNodes, removedNodes, null, null);
    }
  }
  exports.mutation_replaceAll = mutation_replaceAll;
  function mutation_preRemove(child, parent) {
    if (child._parent !== parent)
      throw new DOMException_1.NotFoundError("The child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    mutation_remove(child, parent);
    return child;
  }
  exports.mutation_preRemove = mutation_preRemove;
  function mutation_remove(node, parent, suppressObservers) {
    var e_11, _a, e_12, _b, e_13, _c, e_14, _d;
    if (DOMImpl_1.dom.rangeList.size !== 0) {
      var index = TreeAlgorithm_1.tree_index(node);
      try {
        for (var _e = __values(DOMImpl_1.dom.rangeList), _f = _e.next();!_f.done; _f = _e.next()) {
          var range = _f.value;
          if (TreeAlgorithm_1.tree_isDescendantOf(node, range._start[0], true)) {
            range._start = [parent, index];
          }
          if (TreeAlgorithm_1.tree_isDescendantOf(node, range._end[0], true)) {
            range._end = [parent, index];
          }
          if (range._start[0] === parent && range._start[1] > index) {
            range._start[1]--;
          }
          if (range._end[0] === parent && range._end[1] > index) {
            range._end[1]--;
          }
        }
      } catch (e_11_1) {
        e_11 = { error: e_11_1 };
      } finally {
        try {
          if (_f && !_f.done && (_a = _e.return))
            _a.call(_e);
        } finally {
          if (e_11)
            throw e_11.error;
        }
      }
      try {
        for (var _g = __values(DOMImpl_1.dom.rangeList), _h = _g.next();!_h.done; _h = _g.next()) {
          var range = _h.value;
          if (range._start[0] === parent && range._start[1] > index) {
            range._start[1] -= 1;
          }
          if (range._end[0] === parent && range._end[1] > index) {
            range._end[1] -= 1;
          }
        }
      } catch (e_12_1) {
        e_12 = { error: e_12_1 };
      } finally {
        try {
          if (_h && !_h.done && (_b = _g.return))
            _b.call(_g);
        } finally {
          if (e_12)
            throw e_12.error;
        }
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      try {
        for (var _j = __values(NodeIteratorAlgorithm_1.nodeIterator_iteratorList()), _k = _j.next();!_k.done; _k = _j.next()) {
          var iterator = _k.value;
          if (iterator._root._nodeDocument === node._nodeDocument) {
            DOMAlgorithm_1.dom_runNodeIteratorPreRemovingSteps(iterator, node);
          }
        }
      } catch (e_13_1) {
        e_13 = { error: e_13_1 };
      } finally {
        try {
          if (_k && !_k.done && (_c = _j.return))
            _c.call(_j);
        } finally {
          if (e_13)
            throw e_13.error;
        }
      }
    }
    var oldPreviousSibling = node._previousSibling;
    var oldNextSibling = node._nextSibling;
    if (util_1.Guard.isDocumentNode(parent) && util_1.Guard.isElementNode(node)) {
      parent._documentElement = null;
    }
    node._parent = null;
    parent._children.delete(node);
    var prev = node._previousSibling;
    var next = node._nextSibling;
    node._previousSibling = null;
    node._nextSibling = null;
    if (prev)
      prev._nextSibling = next;
    if (next)
      next._previousSibling = prev;
    if (!prev)
      parent._firstChild = next;
    if (!next)
      parent._lastChild = prev;
    if (DOMImpl_1.dom.features.slots) {
      if (util_1.Guard.isSlotable(node) && node._assignedSlot !== null && ShadowTreeAlgorithm_1.shadowTree_isAssigned(node)) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotables(node._assignedSlot);
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
        ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
      }
    }
    if (DOMImpl_1.dom.features.slots) {
      var descendant_1 = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, false, function(e) {
        return util_1.Guard.isSlot(e);
      });
      if (descendant_1 !== null) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(parent));
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(node);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runRemovingSteps(node, parent);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(node)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, "disconnectedCallback", []);
      }
    }
    var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, true);
    while (descendant !== null) {
      if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runRemovingSteps(descendant, node);
      }
      if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(descendant)) {
          CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(descendant, "disconnectedCallback", []);
        }
      }
      descendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, descendant, false, true);
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      var inclusiveAncestor = TreeAlgorithm_1.tree_getFirstAncestorNode(parent, true);
      while (inclusiveAncestor !== null) {
        try {
          for (var _l = (e_14 = undefined, __values(inclusiveAncestor._registeredObserverList)), _m = _l.next();!_m.done; _m = _l.next()) {
            var registered = _m.value;
            if (registered.options.subtree) {
              node._registeredObserverList.push({
                observer: registered.observer,
                options: registered.options,
                source: registered
              });
            }
          }
        } catch (e_14_1) {
          e_14 = { error: e_14_1 };
        } finally {
          try {
            if (_m && !_m.done && (_d = _l.return))
              _d.call(_l);
          } finally {
            if (e_14)
              throw e_14.error;
          }
        }
        inclusiveAncestor = TreeAlgorithm_1.tree_getNextAncestorNode(parent, inclusiveAncestor, true);
      }
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [], [node], oldPreviousSibling, oldNextSibling);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node)) {
        DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
      }
    }
  }
  exports.mutation_remove = mutation_remove;
});

// node_modules/@oozcitak/dom/lib/algorithm/ElementAlgorithm.js
var require_ElementAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var infra_1 = require_lib10();
  var util_1 = require_util2();
  var DOMException_1 = require_DOMException();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
  var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  var DocumentAlgorithm_1 = require_DocumentAlgorithm();
  function element_has(attribute, element) {
    return element._attributeList._asArray().indexOf(attribute) !== -1;
  }
  exports.element_has = element_has;
  function element_change(attribute, element, value) {
    if (DOMImpl_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, attribute._value, value, attribute._namespace]);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, value, attribute._namespace);
    }
    attribute._value = value;
  }
  exports.element_change = element_change;
  function element_append(attribute, element) {
    if (DOMImpl_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, null);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, null, attribute._value, attribute._namespace]);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, null, attribute._value, attribute._namespace);
    }
    element._attributeList._asArray().push(attribute);
    attribute._element = element;
    if (!element._nodeDocument._hasNamespaces && (attribute._namespace !== null || attribute._namespacePrefix !== null || attribute._localName === "xmlns")) {
      element._nodeDocument._hasNamespaces = true;
    }
  }
  exports.element_append = element_append;
  function element_remove(attribute, element) {
    if (DOMImpl_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, attribute._value, null, attribute._namespace]);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, null, attribute._namespace);
    }
    var index = element._attributeList._asArray().indexOf(attribute);
    element._attributeList._asArray().splice(index, 1);
    attribute._element = null;
  }
  exports.element_remove = element_remove;
  function element_replace(oldAttr, newAttr, element) {
    if (DOMImpl_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, oldAttr._localName, oldAttr._namespace, oldAttr._value);
    }
    if (DOMImpl_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace]);
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runAttributeChangeSteps(element, oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace);
    }
    var index = element._attributeList._asArray().indexOf(oldAttr);
    if (index !== -1) {
      element._attributeList._asArray()[index] = newAttr;
    }
    oldAttr._element = null;
    newAttr._element = element;
    if (!element._nodeDocument._hasNamespaces && (newAttr._namespace !== null || newAttr._namespacePrefix !== null || newAttr._localName === "xmlns")) {
      element._nodeDocument._hasNamespaces = true;
    }
  }
  exports.element_replace = element_replace;
  function element_getAnAttributeByName(qualifiedName, element) {
    if (element._namespace === infra_1.namespace.HTML && element._nodeDocument._type === "html") {
      qualifiedName = qualifiedName.toLowerCase();
    }
    return element._attributeList._asArray().find(function(attr) {
      return attr._qualifiedName === qualifiedName;
    }) || null;
  }
  exports.element_getAnAttributeByName = element_getAnAttributeByName;
  function element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    var ns = namespace || null;
    return element._attributeList._asArray().find(function(attr) {
      return attr._namespace === ns && attr._localName === localName;
    }) || null;
  }
  exports.element_getAnAttributeByNamespaceAndLocalName = element_getAnAttributeByNamespaceAndLocalName;
  function element_getAnAttributeValue(element, localName, namespace) {
    if (namespace === undefined) {
      namespace = "";
    }
    var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr === null)
      return "";
    else
      return attr._value;
  }
  exports.element_getAnAttributeValue = element_getAnAttributeValue;
  function element_setAnAttribute(attr, element) {
    if (attr._element !== null && attr._element !== element)
      throw new DOMException_1.InUseAttributeError("This attribute already exists in the document: " + attr._qualifiedName + " as a child of " + attr._element._qualifiedName + ".");
    var oldAttr = element_getAnAttributeByNamespaceAndLocalName(attr._namespace || "", attr._localName, element);
    if (oldAttr === attr)
      return attr;
    if (oldAttr !== null) {
      element_replace(oldAttr, attr, element);
    } else {
      element_append(attr, element);
    }
    return oldAttr;
  }
  exports.element_setAnAttribute = element_setAnAttribute;
  function element_setAnAttributeValue(element, localName, value, prefix, namespace) {
    if (prefix === undefined) {
      prefix = null;
    }
    if (namespace === undefined) {
      namespace = null;
    }
    var attribute = element_getAnAttributeByNamespaceAndLocalName(namespace || "", localName, element);
    if (attribute === null) {
      var newAttr = CreateAlgorithm_1.create_attr(element._nodeDocument, localName);
      newAttr._namespace = namespace;
      newAttr._namespacePrefix = prefix;
      newAttr._value = value;
      element_append(newAttr, element);
      return;
    }
    element_change(attribute, element, value);
  }
  exports.element_setAnAttributeValue = element_setAnAttributeValue;
  function element_removeAnAttributeByName(qualifiedName, element) {
    var attr = element_getAnAttributeByName(qualifiedName, element);
    if (attr !== null) {
      element_remove(attr, element);
    }
    return attr;
  }
  exports.element_removeAnAttributeByName = element_removeAnAttributeByName;
  function element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr !== null) {
      element_remove(attr, element);
    }
    return attr;
  }
  exports.element_removeAnAttributeByNamespaceAndLocalName = element_removeAnAttributeByNamespaceAndLocalName;
  function element_createAnElement(document2, localName, namespace, prefix, is, synchronousCustomElementsFlag) {
    if (prefix === undefined) {
      prefix = null;
    }
    if (is === undefined) {
      is = null;
    }
    if (synchronousCustomElementsFlag === undefined) {
      synchronousCustomElementsFlag = false;
    }
    var result = null;
    if (!DOMImpl_1.dom.features.customElements) {
      result = CreateAlgorithm_1.create_element(document2, localName, namespace, prefix);
      result._customElementState = "uncustomized";
      result._customElementDefinition = null;
      result._is = is;
      return result;
    }
    var definition = CustomElementAlgorithm_1.customElement_lookUpACustomElementDefinition(document2, namespace, localName, is);
    if (definition !== null && definition.name !== definition.localName) {
      var elemenInterface = DocumentAlgorithm_1.document_elementInterface(localName, infra_1.namespace.HTML);
      result = new elemenInterface;
      result._localName = localName;
      result._namespace = infra_1.namespace.HTML;
      result._namespacePrefix = prefix;
      result._customElementState = "undefined";
      result._customElementDefinition = null;
      result._is = is;
      result._nodeDocument = document2;
      if (synchronousCustomElementsFlag) {
        CustomElementAlgorithm_1.customElement_upgrade(definition, result);
      } else {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
      }
    } else if (definition !== null) {
      if (synchronousCustomElementsFlag) {
        try {
          var C = definition.constructor;
          var result_1 = new C;
          console.assert(result_1._customElementState !== undefined);
          console.assert(result_1._customElementDefinition !== undefined);
          console.assert(result_1._namespace === infra_1.namespace.HTML);
          if (result_1._attributeList.length !== 0)
            throw new DOMException_1.NotSupportedError("Custom element already has attributes.");
          if (result_1._children.size !== 0)
            throw new DOMException_1.NotSupportedError("Custom element already has child nodes.");
          if (result_1._parent !== null)
            throw new DOMException_1.NotSupportedError("Custom element already has a parent node.");
          if (result_1._nodeDocument !== document2)
            throw new DOMException_1.NotSupportedError("Custom element is already in a document.");
          if (result_1._localName !== localName)
            throw new DOMException_1.NotSupportedError("Custom element has a different local name.");
          result_1._namespacePrefix = prefix;
          result_1._is = null;
        } catch (e) {
          result = CreateAlgorithm_1.create_htmlUnknownElement(document2, localName, infra_1.namespace.HTML, prefix);
          result._customElementState = "failed";
          result._customElementDefinition = null;
          result._is = null;
        }
      } else {
        result = CreateAlgorithm_1.create_htmlElement(document2, localName, infra_1.namespace.HTML, prefix);
        result._customElementState = "undefined";
        result._customElementDefinition = null;
        result._is = null;
        CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
      }
    } else {
      var elementInterface = DocumentAlgorithm_1.document_elementInterface(localName, namespace);
      result = new elementInterface;
      result._localName = localName;
      result._namespace = namespace;
      result._namespacePrefix = prefix;
      result._customElementState = "uncustomized";
      result._customElementDefinition = null;
      result._is = is;
      result._nodeDocument = document2;
      if (namespace === infra_1.namespace.HTML && (is !== null || CustomElementAlgorithm_1.customElement_isValidCustomElementName(localName))) {
        result._customElementState = "undefined";
      }
    }
    if (result === null) {
      throw new Error("Unable to create element.");
    }
    return result;
  }
  exports.element_createAnElement = element_createAnElement;
  function element_insertAdjacent(element, where, node) {
    switch (where.toLowerCase()) {
      case "beforebegin":
        if (element._parent === null)
          return null;
        return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element);
      case "afterbegin":
        return MutationAlgorithm_1.mutation_preInsert(node, element, element._firstChild);
      case "beforeend":
        return MutationAlgorithm_1.mutation_preInsert(node, element, null);
      case "afterend":
        if (element._parent === null)
          return null;
        return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element._nextSibling);
      default:
        throw new DOMException_1.SyntaxError(`Invalid 'where' argument. "beforebegin", "afterbegin", "beforeend" or "afterend" expected`);
    }
  }
  exports.element_insertAdjacent = element_insertAdjacent;
});

// node_modules/@oozcitak/dom/lib/algorithm/AttrAlgorithm.js
var require_AttrAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ElementAlgorithm_1 = require_ElementAlgorithm();
  function attr_setAnExistingAttributeValue(attribute, value) {
    if (attribute._element === null) {
      attribute._value = value;
    } else {
      ElementAlgorithm_1.element_change(attribute, attribute._element, value);
    }
  }
  exports.attr_setAnExistingAttributeValue = attr_setAnExistingAttributeValue;
});

// node_modules/@oozcitak/dom/lib/algorithm/BoundaryPointAlgorithm.js
var require_BoundaryPointAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  function boundaryPoint_position(bp, relativeTo) {
    var nodeA = bp[0];
    var offsetA = bp[1];
    var nodeB = relativeTo[0];
    var offsetB = relativeTo[1];
    console.assert(TreeAlgorithm_1.tree_rootNode(nodeA) === TreeAlgorithm_1.tree_rootNode(nodeB), "Boundary points must share the same root node.");
    if (nodeA === nodeB) {
      if (offsetA === offsetB) {
        return interfaces_1.BoundaryPosition.Equal;
      } else if (offsetA < offsetB) {
        return interfaces_1.BoundaryPosition.Before;
      } else {
        return interfaces_1.BoundaryPosition.After;
      }
    }
    if (TreeAlgorithm_1.tree_isFollowing(nodeB, nodeA)) {
      var pos = boundaryPoint_position([nodeB, offsetB], [nodeA, offsetA]);
      if (pos === interfaces_1.BoundaryPosition.Before) {
        return interfaces_1.BoundaryPosition.After;
      } else if (pos === interfaces_1.BoundaryPosition.After) {
        return interfaces_1.BoundaryPosition.Before;
      }
    }
    if (TreeAlgorithm_1.tree_isAncestorOf(nodeB, nodeA)) {
      var child = nodeB;
      while (!TreeAlgorithm_1.tree_isChildOf(nodeA, child)) {
        if (child._parent !== null) {
          child = child._parent;
        }
      }
      if (TreeAlgorithm_1.tree_index(child) < offsetA) {
        return interfaces_1.BoundaryPosition.After;
      }
    }
    return interfaces_1.BoundaryPosition.Before;
  }
  exports.boundaryPoint_position = boundaryPoint_position;
});

// node_modules/@oozcitak/dom/lib/algorithm/CharacterDataAlgorithm.js
var require_CharacterDataAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var DOMException_1 = require_DOMException();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  function characterData_replaceData(node, offset, count, data) {
    var e_1, _a;
    var length = TreeAlgorithm_1.tree_nodeLength(node);
    if (offset > length) {
      throw new DOMException_1.IndexSizeError("Offset exceeds character data length. Offset: " + offset + ", Length: " + length + ", Node is " + node.nodeName + ".");
    }
    if (offset + count > length) {
      count = length - offset;
    }
    if (DOMImpl_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueMutationRecord("characterData", node, null, null, node._data, [], [], null, null);
    }
    var newData = node._data.substring(0, offset) + data + node._data.substring(offset + count);
    node._data = newData;
    try {
      for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next();!_c.done; _c = _b.next()) {
        var range = _c.value;
        if (range._start[0] === node && range._start[1] > offset && range._start[1] <= offset + count) {
          range._start[1] = offset;
        }
        if (range._end[0] === node && range._end[1] > offset && range._end[1] <= offset + count) {
          range._end[1] = offset;
        }
        if (range._start[0] === node && range._start[1] > offset + count) {
          range._start[1] += data.length - count;
        }
        if (range._end[0] === node && range._end[1] > offset + count) {
          range._end[1] += data.length - count;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    if (DOMImpl_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node) && node._parent !== null) {
        DOMAlgorithm_1.dom_runChildTextContentChangeSteps(node._parent);
      }
    }
  }
  exports.characterData_replaceData = characterData_replaceData;
  function characterData_substringData(node, offset, count) {
    var length = TreeAlgorithm_1.tree_nodeLength(node);
    if (offset > length) {
      throw new DOMException_1.IndexSizeError("Offset exceeds character data length. Offset: " + offset + ", Length: " + length + ", Node is " + node.nodeName + ".");
    }
    if (offset + count > length) {
      return node._data.substr(offset);
    } else {
      return node._data.substr(offset, count);
    }
  }
  exports.characterData_substringData = characterData_substringData;
});

// node_modules/@oozcitak/dom/lib/algorithm/OrderedSetAlgorithm.js
var require_OrderedSetAlgorithm = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var infra_1 = require_lib10();
  function orderedSet_parse(value) {
    var inputTokens = infra_1.string.splitAStringOnASCIIWhitespace(value);
    return new Set(inputTokens);
  }
  exports.orderedSet_parse = orderedSet_parse;
  function orderedSet_serialize(tokens) {
    return __spread(tokens).join(" ");
  }
  exports.orderedSet_serialize = orderedSet_serialize;
  function orderedSet_sanitize(value) {
    return orderedSet_serialize(orderedSet_parse(value));
  }
  exports.orderedSet_sanitize = orderedSet_sanitize;
  function orderedSet_contains(set1, set2, caseSensitive) {
    var e_1, _a, e_2, _b;
    try {
      for (var set2_1 = __values(set2), set2_1_1 = set2_1.next();!set2_1_1.done; set2_1_1 = set2_1.next()) {
        var val2 = set2_1_1.value;
        var found = false;
        try {
          for (var set1_1 = (e_2 = undefined, __values(set1)), set1_1_1 = set1_1.next();!set1_1_1.done; set1_1_1 = set1_1.next()) {
            var val1 = set1_1_1.value;
            if (caseSensitive) {
              if (val1 === val2) {
                found = true;
                break;
              }
            } else {
              if (val1.toUpperCase() === val2.toUpperCase()) {
                found = true;
                break;
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (set1_1_1 && !set1_1_1.done && (_b = set1_1.return))
              _b.call(set1_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        if (!found)
          return false;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (set2_1_1 && !set2_1_1.done && (_a = set2_1.return))
          _a.call(set2_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return true;
  }
  exports.orderedSet_contains = orderedSet_contains;
});

// node_modules/@oozcitak/dom/lib/algorithm/DOMTokenListAlgorithm.js
var require_DOMTokenListAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var OrderedSetAlgorithm_1 = require_OrderedSetAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var ElementAlgorithm_1 = require_ElementAlgorithm();
  function tokenList_validationSteps(tokenList, token) {
    if (!DOMAlgorithm_1.dom_hasSupportedTokens(tokenList._attribute._localName)) {
      throw new TypeError("There are no supported tokens defined for attribute name: '" + tokenList._attribute._localName + "'.");
    }
    return DOMAlgorithm_1.dom_getSupportedTokens(tokenList._attribute._localName).has(token.toLowerCase());
  }
  exports.tokenList_validationSteps = tokenList_validationSteps;
  function tokenList_updateSteps(tokenList) {
    if (!tokenList._element.hasAttribute(tokenList._attribute._localName) && tokenList._tokenSet.size === 0) {
      return;
    }
    ElementAlgorithm_1.element_setAnAttributeValue(tokenList._element, tokenList._attribute._localName, OrderedSetAlgorithm_1.orderedSet_serialize(tokenList._tokenSet));
  }
  exports.tokenList_updateSteps = tokenList_updateSteps;
  function tokenList_serializeSteps(tokenList) {
    return ElementAlgorithm_1.element_getAnAttributeValue(tokenList._element, tokenList._attribute._localName);
  }
  exports.tokenList_serializeSteps = tokenList_serializeSteps;
});

// node_modules/@oozcitak/dom/lib/algorithm/EventTargetAlgorithm.js
var require_EventTargetAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  function eventTarget_flatten(options) {
    if (util_1.isBoolean(options)) {
      return options;
    } else {
      return options.capture || false;
    }
  }
  exports.eventTarget_flatten = eventTarget_flatten;
  function eventTarget_flattenMore(options) {
    var capture = eventTarget_flatten(options);
    var once = false;
    var passive = false;
    if (!util_1.isBoolean(options)) {
      once = options.once || false;
      passive = options.passive || false;
    }
    return [capture, passive, once];
  }
  exports.eventTarget_flattenMore = eventTarget_flattenMore;
  function eventTarget_addEventListener(eventTarget, listener) {
    if (listener.callback === null)
      return;
    for (var i = 0;i < eventTarget._eventListenerList.length; i++) {
      var entry = eventTarget._eventListenerList[i];
      if (entry.type === listener.type && entry.callback.handleEvent === listener.callback.handleEvent && entry.capture === listener.capture) {
        return;
      }
    }
    eventTarget._eventListenerList.push(listener);
  }
  exports.eventTarget_addEventListener = eventTarget_addEventListener;
  function eventTarget_removeEventListener(eventTarget, listener, index) {
    listener.removed = true;
    eventTarget._eventListenerList.splice(index, 1);
  }
  exports.eventTarget_removeEventListener = eventTarget_removeEventListener;
  function eventTarget_removeAllEventListeners(eventTarget) {
    var e_1, _a;
    try {
      for (var _b = __values(eventTarget._eventListenerList), _c = _b.next();!_c.done; _c = _b.next()) {
        var e = _c.value;
        e.removed = true;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    eventTarget._eventListenerList.length = 0;
  }
  exports.eventTarget_removeAllEventListeners = eventTarget_removeAllEventListeners;
});

// node_modules/@oozcitak/dom/lib/algorithm/NodeAlgorithm.js
var require_NodeAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var infra_1 = require_lib10();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var OrderedSetAlgorithm_1 = require_OrderedSetAlgorithm();
  var DOMAlgorithm_1 = require_DOMAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  var ElementAlgorithm_1 = require_ElementAlgorithm();
  function node_stringReplaceAll(str, parent) {
    var node = null;
    if (str !== "") {
      node = CreateAlgorithm_1.create_text(parent._nodeDocument, str);
    }
    MutationAlgorithm_1.mutation_replaceAll(node, parent);
  }
  exports.node_stringReplaceAll = node_stringReplaceAll;
  function node_clone(node, document2, cloneChildrenFlag) {
    var e_1, _a, e_2, _b;
    if (document2 === undefined) {
      document2 = null;
    }
    if (cloneChildrenFlag === undefined) {
      cloneChildrenFlag = false;
    }
    if (document2 === null)
      document2 = node._nodeDocument;
    var copy;
    if (util_1.Guard.isElementNode(node)) {
      copy = ElementAlgorithm_1.element_createAnElement(document2, node._localName, node._namespace, node._namespacePrefix, node._is, false);
      try {
        for (var _c = __values(node._attributeList), _d = _c.next();!_d.done; _d = _c.next()) {
          var attribute = _d.value;
          var copyAttribute = node_clone(attribute, document2);
          ElementAlgorithm_1.element_append(copyAttribute, copy);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    } else {
      if (util_1.Guard.isDocumentNode(node)) {
        var doc = CreateAlgorithm_1.create_document();
        doc._encoding = node._encoding;
        doc._contentType = node._contentType;
        doc._URL = node._URL;
        doc._origin = node._origin;
        doc._type = node._type;
        doc._mode = node._mode;
        copy = doc;
      } else if (util_1.Guard.isDocumentTypeNode(node)) {
        var doctype = CreateAlgorithm_1.create_documentType(document2, node._name, node._publicId, node._systemId);
        copy = doctype;
      } else if (util_1.Guard.isAttrNode(node)) {
        var attr = CreateAlgorithm_1.create_attr(document2, node.localName);
        attr._namespace = node._namespace;
        attr._namespacePrefix = node._namespacePrefix;
        attr._value = node._value;
        copy = attr;
      } else if (util_1.Guard.isExclusiveTextNode(node)) {
        copy = CreateAlgorithm_1.create_text(document2, node._data);
      } else if (util_1.Guard.isCDATASectionNode(node)) {
        copy = CreateAlgorithm_1.create_cdataSection(document2, node._data);
      } else if (util_1.Guard.isCommentNode(node)) {
        copy = CreateAlgorithm_1.create_comment(document2, node._data);
      } else if (util_1.Guard.isProcessingInstructionNode(node)) {
        copy = CreateAlgorithm_1.create_processingInstruction(document2, node._target, node._data);
      } else if (util_1.Guard.isDocumentFragmentNode(node)) {
        copy = CreateAlgorithm_1.create_documentFragment(document2);
      } else {
        copy = Object.create(node);
      }
    }
    if (util_1.Guard.isDocumentNode(copy)) {
      copy._nodeDocument = copy;
      document2 = copy;
    } else {
      copy._nodeDocument = document2;
    }
    if (DOMImpl_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runCloningSteps(copy, node, document2, cloneChildrenFlag);
    }
    if (cloneChildrenFlag) {
      try {
        for (var _e = __values(node._children), _f = _e.next();!_f.done; _f = _e.next()) {
          var child = _f.value;
          var childCopy = node_clone(child, document2, true);
          MutationAlgorithm_1.mutation_append(childCopy, copy);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_f && !_f.done && (_b = _e.return))
            _b.call(_e);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    return copy;
  }
  exports.node_clone = node_clone;
  function node_equals(a, b) {
    var e_3, _a, e_4, _b;
    if (a._nodeType !== b._nodeType)
      return false;
    if (util_1.Guard.isDocumentTypeNode(a) && util_1.Guard.isDocumentTypeNode(b)) {
      if (a._name !== b._name || a._publicId !== b._publicId || a._systemId !== b._systemId)
        return false;
    } else if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
      if (a._namespace !== b._namespace || a._namespacePrefix !== b._namespacePrefix || a._localName !== b._localName || a._attributeList.length !== b._attributeList.length)
        return false;
    } else if (util_1.Guard.isAttrNode(a) && util_1.Guard.isAttrNode(b)) {
      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value)
        return false;
    } else if (util_1.Guard.isProcessingInstructionNode(a) && util_1.Guard.isProcessingInstructionNode(b)) {
      if (a._target !== b._target || a._data !== b._data)
        return false;
    } else if (util_1.Guard.isCharacterDataNode(a) && util_1.Guard.isCharacterDataNode(b)) {
      if (a._data !== b._data)
        return false;
    }
    if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
      var attrMap = {};
      try {
        for (var _c = __values(a._attributeList), _d = _c.next();!_d.done; _d = _c.next()) {
          var attrA = _d.value;
          attrMap[attrA._localName] = attrA;
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      try {
        for (var _e = __values(b._attributeList), _f = _e.next();!_f.done; _f = _e.next()) {
          var attrB = _f.value;
          var attrA = attrMap[attrB._localName];
          if (!attrA)
            return false;
          if (!node_equals(attrA, attrB))
            return false;
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_f && !_f.done && (_b = _e.return))
            _b.call(_e);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    }
    if (a._children.size !== b._children.size)
      return false;
    var itA = a._children[Symbol.iterator]();
    var itB = b._children[Symbol.iterator]();
    var resultA = itA.next();
    var resultB = itB.next();
    while (!resultA.done && !resultB.done) {
      var child1 = resultA.value;
      var child2 = resultB.value;
      if (!node_equals(child1, child2))
        return false;
      resultA = itA.next();
      resultB = itB.next();
    }
    return true;
  }
  exports.node_equals = node_equals;
  function node_listOfElementsWithQualifiedName(qualifiedName, root) {
    if (qualifiedName === "*") {
      return CreateAlgorithm_1.create_htmlCollection(root);
    } else if (root._nodeDocument._type === "html") {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        if (ele._namespace === infra_1.namespace.HTML && ele._qualifiedName === qualifiedName.toLowerCase()) {
          return true;
        } else if (ele._namespace !== infra_1.namespace.HTML && ele._qualifiedName === qualifiedName) {
          return true;
        } else {
          return false;
        }
      });
    } else {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        return ele._qualifiedName === qualifiedName;
      });
    }
  }
  exports.node_listOfElementsWithQualifiedName = node_listOfElementsWithQualifiedName;
  function node_listOfElementsWithNamespace(namespace, localName, root) {
    if (namespace === "")
      namespace = null;
    if (namespace === "*" && localName === "*") {
      return CreateAlgorithm_1.create_htmlCollection(root);
    } else if (namespace === "*") {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        return ele._localName === localName;
      });
    } else if (localName === "*") {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        return ele._namespace === namespace;
      });
    } else {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        return ele._localName === localName && ele._namespace === namespace;
      });
    }
  }
  exports.node_listOfElementsWithNamespace = node_listOfElementsWithNamespace;
  function node_listOfElementsWithClassNames(classNames, root) {
    var classes = OrderedSetAlgorithm_1.orderedSet_parse(classNames);
    if (classes.size === 0) {
      return CreateAlgorithm_1.create_htmlCollection(root, function() {
        return false;
      });
    }
    var caseSensitive = root._nodeDocument._mode !== "quirks";
    return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
      var eleClasses = ele.classList;
      return OrderedSetAlgorithm_1.orderedSet_contains(eleClasses._tokenSet, classes, caseSensitive);
    });
  }
  exports.node_listOfElementsWithClassNames = node_listOfElementsWithClassNames;
  function node_locateANamespacePrefix(element, namespace) {
    if (element._namespace === namespace && element._namespacePrefix !== null) {
      return element._namespacePrefix;
    }
    for (var i = 0;i < element._attributeList.length; i++) {
      var attr = element._attributeList[i];
      if (attr._namespacePrefix === "xmlns" && attr._value === namespace) {
        return attr._localName;
      }
    }
    if (element._parent && util_1.Guard.isElementNode(element._parent)) {
      return node_locateANamespacePrefix(element._parent, namespace);
    }
    return null;
  }
  exports.node_locateANamespacePrefix = node_locateANamespacePrefix;
  function node_locateANamespace(node, prefix) {
    if (util_1.Guard.isElementNode(node)) {
      if (node._namespace !== null && node._namespacePrefix === prefix) {
        return node._namespace;
      }
      for (var i = 0;i < node._attributeList.length; i++) {
        var attr = node._attributeList[i];
        if (attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === "xmlns" && attr._localName === prefix) {
          return attr._value || null;
        }
        if (prefix === null && attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === null && attr._localName === "xmlns") {
          return attr._value || null;
        }
      }
      if (node.parentElement === null)
        return null;
      return node_locateANamespace(node.parentElement, prefix);
    } else if (util_1.Guard.isDocumentNode(node)) {
      if (node.documentElement === null)
        return null;
      return node_locateANamespace(node.documentElement, prefix);
    } else if (util_1.Guard.isDocumentTypeNode(node) || util_1.Guard.isDocumentFragmentNode(node)) {
      return null;
    } else if (util_1.Guard.isAttrNode(node)) {
      if (node._element === null)
        return null;
      return node_locateANamespace(node._element, prefix);
    } else {
      if (!node._parent || !util_1.Guard.isElementNode(node._parent))
        return null;
      return node_locateANamespace(node._parent, prefix);
    }
  }
  exports.node_locateANamespace = node_locateANamespace;
});

// node_modules/@oozcitak/dom/lib/algorithm/ParentNodeAlgorithm.js
var require_ParentNodeAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  function parentNode_convertNodesIntoANode(nodes, document2) {
    var e_1, _a;
    var node = null;
    for (var i = 0;i < nodes.length; i++) {
      var item = nodes[i];
      if (util_1.isString(item)) {
        var text = CreateAlgorithm_1.create_text(document2, item);
        nodes[i] = text;
      }
    }
    if (nodes.length === 1) {
      node = nodes[0];
    } else {
      node = CreateAlgorithm_1.create_documentFragment(document2);
      var ns = node;
      try {
        for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next();!nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
          var item = nodes_1_1.value;
          ns.appendChild(item);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return))
            _a.call(nodes_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    return node;
  }
  exports.parentNode_convertNodesIntoANode = parentNode_convertNodesIntoANode;
});

// node_modules/@oozcitak/dom/lib/algorithm/TextAlgorithm.js
var require_TextAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var DOMException_1 = require_DOMException();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var CharacterDataAlgorithm_1 = require_CharacterDataAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  function text_contiguousTextNodes(node, self2) {
    var _a;
    if (self2 === undefined) {
      self2 = false;
    }
    return _a = {}, _a[Symbol.iterator] = function() {
      var currentNode = node;
      while (currentNode && util_1.Guard.isTextNode(currentNode._previousSibling)) {
        currentNode = currentNode._previousSibling;
      }
      return {
        next: function() {
          if (currentNode && (!self2 && currentNode === node)) {
            if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
              currentNode = currentNode._nextSibling;
            } else {
              currentNode = null;
            }
          }
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
              currentNode = currentNode._nextSibling;
            } else {
              currentNode = null;
            }
            return result;
          }
        }
      };
    }, _a;
  }
  exports.text_contiguousTextNodes = text_contiguousTextNodes;
  function text_contiguousExclusiveTextNodes(node, self2) {
    var _a;
    if (self2 === undefined) {
      self2 = false;
    }
    return _a = {}, _a[Symbol.iterator] = function() {
      var currentNode = node;
      while (currentNode && util_1.Guard.isExclusiveTextNode(currentNode._previousSibling)) {
        currentNode = currentNode._previousSibling;
      }
      return {
        next: function() {
          if (currentNode && (!self2 && currentNode === node)) {
            if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
              currentNode = currentNode._nextSibling;
            } else {
              currentNode = null;
            }
          }
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
              currentNode = currentNode._nextSibling;
            } else {
              currentNode = null;
            }
            return result;
          }
        }
      };
    }, _a;
  }
  exports.text_contiguousExclusiveTextNodes = text_contiguousExclusiveTextNodes;
  function text_descendantTextContent(node) {
    var contents = "";
    var text = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, false, function(e) {
      return util_1.Guard.isTextNode(e);
    });
    while (text !== null) {
      contents += text._data;
      text = TreeAlgorithm_1.tree_getNextDescendantNode(node, text, false, false, function(e) {
        return util_1.Guard.isTextNode(e);
      });
    }
    return contents;
  }
  exports.text_descendantTextContent = text_descendantTextContent;
  function text_split(node, offset) {
    var e_1, _a;
    var length = node._data.length;
    if (offset > length) {
      throw new DOMException_1.IndexSizeError;
    }
    var count = length - offset;
    var newData = CharacterDataAlgorithm_1.characterData_substringData(node, offset, count);
    var newNode = CreateAlgorithm_1.create_text(node._nodeDocument, newData);
    var parent = node._parent;
    if (parent !== null) {
      MutationAlgorithm_1.mutation_insert(newNode, parent, node._nextSibling);
      try {
        for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next();!_c.done; _c = _b.next()) {
          var range = _c.value;
          if (range._start[0] === node && range._start[1] > offset) {
            range._start[0] = newNode;
            range._start[1] -= offset;
          }
          if (range._end[0] === node && range._end[1] > offset) {
            range._end[0] = newNode;
            range._end[1] -= offset;
          }
          var index = TreeAlgorithm_1.tree_index(node);
          if (range._start[0] === parent && range._start[1] === index + 1) {
            range._start[1]++;
          }
          if (range._end[0] === parent && range._end[1] === index + 1) {
            range._end[1]++;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    CharacterDataAlgorithm_1.characterData_replaceData(node, offset, count, "");
    return newNode;
  }
  exports.text_split = text_split;
});

// node_modules/@oozcitak/dom/lib/algorithm/RangeAlgorithm.js
var require_RangeAlgorithm = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spread = exports && exports.__spread || function() {
    for (var ar = [], i = 0;i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var DOMException_1 = require_DOMException();
  var util_1 = require_util2();
  var CreateAlgorithm_1 = require_CreateAlgorithm();
  var TreeAlgorithm_1 = require_TreeAlgorithm();
  var BoundaryPointAlgorithm_1 = require_BoundaryPointAlgorithm();
  var CharacterDataAlgorithm_1 = require_CharacterDataAlgorithm();
  var NodeAlgorithm_1 = require_NodeAlgorithm();
  var MutationAlgorithm_1 = require_MutationAlgorithm();
  var TextAlgorithm_1 = require_TextAlgorithm();
  function range_collapsed(range) {
    return range._startNode === range._endNode && range._startOffset === range._endOffset;
  }
  exports.range_collapsed = range_collapsed;
  function range_root(range) {
    return TreeAlgorithm_1.tree_rootNode(range._startNode);
  }
  exports.range_root = range_root;
  function range_isContained(node, range) {
    return TreeAlgorithm_1.tree_rootNode(node) === range_root(range) && BoundaryPointAlgorithm_1.boundaryPoint_position([node, 0], range._start) === interfaces_1.BoundaryPosition.After && BoundaryPointAlgorithm_1.boundaryPoint_position([node, TreeAlgorithm_1.tree_nodeLength(node)], range._end) === interfaces_1.BoundaryPosition.Before;
  }
  exports.range_isContained = range_isContained;
  function range_isPartiallyContained(node, range) {
    var startCheck = TreeAlgorithm_1.tree_isAncestorOf(range._startNode, node, true);
    var endCheck = TreeAlgorithm_1.tree_isAncestorOf(range._endNode, node, true);
    return startCheck && !endCheck || !startCheck && endCheck;
  }
  exports.range_isPartiallyContained = range_isPartiallyContained;
  function range_setTheStart(range, node, offset) {
    if (util_1.Guard.isDocumentTypeNode(node)) {
      throw new DOMException_1.InvalidNodeTypeError;
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {
      throw new DOMException_1.IndexSizeError;
    }
    var bp = [node, offset];
    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) || BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._end) === interfaces_1.BoundaryPosition.After) {
      range._end = bp;
    }
    range._start = bp;
  }
  exports.range_setTheStart = range_setTheStart;
  function range_setTheEnd(range, node, offset) {
    if (util_1.Guard.isDocumentTypeNode(node)) {
      throw new DOMException_1.InvalidNodeTypeError;
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {
      throw new DOMException_1.IndexSizeError;
    }
    var bp = [node, offset];
    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) || BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._start) === interfaces_1.BoundaryPosition.Before) {
      range._start = bp;
    }
    range._end = bp;
  }
  exports.range_setTheEnd = range_setTheEnd;
  function range_select(node, range) {
    var parent = node._parent;
    if (parent === null)
      throw new DOMException_1.InvalidNodeTypeError;
    var index = TreeAlgorithm_1.tree_index(node);
    range._start = [parent, index];
    range._end = [parent, index + 1];
  }
  exports.range_select = range_select;
  function range_extract(range) {
    var e_1, _a, e_2, _b, e_3, _c;
    var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);
    if (range_collapsed(range))
      return fragment;
    var originalStartNode = range._startNode;
    var originalStartOffset = range._startOffset;
    var originalEndNode = range._endNode;
    var originalEndOffset = range._endOffset;
    if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
      var clone = NodeAlgorithm_1.node_clone(originalStartNode);
      clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
      MutationAlgorithm_1.mutation_append(clone, fragment);
      CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
      return fragment;
    }
    var commonAncestor = originalStartNode;
    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {
      if (commonAncestor._parent === null) {
        throw new Error("Parent node  is null.");
      }
      commonAncestor = commonAncestor._parent;
    }
    var firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
      try {
        for (var _d = __values(commonAncestor._children), _e = _d.next();!_e.done; _e = _d.next()) {
          var node = _e.value;
          if (range_isPartiallyContained(node, range)) {
            firstPartiallyContainedChild = node;
            break;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a = _d.return))
            _a.call(_d);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    var lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
      var children = __spread(commonAncestor._children);
      for (var i = children.length - 1;i > 0; i--) {
        var node = children[i];
        if (range_isPartiallyContained(node, range)) {
          lastPartiallyContainedChild = node;
          break;
        }
      }
    }
    var containedChildren = [];
    try {
      for (var _f = __values(commonAncestor._children), _g = _f.next();!_g.done; _g = _f.next()) {
        var child = _g.value;
        if (range_isContained(child, range)) {
          if (util_1.Guard.isDocumentTypeNode(child)) {
            throw new DOMException_1.HierarchyRequestError;
          }
          containedChildren.push(child);
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_g && !_g.done && (_b = _f.return))
          _b.call(_f);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    var newNode;
    var newOffset;
    if (TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
      newNode = originalStartNode;
      newOffset = originalStartOffset;
    } else {
      var referenceNode = originalStartNode;
      while (referenceNode._parent !== null && !TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent)) {
        referenceNode = referenceNode._parent;
      }
      if (referenceNode._parent === null) {
        throw new Error("Parent node is null.");
      }
      newNode = referenceNode._parent;
      newOffset = 1 + TreeAlgorithm_1.tree_index(referenceNode);
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
      var clone = NodeAlgorithm_1.node_clone(originalStartNode);
      clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
      MutationAlgorithm_1.mutation_append(clone, fragment);
      CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, "");
    } else if (firstPartiallyContainedChild !== null) {
      var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
      MutationAlgorithm_1.mutation_append(clone, fragment);
      var subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);
      var subfragment = range_extract(subrange);
      MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    try {
      for (var containedChildren_1 = __values(containedChildren), containedChildren_1_1 = containedChildren_1.next();!containedChildren_1_1.done; containedChildren_1_1 = containedChildren_1.next()) {
        var child = containedChildren_1_1.value;
        MutationAlgorithm_1.mutation_append(child, fragment);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (containedChildren_1_1 && !containedChildren_1_1.done && (_c = containedChildren_1.return))
          _c.call(containedChildren_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
      var clone = NodeAlgorithm_1.node_clone(originalEndNode);
      clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
      MutationAlgorithm_1.mutation_append(clone, fragment);
      CharacterDataAlgorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, "");
    } else if (lastPartiallyContainedChild !== null) {
      var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
      MutationAlgorithm_1.mutation_append(clone, fragment);
      var subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
      var subfragment = range_extract(subrange);
      MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    range._start = [newNode, newOffset];
    range._end = [newNode, newOffset];
    return fragment;
  }
  exports.range_extract = range_extract;
  function range_cloneTheContents(range) {
    var e_4, _a, e_5, _b, e_6, _c;
    var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);
    if (range_collapsed(range))
      return fragment;
    var originalStartNode = range._startNode;
    var originalStartOffset = range._startOffset;
    var originalEndNode = range._endNode;
    var originalEndOffset = range._endOffset;
    if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
      var clone = NodeAlgorithm_1.node_clone(originalStartNode);
      clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
      MutationAlgorithm_1.mutation_append(clone, fragment);
    }
    var commonAncestor = originalStartNode;
    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {
      if (commonAncestor._parent === null) {
        throw new Error("Parent node  is null.");
      }
      commonAncestor = commonAncestor._parent;
    }
    var firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
      try {
        for (var _d = __values(commonAncestor._children), _e = _d.next();!_e.done; _e = _d.next()) {
          var node = _e.value;
          if (range_isPartiallyContained(node, range)) {
            firstPartiallyContainedChild = node;
            break;
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a = _d.return))
            _a.call(_d);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    }
    var lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
      var children = __spread(commonAncestor._children);
      for (var i = children.length - 1;i > 0; i--) {
        var node = children[i];
        if (range_isPartiallyContained(node, range)) {
          lastPartiallyContainedChild = node;
          break;
        }
      }
    }
    var containedChildren = [];
    try {
      for (var _f = __values(commonAncestor._children), _g = _f.next();!_g.done; _g = _f.next()) {
        var child = _g.value;
        if (range_isContained(child, range)) {
          if (util_1.Guard.isDocumentTypeNode(child)) {
            throw new DOMException_1.HierarchyRequestError;
          }
          containedChildren.push(child);
        }
      }
    } catch (e_5_1) {
      e_5 = { error: e_5_1 };
    } finally {
      try {
        if (_g && !_g.done && (_b = _f.return))
          _b.call(_f);
      } finally {
        if (e_5)
          throw e_5.error;
      }
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
      var clone = NodeAlgorithm_1.node_clone(originalStartNode);
      clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
      MutationAlgorithm_1.mutation_append(clone, fragment);
    } else if (firstPartiallyContainedChild !== null) {
      var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
      MutationAlgorithm_1.mutation_append(clone, fragment);
      var subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);
      var subfragment = range_cloneTheContents(subrange);
      MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    try {
      for (var containedChildren_2 = __values(containedChildren), containedChildren_2_1 = containedChildren_2.next();!containedChildren_2_1.done; containedChildren_2_1 = containedChildren_2.next()) {
        var child = containedChildren_2_1.value;
        var clone = NodeAlgorithm_1.node_clone(child);
        MutationAlgorithm_1.mutation_append(clone, fragment);
      }
    } catch (e_6_1) {
      e_6 = { error: e_6_1 };
    } finally {
      try {
        if (containedChildren_2_1 && !containedChildren_2_1.done && (_c = containedChildren_2.return))
          _c.call(containedChildren_2);
      } finally {
        if (e_6)
          throw e_6.error;
      }
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
      var clone = NodeAlgorithm_1.node_clone(originalEndNode);
      clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
      MutationAlgorithm_1.mutation_append(clone, fragment);
    } else if (lastPartiallyContainedChild !== null) {
      var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
      fragment.append(clone);
      var subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
      var subfragment = range_extract(subrange);
      MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    return fragment;
  }
  exports.range_cloneTheContents = range_cloneTheContents;
  function range_insert(node, range) {
    var e_7, _a;
    if (util_1.Guard.isProcessingInstructionNode(range._startNode) || util_1.Guard.isCommentNode(range._startNode) || util_1.Guard.isTextNode(range._startNode) && range._startNode._parent === null || range._startNode === node) {
      throw new DOMException_1.HierarchyRequestError;
    }
    var referenceNode = null;
    if (util_1.Guard.isTextNode(range._startNode)) {
      referenceNode = range._startNode;
    } else {
      var index = 0;
      try {
        for (var _b = __values(range._startNode._children), _c = _b.next();!_c.done; _c = _b.next()) {
          var child = _c.value;
          if (index === range._startOffset) {
            referenceNode = child;
            break;
          }
          index++;
        }
      } catch (e_7_1) {
        e_7 = { error: e_7_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_7)
            throw e_7.error;
        }
      }
    }
    var parent;
    if (referenceNode === null) {
      parent = range._startNode;
    } else {
      if (referenceNode._parent === null) {
        throw new Error("Parent node is null.");
      }
      parent = referenceNode._parent;
    }
    MutationAlgorithm_1.mutation_ensurePreInsertionValidity(node, parent, referenceNode);
    if (util_1.Guard.isTextNode(range._startNode)) {
      referenceNode = TextAlgorithm_1.text_split(range._startNode, range._startOffset);
    }
    if (node === referenceNode) {
      referenceNode = node._nextSibling;
    }
    if (node._parent !== null) {
      MutationAlgorithm_1.mutation_remove(node, node._parent);
    }
    var newOffset = referenceNode === null ? TreeAlgorithm_1.tree_nodeLength(parent) : TreeAlgorithm_1.tree_index(referenceNode);
    if (util_1.Guard.isDocumentFragmentNode(node)) {
      newOffset += TreeAlgorithm_1.tree_nodeLength(node);
    } else {
      newOffset++;
    }
    MutationAlgorithm_1.mutation_preInsert(node, parent, referenceNode);
    if (range_collapsed(range)) {
      range._end = [parent, newOffset];
    }
  }
  exports.range_insert = range_insert;
  function range_getContainedNodes(range) {
    var _a;
    return _a = {}, _a[Symbol.iterator] = function() {
      var container = range.commonAncestorContainer;
      var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
      return {
        next: function() {
          while (currentNode && !range_isContained(currentNode, range)) {
            currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
          }
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
            return result;
          }
        }
      };
    }, _a;
  }
  exports.range_getContainedNodes = range_getContainedNodes;
  function range_getPartiallyContainedNodes(range) {
    var _a;
    return _a = {}, _a[Symbol.iterator] = function() {
      var container = range.commonAncestorContainer;
      var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
      return {
        next: function() {
          while (currentNode && !range_isPartiallyContained(currentNode, range)) {
            currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
          }
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            var result = { done: false, value: currentNode };
            currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
            return result;
          }
        }
      };
    }, _a;
  }
  exports.range_getPartiallyContainedNodes = range_getPartiallyContainedNodes;
});

// node_modules/@oozcitak/dom/lib/algorithm/SelectorsAlgorithm.js
var require_SelectorsAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMException_1 = require_DOMException();
  function selectors_scopeMatchASelectorsString(selectors, node) {
    throw new DOMException_1.NotSupportedError;
  }
  exports.selectors_scopeMatchASelectorsString = selectors_scopeMatchASelectorsString;
});

// node_modules/@oozcitak/dom/lib/algorithm/TreeWalkerAlgorithm.js
var require_TreeWalkerAlgorithm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var TraversalAlgorithm_1 = require_TraversalAlgorithm();
  function treeWalker_traverseChildren(walker, first) {
    var node = first ? walker._current._firstChild : walker._current._lastChild;
    while (node !== null) {
      var result = TraversalAlgorithm_1.traversal_filter(walker, node);
      if (result === interfaces_1.FilterResult.Accept) {
        walker._current = node;
        return node;
      } else if (result === interfaces_1.FilterResult.Skip) {
        var child = first ? node._firstChild : node._lastChild;
        if (child !== null) {
          node = child;
          continue;
        }
      }
      while (node !== null) {
        var sibling = first ? node._nextSibling : node._previousSibling;
        if (sibling !== null) {
          node = sibling;
          break;
        }
        var parent = node._parent;
        if (parent === null || parent === walker._root || parent === walker._current) {
          return null;
        }
        node = parent;
      }
    }
    return null;
  }
  exports.treeWalker_traverseChildren = treeWalker_traverseChildren;
  function treeWalker_traverseSiblings(walker, next) {
    var node = walker._current;
    if (node === walker._root)
      return null;
    while (true) {
      var sibling = next ? node._nextSibling : node._previousSibling;
      while (sibling !== null) {
        node = sibling;
        var result = TraversalAlgorithm_1.traversal_filter(walker, node);
        if (result === interfaces_1.FilterResult.Accept) {
          walker._current = node;
          return node;
        }
        sibling = next ? node._firstChild : node._lastChild;
        if (result === interfaces_1.FilterResult.Reject || sibling === null) {
          sibling = next ? node._nextSibling : node._previousSibling;
        }
      }
      node = node._parent;
      if (node === null || node === walker._root) {
        return null;
      }
      if (TraversalAlgorithm_1.traversal_filter(walker, node) === interfaces_1.FilterResult.Accept) {
        return null;
      }
    }
  }
  exports.treeWalker_traverseSiblings = treeWalker_traverseSiblings;
});

// node_modules/@oozcitak/dom/lib/algorithm/index.js
var require_algorithm = __commonJS((exports) => {
  function __export2(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  __export2(require_AbortAlgorithm());
  __export2(require_AttrAlgorithm());
  __export2(require_BoundaryPointAlgorithm());
  __export2(require_CharacterDataAlgorithm());
  __export2(require_CreateAlgorithm());
  __export2(require_CustomElementAlgorithm());
  __export2(require_DocumentAlgorithm());
  __export2(require_DOMAlgorithm());
  __export2(require_DOMTokenListAlgorithm());
  __export2(require_ElementAlgorithm());
  __export2(require_EventAlgorithm());
  __export2(require_EventTargetAlgorithm());
  __export2(require_MutationAlgorithm());
  __export2(require_MutationObserverAlgorithm());
  __export2(require_NamespaceAlgorithm());
  __export2(require_NodeAlgorithm());
  __export2(require_NodeIteratorAlgorithm());
  __export2(require_OrderedSetAlgorithm());
  __export2(require_ParentNodeAlgorithm());
  __export2(require_RangeAlgorithm());
  __export2(require_SelectorsAlgorithm());
  __export2(require_ShadowTreeAlgorithm());
  __export2(require_TextAlgorithm());
  __export2(require_TraversalAlgorithm());
  __export2(require_TreeAlgorithm());
  __export2(require_TreeWalkerAlgorithm());
  __export2(require_WebIDLAlgorithm());
  __export2(require_XMLAlgorithm());
});

// node_modules/xmlbuilder2/lib/writers/BaseWriter.js
var require_BaseWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var LocalNameSet_1 = require_LocalNameSet();
  var NamespacePrefixMap_1 = require_NamespacePrefixMap();
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib9();
  var algorithm_1 = require_algorithm();

  class BaseWriter {
    constructor(builderOptions) {
      this.level = 0;
      this._builderOptions = builderOptions;
    }
    docType(name, publicId, systemId) {
    }
    comment(data) {
    }
    text(data) {
    }
    instruction(target, data) {
    }
    cdata(data) {
    }
    openTagBegin(name) {
    }
    openTagEnd(name, selfClosing, voidElement) {
    }
    closeTag(name) {
    }
    attributes(attributes) {
      for (const attr of attributes) {
        this.attribute(attr[1] === null ? attr[2] : attr[1] + ":" + attr[2], attr[3]);
      }
    }
    attribute(name, value) {
    }
    beginElement(name) {
    }
    endElement(name) {
    }
    serializeNode(node, requireWellFormed, noDoubleEncoding) {
      const hasNamespaces = node._nodeDocument !== undefined && node._nodeDocument._hasNamespaces;
      this.level = 0;
      this.currentNode = node;
      if (hasNamespaces) {
        let namespace = null;
        const prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap;
        prefixMap.set("xml", infra_1.namespace.XML);
        const prefixIndex = { value: 1 };
        try {
          this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
        } catch (e) {
          throw new DOMException_1.InvalidStateError(e.message);
        }
      } else {
        try {
          this._serializeNode(node, requireWellFormed, noDoubleEncoding);
        } catch (e) {
          throw new DOMException_1.InvalidStateError(e.message);
        }
      }
    }
    _serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {
      this.currentNode = node;
      switch (node.nodeType) {
        case interfaces_1.NodeType.Element:
          this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Document:
          this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Comment:
          this._serializeComment(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Text:
          this._serializeText(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.DocumentFragment:
          this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.DocumentType:
          this._serializeDocumentType(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.ProcessingInstruction:
          this._serializeProcessingInstruction(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.CData:
          this._serializeCData(node, requireWellFormed, noDoubleEncoding);
          break;
        default:
          throw new Error(`Unknown node type: ${node.nodeType}`);
      }
    }
    _serializeNode(node, requireWellFormed, noDoubleEncoding) {
      this.currentNode = node;
      switch (node.nodeType) {
        case interfaces_1.NodeType.Element:
          this._serializeElement(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Document:
          this._serializeDocument(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Comment:
          this._serializeComment(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Text:
          this._serializeText(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.DocumentFragment:
          this._serializeDocumentFragment(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.DocumentType:
          this._serializeDocumentType(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.ProcessingInstruction:
          this._serializeProcessingInstruction(node, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.CData:
          this._serializeCData(node, requireWellFormed, noDoubleEncoding);
          break;
        default:
          throw new Error(`Unknown node type: ${node.nodeType}`);
      }
    }
    _serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {
      const attributes = [];
      if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let qualifiedName = "";
      let skipEndTag = false;
      let ignoreNamespaceDefinitionAttribute = false;
      let map = prefixMap.copy();
      let localPrefixesMap = {};
      let localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
      let inheritedNS = namespace;
      let ns = node.namespaceURI;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node.localName;
        } else {
          qualifiedName = node.localName;
        }
        this.beginElement(qualifiedName);
        this.openTagBegin(qualifiedName);
      } else {
        let prefix = node.prefix;
        let candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (requireWellFormed) {
            throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map, prefixIndex);
          }
          map.set(prefix, ns);
          qualifiedName += prefix + ":" + node.localName;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
          attributes.push([
            null,
            "xmlns",
            prefix,
            this._serializeAttributeValue(ns, requireWellFormed, noDoubleEncoding)
          ]);
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node.localName;
          inheritedNS = ns;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
          attributes.push([
            null,
            null,
            "xmlns",
            this._serializeAttributeValue(ns, requireWellFormed, noDoubleEncoding)
          ]);
        } else {
          qualifiedName += node.localName;
          inheritedNS = ns;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
        }
      }
      attributes.push(...this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, noDoubleEncoding));
      this.attributes(attributes);
      const isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && node.childNodes.length === 0 && BaseWriter._VoidElementNames.has(node.localName)) {
        this.openTagEnd(qualifiedName, true, true);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else if (!isHTML && node.childNodes.length === 0) {
        this.openTagEnd(qualifiedName, true, false);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else {
        this.openTagEnd(qualifiedName, false, false);
      }
      if (skipEndTag)
        return;
      if (isHTML && node.localName === "template") {
      } else {
        for (const childNode of node.childNodes) {
          this.level++;
          this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed, noDoubleEncoding);
          this.level--;
        }
      }
      this.closeTag(qualifiedName);
      this.endElement(qualifiedName);
    }
    _serializeElement(node, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let skipEndTag = false;
      const qualifiedName = node.localName;
      this.beginElement(qualifiedName);
      this.openTagBegin(qualifiedName);
      const attributes = this._serializeAttributes(node, requireWellFormed, noDoubleEncoding);
      this.attributes(attributes);
      if (!node.hasChildNodes()) {
        this.openTagEnd(qualifiedName, true, false);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else {
        this.openTagEnd(qualifiedName, false, false);
      }
      if (skipEndTag)
        return;
      for (const childNode of node._children) {
        this.level++;
        this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);
        this.level--;
      }
      this.closeTag(qualifiedName);
      this.endElement(qualifiedName);
    }
    _serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && node.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      for (const childNode of node.childNodes) {
        this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
      }
    }
    _serializeDocument(node, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && node.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      for (const childNode of node._children) {
        this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);
      }
    }
    _serializeComment(node, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
        throw new Error("Comment data contains invalid characters (well-formed required).");
      }
      this.comment(node.data);
    }
    _serializeText(node, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
        throw new Error("Text data contains invalid characters (well-formed required).");
      }
      let markup = "";
      if (noDoubleEncoding) {
        markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      } else {
        for (let i = 0;i < node.data.length; i++) {
          const c = node.data[i];
          if (c === "&")
            markup += "&amp;";
          else if (c === "<")
            markup += "&lt;";
          else if (c === ">")
            markup += "&gt;";
          else
            markup += c;
        }
      }
      this.text(markup);
    }
    _serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {
      for (const childNode of node.childNodes) {
        this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
      }
    }
    _serializeDocumentFragment(node, requireWellFormed, noDoubleEncoding) {
      for (const childNode of node._children) {
        this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);
      }
    }
    _serializeDocumentType(node, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
        throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
      }
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
        throw new Error("DocType system identifier contains invalid characters (well-formed required).");
      }
      this.docType(node.name, node.publicId, node.systemId);
    }
    _serializeProcessingInstruction(node, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
        throw new Error("Processing instruction target contains invalid characters (well-formed required).");
      }
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("?>") !== -1)) {
        throw new Error("Processing instruction data contains invalid characters (well-formed required).");
      }
      this.instruction(node.target, node.data);
    }
    _serializeCData(node, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && node.data.indexOf("]]>") !== -1) {
        throw new Error("CDATA contains invalid characters (well-formed required).");
      }
      this.cdata(node.data);
    }
    _serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, noDoubleEncoding) {
      const result = [];
      const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet : undefined;
      for (const attr of node.attributes) {
        if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
          result.push([
            null,
            null,
            attr.localName,
            this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)
          ]);
          continue;
        }
        if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet.set(attr.namespaceURI, attr.localName);
        let attributeNamespace = attr.namespaceURI;
        let candidatePrefix = null;
        if (attributeNamespace !== null) {
          candidatePrefix = map.get(attr.prefix, attributeNamespace);
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
              continue;
            if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
              throw new Error("XMLNS namespace is reserved (well-formed required).");
            }
            if (requireWellFormed && attr.value === "") {
              throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
            }
            if (attr.prefix === "xmlns")
              candidatePrefix = "xmlns";
          } else if (candidatePrefix === null) {
            if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
              candidatePrefix = attr.prefix;
            } else {
              candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
            }
            result.push([
              null,
              "xmlns",
              candidatePrefix,
              this._serializeAttributeValue(attributeNamespace, requireWellFormed, noDoubleEncoding)
            ]);
          }
        }
        let attrName = "";
        if (candidatePrefix !== null) {
          attrName = candidatePrefix;
        }
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result.push([
          attributeNamespace,
          candidatePrefix,
          attr.localName,
          this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)
        ]);
      }
      return result;
    }
    _serializeAttributes(node, requireWellFormed, noDoubleEncoding) {
      const result = [];
      const localNameSet = requireWellFormed ? {} : undefined;
      for (const attr of node.attributes) {
        if (!requireWellFormed) {
          result.push([
            null,
            null,
            attr.localName,
            this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)
          ]);
          continue;
        }
        if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet[attr.localName] = true;
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName))) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result.push([
          null,
          null,
          attr.localName,
          this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)
        ]);
      }
      return result;
    }
    _recordNamespaceInformation(node, map, localPrefixesMap) {
      let defaultNamespaceAttrValue = null;
      for (const attr of node.attributes) {
        let attributeNamespace = attr.namespaceURI;
        let attributePrefix = attr.prefix;
        if (attributeNamespace === infra_1.namespace.XMLNS) {
          if (attributePrefix === null) {
            defaultNamespaceAttrValue = attr.value;
            continue;
          } else {
            let prefixDefinition = attr.localName;
            let namespaceDefinition = attr.value;
            if (namespaceDefinition === infra_1.namespace.XML) {
              continue;
            }
            if (namespaceDefinition === "") {
              namespaceDefinition = null;
            }
            if (map.has(prefixDefinition, namespaceDefinition)) {
              continue;
            }
            map.set(prefixDefinition, namespaceDefinition);
            localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
          }
        }
      }
      return defaultNamespaceAttrValue;
    }
    _generatePrefix(newNamespace, prefixMap, prefixIndex) {
      const generatedPrefix = "ns" + prefixIndex.value.toString();
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    }
    _serializeAttributeValue(value, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
        throw new Error("Invalid characters in attribute value.");
      }
      if (value === null)
        return "";
      if (noDoubleEncoding) {
        return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      } else {
        let result = "";
        for (let i = 0;i < value.length; i++) {
          const c = value[i];
          if (c === '"')
            result += "&quot;";
          else if (c === "&")
            result += "&amp;";
          else if (c === "<")
            result += "&lt;";
          else if (c === ">")
            result += "&gt;";
          else
            result += c;
        }
        return result;
      }
    }
  }
  exports.BaseWriter = BaseWriter;
  BaseWriter._VoidElementNames = new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
});

// node_modules/xmlbuilder2/lib/writers/ObjectWriter.js
var require_ObjectWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  var interfaces_1 = require_interfaces2();
  var BaseWriter_1 = require_BaseWriter();

  class ObjectWriter extends BaseWriter_1.BaseWriter {
    serialize(node, writerOptions) {
      const options = util_1.applyDefaults(writerOptions, {
        format: "object",
        wellFormed: false,
        noDoubleEncoding: false,
        group: false
      });
      this._currentList = [];
      this._currentIndex = 0;
      this._listRegister = [this._currentList];
      this.serializeNode(node, options.wellFormed, options.noDoubleEncoding);
      return this._process(this._currentList, options);
    }
    _process(items, options) {
      if (items.length === 0)
        return {};
      const namesSeen = {};
      let hasNonUniqueNames = false;
      let textCount = 0;
      let commentCount = 0;
      let instructionCount = 0;
      let cdataCount = 0;
      for (let i = 0;i < items.length; i++) {
        const item = items[i];
        const key = Object.keys(item)[0];
        switch (key) {
          case "@":
            continue;
          case "#":
            textCount++;
            break;
          case "!":
            commentCount++;
            break;
          case "?":
            instructionCount++;
            break;
          case "$":
            cdataCount++;
            break;
          default:
            if (namesSeen[key]) {
              hasNonUniqueNames = true;
            } else {
              namesSeen[key] = true;
            }
            break;
        }
      }
      const defAttrKey = this._getAttrKey();
      const defTextKey = this._getNodeKey(interfaces_1.NodeType.Text);
      const defCommentKey = this._getNodeKey(interfaces_1.NodeType.Comment);
      const defInstructionKey = this._getNodeKey(interfaces_1.NodeType.ProcessingInstruction);
      const defCdataKey = this._getNodeKey(interfaces_1.NodeType.CData);
      if (textCount === 1 && items.length === 1 && util_1.isString(items[0]["#"])) {
        return items[0]["#"];
      } else if (hasNonUniqueNames) {
        const result = [];
        const obj = { [defTextKey]: result };
        for (let i = 0;i < items.length; i++) {
          const item = items[i];
          const key = Object.keys(item)[0];
          switch (key) {
            case "@":
              const attrs = item["@"];
              const attrKeys = Object.keys(attrs);
              if (attrKeys.length === 1) {
                result.push({ [defAttrKey + attrKeys[0]]: attrs[attrKeys[0]] });
              } else {
                result.push({ [defAttrKey]: item["@"] });
              }
              break;
            case "#":
              result.push({ [defTextKey]: item["#"] });
              break;
            case "!":
              result.push({ [defCommentKey]: item["!"] });
              break;
            case "?":
              result.push({ [defInstructionKey]: item["?"] });
              break;
            case "$":
              result.push({ [defCdataKey]: item["$"] });
              break;
            default:
              const ele = item;
              if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                const eleGroup = [];
                const listOfLists = ele[key];
                for (let i2 = 0;i2 < listOfLists.length; i2++) {
                  eleGroup.push(this._process(listOfLists[i2], options));
                }
                result.push({ [key]: eleGroup });
              } else {
                result.push({ [key]: this._process(ele[key], options) });
              }
              break;
          }
        }
        return obj;
      } else {
        let textId = 1;
        let commentId = 1;
        let instructionId = 1;
        let cdataId = 1;
        const obj = {};
        for (let i = 0;i < items.length; i++) {
          const item = items[i];
          const key = Object.keys(item)[0];
          switch (key) {
            case "@":
              const attrs = item["@"];
              const attrKeys = Object.keys(attrs);
              if (!options.group || attrKeys.length === 1) {
                for (const attrName in attrs) {
                  obj[defAttrKey + attrName] = attrs[attrName];
                }
              } else {
                obj[defAttrKey] = attrs;
              }
              break;
            case "#":
              textId = this._processSpecItem(item["#"], obj, options.group, defTextKey, textCount, textId);
              break;
            case "!":
              commentId = this._processSpecItem(item["!"], obj, options.group, defCommentKey, commentCount, commentId);
              break;
            case "?":
              instructionId = this._processSpecItem(item["?"], obj, options.group, defInstructionKey, instructionCount, instructionId);
              break;
            case "$":
              cdataId = this._processSpecItem(item["$"], obj, options.group, defCdataKey, cdataCount, cdataId);
              break;
            default:
              const ele = item;
              if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                const eleGroup = [];
                const listOfLists = ele[key];
                for (let i2 = 0;i2 < listOfLists.length; i2++) {
                  eleGroup.push(this._process(listOfLists[i2], options));
                }
                obj[key] = eleGroup;
              } else {
                obj[key] = this._process(ele[key], options);
              }
              break;
          }
        }
        return obj;
      }
    }
    _processSpecItem(item, obj, group, defKey, count, id) {
      if (!group && util_1.isArray(item) && count + item.length > 2) {
        for (const subItem of item) {
          const key = defKey + (id++).toString();
          obj[key] = subItem;
        }
      } else {
        const key = count > 1 ? defKey + (id++).toString() : defKey;
        obj[key] = item;
      }
      return id;
    }
    beginElement(name) {
      const childItems = [];
      if (this._currentList.length === 0) {
        this._currentList.push({ [name]: childItems });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isElementNode(lastItem, name)) {
          if (lastItem[name].length !== 0 && util_1.isArray(lastItem[name][0])) {
            const listOfLists = lastItem[name];
            listOfLists.push(childItems);
          } else {
            lastItem[name] = [lastItem[name], childItems];
          }
        } else {
          this._currentList.push({ [name]: childItems });
        }
      }
      this._currentIndex++;
      if (this._listRegister.length > this._currentIndex) {
        this._listRegister[this._currentIndex] = childItems;
      } else {
        this._listRegister.push(childItems);
      }
      this._currentList = childItems;
    }
    endElement() {
      this._currentList = this._listRegister[--this._currentIndex];
    }
    attribute(name, value) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "@": { [name]: value } });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isAttrNode(lastItem)) {
          lastItem["@"][name] = value;
        } else {
          this._currentList.push({ "@": { [name]: value } });
        }
      }
    }
    comment(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "!": data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isCommentNode(lastItem)) {
          if (util_1.isArray(lastItem["!"])) {
            lastItem["!"].push(data);
          } else {
            lastItem["!"] = [lastItem["!"], data];
          }
        } else {
          this._currentList.push({ "!": data });
        }
      }
    }
    text(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "#": data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isTextNode(lastItem)) {
          if (util_1.isArray(lastItem["#"])) {
            lastItem["#"].push(data);
          } else {
            lastItem["#"] = [lastItem["#"], data];
          }
        } else {
          this._currentList.push({ "#": data });
        }
      }
    }
    instruction(target, data) {
      const value = data === "" ? target : target + " " + data;
      if (this._currentList.length === 0) {
        this._currentList.push({ "?": value });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isInstructionNode(lastItem)) {
          if (util_1.isArray(lastItem["?"])) {
            lastItem["?"].push(value);
          } else {
            lastItem["?"] = [lastItem["?"], value];
          }
        } else {
          this._currentList.push({ "?": value });
        }
      }
    }
    cdata(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ $: data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isCDATANode(lastItem)) {
          if (util_1.isArray(lastItem["$"])) {
            lastItem["$"].push(data);
          } else {
            lastItem["$"] = [lastItem["$"], data];
          }
        } else {
          this._currentList.push({ $: data });
        }
      }
    }
    _isAttrNode(x) {
      return "@" in x;
    }
    _isTextNode(x) {
      return "#" in x;
    }
    _isCommentNode(x) {
      return "!" in x;
    }
    _isInstructionNode(x) {
      return "?" in x;
    }
    _isCDATANode(x) {
      return "$" in x;
    }
    _isElementNode(x, name) {
      return name in x;
    }
    _getAttrKey() {
      return this._builderOptions.convert.att;
    }
    _getNodeKey(nodeType) {
      switch (nodeType) {
        case interfaces_1.NodeType.Comment:
          return this._builderOptions.convert.comment;
        case interfaces_1.NodeType.Text:
          return this._builderOptions.convert.text;
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._builderOptions.convert.ins;
        case interfaces_1.NodeType.CData:
          return this._builderOptions.convert.cdata;
        default:
          throw new Error("Invalid node type.");
      }
    }
  }
  exports.ObjectWriter = ObjectWriter;
});

// node_modules/xmlbuilder2/lib/writers/MapWriter.js
var require_MapWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  var ObjectWriter_1 = require_ObjectWriter();
  var BaseWriter_1 = require_BaseWriter();

  class MapWriter extends BaseWriter_1.BaseWriter {
    serialize(node, writerOptions) {
      const options = util_1.applyDefaults(writerOptions, {
        format: "map",
        wellFormed: false,
        noDoubleEncoding: false,
        group: false
      });
      const objectWriterOptions = util_1.applyDefaults(options, {
        format: "object",
        wellFormed: false,
        noDoubleEncoding: false
      });
      const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions);
      const val = objectWriter.serialize(node, objectWriterOptions);
      return this._convertObject(val);
    }
    _convertObject(obj) {
      if (util_1.isArray(obj)) {
        for (let i = 0;i < obj.length; i++) {
          obj[i] = this._convertObject(obj[i]);
        }
        return obj;
      } else if (util_1.isObject(obj)) {
        const map = new Map;
        for (const key in obj) {
          map.set(key, this._convertObject(obj[key]));
        }
        return map;
      } else {
        return obj;
      }
    }
  }
  exports.MapWriter = MapWriter;
});

// node_modules/xmlbuilder2/lib/writers/XMLWriter.js
var require_XMLWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  var interfaces_1 = require_interfaces2();
  var BaseWriter_1 = require_BaseWriter();
  var util_2 = require_util2();

  class XMLWriter extends BaseWriter_1.BaseWriter {
    constructor() {
      super(...arguments);
      this._indentation = {};
      this._lengthToLastNewline = 0;
    }
    serialize(node, writerOptions) {
      this._options = util_1.applyDefaults(writerOptions, {
        wellFormed: false,
        noDoubleEncoding: false,
        headless: false,
        prettyPrint: false,
        indent: "  ",
        newline: `
`,
        offset: 0,
        width: 0,
        allowEmptyTags: false,
        indentTextOnlyNodes: false,
        spaceBeforeSlash: false
      });
      this._refs = { suppressPretty: false, emptyNode: false, markup: "" };
      if (node.nodeType === interfaces_1.NodeType.Document && !this._options.headless) {
        this._beginLine();
        this._refs.markup = "<?xml";
        this._refs.markup += ' version="' + this._builderOptions.version + '"';
        if (this._builderOptions.encoding !== undefined) {
          this._refs.markup += ' encoding="' + this._builderOptions.encoding + '"';
        }
        if (this._builderOptions.standalone !== undefined) {
          this._refs.markup += ' standalone="' + (this._builderOptions.standalone ? "yes" : "no") + '"';
        }
        this._refs.markup += "?>";
        this._endLine();
      }
      this.serializeNode(node, this._options.wellFormed, this._options.noDoubleEncoding);
      if (this._options.prettyPrint && this._refs.markup.slice(-this._options.newline.length) === this._options.newline) {
        this._refs.markup = this._refs.markup.slice(0, -this._options.newline.length);
      }
      return this._refs.markup;
    }
    docType(name, publicId, systemId) {
      this._beginLine();
      if (publicId && systemId) {
        this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
      } else if (publicId) {
        this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
      } else if (systemId) {
        this._refs.markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
      } else {
        this._refs.markup += "<!DOCTYPE " + name + ">";
      }
      this._endLine();
    }
    openTagBegin(name) {
      this._beginLine();
      this._refs.markup += "<" + name;
    }
    openTagEnd(name, selfClosing, voidElement) {
      this._refs.suppressPretty = false;
      this._refs.emptyNode = false;
      if (this._options.prettyPrint && !selfClosing && !voidElement) {
        let textOnlyNode = true;
        let emptyNode = true;
        let childNode = this.currentNode.firstChild;
        let cdataCount = 0;
        let textCount = 0;
        while (childNode) {
          if (util_2.Guard.isExclusiveTextNode(childNode)) {
            textCount++;
          } else if (util_2.Guard.isCDATASectionNode(childNode)) {
            cdataCount++;
          } else {
            textOnlyNode = false;
            emptyNode = false;
            break;
          }
          if (childNode.data !== "") {
            emptyNode = false;
          }
          childNode = childNode.nextSibling;
        }
        this._refs.suppressPretty = !this._options.indentTextOnlyNodes && textOnlyNode && (cdataCount <= 1 && textCount === 0 || cdataCount === 0);
        this._refs.emptyNode = emptyNode;
      }
      if ((voidElement || selfClosing || this._refs.emptyNode) && this._options.allowEmptyTags) {
        this._refs.markup += "></" + name + ">";
      } else {
        this._refs.markup += voidElement ? " />" : selfClosing || this._refs.emptyNode ? this._options.spaceBeforeSlash ? " />" : "/>" : ">";
      }
      this._endLine();
    }
    closeTag(name) {
      if (!this._refs.emptyNode) {
        this._beginLine();
        this._refs.markup += "</" + name + ">";
      }
      this._refs.suppressPretty = false;
      this._refs.emptyNode = false;
      this._endLine();
    }
    attribute(name, value) {
      const str = name + '="' + value + '"';
      if (this._options.prettyPrint && this._options.width > 0 && this._refs.markup.length - this._lengthToLastNewline + 1 + str.length > this._options.width) {
        this._endLine();
        this._beginLine();
        this._refs.markup += this._indent(1) + str;
      } else {
        this._refs.markup += " " + str;
      }
    }
    text(data) {
      if (data !== "") {
        this._beginLine();
        this._refs.markup += data;
        this._endLine();
      }
    }
    cdata(data) {
      if (data !== "") {
        this._beginLine();
        this._refs.markup += "<![CDATA[" + data + "]]>";
        this._endLine();
      }
    }
    comment(data) {
      this._beginLine();
      this._refs.markup += "<!--" + data + "-->";
      this._endLine();
    }
    instruction(target, data) {
      this._beginLine();
      this._refs.markup += "<?" + (data === "" ? target : target + " " + data) + "?>";
      this._endLine();
    }
    _beginLine() {
      if (this._options.prettyPrint && !this._refs.suppressPretty) {
        this._refs.markup += this._indent(this._options.offset + this.level);
      }
    }
    _endLine() {
      if (this._options.prettyPrint && !this._refs.suppressPretty) {
        this._refs.markup += this._options.newline;
        this._lengthToLastNewline = this._refs.markup.length;
      }
    }
    _indent(level) {
      if (level <= 0) {
        return "";
      } else if (this._indentation[level] !== undefined) {
        return this._indentation[level];
      } else {
        const str = this._options.indent.repeat(level);
        this._indentation[level] = str;
        return str;
      }
    }
  }
  exports.XMLWriter = XMLWriter;
});

// node_modules/xmlbuilder2/lib/writers/JSONWriter.js
var require_JSONWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ObjectWriter_1 = require_ObjectWriter();
  var util_1 = require_lib8();
  var BaseWriter_1 = require_BaseWriter();

  class JSONWriter extends BaseWriter_1.BaseWriter {
    serialize(node, writerOptions) {
      const options = util_1.applyDefaults(writerOptions, {
        wellFormed: false,
        noDoubleEncoding: false,
        prettyPrint: false,
        indent: "  ",
        newline: `
`,
        offset: 0,
        group: false
      });
      const objectWriterOptions = util_1.applyDefaults(options, {
        format: "object",
        wellFormed: false,
        noDoubleEncoding: false
      });
      const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions);
      const val = objectWriter.serialize(node, objectWriterOptions);
      return this._beginLine(options, 0) + this._convertObject(val, options);
    }
    _convertObject(obj, options, level = 0) {
      let markup = "";
      const isLeaf = this._isLeafNode(obj);
      if (util_1.isArray(obj)) {
        markup += "[";
        const len = obj.length;
        let i = 0;
        for (const val of obj) {
          markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1) + this._convertObject(val, options, level + 1);
          if (i < len - 1) {
            markup += ",";
          }
          i++;
        }
        markup += this._endLine(options, level) + this._beginLine(options, level);
        markup += "]";
      } else if (util_1.isObject(obj)) {
        markup += "{";
        const len = util_1.objectLength(obj);
        let i = 0;
        util_1.forEachObject(obj, (key, val) => {
          if (isLeaf && options.prettyPrint) {
            markup += " ";
          } else {
            markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1);
          }
          markup += '"' + key + '":';
          if (options.prettyPrint) {
            markup += " ";
          }
          markup += this._convertObject(val, options, level + 1);
          if (i < len - 1) {
            markup += ",";
          }
          i++;
        }, this);
        if (isLeaf && options.prettyPrint) {
          markup += " ";
        } else {
          markup += this._endLine(options, level) + this._beginLine(options, level);
        }
        markup += "}";
      } else {
        markup += '"' + obj + '"';
      }
      return markup;
    }
    _beginLine(options, level) {
      if (!options.prettyPrint) {
        return "";
      } else {
        const indentLevel = options.offset + level + 1;
        if (indentLevel > 0) {
          return new Array(indentLevel).join(options.indent);
        }
      }
      return "";
    }
    _endLine(options, level) {
      if (!options.prettyPrint) {
        return "";
      } else {
        return options.newline;
      }
    }
    _isLeafNode(obj) {
      return this._descendantCount(obj) <= 1;
    }
    _descendantCount(obj, count = 0) {
      if (util_1.isArray(obj)) {
        util_1.forEachArray(obj, (val) => count += this._descendantCount(val, count), this);
      } else if (util_1.isObject(obj)) {
        util_1.forEachObject(obj, (key, val) => count += this._descendantCount(val, count), this);
      } else {
        count++;
      }
      return count;
    }
  }
  exports.JSONWriter = JSONWriter;
});

// node_modules/xmlbuilder2/lib/writers/index.js
var require_writers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MapWriter_1 = require_MapWriter();
  exports.MapWriter = MapWriter_1.MapWriter;
  var XMLWriter_1 = require_XMLWriter();
  exports.XMLWriter = XMLWriter_1.XMLWriter;
  var ObjectWriter_1 = require_ObjectWriter();
  exports.ObjectWriter = ObjectWriter_1.ObjectWriter;
  var JSONWriter_1 = require_JSONWriter();
  exports.JSONWriter = JSONWriter_1.JSONWriter;
});

// node_modules/@oozcitak/dom/lib/dom/ChildNodeImpl.js
var require_ChildNodeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var algorithm_1 = require_algorithm();
  var ChildNodeImpl = function() {
    function ChildNodeImpl2() {
    }
    ChildNodeImpl2.prototype.before = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      var context = util_1.Cast.asNode(this);
      var parent = context._parent;
      if (parent === null)
        return;
      var viablePreviousSibling = context._previousSibling;
      var flag = true;
      while (flag && viablePreviousSibling) {
        flag = false;
        for (var i = 0;i < nodes.length; i++) {
          var child = nodes[i];
          if (child === viablePreviousSibling) {
            viablePreviousSibling = viablePreviousSibling._previousSibling;
            flag = true;
            break;
          }
        }
      }
      var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
      if (viablePreviousSibling === null)
        viablePreviousSibling = parent._firstChild;
      else
        viablePreviousSibling = viablePreviousSibling._nextSibling;
      algorithm_1.mutation_preInsert(node, parent, viablePreviousSibling);
    };
    ChildNodeImpl2.prototype.after = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      var context = util_1.Cast.asNode(this);
      var parent = context._parent;
      if (!parent)
        return;
      var viableNextSibling = context._nextSibling;
      var flag = true;
      while (flag && viableNextSibling) {
        flag = false;
        for (var i = 0;i < nodes.length; i++) {
          var child = nodes[i];
          if (child === viableNextSibling) {
            viableNextSibling = viableNextSibling._nextSibling;
            flag = true;
            break;
          }
        }
      }
      var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
      algorithm_1.mutation_preInsert(node, parent, viableNextSibling);
    };
    ChildNodeImpl2.prototype.replaceWith = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      var context = util_1.Cast.asNode(this);
      var parent = context._parent;
      if (!parent)
        return;
      var viableNextSibling = context._nextSibling;
      var flag = true;
      while (flag && viableNextSibling) {
        flag = false;
        for (var i = 0;i < nodes.length; i++) {
          var child = nodes[i];
          if (child === viableNextSibling) {
            viableNextSibling = viableNextSibling._nextSibling;
            flag = true;
            break;
          }
        }
      }
      var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
      if (context._parent === parent)
        algorithm_1.mutation_replace(context, node, parent);
      else
        algorithm_1.mutation_preInsert(node, parent, viableNextSibling);
    };
    ChildNodeImpl2.prototype.remove = function() {
      var context = util_1.Cast.asNode(this);
      var parent = context._parent;
      if (!parent)
        return;
      algorithm_1.mutation_remove(context, parent);
    };
    return ChildNodeImpl2;
  }();
  exports.ChildNodeImpl = ChildNodeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/DocumentOrShadowRootImpl.js
var require_DocumentOrShadowRootImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DocumentOrShadowRootImpl = function() {
    function DocumentOrShadowRootImpl2() {
    }
    return DocumentOrShadowRootImpl2;
  }();
  exports.DocumentOrShadowRootImpl = DocumentOrShadowRootImpl;
});

// node_modules/@oozcitak/dom/lib/dom/MutationObserverImpl.js
var require_MutationObserverImpl = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMImpl_1 = require_DOMImpl();
  var util_1 = require_util2();
  var infra_1 = require_lib10();
  var MutationObserverImpl = function() {
    function MutationObserverImpl2(callback) {
      this._nodeList = [];
      this._recordQueue = [];
      this._callback = callback;
      var window2 = DOMImpl_1.dom.window;
      infra_1.set.append(window2._mutationObservers, this);
    }
    MutationObserverImpl2.prototype.observe = function(target, options) {
      var e_1, _a;
      options = options || {
        childList: false,
        subtree: false
      };
      if ((options.attributeOldValue !== undefined || options.attributeFilter !== undefined) && options.attributes === undefined) {
        options.attributes = true;
      }
      if (options.characterDataOldValue !== undefined && options.characterData === undefined) {
        options.characterData = true;
      }
      if (!options.childList && !options.attributes && !options.characterData) {
        throw new TypeError;
      }
      if (options.attributeOldValue && !options.attributes) {
        throw new TypeError;
      }
      if (options.attributeFilter !== undefined && !options.attributes) {
        throw new TypeError;
      }
      if (options.characterDataOldValue && !options.characterData) {
        throw new TypeError;
      }
      var isRegistered = false;
      var coptions = options;
      var _loop_1 = function(registered2) {
        var e_2, _a2;
        if (registered2.observer === this_1) {
          isRegistered = true;
          try {
            for (var _b2 = (e_2 = undefined, __values(this_1._nodeList)), _c2 = _b2.next();!_c2.done; _c2 = _b2.next()) {
              var node = _c2.value;
              infra_1.list.remove(node._registeredObserverList, function(ob) {
                return util_1.Guard.isTransientRegisteredObserver(ob) && ob.source === registered2;
              });
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_c2 && !_c2.done && (_a2 = _b2.return))
                _a2.call(_b2);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          registered2.options = coptions;
        }
      };
      var this_1 = this;
      try {
        for (var _b = __values(target._registeredObserverList), _c = _b.next();!_c.done; _c = _b.next()) {
          var registered = _c.value;
          _loop_1(registered);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (!isRegistered) {
        target._registeredObserverList.push({ observer: this, options });
        this._nodeList.push(target);
      }
    };
    MutationObserverImpl2.prototype.disconnect = function() {
      var e_3, _a;
      var _this = this;
      try {
        for (var _b = __values(this._nodeList), _c = _b.next();!_c.done; _c = _b.next()) {
          var node = _c.value;
          infra_1.list.remove(node._registeredObserverList, function(ob) {
            return ob.observer === _this;
          });
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      this._recordQueue = [];
    };
    MutationObserverImpl2.prototype.takeRecords = function() {
      var records = this._recordQueue;
      this._recordQueue = [];
      return records;
    };
    return MutationObserverImpl2;
  }();
  exports.MutationObserverImpl = MutationObserverImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NonDocumentTypeChildNodeImpl.js
var require_NonDocumentTypeChildNodeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var NonDocumentTypeChildNodeImpl = function() {
    function NonDocumentTypeChildNodeImpl2() {
    }
    Object.defineProperty(NonDocumentTypeChildNodeImpl2.prototype, "previousElementSibling", {
      get: function() {
        var node = util_1.Cast.asNode(this)._previousSibling;
        while (node) {
          if (util_1.Guard.isElementNode(node))
            return node;
          else
            node = node._previousSibling;
        }
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NonDocumentTypeChildNodeImpl2.prototype, "nextElementSibling", {
      get: function() {
        var node = util_1.Cast.asNode(this)._nextSibling;
        while (node) {
          if (util_1.Guard.isElementNode(node))
            return node;
          else
            node = node._nextSibling;
        }
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return NonDocumentTypeChildNodeImpl2;
  }();
  exports.NonDocumentTypeChildNodeImpl = NonDocumentTypeChildNodeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/NonElementParentNodeImpl.js
var require_NonElementParentNodeImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var algorithm_1 = require_algorithm();
  var NonElementParentNodeImpl = function() {
    function NonElementParentNodeImpl2() {
    }
    NonElementParentNodeImpl2.prototype.getElementById = function(id) {
      var ele = algorithm_1.tree_getFirstDescendantNode(util_1.Cast.asNode(this), false, false, function(e) {
        return util_1.Guard.isElementNode(e);
      });
      while (ele !== null) {
        if (ele._uniqueIdentifier === id) {
          return ele;
        }
        ele = algorithm_1.tree_getNextDescendantNode(util_1.Cast.asNode(this), ele, false, false, function(e) {
          return util_1.Guard.isElementNode(e);
        });
      }
      return null;
    };
    return NonElementParentNodeImpl2;
  }();
  exports.NonElementParentNodeImpl = NonElementParentNodeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/ParentNodeImpl.js
var require_ParentNodeImpl = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var algorithm_1 = require_algorithm();
  var ParentNodeImpl = function() {
    function ParentNodeImpl2() {
    }
    Object.defineProperty(ParentNodeImpl2.prototype, "children", {
      get: function() {
        return algorithm_1.create_htmlCollection(util_1.Cast.asNode(this));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ParentNodeImpl2.prototype, "firstElementChild", {
      get: function() {
        var node = util_1.Cast.asNode(this)._firstChild;
        while (node) {
          if (util_1.Guard.isElementNode(node))
            return node;
          else
            node = node._nextSibling;
        }
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ParentNodeImpl2.prototype, "lastElementChild", {
      get: function() {
        var node = util_1.Cast.asNode(this)._lastChild;
        while (node) {
          if (util_1.Guard.isElementNode(node))
            return node;
          else
            node = node._previousSibling;
        }
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ParentNodeImpl2.prototype, "childElementCount", {
      get: function() {
        var e_1, _a;
        var count = 0;
        try {
          for (var _b = __values(util_1.Cast.asNode(this)._children), _c = _b.next();!_c.done; _c = _b.next()) {
            var childNode = _c.value;
            if (util_1.Guard.isElementNode(childNode))
              count++;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return count;
      },
      enumerable: true,
      configurable: true
    });
    ParentNodeImpl2.prototype.prepend = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      var node = util_1.Cast.asNode(this);
      var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);
      algorithm_1.mutation_preInsert(childNode, node, node._firstChild);
    };
    ParentNodeImpl2.prototype.append = function() {
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      var node = util_1.Cast.asNode(this);
      var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);
      algorithm_1.mutation_append(childNode, node);
    };
    ParentNodeImpl2.prototype.querySelector = function(selectors) {
      var node = util_1.Cast.asNode(this);
      var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);
      return result.length === 0 ? null : result[0];
    };
    ParentNodeImpl2.prototype.querySelectorAll = function(selectors) {
      var node = util_1.Cast.asNode(this);
      var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);
      return algorithm_1.create_nodeListStatic(node, result);
    };
    return ParentNodeImpl2;
  }();
  exports.ParentNodeImpl = ParentNodeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/SlotableImpl.js
var require_SlotableImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var algorithm_1 = require_algorithm();
  var SlotableImpl = function() {
    function SlotableImpl2() {
    }
    Object.defineProperty(SlotableImpl2.prototype, "_name", {
      get: function() {
        return this.__name || "";
      },
      set: function(val) {
        this.__name = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SlotableImpl2.prototype, "_assignedSlot", {
      get: function() {
        return this.__assignedSlot || null;
      },
      set: function(val) {
        this.__assignedSlot = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SlotableImpl2.prototype, "assignedSlot", {
      get: function() {
        return algorithm_1.shadowTree_findASlot(this, true);
      },
      enumerable: true,
      configurable: true
    });
    return SlotableImpl2;
  }();
  exports.SlotableImpl = SlotableImpl;
});

// node_modules/@oozcitak/dom/lib/dom/StaticRangeImpl.js
var require_StaticRangeImpl = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var AbstractRangeImpl_1 = require_AbstractRangeImpl();
  var DOMException_1 = require_DOMException();
  var util_1 = require_util2();
  var StaticRangeImpl = function(_super) {
    __extends(StaticRangeImpl2, _super);
    function StaticRangeImpl2(init) {
      var _this = _super.call(this) || this;
      if (util_1.Guard.isDocumentTypeNode(init.startContainer) || util_1.Guard.isAttrNode(init.startContainer) || util_1.Guard.isDocumentTypeNode(init.endContainer) || util_1.Guard.isAttrNode(init.endContainer)) {
        throw new DOMException_1.InvalidNodeTypeError;
      }
      _this._start = [init.startContainer, init.startOffset];
      _this._end = [init.endContainer, init.endOffset];
      return _this;
    }
    return StaticRangeImpl2;
  }(AbstractRangeImpl_1.AbstractRangeImpl);
  exports.StaticRangeImpl = StaticRangeImpl;
});

// node_modules/@oozcitak/dom/lib/dom/index.js
var require_dom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_lib8();
  var AbortControllerImpl_1 = require_AbortControllerImpl();
  exports.AbortController = AbortControllerImpl_1.AbortControllerImpl;
  var AbortSignalImpl_1 = require_AbortSignalImpl();
  exports.AbortSignal = AbortSignalImpl_1.AbortSignalImpl;
  var AbstractRangeImpl_1 = require_AbstractRangeImpl();
  exports.AbstractRange = AbstractRangeImpl_1.AbstractRangeImpl;
  var AttrImpl_1 = require_AttrImpl();
  exports.Attr = AttrImpl_1.AttrImpl;
  var CDATASectionImpl_1 = require_CDATASectionImpl();
  exports.CDATASection = CDATASectionImpl_1.CDATASectionImpl;
  var CharacterDataImpl_1 = require_CharacterDataImpl();
  exports.CharacterData = CharacterDataImpl_1.CharacterDataImpl;
  var ChildNodeImpl_1 = require_ChildNodeImpl();
  var CommentImpl_1 = require_CommentImpl();
  exports.Comment = CommentImpl_1.CommentImpl;
  var CustomEventImpl_1 = require_CustomEventImpl();
  exports.CustomEvent = CustomEventImpl_1.CustomEventImpl;
  var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
  exports.DocumentFragment = DocumentFragmentImpl_1.DocumentFragmentImpl;
  var DocumentImpl_1 = require_DocumentImpl();
  exports.Document = DocumentImpl_1.DocumentImpl;
  var DocumentOrShadowRootImpl_1 = require_DocumentOrShadowRootImpl();
  var DocumentTypeImpl_1 = require_DocumentTypeImpl();
  exports.DocumentType = DocumentTypeImpl_1.DocumentTypeImpl;
  var DOMImpl_1 = require_DOMImpl();
  exports.dom = DOMImpl_1.dom;
  var DOMImplementationImpl_1 = require_DOMImplementationImpl();
  exports.DOMImplementation = DOMImplementationImpl_1.DOMImplementationImpl;
  var DOMTokenListImpl_1 = require_DOMTokenListImpl();
  exports.DOMTokenList = DOMTokenListImpl_1.DOMTokenListImpl;
  var ElementImpl_1 = require_ElementImpl();
  exports.Element = ElementImpl_1.ElementImpl;
  var EventImpl_1 = require_EventImpl();
  exports.Event = EventImpl_1.EventImpl;
  var EventTargetImpl_1 = require_EventTargetImpl();
  exports.EventTarget = EventTargetImpl_1.EventTargetImpl;
  var HTMLCollectionImpl_1 = require_HTMLCollectionImpl();
  exports.HTMLCollection = HTMLCollectionImpl_1.HTMLCollectionImpl;
  var MutationObserverImpl_1 = require_MutationObserverImpl();
  exports.MutationObserver = MutationObserverImpl_1.MutationObserverImpl;
  var MutationRecordImpl_1 = require_MutationRecordImpl();
  exports.MutationRecord = MutationRecordImpl_1.MutationRecordImpl;
  var NamedNodeMapImpl_1 = require_NamedNodeMapImpl();
  exports.NamedNodeMap = NamedNodeMapImpl_1.NamedNodeMapImpl;
  var NodeFilterImpl_1 = require_NodeFilterImpl();
  exports.NodeFilter = NodeFilterImpl_1.NodeFilterImpl;
  var NodeImpl_1 = require_NodeImpl();
  exports.Node = NodeImpl_1.NodeImpl;
  var NodeIteratorImpl_1 = require_NodeIteratorImpl();
  exports.NodeIterator = NodeIteratorImpl_1.NodeIteratorImpl;
  var NodeListImpl_1 = require_NodeListImpl();
  exports.NodeList = NodeListImpl_1.NodeListImpl;
  var NodeListStaticImpl_1 = require_NodeListStaticImpl();
  exports.NodeListStatic = NodeListStaticImpl_1.NodeListStaticImpl;
  var NonDocumentTypeChildNodeImpl_1 = require_NonDocumentTypeChildNodeImpl();
  var NonElementParentNodeImpl_1 = require_NonElementParentNodeImpl();
  var ParentNodeImpl_1 = require_ParentNodeImpl();
  var ProcessingInstructionImpl_1 = require_ProcessingInstructionImpl();
  exports.ProcessingInstruction = ProcessingInstructionImpl_1.ProcessingInstructionImpl;
  var RangeImpl_1 = require_RangeImpl();
  exports.Range = RangeImpl_1.RangeImpl;
  var ShadowRootImpl_1 = require_ShadowRootImpl();
  exports.ShadowRoot = ShadowRootImpl_1.ShadowRootImpl;
  var SlotableImpl_1 = require_SlotableImpl();
  var StaticRangeImpl_1 = require_StaticRangeImpl();
  exports.StaticRange = StaticRangeImpl_1.StaticRangeImpl;
  var TextImpl_1 = require_TextImpl();
  exports.Text = TextImpl_1.TextImpl;
  var TraverserImpl_1 = require_TraverserImpl();
  exports.Traverser = TraverserImpl_1.TraverserImpl;
  var TreeWalkerImpl_1 = require_TreeWalkerImpl();
  exports.TreeWalker = TreeWalkerImpl_1.TreeWalkerImpl;
  var WindowImpl_1 = require_WindowImpl();
  exports.Window = WindowImpl_1.WindowImpl;
  var XMLDocumentImpl_1 = require_XMLDocumentImpl();
  exports.XMLDocument = XMLDocumentImpl_1.XMLDocumentImpl;
  util_1.applyMixin(ElementImpl_1.ElementImpl, ChildNodeImpl_1.ChildNodeImpl);
  util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, ChildNodeImpl_1.ChildNodeImpl);
  util_1.applyMixin(DocumentTypeImpl_1.DocumentTypeImpl, ChildNodeImpl_1.ChildNodeImpl);
  util_1.applyMixin(DocumentImpl_1.DocumentImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
  util_1.applyMixin(ShadowRootImpl_1.ShadowRootImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
  util_1.applyMixin(ElementImpl_1.ElementImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
  util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
  util_1.applyMixin(DocumentImpl_1.DocumentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
  util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
  util_1.applyMixin(DocumentImpl_1.DocumentImpl, ParentNodeImpl_1.ParentNodeImpl);
  util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, ParentNodeImpl_1.ParentNodeImpl);
  util_1.applyMixin(ElementImpl_1.ElementImpl, ParentNodeImpl_1.ParentNodeImpl);
  util_1.applyMixin(TextImpl_1.TextImpl, SlotableImpl_1.SlotableImpl);
  util_1.applyMixin(ElementImpl_1.ElementImpl, SlotableImpl_1.SlotableImpl);
});

// node_modules/@oozcitak/dom/lib/parser/interfaces.js
var require_interfaces4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var TokenType;
  (function(TokenType2) {
    TokenType2[TokenType2["EOF"] = 0] = "EOF";
    TokenType2[TokenType2["Declaration"] = 1] = "Declaration";
    TokenType2[TokenType2["DocType"] = 2] = "DocType";
    TokenType2[TokenType2["Element"] = 3] = "Element";
    TokenType2[TokenType2["Text"] = 4] = "Text";
    TokenType2[TokenType2["CDATA"] = 5] = "CDATA";
    TokenType2[TokenType2["PI"] = 6] = "PI";
    TokenType2[TokenType2["Comment"] = 7] = "Comment";
    TokenType2[TokenType2["ClosingTag"] = 8] = "ClosingTag";
  })(TokenType = exports.TokenType || (exports.TokenType = {}));
});

// node_modules/@oozcitak/dom/lib/parser/XMLStringLexer.js
var require_XMLStringLexer = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces4();
  var XMLStringLexer = function() {
    function XMLStringLexer2(str, options) {
      this._options = {
        skipWhitespaceOnlyText: false
      };
      this.err = { line: -1, col: -1, index: -1, str: "" };
      this._str = str;
      this._index = 0;
      this._length = str.length;
      if (options) {
        this._options.skipWhitespaceOnlyText = options.skipWhitespaceOnlyText || false;
      }
    }
    XMLStringLexer2.prototype.nextToken = function() {
      if (this.eof()) {
        return { type: interfaces_1.TokenType.EOF };
      }
      var token = this.skipIfStartsWith("<") ? this.openBracket() : this.text();
      if (this._options.skipWhitespaceOnlyText) {
        if (token.type === interfaces_1.TokenType.Text && XMLStringLexer2.isWhiteSpaceToken(token)) {
          token = this.nextToken();
        }
      }
      return token;
    };
    XMLStringLexer2.prototype.openBracket = function() {
      if (this.skipIfStartsWith("?")) {
        if (this.skipIfStartsWith("xml")) {
          if (XMLStringLexer2.isSpace(this._str[this._index])) {
            return this.declaration();
          } else {
            this.seek(-3);
            return this.pi();
          }
        } else {
          return this.pi();
        }
      } else if (this.skipIfStartsWith("!")) {
        if (this.skipIfStartsWith("--")) {
          return this.comment();
        } else if (this.skipIfStartsWith("[CDATA[")) {
          return this.cdata();
        } else if (this.skipIfStartsWith("DOCTYPE")) {
          return this.doctype();
        } else {
          this.throwError("Invalid '!' in opening tag.");
        }
      } else if (this.skipIfStartsWith("/")) {
        return this.closeTag();
      } else {
        return this.openTag();
      }
    };
    XMLStringLexer2.prototype.declaration = function() {
      var version = "";
      var encoding = "";
      var standalone = "";
      while (!this.eof()) {
        this.skipSpace();
        if (this.skipIfStartsWith("?>")) {
          return { type: interfaces_1.TokenType.Declaration, version, encoding, standalone };
        } else {
          var _a = __read(this.attribute(), 2), attName = _a[0], attValue = _a[1];
          if (attName === "version")
            version = attValue;
          else if (attName === "encoding")
            encoding = attValue;
          else if (attName === "standalone")
            standalone = attValue;
          else
            this.throwError("Invalid attribute name: " + attName);
        }
      }
      this.throwError("Missing declaration end symbol `?>`");
    };
    XMLStringLexer2.prototype.doctype = function() {
      var pubId = "";
      var sysId = "";
      this.skipSpace();
      var name = this.takeUntil2("[", ">", true);
      this.skipSpace();
      if (this.skipIfStartsWith("PUBLIC")) {
        pubId = this.quotedString();
        sysId = this.quotedString();
      } else if (this.skipIfStartsWith("SYSTEM")) {
        sysId = this.quotedString();
      }
      this.skipSpace();
      if (this.skipIfStartsWith("[")) {
        this.skipUntil("]");
        if (!this.skipIfStartsWith("]")) {
          this.throwError("Missing end bracket of DTD internal subset");
        }
      }
      this.skipSpace();
      if (!this.skipIfStartsWith(">")) {
        this.throwError("Missing doctype end symbol `>`");
      }
      return { type: interfaces_1.TokenType.DocType, name, pubId, sysId };
    };
    XMLStringLexer2.prototype.pi = function() {
      var target = this.takeUntilStartsWith("?>", true);
      if (this.eof()) {
        this.throwError("Missing processing instruction end symbol `?>`");
      }
      this.skipSpace();
      if (this.skipIfStartsWith("?>")) {
        return { type: interfaces_1.TokenType.PI, target, data: "" };
      }
      var data = this.takeUntilStartsWith("?>");
      if (this.eof()) {
        this.throwError("Missing processing instruction end symbol `?>`");
      }
      this.seek(2);
      return { type: interfaces_1.TokenType.PI, target, data };
    };
    XMLStringLexer2.prototype.text = function() {
      var data = this.takeUntil("<");
      return { type: interfaces_1.TokenType.Text, data };
    };
    XMLStringLexer2.prototype.comment = function() {
      var data = this.takeUntilStartsWith("-->");
      if (this.eof()) {
        this.throwError("Missing comment end symbol `-->`");
      }
      this.seek(3);
      return { type: interfaces_1.TokenType.Comment, data };
    };
    XMLStringLexer2.prototype.cdata = function() {
      var data = this.takeUntilStartsWith("]]>");
      if (this.eof()) {
        this.throwError("Missing CDATA end symbol `]>`");
      }
      this.seek(3);
      return { type: interfaces_1.TokenType.CDATA, data };
    };
    XMLStringLexer2.prototype.openTag = function() {
      this.skipSpace();
      var name = this.takeUntil2(">", "/", true);
      this.skipSpace();
      if (this.skipIfStartsWith(">")) {
        return { type: interfaces_1.TokenType.Element, name, attributes: [], selfClosing: false };
      } else if (this.skipIfStartsWith("/>")) {
        return { type: interfaces_1.TokenType.Element, name, attributes: [], selfClosing: true };
      }
      var attributes = [];
      while (!this.eof()) {
        this.skipSpace();
        if (this.skipIfStartsWith(">")) {
          return { type: interfaces_1.TokenType.Element, name, attributes, selfClosing: false };
        } else if (this.skipIfStartsWith("/>")) {
          return { type: interfaces_1.TokenType.Element, name, attributes, selfClosing: true };
        }
        var attr = this.attribute();
        attributes.push(attr);
      }
      this.throwError("Missing opening element tag end symbol `>`");
    };
    XMLStringLexer2.prototype.closeTag = function() {
      this.skipSpace();
      var name = this.takeUntil(">", true);
      this.skipSpace();
      if (!this.skipIfStartsWith(">")) {
        this.throwError("Missing closing element tag end symbol `>`");
      }
      return { type: interfaces_1.TokenType.ClosingTag, name };
    };
    XMLStringLexer2.prototype.attribute = function() {
      this.skipSpace();
      var name = this.takeUntil("=", true);
      this.skipSpace();
      if (!this.skipIfStartsWith("=")) {
        this.throwError("Missing equals sign before attribute value");
      }
      var value = this.quotedString();
      return [name, value];
    };
    XMLStringLexer2.prototype.quotedString = function() {
      this.skipSpace();
      var startQuote = this.take(1);
      if (!XMLStringLexer2.isQuote(startQuote)) {
        this.throwError("Missing start quote character before quoted value");
      }
      var value = this.takeUntil(startQuote);
      if (!this.skipIfStartsWith(startQuote)) {
        this.throwError("Missing end quote character after quoted value");
      }
      return value;
    };
    XMLStringLexer2.prototype.eof = function() {
      return this._index >= this._length;
    };
    XMLStringLexer2.prototype.skipIfStartsWith = function(str) {
      var strLength = str.length;
      if (strLength === 1) {
        if (this._str[this._index] === str) {
          this._index++;
          return true;
        } else {
          return false;
        }
      }
      for (var i = 0;i < strLength; i++) {
        if (this._str[this._index + i] !== str[i])
          return false;
      }
      this._index += strLength;
      return true;
    };
    XMLStringLexer2.prototype.seek = function(count) {
      this._index += count;
      if (this._index < 0)
        this._index = 0;
      if (this._index > this._length)
        this._index = this._length;
    };
    XMLStringLexer2.prototype.skipSpace = function() {
      while (!this.eof() && XMLStringLexer2.isSpace(this._str[this._index])) {
        this._index++;
      }
    };
    XMLStringLexer2.prototype.take = function(count) {
      if (count === 1) {
        return this._str[this._index++];
      }
      var startIndex = this._index;
      this.seek(count);
      return this._str.slice(startIndex, this._index);
    };
    XMLStringLexer2.prototype.takeUntil = function(char, space) {
      if (space === undefined) {
        space = false;
      }
      var startIndex = this._index;
      while (this._index < this._length) {
        var c = this._str[this._index];
        if (c !== char && (!space || !XMLStringLexer2.isSpace(c))) {
          this._index++;
        } else {
          break;
        }
      }
      return this._str.slice(startIndex, this._index);
    };
    XMLStringLexer2.prototype.takeUntil2 = function(char1, char2, space) {
      if (space === undefined) {
        space = false;
      }
      var startIndex = this._index;
      while (this._index < this._length) {
        var c = this._str[this._index];
        if (c !== char1 && c !== char2 && (!space || !XMLStringLexer2.isSpace(c))) {
          this._index++;
        } else {
          break;
        }
      }
      return this._str.slice(startIndex, this._index);
    };
    XMLStringLexer2.prototype.takeUntilStartsWith = function(str, space) {
      if (space === undefined) {
        space = false;
      }
      var startIndex = this._index;
      var strLength = str.length;
      while (this._index < this._length) {
        var match = true;
        for (var i = 0;i < strLength; i++) {
          var c = this._str[this._index + i];
          var char = str[i];
          if (space && XMLStringLexer2.isSpace(c)) {
            return this._str.slice(startIndex, this._index);
          } else if (c !== char) {
            this._index++;
            match = false;
            break;
          }
        }
        if (match)
          return this._str.slice(startIndex, this._index);
      }
      this._index = this._length;
      return this._str.slice(startIndex);
    };
    XMLStringLexer2.prototype.skipUntil = function(char) {
      while (this._index < this._length) {
        var c = this._str[this._index];
        if (c !== char) {
          this._index++;
        } else {
          break;
        }
      }
    };
    XMLStringLexer2.isWhiteSpaceToken = function(token) {
      var str = token.data;
      for (var i = 0;i < str.length; i++) {
        var c = str[i];
        if (c !== " " && c !== `
` && c !== "\r" && c !== "\t" && c !== "\f")
          return false;
      }
      return true;
    };
    XMLStringLexer2.isSpace = function(char) {
      return char === " " || char === `
` || char === "\r" || char === "\t";
    };
    XMLStringLexer2.isQuote = function(char) {
      return char === '"' || char === "'";
    };
    XMLStringLexer2.prototype.throwError = function(msg) {
      var regexp = /\r\n|\r|\n/g;
      var match = null;
      var line = 0;
      var firstNewLineIndex = 0;
      var lastNewlineIndex = this._str.length;
      while ((match = regexp.exec(this._str)) !== null) {
        if (match === null)
          break;
        line++;
        if (match.index < this._index)
          firstNewLineIndex = regexp.lastIndex;
        if (match.index > this._index) {
          lastNewlineIndex = match.index;
          break;
        }
      }
      this.err = {
        line,
        col: this._index - firstNewLineIndex,
        index: this._index,
        str: this._str.substring(firstNewLineIndex, lastNewlineIndex)
      };
      throw new Error(msg + `
Index: ` + this.err.index + `
Ln: ` + this.err.line + ", Col: " + this.err.col + `
Input: ` + this.err.str);
    };
    XMLStringLexer2.prototype[Symbol.iterator] = function() {
      this._index = 0;
      return {
        next: function() {
          var token = this.nextToken();
          if (token.type === interfaces_1.TokenType.EOF) {
            return { done: true, value: null };
          } else {
            return { done: false, value: token };
          }
        }.bind(this)
      };
    };
    return XMLStringLexer2;
  }();
  exports.XMLStringLexer = XMLStringLexer;
});

// node_modules/@oozcitak/dom/lib/parser/XMLParserImpl.js
var require_XMLParserImpl = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XMLStringLexer_1 = require_XMLStringLexer();
  var interfaces_1 = require_interfaces4();
  var infra_1 = require_lib10();
  var algorithm_1 = require_algorithm();
  var LocalNameSet_1 = require_LocalNameSet();
  var XMLParserImpl = function() {
    function XMLParserImpl2() {
    }
    XMLParserImpl2.prototype.parse = function(source) {
      var e_1, _a, e_2, _b;
      var lexer = new XMLStringLexer_1.XMLStringLexer(source, { skipWhitespaceOnlyText: true });
      var doc = algorithm_1.create_document();
      var context = doc;
      var token = lexer.nextToken();
      while (token.type !== interfaces_1.TokenType.EOF) {
        switch (token.type) {
          case interfaces_1.TokenType.Declaration:
            var declaration = token;
            if (declaration.version !== "1.0") {
              throw new Error("Invalid xml version: " + declaration.version);
            }
            break;
          case interfaces_1.TokenType.DocType:
            var doctype = token;
            if (!algorithm_1.xml_isPubidChar(doctype.pubId)) {
              throw new Error("DocType public identifier does not match PubidChar construct.");
            }
            if (!algorithm_1.xml_isLegalChar(doctype.sysId) || doctype.sysId.indexOf('"') !== -1 && doctype.sysId.indexOf("'") !== -1) {
              throw new Error("DocType system identifier contains invalid characters.");
            }
            context.appendChild(doc.implementation.createDocumentType(doctype.name, doctype.pubId, doctype.sysId));
            break;
          case interfaces_1.TokenType.CDATA:
            var cdata = token;
            if (!algorithm_1.xml_isLegalChar(cdata.data) || cdata.data.indexOf("]]>") !== -1) {
              throw new Error("CDATA contains invalid characters.");
            }
            context.appendChild(doc.createCDATASection(cdata.data));
            break;
          case interfaces_1.TokenType.Comment:
            var comment = token;
            if (!algorithm_1.xml_isLegalChar(comment.data) || comment.data.indexOf("--") !== -1 || comment.data.endsWith("-")) {
              throw new Error("Comment data contains invalid characters.");
            }
            context.appendChild(doc.createComment(comment.data));
            break;
          case interfaces_1.TokenType.PI:
            var pi = token;
            if (pi.target.indexOf(":") !== -1 || /^xml$/i.test(pi.target)) {
              throw new Error("Processing instruction target contains invalid characters.");
            }
            if (!algorithm_1.xml_isLegalChar(pi.data) || pi.data.indexOf("?>") !== -1) {
              throw new Error("Processing instruction data contains invalid characters.");
            }
            context.appendChild(doc.createProcessingInstruction(pi.target, pi.data));
            break;
          case interfaces_1.TokenType.Text:
            var text = token;
            if (!algorithm_1.xml_isLegalChar(text.data)) {
              throw new Error("Text data contains invalid characters.");
            }
            context.appendChild(doc.createTextNode(this._decodeText(text.data)));
            break;
          case interfaces_1.TokenType.Element:
            var element = token;
            var _c = __read(algorithm_1.namespace_extractQName(element.name), 2), prefix = _c[0], localName = _c[1];
            if (localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(localName)) {
              throw new Error("Node local name contains invalid characters.");
            }
            if (prefix === "xmlns") {
              throw new Error("An element cannot have the 'xmlns' prefix.");
            }
            var namespace = context.lookupNamespaceURI(prefix);
            var nsDeclarations = {};
            try {
              for (var _d = (e_1 = undefined, __values(element.attributes)), _e = _d.next();!_e.done; _e = _d.next()) {
                var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];
                if (attName === "xmlns") {
                  namespace = attValue;
                } else {
                  var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];
                  if (attPrefix === "xmlns") {
                    if (attLocalName === prefix) {
                      namespace = attValue;
                    }
                    nsDeclarations[attLocalName] = attValue;
                  }
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_e && !_e.done && (_a = _d.return))
                  _a.call(_d);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            var elementNode = namespace !== null ? doc.createElementNS(namespace, element.name) : doc.createElement(element.name);
            context.appendChild(elementNode);
            var localNameSet = new LocalNameSet_1.LocalNameSet;
            try {
              for (var _h = (e_2 = undefined, __values(element.attributes)), _j = _h.next();!_j.done; _j = _h.next()) {
                var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];
                var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];
                var attNamespace = null;
                if (attPrefix === "xmlns" || attPrefix === null && attLocalName === "xmlns") {
                  attNamespace = infra_1.namespace.XMLNS;
                } else {
                  attNamespace = elementNode.lookupNamespaceURI(attPrefix);
                  if (attNamespace !== null && elementNode.isDefaultNamespace(attNamespace)) {
                    attNamespace = null;
                  } else if (attNamespace === null && attPrefix !== null) {
                    attNamespace = nsDeclarations[attPrefix] || null;
                  }
                }
                if (localNameSet.has(attNamespace, attLocalName)) {
                  throw new Error("Element contains duplicate attributes.");
                }
                localNameSet.set(attNamespace, attLocalName);
                if (attNamespace === infra_1.namespace.XMLNS) {
                  if (attValue === infra_1.namespace.XMLNS) {
                    throw new Error("XMLNS namespace is reserved.");
                  }
                }
                if (attLocalName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attLocalName)) {
                  throw new Error("Attribute local name contains invalid characters.");
                }
                if (attPrefix === "xmlns" && attValue === "") {
                  throw new Error("Empty XML namespace is not allowed.");
                }
                if (attNamespace !== null)
                  elementNode.setAttributeNS(attNamespace, attName, this._decodeAttributeValue(attValue));
                else
                  elementNode.setAttribute(attName, this._decodeAttributeValue(attValue));
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_j && !_j.done && (_b = _h.return))
                  _b.call(_h);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
            if (!element.selfClosing) {
              context = elementNode;
            }
            break;
          case interfaces_1.TokenType.ClosingTag:
            var closingTag = token;
            if (closingTag.name !== context.nodeName) {
              throw new Error("Closing tag name does not match opening tag name.");
            }
            if (context._parent) {
              context = context._parent;
            }
            break;
        }
        token = lexer.nextToken();
      }
      return doc;
    };
    XMLParserImpl2.prototype._decodeText = function(text) {
      return text == null ? text : text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
    };
    XMLParserImpl2.prototype._decodeAttributeValue = function(text) {
      return text == null ? text : text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
    };
    return XMLParserImpl2;
  }();
  exports.XMLParserImpl = XMLParserImpl;
});

// node_modules/@oozcitak/dom/lib/parser/DOMParserImpl.js
var require_DOMParserImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var algorithm_1 = require_algorithm();
  var XMLParserImpl_1 = require_XMLParserImpl();
  var DOMParserImpl = function() {
    function DOMParserImpl2() {
    }
    DOMParserImpl2.prototype.parseFromString = function(source, mimeType) {
      if (mimeType === "text/html")
        throw new Error("HTML parser not implemented.");
      try {
        var parser = new XMLParserImpl_1.XMLParserImpl;
        var doc = parser.parse(source);
        doc._contentType = mimeType;
        return doc;
      } catch (e) {
        var errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
        var doc = algorithm_1.create_xmlDocument();
        var root = doc.createElementNS(errorNS, "parsererror");
        var ele = doc.createElementNS(errorNS, "error");
        ele.setAttribute("message", e.message);
        root.appendChild(ele);
        doc.appendChild(root);
        return doc;
      }
    };
    return DOMParserImpl2;
  }();
  exports.DOMParserImpl = DOMParserImpl;
});

// node_modules/@oozcitak/dom/lib/parser/index.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DOMParserImpl_1 = require_DOMParserImpl();
  exports.DOMParser = DOMParserImpl_1.DOMParserImpl;
});

// node_modules/@oozcitak/dom/lib/serializer/XMLSerializerImpl.js
var require_XMLSerializerImpl = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces2();
  var LocalNameSet_1 = require_LocalNameSet();
  var NamespacePrefixMap_1 = require_NamespacePrefixMap();
  var DOMException_1 = require_DOMException();
  var infra_1 = require_lib10();
  var algorithm_1 = require_algorithm();
  var XMLSerializerImpl = function() {
    function XMLSerializerImpl2() {
    }
    XMLSerializerImpl2.prototype.serializeToString = function(root) {
      return this._xmlSerialization(root, false);
    };
    XMLSerializerImpl2.prototype._xmlSerialization = function(node, requireWellFormed) {
      if (node._nodeDocument === undefined || node._nodeDocument._hasNamespaces) {
        var namespace = null;
        var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap;
        prefixMap.set("xml", infra_1.namespace.XML);
        var prefixIndex = { value: 1 };
        try {
          return this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        } catch (_a) {
          throw new DOMException_1.InvalidStateError;
        }
      } else {
        try {
          return this._serializeNode(node, requireWellFormed);
        } catch (_b) {
          throw new DOMException_1.InvalidStateError;
        }
      }
    };
    XMLSerializerImpl2.prototype._serializeNodeNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      switch (node.nodeType) {
        case interfaces_1.NodeType.Element:
          return this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.Document:
          return this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.Comment:
          return this._serializeComment(node, requireWellFormed);
        case interfaces_1.NodeType.Text:
          return this._serializeText(node, requireWellFormed);
        case interfaces_1.NodeType.DocumentFragment:
          return this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.DocumentType:
          return this._serializeDocumentType(node, requireWellFormed);
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._serializeProcessingInstruction(node, requireWellFormed);
        case interfaces_1.NodeType.CData:
          return this._serializeCData(node, requireWellFormed);
        default:
          throw new Error("Unknown node type: " + node.nodeType);
      }
    };
    XMLSerializerImpl2.prototype._serializeNode = function(node, requireWellFormed) {
      switch (node.nodeType) {
        case interfaces_1.NodeType.Element:
          return this._serializeElement(node, requireWellFormed);
        case interfaces_1.NodeType.Document:
          return this._serializeDocument(node, requireWellFormed);
        case interfaces_1.NodeType.Comment:
          return this._serializeComment(node, requireWellFormed);
        case interfaces_1.NodeType.Text:
          return this._serializeText(node, requireWellFormed);
        case interfaces_1.NodeType.DocumentFragment:
          return this._serializeDocumentFragment(node, requireWellFormed);
        case interfaces_1.NodeType.DocumentType:
          return this._serializeDocumentType(node, requireWellFormed);
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._serializeProcessingInstruction(node, requireWellFormed);
        case interfaces_1.NodeType.CData:
          return this._serializeCData(node, requireWellFormed);
        default:
          throw new Error("Unknown node type: " + node.nodeType);
      }
    };
    XMLSerializerImpl2.prototype._serializeElementNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      var e_1, _a;
      if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      var markup = "<";
      var qualifiedName = "";
      var skipEndTag = false;
      var ignoreNamespaceDefinitionAttribute = false;
      var map = prefixMap.copy();
      var localPrefixesMap = {};
      var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
      var inheritedNS = namespace;
      var ns = node.namespaceURI;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node.localName;
        } else {
          qualifiedName = node.localName;
        }
        markup += qualifiedName;
      } else {
        var prefix = node.prefix;
        var candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (requireWellFormed) {
            throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          markup += qualifiedName;
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map, prefixIndex);
          }
          map.set(prefix, ns);
          qualifiedName += prefix + ":" + node.localName;
          markup += qualifiedName;
          markup += " xmlns:" + prefix + '="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node.localName;
          inheritedNS = ns;
          markup += qualifiedName;
          markup += " xmlns" + '="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
        } else {
          qualifiedName += node.localName;
          inheritedNS = ns;
          markup += qualifiedName;
        }
      }
      markup += this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed);
      var isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && node.childNodes.length === 0 && XMLSerializerImpl2._VoidElementNames.has(node.localName)) {
        markup += " /";
        skipEndTag = true;
      } else if (!isHTML && node.childNodes.length === 0) {
        markup += "/";
        skipEndTag = true;
      }
      markup += ">";
      if (skipEndTag)
        return markup;
      if (isHTML && node.localName === "template") {
      } else {
        try {
          for (var _b = __values(node._children || node.childNodes), _c = _b.next();!_c.done; _c = _b.next()) {
            var childNode = _c.value;
            markup += this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      markup += "</" + qualifiedName + ">";
      return markup;
    };
    XMLSerializerImpl2.prototype._serializeDocumentNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      var e_2, _a;
      if (requireWellFormed && node.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      var serializedDocument = "";
      try {
        for (var _b = __values(node._children || node.childNodes), _c = _b.next();!_c.done; _c = _b.next()) {
          var childNode = _c.value;
          serializedDocument += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return serializedDocument;
    };
    XMLSerializerImpl2.prototype._serializeComment = function(node, requireWellFormed) {
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
        throw new Error("Comment data contains invalid characters (well-formed required).");
      }
      return "<!--" + node.data + "-->";
    };
    XMLSerializerImpl2.prototype._serializeText = function(node, requireWellFormed) {
      if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
        throw new Error("Text data contains invalid characters (well-formed required).");
      }
      var result = "";
      for (var i = 0;i < node.data.length; i++) {
        var c = node.data[i];
        if (c === "&")
          result += "&amp;";
        else if (c === "<")
          result += "&lt;";
        else if (c === ">")
          result += "&gt;";
        else
          result += c;
      }
      return result;
    };
    XMLSerializerImpl2.prototype._serializeDocumentFragmentNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
      var e_3, _a;
      var markup = "";
      try {
        for (var _b = __values(node._children || node.childNodes), _c = _b.next();!_c.done; _c = _b.next()) {
          var childNode = _c.value;
          markup += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return markup;
    };
    XMLSerializerImpl2.prototype._serializeDocumentType = function(node, requireWellFormed) {
      if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
        throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
      }
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
        throw new Error("DocType system identifier contains invalid characters (well-formed required).");
      }
      return node.publicId && node.systemId ? "<!DOCTYPE " + node.name + ' PUBLIC "' + node.publicId + '" "' + node.systemId + '">' : node.publicId ? "<!DOCTYPE " + node.name + ' PUBLIC "' + node.publicId + '">' : node.systemId ? "<!DOCTYPE " + node.name + ' SYSTEM "' + node.systemId + '">' : "<!DOCTYPE " + node.name + ">";
    };
    XMLSerializerImpl2.prototype._serializeProcessingInstruction = function(node, requireWellFormed) {
      if (requireWellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
        throw new Error("Processing instruction target contains invalid characters (well-formed required).");
      }
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("?>") !== -1)) {
        throw new Error("Processing instruction data contains invalid characters (well-formed required).");
      }
      return "<?" + (node.data === "" ? node.target : node.target + " " + node.data) + "?>";
    };
    XMLSerializerImpl2.prototype._serializeCData = function(node, requireWellFormed) {
      if (requireWellFormed && node.data.indexOf("]]>") !== -1) {
        throw new Error("CDATA contains invalid characters (well-formed required).");
      }
      return "<![CDATA[" + node.data + "]]>";
    };
    XMLSerializerImpl2.prototype._serializeAttributesNS = function(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
      var e_4, _a;
      var result = "";
      var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet : undefined;
      try {
        for (var _b = __values(node.attributes), _c = _b.next();!_c.done; _c = _b.next()) {
          var attr = _c.value;
          if (!ignoreNamespaceDefinitionAttribute && !requireWellFormed && attr.namespaceURI === null) {
            result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
            continue;
          }
          if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
            throw new Error("Element contains duplicate attributes (well-formed required).");
          }
          if (requireWellFormed && localNameSet)
            localNameSet.set(attr.namespaceURI, attr.localName);
          var attributeNamespace = attr.namespaceURI;
          var candidatePrefix = null;
          if (attributeNamespace !== null) {
            candidatePrefix = map.get(attr.prefix, attributeNamespace);
            if (attributeNamespace === infra_1.namespace.XMLNS) {
              if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
                continue;
              if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                throw new Error("XMLNS namespace is reserved (well-formed required).");
              }
              if (requireWellFormed && attr.value === "") {
                throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
              }
              if (attr.prefix === "xmlns")
                candidatePrefix = "xmlns";
            } else if (candidatePrefix === null) {
              if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
                candidatePrefix = attr.prefix;
              } else {
                candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
              }
              result += " xmlns:" + candidatePrefix + '="' + this._serializeAttributeValue(attributeNamespace, requireWellFormed) + '"';
            }
          }
          result += " ";
          if (candidatePrefix !== null) {
            result += candidatePrefix + ":";
          }
          if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
            throw new Error("Attribute local name contains invalid characters (well-formed required).");
          }
          result += attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return result;
    };
    XMLSerializerImpl2.prototype._recordNamespaceInformation = function(node, map, localPrefixesMap) {
      var e_5, _a;
      var defaultNamespaceAttrValue = null;
      try {
        for (var _b = __values(node.attributes), _c = _b.next();!_c.done; _c = _b.next()) {
          var attr = _c.value;
          var attributeNamespace = attr.namespaceURI;
          var attributePrefix = attr.prefix;
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attributePrefix === null) {
              defaultNamespaceAttrValue = attr.value;
              continue;
            } else {
              var prefixDefinition = attr.localName;
              var namespaceDefinition = attr.value;
              if (namespaceDefinition === infra_1.namespace.XML) {
                continue;
              }
              if (namespaceDefinition === "") {
                namespaceDefinition = null;
              }
              if (map.has(prefixDefinition, namespaceDefinition)) {
                continue;
              }
              map.set(prefixDefinition, namespaceDefinition);
              localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
            }
          }
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      return defaultNamespaceAttrValue;
    };
    XMLSerializerImpl2.prototype._generatePrefix = function(newNamespace, prefixMap, prefixIndex) {
      var generatedPrefix = "ns" + prefixIndex.value;
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    };
    XMLSerializerImpl2.prototype._serializeAttributeValue = function(value, requireWellFormed) {
      if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
        throw new Error("Invalid characters in attribute value.");
      }
      if (value === null)
        return "";
      var result = "";
      for (var i = 0;i < value.length; i++) {
        var c = value[i];
        if (c === '"')
          result += "&quot;";
        else if (c === "&")
          result += "&amp;";
        else if (c === "<")
          result += "&lt;";
        else if (c === ">")
          result += "&gt;";
        else
          result += c;
      }
      return result;
    };
    XMLSerializerImpl2.prototype._serializeElement = function(node, requireWellFormed) {
      var e_6, _a;
      if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      var skipEndTag = false;
      var qualifiedName = node.localName;
      var markup = "<" + qualifiedName;
      markup += this._serializeAttributes(node, requireWellFormed);
      if (node._children.size === 0) {
        markup += "/";
        skipEndTag = true;
      }
      markup += ">";
      if (skipEndTag)
        return markup;
      try {
        for (var _b = __values(node._children), _c = _b.next();!_c.done; _c = _b.next()) {
          var childNode = _c.value;
          markup += this._serializeNode(childNode, requireWellFormed);
        }
      } catch (e_6_1) {
        e_6 = { error: e_6_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_6)
            throw e_6.error;
        }
      }
      markup += "</" + qualifiedName + ">";
      return markup;
    };
    XMLSerializerImpl2.prototype._serializeDocument = function(node, requireWellFormed) {
      var e_7, _a;
      if (requireWellFormed && node.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      var serializedDocument = "";
      try {
        for (var _b = __values(node._children), _c = _b.next();!_c.done; _c = _b.next()) {
          var childNode = _c.value;
          serializedDocument += this._serializeNode(childNode, requireWellFormed);
        }
      } catch (e_7_1) {
        e_7 = { error: e_7_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_7)
            throw e_7.error;
        }
      }
      return serializedDocument;
    };
    XMLSerializerImpl2.prototype._serializeDocumentFragment = function(node, requireWellFormed) {
      var e_8, _a;
      var markup = "";
      try {
        for (var _b = __values(node._children), _c = _b.next();!_c.done; _c = _b.next()) {
          var childNode = _c.value;
          markup += this._serializeNode(childNode, requireWellFormed);
        }
      } catch (e_8_1) {
        e_8 = { error: e_8_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_8)
            throw e_8.error;
        }
      }
      return markup;
    };
    XMLSerializerImpl2.prototype._serializeAttributes = function(node, requireWellFormed) {
      var e_9, _a;
      var result = "";
      var localNameSet = requireWellFormed ? {} : undefined;
      try {
        for (var _b = __values(node.attributes), _c = _b.next();!_c.done; _c = _b.next()) {
          var attr = _c.value;
          if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
            throw new Error("Element contains duplicate attributes (well-formed required).");
          }
          if (requireWellFormed && localNameSet)
            localNameSet[attr.localName] = true;
          if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName))) {
            throw new Error("Attribute local name contains invalid characters (well-formed required).");
          }
          result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
        }
      } catch (e_9_1) {
        e_9 = { error: e_9_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_9)
            throw e_9.error;
        }
      }
      return result;
    };
    XMLSerializerImpl2._VoidElementNames = new Set([
      "area",
      "base",
      "basefont",
      "bgsound",
      "br",
      "col",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    return XMLSerializerImpl2;
  }();
  exports.XMLSerializerImpl = XMLSerializerImpl;
});

// node_modules/@oozcitak/dom/lib/serializer/index.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var XMLSerializerImpl_1 = require_XMLSerializerImpl();
  exports.XMLSerializer = XMLSerializerImpl_1.XMLSerializerImpl;
});

// node_modules/@oozcitak/dom/lib/index.js
var require_lib11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dom_1 = require_dom();
  dom_1.dom.setFeatures(true);
  var dom_2 = require_dom();
  exports.DOMImplementation = dom_2.DOMImplementation;
  var parser_1 = require_parser();
  exports.DOMParser = parser_1.DOMParser;
  var serializer_1 = require_serializer();
  exports.XMLSerializer = serializer_1.XMLSerializer;
});

// node_modules/xmlbuilder2/lib/builder/dom.js
var require_dom2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dom_1 = require_lib11();
  var dom_2 = require_dom();
  var util_1 = __require("util");
  dom_2.dom.setFeatures(false);
  function throwIfParserError(doc) {
    const root = doc.documentElement;
    if (root !== null && root.localName === "parsererror" && root.namespaceURI === "http://www.mozilla.org/newlayout/xml/parsererror.xml") {
      const msgElement = root.firstElementChild;
      if (msgElement === null)
        throw new Error("Error parsing XML string.");
      const msg = msgElement.getAttribute("message");
      if (msg === null)
        throw new Error("Error parsing XML string.");
      throw new Error(msg);
    }
  }
  exports.throwIfParserError = throwIfParserError;
  function createDocument() {
    const impl = new dom_1.DOMImplementation;
    const doc = impl.createDocument(null, "root", null);
    if (doc.documentElement) {
      doc.removeChild(doc.documentElement);
    }
    return doc;
  }
  exports.createDocument = createDocument;
  function createParser() {
    return new dom_1.DOMParser;
  }
  exports.createParser = createParser;
  function sanitizeInput(str, replacement) {
    if (str == null) {
      return str;
    } else if (replacement === undefined) {
      return str + "";
    } else {
      let result = "";
      str = str + "";
      for (let i = 0;i < str.length; i++) {
        let n = str.charCodeAt(i);
        if (n === 9 || n === 10 || n === 13 || n >= 32 && n <= 55295 || n >= 57344 && n <= 65533) {
          result += str.charAt(i);
        } else if (n >= 55296 && n <= 56319 && i < str.length - 1) {
          const n2 = str.charCodeAt(i + 1);
          if (n2 >= 56320 && n2 <= 57343) {
            n = (n - 55296) * 1024 + n2 - 56320 + 65536;
            if (n >= 65536 && n <= 1114111) {
              result += String.fromCodePoint(n);
            } else {
              result += util_1.isString(replacement) ? replacement : replacement(String.fromCodePoint(n), i, str);
            }
            i++;
          } else {
            result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
          }
        } else {
          result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
        }
      }
      return result;
    }
  }
  exports.sanitizeInput = sanitizeInput;
});

// node_modules/xmlbuilder2/lib/builder/XMLBuilderImpl.js
var require_XMLBuilderImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces();
  var util_1 = require_lib8();
  var writers_1 = require_writers();
  var interfaces_2 = require_interfaces2();
  var util_2 = require_util2();
  var algorithm_1 = require_algorithm();
  var dom_1 = require_dom2();
  var infra_1 = require_lib9();

  class XMLBuilderImpl {
    constructor(domNode) {
      this._domNode = domNode;
    }
    get node() {
      return this._domNode;
    }
    set(options) {
      this._options = util_1.applyDefaults(util_1.applyDefaults(this._options, options, true), interfaces_1.DefaultBuilderOptions);
      return this;
    }
    ele(p1, p2, p3) {
      let namespace;
      let name;
      let attributes;
      let lastChild = null;
      if (util_1.isString(p1) && /^\s*</.test(p1)) {
        const contents = "<TEMP_ROOT>" + p1 + "</TEMP_ROOT>";
        const domParser = dom_1.createParser();
        const doc = domParser.parseFromString(dom_1.sanitizeInput(contents, this._options.invalidCharReplacement), "text/xml");
        if (doc.documentElement === null) {
          throw new Error("Document element is null.");
        }
        dom_1.throwIfParserError(doc);
        for (const child of doc.documentElement.childNodes) {
          const newChild = doc.importNode(child, true);
          lastChild = new XMLBuilderImpl(newChild);
          this._domNode.appendChild(newChild);
        }
        if (lastChild === null) {
          throw new Error("Could not create any elements with: " + p1.toString() + ". " + this._debugInfo());
        }
        return lastChild;
      } else if (util_1.isString(p1) && /^\s*[\{\[]/.test(p1)) {
        const obj = JSON.parse(p1);
        return this.ele(obj);
      } else if (util_1.isObject(p1)) {
        [namespace, name, attributes] = [undefined, p1, undefined];
      } else if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2)) {
        [namespace, name, attributes] = [p1, p2, p3];
      } else if (p1 !== null) {
        [namespace, name, attributes] = [undefined, p1, util_1.isObject(p2) ? p2 : undefined];
      } else {
        throw new Error("Element name cannot be null. " + this._debugInfo());
      }
      if (attributes) {
        attributes = util_1.getValue(attributes);
      }
      if (util_1.isFunction(name)) {
        lastChild = this.ele(name.apply(this));
      } else if (util_1.isArray(name) || util_1.isSet(name)) {
        util_1.forEachArray(name, (item) => lastChild = this.ele(item), this);
      } else if (util_1.isMap(name) || util_1.isObject(name)) {
        util_1.forEachObject(name, (key, val) => {
          if (util_1.isFunction(val)) {
            val = val.apply(this);
          }
          if (!this._options.ignoreConverters && key.indexOf(this._options.convert.att) === 0) {
            if (key === this._options.convert.att) {
              lastChild = this.att(val);
            } else {
              lastChild = this.att(key.substr(this._options.convert.att.length), val);
            }
          } else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.text) === 0) {
            if (util_1.isMap(val) || util_1.isObject(val)) {
              lastChild = this.ele(val);
            } else {
              lastChild = this.txt(val);
            }
          } else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.cdata) === 0) {
            if (util_1.isArray(val) || util_1.isSet(val)) {
              util_1.forEachArray(val, (item) => lastChild = this.dat(item), this);
            } else {
              lastChild = this.dat(val);
            }
          } else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.comment) === 0) {
            if (util_1.isArray(val) || util_1.isSet(val)) {
              util_1.forEachArray(val, (item) => lastChild = this.com(item), this);
            } else {
              lastChild = this.com(val);
            }
          } else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.ins) === 0) {
            if (util_1.isString(val)) {
              const insIndex = val.indexOf(" ");
              const insTarget = insIndex === -1 ? val : val.substr(0, insIndex);
              const insValue = insIndex === -1 ? "" : val.substr(insIndex + 1);
              lastChild = this.ins(insTarget, insValue);
            } else {
              lastChild = this.ins(val);
            }
          } else if ((util_1.isArray(val) || util_1.isSet(val)) && util_1.isEmpty(val)) {
            lastChild = this._dummy();
          } else if ((util_1.isMap(val) || util_1.isObject(val)) && util_1.isEmpty(val)) {
            lastChild = this.ele(key);
          } else if (!this._options.keepNullNodes && val == null) {
            lastChild = this._dummy();
          } else if (util_1.isArray(val) || util_1.isSet(val)) {
            util_1.forEachArray(val, (item) => {
              const childNode = {};
              childNode[key] = item;
              lastChild = this.ele(childNode);
            }, this);
          } else if (util_1.isMap(val) || util_1.isObject(val)) {
            lastChild = this.ele(key);
            lastChild.ele(val);
          } else if (val) {
            lastChild = this.ele(key);
            lastChild.txt(val);
          } else {
            lastChild = this.ele(key);
          }
        }, this);
      } else {
        [namespace, name] = this._extractNamespace(dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement), dom_1.sanitizeInput(name, this._options.invalidCharReplacement), true);
        if (namespace === undefined) {
          const [prefix] = algorithm_1.namespace_extractQName(name);
          namespace = this.node.lookupNamespaceURI(prefix);
        }
        const childNode = namespace !== undefined && namespace !== null ? this._doc.createElementNS(namespace, name) : this._doc.createElement(name);
        this.node.appendChild(childNode);
        lastChild = new XMLBuilderImpl(childNode);
        const oldDocType = this._doc.doctype;
        if (childNode === this._doc.documentElement && oldDocType !== null) {
          const docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);
          this._doc.replaceChild(docType, oldDocType);
        }
        if (attributes && !util_1.isEmpty(attributes)) {
          lastChild.att(attributes);
        }
      }
      if (lastChild === null) {
        throw new Error("Could not create any elements with: " + name.toString() + ". " + this._debugInfo());
      }
      return lastChild;
    }
    remove() {
      const parent = this.up();
      parent.node.removeChild(this.node);
      return parent;
    }
    att(p1, p2, p3) {
      if (util_1.isMap(p1) || util_1.isObject(p1)) {
        util_1.forEachObject(p1, (attName, attValue) => this.att(attName, attValue), this);
        return this;
      }
      if (p1 !== undefined && p1 !== null)
        p1 = util_1.getValue(p1 + "");
      if (p2 !== undefined && p2 !== null)
        p2 = util_1.getValue(p2 + "");
      if (p3 !== undefined && p3 !== null)
        p3 = util_1.getValue(p3 + "");
      let namespace;
      let name;
      let value;
      if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2) && (p3 === null || util_1.isString(p3))) {
        [namespace, name, value] = [p1, p2, p3];
      } else if (util_1.isString(p1) && (p2 == null || util_1.isString(p2))) {
        [namespace, name, value] = [undefined, p1, p2];
      } else {
        throw new Error("Attribute name and value not specified. " + this._debugInfo());
      }
      if (this._options.keepNullAttributes && value == null) {
        value = "";
      } else if (value == null) {
        return this;
      }
      if (!util_2.Guard.isElementNode(this.node)) {
        throw new Error("An attribute can only be assigned to an element node.");
      }
      let ele = this.node;
      [namespace, name] = this._extractNamespace(namespace, name, false);
      name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
      namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
      value = dom_1.sanitizeInput(value, this._options.invalidCharReplacement);
      const [prefix, localName] = algorithm_1.namespace_extractQName(name);
      const [elePrefix, eleLocalName] = algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ":" + ele.localName : ele.localName);
      let eleNamespace = null;
      if (prefix === "xmlns") {
        namespace = infra_1.namespace.XMLNS;
        if (ele.namespaceURI === null && elePrefix === localName) {
          eleNamespace = value;
        }
      } else if (prefix === null && localName === "xmlns" && elePrefix === null) {
        namespace = infra_1.namespace.XMLNS;
        eleNamespace = value;
      }
      if (eleNamespace !== null) {
        const newEle = algorithm_1.create_element(this._doc, eleLocalName, eleNamespace, elePrefix);
        for (const attr of ele.attributes) {
          newEle.setAttributeNodeNS(attr.cloneNode());
        }
        for (const childNode of ele.childNodes) {
          newEle.appendChild(childNode.cloneNode());
        }
        const parent = ele.parentNode;
        if (parent === null) {
          throw new Error("Parent node is null." + this._debugInfo());
        }
        parent.replaceChild(newEle, ele);
        this._domNode = newEle;
        ele = newEle;
      }
      if (namespace !== undefined) {
        ele.setAttributeNS(namespace, name, value);
      } else {
        ele.setAttribute(name, value);
      }
      return this;
    }
    removeAtt(p1, p2) {
      if (!util_2.Guard.isElementNode(this.node)) {
        throw new Error("An attribute can only be removed from an element node.");
      }
      p1 = util_1.getValue(p1);
      if (p2 !== undefined) {
        p2 = util_1.getValue(p2);
      }
      let namespace;
      let name;
      if (p1 !== null && p2 === undefined) {
        name = p1;
      } else if ((p1 === null || util_1.isString(p1)) && p2 !== undefined) {
        namespace = p1;
        name = p2;
      } else {
        throw new Error("Attribute namespace must be a string. " + this._debugInfo());
      }
      if (util_1.isArray(name) || util_1.isSet(name)) {
        util_1.forEachArray(name, (attName) => namespace === undefined ? this.removeAtt(attName) : this.removeAtt(namespace, attName), this);
      } else if (namespace !== undefined) {
        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
        namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
        this.node.removeAttributeNS(namespace, name);
      } else {
        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
        this.node.removeAttribute(name);
      }
      return this;
    }
    txt(content) {
      const child = this._doc.createTextNode(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    com(content) {
      const child = this._doc.createComment(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    dat(content) {
      const child = this._doc.createCDATASection(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    ins(target, content = "") {
      if (util_1.isArray(target) || util_1.isSet(target)) {
        util_1.forEachArray(target, (item) => {
          item += "";
          const insIndex = item.indexOf(" ");
          const insTarget = insIndex === -1 ? item : item.substr(0, insIndex);
          const insValue = insIndex === -1 ? "" : item.substr(insIndex + 1);
          this.ins(insTarget, insValue);
        }, this);
      } else if (util_1.isMap(target) || util_1.isObject(target)) {
        util_1.forEachObject(target, (insTarget, insValue) => this.ins(insTarget, insValue), this);
      } else {
        const child = this._doc.createProcessingInstruction(dom_1.sanitizeInput(target, this._options.invalidCharReplacement), dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
      }
      return this;
    }
    dec(options) {
      this._options.version = options.version || "1.0";
      this._options.encoding = options.encoding;
      this._options.standalone = options.standalone;
      return this;
    }
    dtd(options) {
      const name = dom_1.sanitizeInput(options && options.name || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement);
      const pubID = dom_1.sanitizeInput(options && options.pubID || "", this._options.invalidCharReplacement);
      const sysID = dom_1.sanitizeInput(options && options.sysID || "", this._options.invalidCharReplacement);
      if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {
        throw new Error("DocType name does not match document element name.");
      }
      const docType = this._doc.implementation.createDocumentType(name, pubID, sysID);
      if (this._doc.doctype !== null) {
        this._doc.replaceChild(docType, this._doc.doctype);
      } else {
        this._doc.insertBefore(docType, this._doc.documentElement);
      }
      return this;
    }
    import(node) {
      const hostNode = this._domNode;
      const hostDoc = this._doc;
      const importedNode = node.node;
      if (util_2.Guard.isDocumentNode(importedNode)) {
        const elementNode = importedNode.documentElement;
        if (elementNode === null) {
          throw new Error("Imported document has no document element node. " + this._debugInfo());
        }
        const clone = hostDoc.importNode(elementNode, true);
        hostNode.appendChild(clone);
      } else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {
        for (const childNode of importedNode.childNodes) {
          const clone = hostDoc.importNode(childNode, true);
          hostNode.appendChild(clone);
        }
      } else {
        const clone = hostDoc.importNode(importedNode, true);
        hostNode.appendChild(clone);
      }
      return this;
    }
    doc() {
      if (this._doc._isFragment) {
        let node = this.node;
        while (node && node.nodeType !== interfaces_2.NodeType.DocumentFragment) {
          node = node.parentNode;
        }
        if (node === null) {
          throw new Error("Node has no parent node while searching for document fragment ancestor.");
        }
        return new XMLBuilderImpl(node);
      } else {
        return new XMLBuilderImpl(this._doc);
      }
    }
    root() {
      const ele = this._doc.documentElement;
      if (!ele) {
        throw new Error("Document root element is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(ele);
    }
    up() {
      const parent = this._domNode.parentNode;
      if (!parent) {
        throw new Error("Parent node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(parent);
    }
    prev() {
      const node = this._domNode.previousSibling;
      if (!node) {
        throw new Error("Previous sibling node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(node);
    }
    next() {
      const node = this._domNode.nextSibling;
      if (!node) {
        throw new Error("Next sibling node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(node);
    }
    first() {
      const node = this._domNode.firstChild;
      if (!node) {
        throw new Error("First child node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(node);
    }
    last() {
      const node = this._domNode.lastChild;
      if (!node) {
        throw new Error("Last child node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl(node);
    }
    each(callback, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        callback.call(thisArg, new XMLBuilderImpl(result[0]), result[1], result[2]);
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return this;
    }
    map(callback, self2 = false, recursive = false, thisArg) {
      let result = [];
      this.each((node, index, level) => result.push(callback.call(thisArg, node, index, level)), self2, recursive);
      return result;
    }
    reduce(callback, initialValue, self2 = false, recursive = false, thisArg) {
      let value = initialValue;
      this.each((node, index, level) => value = callback.call(thisArg, value, node, index, level), self2, recursive);
      return value;
    }
    find(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder = new XMLBuilderImpl(result[0]);
        if (predicate.call(thisArg, builder, result[1], result[2])) {
          return builder;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return;
    }
    filter(predicate, self2 = false, recursive = false, thisArg) {
      let result = [];
      this.each((node, index, level) => {
        if (predicate.call(thisArg, node, index, level)) {
          result.push(node);
        }
      }, self2, recursive);
      return result;
    }
    every(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder = new XMLBuilderImpl(result[0]);
        if (!predicate.call(thisArg, builder, result[1], result[2])) {
          return false;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return true;
    }
    some(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder = new XMLBuilderImpl(result[0]);
        if (predicate.call(thisArg, builder, result[1], result[2])) {
          return true;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return false;
    }
    toArray(self2 = false, recursive = false) {
      let result = [];
      this.each((node) => result.push(node), self2, recursive);
      return result;
    }
    toString(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === undefined) {
        writerOptions.format = "xml";
      }
      return this._serialize(writerOptions);
    }
    toObject(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === undefined) {
        writerOptions.format = "object";
      }
      return this._serialize(writerOptions);
    }
    end(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === undefined) {
        writerOptions.format = "xml";
      }
      return this.doc()._serialize(writerOptions);
    }
    _getFirstDescendantNode(root, self2, recursive) {
      if (self2)
        return [this._domNode, 0, 0];
      else if (recursive)
        return this._getNextDescendantNode(root, root, recursive, 0, 0);
      else
        return [this._domNode.firstChild, 0, 1];
    }
    _getNextDescendantNode(root, node, recursive, index, level) {
      if (recursive) {
        if (node.firstChild)
          return [node.firstChild, 0, level + 1];
        if (node === root)
          return [null, -1, -1];
        if (node.nextSibling)
          return [node.nextSibling, index + 1, level];
        let parent = node.parentNode;
        while (parent && parent !== root) {
          if (parent.nextSibling)
            return [parent.nextSibling, algorithm_1.tree_index(parent.nextSibling), level - 1];
          parent = parent.parentNode;
          level--;
        }
      } else {
        if (root === node)
          return [node.firstChild, 0, level + 1];
        else
          return [node.nextSibling, index + 1, level];
      }
      return [null, -1, -1];
    }
    _serialize(writerOptions) {
      if (writerOptions.format === "xml") {
        const writer = new writers_1.XMLWriter(this._options);
        return writer.serialize(this.node, writerOptions);
      } else if (writerOptions.format === "map") {
        const writer = new writers_1.MapWriter(this._options);
        return writer.serialize(this.node, writerOptions);
      } else if (writerOptions.format === "object") {
        const writer = new writers_1.ObjectWriter(this._options);
        return writer.serialize(this.node, writerOptions);
      } else if (writerOptions.format === "json") {
        const writer = new writers_1.JSONWriter(this._options);
        return writer.serialize(this.node, writerOptions);
      } else {
        throw new Error("Invalid writer format: " + writerOptions.format + ". " + this._debugInfo());
      }
    }
    _dummy() {
      return new XMLBuilderImpl(this._doc.createElement("dummy_node"));
    }
    _extractNamespace(namespace, name, ele) {
      const atIndex = name.indexOf("@");
      if (atIndex > 0) {
        if (namespace === undefined)
          namespace = name.slice(atIndex + 1);
        name = name.slice(0, atIndex);
      }
      if (namespace === undefined) {
        namespace = ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att;
      } else if (namespace !== null && namespace[0] === "@") {
        const alias = namespace.slice(1);
        namespace = this._options.namespaceAlias[alias];
        if (namespace === undefined) {
          throw new Error("Namespace alias `" + alias + "` is not defined. " + this._debugInfo());
        }
      }
      return [namespace, name];
    }
    get _doc() {
      const node = this.node;
      if (util_2.Guard.isDocumentNode(node)) {
        return node;
      } else {
        const docNode = node.ownerDocument;
        if (!docNode)
          throw new Error("Owner document is null. " + this._debugInfo());
        return docNode;
      }
    }
    _debugInfo(name) {
      const node = this.node;
      const parentNode = node.parentNode;
      name = name || node.nodeName;
      const parentName = parentNode ? parentNode.nodeName : "";
      if (!parentName) {
        return "node: <" + name + ">";
      } else {
        return "node: <" + name + ">, parent: <" + parentName + ">";
      }
    }
    get _options() {
      const doc = this._doc;
      if (doc._xmlBuilderOptions === undefined) {
        throw new Error("Builder options is not set.");
      }
      return doc._xmlBuilderOptions;
    }
    set _options(value) {
      const doc = this._doc;
      doc._xmlBuilderOptions = value;
    }
  }
  exports.XMLBuilderImpl = XMLBuilderImpl;
});

// node_modules/xmlbuilder2/lib/writers/BaseCBWriter.js
var require_BaseCBWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class BaseCBWriter {
    constructor(builderOptions) {
      this.level = 0;
      this._builderOptions = builderOptions;
      this._writerOptions = builderOptions;
    }
  }
  exports.BaseCBWriter = BaseCBWriter;
});

// node_modules/xmlbuilder2/lib/writers/XMLCBWriter.js
var require_XMLCBWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var BaseCBWriter_1 = require_BaseCBWriter();

  class XMLCBWriter extends BaseCBWriter_1.BaseCBWriter {
    constructor(builderOptions) {
      super(builderOptions);
      this._lineLength = 0;
    }
    declaration(version, encoding, standalone) {
      let markup = this._beginLine() + "<?xml";
      markup += ' version="' + version + '"';
      if (encoding !== undefined) {
        markup += ' encoding="' + encoding + '"';
      }
      if (standalone !== undefined) {
        markup += ' standalone="' + (standalone ? "yes" : "no") + '"';
      }
      markup += "?>";
      return markup;
    }
    docType(name, publicId, systemId) {
      let markup = this._beginLine();
      if (publicId && systemId) {
        markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
      } else if (publicId) {
        markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
      } else if (systemId) {
        markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
      } else {
        markup += "<!DOCTYPE " + name + ">";
      }
      return markup;
    }
    comment(data) {
      return this._beginLine() + "<!--" + data + "-->";
    }
    text(data) {
      return this._beginLine() + data;
    }
    instruction(target, data) {
      if (data) {
        return this._beginLine() + "<?" + target + " " + data + "?>";
      } else {
        return this._beginLine() + "<?" + target + "?>";
      }
    }
    cdata(data) {
      return this._beginLine() + "<![CDATA[" + data + "]]>";
    }
    openTagBegin(name) {
      this._lineLength += 1 + name.length;
      return this._beginLine() + "<" + name;
    }
    openTagEnd(name, selfClosing, voidElement) {
      if (voidElement) {
        return " />";
      } else if (selfClosing) {
        if (this._writerOptions.allowEmptyTags) {
          return "></" + name + ">";
        } else if (this._writerOptions.spaceBeforeSlash) {
          return " />";
        } else {
          return "/>";
        }
      } else {
        return ">";
      }
    }
    closeTag(name) {
      return this._beginLine() + "</" + name + ">";
    }
    attribute(name, value) {
      let str = name + '="' + value + '"';
      if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._lineLength + 1 + str.length > this._writerOptions.width) {
        str = this._beginLine() + this._indent(1) + str;
        this._lineLength = str.length;
        return str;
      } else {
        this._lineLength += 1 + str.length;
        return " " + str;
      }
    }
    beginElement(name) {
    }
    endElement(name) {
    }
    _beginLine() {
      if (this._writerOptions.prettyPrint) {
        const str = (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level);
        this._lineLength = str.length;
        return str;
      } else {
        return "";
      }
    }
    _indent(level) {
      if (level <= 0) {
        return "";
      } else {
        return this._writerOptions.indent.repeat(level);
      }
    }
  }
  exports.XMLCBWriter = XMLCBWriter;
});

// node_modules/xmlbuilder2/lib/writers/JSONCBWriter.js
var require_JSONCBWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var BaseCBWriter_1 = require_BaseCBWriter();

  class JSONCBWriter extends BaseCBWriter_1.BaseCBWriter {
    constructor(builderOptions) {
      super(builderOptions);
      this._hasChildren = [];
      this._additionalLevel = 0;
    }
    declaration(version, encoding, standalone) {
      return "";
    }
    docType(name, publicId, systemId) {
      return "";
    }
    comment(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.comment) + this._sep() + this._val(data) + this._sep() + "}";
    }
    text(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.text) + this._sep() + this._val(data) + this._sep() + "}";
    }
    instruction(target, data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.ins) + this._sep() + this._val(data ? target + " " + data : target) + this._sep() + "}";
    }
    cdata(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.cdata) + this._sep() + this._val(data) + this._sep() + "}";
    }
    attribute(name, value) {
      return this._comma() + this._beginLine(1) + "{" + this._sep() + this._key(this._builderOptions.convert.att + name) + this._sep() + this._val(value) + this._sep() + "}";
    }
    openTagBegin(name) {
      let str = this._comma() + this._beginLine() + "{" + this._sep() + this._key(name) + this._sep() + "{";
      this._additionalLevel++;
      this.hasData = true;
      str += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[";
      this._hasChildren.push(false);
      return str;
    }
    openTagEnd(name, selfClosing, voidElement) {
      if (selfClosing) {
        let str = this._sep() + "]";
        this._additionalLevel--;
        str += this._beginLine() + "}" + this._sep() + "}";
        return str;
      } else {
        return "";
      }
    }
    closeTag(name) {
      let str = this._beginLine() + "]";
      this._additionalLevel--;
      str += this._beginLine() + "}" + this._sep() + "}";
      return str;
    }
    beginElement(name) {
    }
    endElement(name) {
      this._hasChildren.pop();
    }
    _beginLine(additionalOffset = 0) {
      if (this._writerOptions.prettyPrint) {
        return (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level + additionalOffset);
      } else {
        return "";
      }
    }
    _indent(level) {
      if (level + this._additionalLevel <= 0) {
        return "";
      } else {
        return this._writerOptions.indent.repeat(level + this._additionalLevel);
      }
    }
    _comma() {
      const str = this._hasChildren[this._hasChildren.length - 1] ? "," : "";
      if (this._hasChildren.length > 0) {
        this._hasChildren[this._hasChildren.length - 1] = true;
      }
      return str;
    }
    _sep() {
      return this._writerOptions.prettyPrint ? " " : "";
    }
    _key(key) {
      return '"' + key + '":';
    }
    _val(val) {
      return '"' + val + '"';
    }
  }
  exports.JSONCBWriter = JSONCBWriter;
});

// node_modules/xmlbuilder2/lib/builder/XMLBuilderCBImpl.js
var require_XMLBuilderCBImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces();
  var util_1 = require_lib8();
  var __1 = require_lib12();
  var algorithm_1 = require_algorithm();
  var infra_1 = require_lib9();
  var NamespacePrefixMap_1 = require_NamespacePrefixMap();
  var LocalNameSet_1 = require_LocalNameSet();
  var util_2 = require_util2();
  var XMLCBWriter_1 = require_XMLCBWriter();
  var JSONCBWriter_1 = require_JSONCBWriter();
  var events_1 = __require("events");

  class XMLBuilderCBImpl extends events_1.EventEmitter {
    constructor(options, fragment = false) {
      super();
      this._hasDeclaration = false;
      this._docTypeName = "";
      this._hasDocumentElement = false;
      this._currentElementSerialized = false;
      this._openTags = [];
      this._ended = false;
      this._fragment = fragment;
      this._options = util_1.applyDefaults(options || {}, interfaces_1.DefaultXMLBuilderCBOptions);
      this._builderOptions = {
        defaultNamespace: this._options.defaultNamespace,
        namespaceAlias: this._options.namespaceAlias
      };
      this._writer = this._options.format === "xml" ? new XMLCBWriter_1.XMLCBWriter(this._options) : new JSONCBWriter_1.JSONCBWriter(this._options);
      if (this._options.data !== undefined) {
        this.on("data", this._options.data);
      }
      if (this._options.end !== undefined) {
        this.on("end", this._options.end);
      }
      if (this._options.error !== undefined) {
        this.on("error", this._options.error);
      }
      this._prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap;
      this._prefixMap.set("xml", infra_1.namespace.XML);
      this._prefixIndex = { value: 1 };
    }
    ele(p1, p2, p3) {
      if (util_1.isObject(p1) || util_1.isString(p1) && (/^\s*</.test(p1) || /^\s*[\{\[]/.test(p1))) {
        const frag = __1.fragment().set(this._options);
        try {
          frag.ele(p1);
        } catch (err) {
          this.emit("error", err);
          return this;
        }
        for (const node of frag.node.childNodes) {
          this._fromNode(node);
        }
        return this;
      }
      this._serializeOpenTag(true);
      if (!this._fragment && this._hasDocumentElement && this._writer.level === 0) {
        this.emit("error", new Error("Document cannot have multiple document element nodes."));
        return this;
      }
      try {
        this._currentElement = __1.fragment(this._builderOptions).ele(p1, p2, p3);
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (!this._fragment && !this._hasDocumentElement && this._docTypeName !== "" && this._currentElement.node._qualifiedName !== this._docTypeName) {
        this.emit("error", new Error("Document element name does not match DocType declaration name."));
        return this;
      }
      this._currentElementSerialized = false;
      if (!this._fragment) {
        this._hasDocumentElement = true;
      }
      return this;
    }
    att(p1, p2, p3) {
      if (this._currentElement === undefined) {
        this.emit("error", new Error("Cannot insert an attribute node as child of a document node."));
        return this;
      }
      try {
        this._currentElement.att(p1, p2, p3);
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      return this;
    }
    com(content) {
      this._serializeOpenTag(true);
      let node;
      try {
        node = __1.fragment(this._builderOptions).com(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
        this.emit("error", new Error("Comment data contains invalid characters (well-formed required)."));
        return this;
      }
      this._push(this._writer.comment(node.data));
      return this;
    }
    txt(content) {
      if (!this._fragment && this._currentElement === undefined) {
        this.emit("error", new Error("Cannot insert a text node as child of a document node."));
        return this;
      }
      this._serializeOpenTag(true);
      let node;
      try {
        node = __1.fragment(this._builderOptions).txt(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
        this.emit("error", new Error("Text data contains invalid characters (well-formed required)."));
        return this;
      }
      let markup = "";
      if (this._options.noDoubleEncoding) {
        markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      } else {
        for (let i = 0;i < node.data.length; i++) {
          const c = node.data[i];
          if (c === "&")
            markup += "&amp;";
          else if (c === "<")
            markup += "&lt;";
          else if (c === ">")
            markup += "&gt;";
          else
            markup += c;
        }
      }
      this._push(this._writer.text(markup));
      return this;
    }
    ins(target, content = "") {
      this._serializeOpenTag(true);
      let node;
      try {
        node = __1.fragment(this._builderOptions).ins(target, content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
        this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required)."));
        return this;
      }
      if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
        this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required)."));
        return this;
      }
      this._push(this._writer.instruction(node.target, node.data));
      return this;
    }
    dat(content) {
      this._serializeOpenTag(true);
      let node;
      try {
        node = __1.fragment(this._builderOptions).dat(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      this._push(this._writer.cdata(node.data));
      return this;
    }
    dec(options = { version: "1.0" }) {
      if (this._fragment) {
        this.emit("error", Error("Cannot insert an XML declaration into a document fragment."));
        return this;
      }
      if (this._hasDeclaration) {
        this.emit("error", Error("XML declaration is already inserted."));
        return this;
      }
      this._push(this._writer.declaration(options.version || "1.0", options.encoding, options.standalone));
      this._hasDeclaration = true;
      return this;
    }
    dtd(options) {
      if (this._fragment) {
        this.emit("error", Error("Cannot insert a DocType declaration into a document fragment."));
        return this;
      }
      if (this._docTypeName !== "") {
        this.emit("error", new Error("DocType declaration is already inserted."));
        return this;
      }
      if (this._hasDocumentElement) {
        this.emit("error", new Error("Cannot insert DocType declaration after document element."));
        return this;
      }
      let node;
      try {
        node = __1.create().dtd(options).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
        this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required)."));
        return this;
      }
      if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
        this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required)."));
        return this;
      }
      this._docTypeName = options.name;
      this._push(this._writer.docType(options.name, node.publicId, node.systemId));
      return this;
    }
    up() {
      this._serializeOpenTag(false);
      this._serializeCloseTag();
      return this;
    }
    end() {
      this._serializeOpenTag(false);
      while (this._openTags.length > 0) {
        this._serializeCloseTag();
      }
      this._push(null);
      return this;
    }
    _serializeOpenTag(hasChildren) {
      if (this._currentElementSerialized)
        return;
      if (this._currentElement === undefined)
        return;
      const node = this._currentElement.node;
      if (this._options.wellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
        this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
        return;
      }
      let qualifiedName = "";
      let ignoreNamespaceDefinitionAttribute = false;
      let map = this._prefixMap.copy();
      let localPrefixesMap = {};
      let localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
      let inheritedNS = this._openTags.length === 0 ? null : this._openTags[this._openTags.length - 1][1];
      let ns = node.namespaceURI;
      if (ns === null)
        ns = inheritedNS;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node.localName;
        } else {
          qualifiedName = node.localName;
        }
        this._writer.beginElement(qualifiedName);
        this._push(this._writer.openTagBegin(qualifiedName));
      } else {
        let prefix = node.prefix;
        let candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (this._options.wellFormed) {
            this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
            return;
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map, this._prefixIndex);
          }
          map.set(prefix, ns);
          qualifiedName += prefix + ":" + node.localName;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
          this._push(this._writer.attribute("xmlns:" + prefix, this._serializeAttributeValue(ns, this._options.wellFormed)));
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node.localName;
          inheritedNS = ns;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
          this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(ns, this._options.wellFormed)));
        } else {
          qualifiedName += node.localName;
          inheritedNS = ns;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
        }
      }
      this._serializeAttributes(node, map, this._prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, this._options.wellFormed);
      const isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && !hasChildren && XMLBuilderCBImpl._VoidElementNames.has(node.localName)) {
        this._push(this._writer.openTagEnd(qualifiedName, true, true));
        this._writer.endElement(qualifiedName);
      } else if (!isHTML && !hasChildren) {
        this._push(this._writer.openTagEnd(qualifiedName, true, false));
        this._writer.endElement(qualifiedName);
      } else {
        this._push(this._writer.openTagEnd(qualifiedName, false, false));
      }
      this._currentElementSerialized = true;
      this._openTags.push([qualifiedName, inheritedNS, this._prefixMap, hasChildren]);
      if (this._isPrefixMapModified(this._prefixMap, map)) {
        this._prefixMap = map;
      }
      this._writer.level++;
    }
    _serializeCloseTag() {
      this._writer.level--;
      const lastEle = this._openTags.pop();
      if (lastEle === undefined) {
        this.emit("error", new Error("Last element is undefined."));
        return;
      }
      const [qualifiedName, ns, map, hasChildren] = lastEle;
      this._prefixMap = map;
      if (!hasChildren)
        return;
      this._push(this._writer.closeTag(qualifiedName));
      this._writer.endElement(qualifiedName);
    }
    _push(data) {
      if (data === null) {
        this._ended = true;
        this.emit("end");
      } else if (this._ended) {
        this.emit("error", new Error("Cannot push to ended stream."));
      } else if (data.length !== 0) {
        this._writer.hasData = true;
        this.emit("data", data, this._writer.level);
      }
    }
    _fromNode(node) {
      if (util_2.Guard.isElementNode(node)) {
        const name = node.prefix ? node.prefix + ":" + node.localName : node.localName;
        if (node.namespaceURI !== null) {
          this.ele(node.namespaceURI, name);
        } else {
          this.ele(name);
        }
        for (const attr of node.attributes) {
          const name2 = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
          if (attr.namespaceURI !== null) {
            this.att(attr.namespaceURI, name2, attr.value);
          } else {
            this.att(name2, attr.value);
          }
        }
        for (const child of node.childNodes) {
          this._fromNode(child);
        }
        this.up();
      } else if (util_2.Guard.isExclusiveTextNode(node) && node.data) {
        this.txt(node.data);
      } else if (util_2.Guard.isCommentNode(node)) {
        this.com(node.data);
      } else if (util_2.Guard.isCDATASectionNode(node)) {
        this.dat(node.data);
      } else if (util_2.Guard.isProcessingInstructionNode(node)) {
        this.ins(node.target, node.data);
      }
    }
    _serializeAttributes(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
      const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet : undefined;
      for (const attr of node.attributes) {
        if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
          this._push(this._writer.attribute(attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
          continue;
        }
        if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
          this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
          return;
        }
        if (requireWellFormed && localNameSet)
          localNameSet.set(attr.namespaceURI, attr.localName);
        let attributeNamespace = attr.namespaceURI;
        let candidatePrefix = null;
        if (attributeNamespace !== null) {
          candidatePrefix = map.get(attr.prefix, attributeNamespace);
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
              continue;
            if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
              this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
              return;
            }
            if (requireWellFormed && attr.value === "") {
              this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
              return;
            }
            if (attr.prefix === "xmlns")
              candidatePrefix = "xmlns";
          } else if (candidatePrefix === null) {
            if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
              candidatePrefix = attr.prefix;
            } else {
              candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
            }
            this._push(this._writer.attribute("xmlns:" + candidatePrefix, this._serializeAttributeValue(attributeNamespace, this._options.wellFormed)));
          }
        }
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
          this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
          return;
        }
        this._push(this._writer.attribute((candidatePrefix !== null ? candidatePrefix + ":" : "") + attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
      }
    }
    _serializeAttributeValue(value, requireWellFormed) {
      if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
        this.emit("error", new Error("Invalid characters in attribute value."));
        return "";
      }
      if (value === null)
        return "";
      if (this._options.noDoubleEncoding) {
        return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      } else {
        let result = "";
        for (let i = 0;i < value.length; i++) {
          const c = value[i];
          if (c === '"')
            result += "&quot;";
          else if (c === "&")
            result += "&amp;";
          else if (c === "<")
            result += "&lt;";
          else if (c === ">")
            result += "&gt;";
          else
            result += c;
        }
        return result;
      }
    }
    _recordNamespaceInformation(node, map, localPrefixesMap) {
      let defaultNamespaceAttrValue = null;
      for (const attr of node.attributes) {
        let attributeNamespace = attr.namespaceURI;
        let attributePrefix = attr.prefix;
        if (attributeNamespace === infra_1.namespace.XMLNS) {
          if (attributePrefix === null) {
            defaultNamespaceAttrValue = attr.value;
            continue;
          } else {
            let prefixDefinition = attr.localName;
            let namespaceDefinition = attr.value;
            if (namespaceDefinition === infra_1.namespace.XML) {
              continue;
            }
            if (namespaceDefinition === "") {
              namespaceDefinition = null;
            }
            if (map.has(prefixDefinition, namespaceDefinition)) {
              continue;
            }
            map.set(prefixDefinition, namespaceDefinition);
            localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
          }
        }
      }
      return defaultNamespaceAttrValue;
    }
    _generatePrefix(newNamespace, prefixMap, prefixIndex) {
      let generatedPrefix = "ns" + prefixIndex.value;
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    }
    _isPrefixMapModified(originalMap, newMap) {
      const items1 = originalMap._items;
      const items2 = newMap._items;
      const nullItems1 = originalMap._nullItems;
      const nullItems2 = newMap._nullItems;
      for (const key in items2) {
        const arr1 = items1[key];
        if (arr1 === undefined)
          return true;
        const arr2 = items2[key];
        if (arr1.length !== arr2.length)
          return true;
        for (let i = 0;i < arr1.length; i++) {
          if (arr1[i] !== arr2[i])
            return true;
        }
      }
      if (nullItems1.length !== nullItems2.length)
        return true;
      for (let i = 0;i < nullItems1.length; i++) {
        if (nullItems1[i] !== nullItems2[i])
          return true;
      }
      return false;
    }
  }
  exports.XMLBuilderCBImpl = XMLBuilderCBImpl;
  XMLBuilderCBImpl._VoidElementNames = new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
});

// node_modules/xmlbuilder2/lib/builder/index.js
var require_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var XMLBuilderImpl_1 = require_XMLBuilderImpl();
  exports.XMLBuilderImpl = XMLBuilderImpl_1.XMLBuilderImpl;
  var XMLBuilderCBImpl_1 = require_XMLBuilderCBImpl();
  exports.XMLBuilderCBImpl = XMLBuilderCBImpl_1.XMLBuilderCBImpl;
});

// node_modules/xmlbuilder2/lib/index.js
var require_lib12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var interfaces_1 = require_interfaces();
  var util_1 = require_lib8();
  var util_2 = require_util2();
  var builder_1 = require_builder();
  var dom_1 = require_dom2();
  var util_3 = __require("util");
  var builder_2 = require_builder();
  function builder(p1, p2) {
    const options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const nodes = util_2.Guard.isNode(p1) || util_3.isArray(p1) ? p1 : p2;
    if (nodes === undefined) {
      throw new Error("Invalid arguments.");
    }
    if (util_3.isArray(nodes)) {
      const builders = [];
      for (let i = 0;i < nodes.length; i++) {
        const builder2 = new builder_1.XMLBuilderImpl(nodes[i]);
        builder2.set(options);
        builders.push(builder2);
      }
      return builders;
    } else {
      const builder2 = new builder_1.XMLBuilderImpl(nodes);
      builder2.set(options);
      return builder2;
    }
  }
  exports.builder = builder;
  function create(p1, p2) {
    const options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    let builder2;
    if (contents === undefined) {
      const doc = dom_1.createDocument();
      builder2 = new builder_1.XMLBuilderImpl(doc);
      setOptions(doc, options);
    } else if (util_1.isObject(contents)) {
      const doc = dom_1.createDocument();
      builder2 = new builder_1.XMLBuilderImpl(doc);
      setOptions(doc, options);
      builder2.ele(contents);
    } else if (/^\s*</.test(contents)) {
      const domParser = dom_1.createParser();
      const doc = domParser.parseFromString(dom_1.sanitizeInput(contents, options.invalidCharReplacement), "text/xml");
      dom_1.throwIfParserError(doc);
      builder2 = new builder_1.XMLBuilderImpl(doc);
      setOptions(doc, options);
    } else {
      const doc = dom_1.createDocument();
      builder2 = new builder_1.XMLBuilderImpl(doc);
      setOptions(doc, options);
      const obj = JSON.parse(contents);
      builder2.ele(obj);
    }
    return builder2;
  }
  exports.create = create;
  function fragment(p1, p2) {
    const options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    let builder2;
    if (contents === undefined) {
      const doc = dom_1.createDocument();
      setOptions(doc, options, true);
      builder2 = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
    } else if (util_1.isObject(contents)) {
      const doc = dom_1.createDocument();
      setOptions(doc, options, true);
      builder2 = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
      builder2.ele(contents);
    } else if (/^\s*</.test(contents)) {
      const domParser = dom_1.createParser();
      const doc = domParser.parseFromString("<TEMP_ROOT>" + dom_1.sanitizeInput(contents, options.invalidCharReplacement) + "</TEMP_ROOT>", "text/xml");
      dom_1.throwIfParserError(doc);
      setOptions(doc, options, true);
      if (doc.documentElement === null) {
        throw new Error("Document element is null.");
      }
      const frag = doc.createDocumentFragment();
      for (const child of doc.documentElement.childNodes) {
        const newChild = doc.importNode(child, true);
        frag.appendChild(newChild);
      }
      builder2 = new builder_1.XMLBuilderImpl(frag);
    } else {
      const doc = dom_1.createDocument();
      setOptions(doc, options, true);
      builder2 = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
      const obj = JSON.parse(contents);
      builder2.ele(obj);
    }
    return builder2;
  }
  exports.fragment = fragment;
  function convert(p1, p2, p3) {
    let builderOptions;
    let contents;
    let convertOptions;
    if (isXMLBuilderCreateOptions(p1) && p2 !== undefined) {
      builderOptions = p1;
      contents = p2;
      convertOptions = p3;
    } else {
      builderOptions = interfaces_1.DefaultBuilderOptions;
      contents = p1;
      convertOptions = p2 || undefined;
    }
    return create(builderOptions, contents).end(convertOptions);
  }
  exports.convert = convert;
  function createCB(options) {
    return new builder_2.XMLBuilderCBImpl(options);
  }
  exports.createCB = createCB;
  function fragmentCB(options) {
    return new builder_2.XMLBuilderCBImpl(options, true);
  }
  exports.fragmentCB = fragmentCB;
  function isXMLBuilderCreateOptions(obj) {
    if (!util_1.isPlainObject(obj))
      return false;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (!interfaces_1.XMLBuilderOptionKeys.has(key))
          return false;
      }
    }
    return true;
  }
  function formatBuilderOptions(createOptions = {}) {
    const options = util_1.applyDefaults(createOptions, interfaces_1.DefaultBuilderOptions);
    if (options.convert.att.length === 0 || options.convert.ins.length === 0 || options.convert.text.length === 0 || options.convert.cdata.length === 0 || options.convert.comment.length === 0) {
      throw new Error("JS object converter strings cannot be zero length.");
    }
    return options;
  }
  function setOptions(doc, options, isFragment) {
    const docWithSettings = doc;
    docWithSettings._xmlBuilderOptions = options;
    docWithSettings._isFragment = isFragment;
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports, module) => {
  (function() {
    var undefined2;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var { Array: Array2, Date: Date2, Error: Error2, Function: Function2, Math: Math2, Object: Object2, RegExp: RegExp2, String: String2, TypeError: TypeError2 } = context;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object;
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash,
          map: new (Map2 || ListCache),
          string: new Hash
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index, value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, `{
/* [wrapped with ` + details + `] */
`);
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || (key in Object2(object)));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return { done, value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + `
`;
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += `' +
__e(` + escapeValue + `) +
'`;
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += `';
` + evaluateValue + `;
__p += '`;
          }
          if (interpolateValue) {
            source += `' +
((__t = (` + interpolateValue + `)) == null ? '' : __t) +
'`;
          }
          index = offset + match.length;
          return match;
        });
        source += `';
`;
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = `with (obj) {
` + source + `
}
`;
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + `) {
` + (variable ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? `, __j = Array.prototype.join;
` + `function print() { __p += __j.call(arguments, '') }
` : `;
`) + source + `return __p
}`;
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && ("chain" in options)) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined2 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined2 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports);
});

// node_modules/queue/index.js
var require_queue = __commonJS((exports, module) => {
  var inherits = require_inherits();
  var EventEmitter = __require("events").EventEmitter;
  module.exports = Queue;
  module.exports.default = Queue;
  function Queue(options) {
    if (!(this instanceof Queue)) {
      return new Queue(options);
    }
    EventEmitter.call(this);
    options = options || {};
    this.concurrency = options.concurrency || Infinity;
    this.timeout = options.timeout || 0;
    this.autostart = options.autostart || false;
    this.results = options.results || null;
    this.pending = 0;
    this.session = 0;
    this.running = false;
    this.jobs = [];
    this.timers = {};
  }
  inherits(Queue, EventEmitter);
  var arrayMethods = [
    "pop",
    "shift",
    "indexOf",
    "lastIndexOf"
  ];
  arrayMethods.forEach(function(method) {
    Queue.prototype[method] = function() {
      return Array.prototype[method].apply(this.jobs, arguments);
    };
  });
  Queue.prototype.slice = function(begin, end) {
    this.jobs = this.jobs.slice(begin, end);
    return this;
  };
  Queue.prototype.reverse = function() {
    this.jobs.reverse();
    return this;
  };
  var arrayAddMethods = [
    "push",
    "unshift",
    "splice"
  ];
  arrayAddMethods.forEach(function(method) {
    Queue.prototype[method] = function() {
      var methodResult = Array.prototype[method].apply(this.jobs, arguments);
      if (this.autostart) {
        this.start();
      }
      return methodResult;
    };
  });
  Object.defineProperty(Queue.prototype, "length", {
    get: function() {
      return this.pending + this.jobs.length;
    }
  });
  Queue.prototype.start = function(cb) {
    if (cb) {
      callOnErrorOrEnd.call(this, cb);
    }
    this.running = true;
    if (this.pending >= this.concurrency) {
      return;
    }
    if (this.jobs.length === 0) {
      if (this.pending === 0) {
        done.call(this);
      }
      return;
    }
    var self2 = this;
    var job = this.jobs.shift();
    var once = true;
    var session = this.session;
    var timeoutId = null;
    var didTimeout = false;
    var resultIndex = null;
    var timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
    function next(err, result) {
      if (once && self2.session === session) {
        once = false;
        self2.pending--;
        if (timeoutId !== null) {
          delete self2.timers[timeoutId];
          clearTimeout(timeoutId);
        }
        if (err) {
          self2.emit("error", err, job);
        } else if (didTimeout === false) {
          if (resultIndex !== null) {
            self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
          }
          self2.emit("success", result, job);
        }
        if (self2.session === session) {
          if (self2.pending === 0 && self2.jobs.length === 0) {
            done.call(self2);
          } else if (self2.running) {
            self2.start();
          }
        }
      }
    }
    if (timeout) {
      timeoutId = setTimeout(function() {
        didTimeout = true;
        if (self2.listeners("timeout").length > 0) {
          self2.emit("timeout", next, job);
        } else {
          next();
        }
      }, timeout);
      this.timers[timeoutId] = timeoutId;
    }
    if (this.results) {
      resultIndex = this.results.length;
      this.results[resultIndex] = null;
    }
    this.pending++;
    self2.emit("start", job);
    var promise = job(next);
    if (promise && promise.then && typeof promise.then === "function") {
      promise.then(function(result) {
        return next(null, result);
      }).catch(function(err) {
        return next(err || true);
      });
    }
    if (this.running && this.jobs.length > 0) {
      this.start();
    }
  };
  Queue.prototype.stop = function() {
    this.running = false;
  };
  Queue.prototype.end = function(err) {
    clearTimers.call(this);
    this.jobs.length = 0;
    this.pending = 0;
    done.call(this, err);
  };
  function clearTimers() {
    for (var key in this.timers) {
      var timeoutId = this.timers[key];
      delete this.timers[key];
      clearTimeout(timeoutId);
    }
  }
  function callOnErrorOrEnd(cb) {
    var self2 = this;
    this.on("error", onerror);
    this.on("end", onend);
    function onerror(err) {
      self2.end(err);
    }
    function onend(err) {
      self2.removeListener("error", onerror);
      self2.removeListener("end", onend);
      cb(err, this.results);
    }
  }
  function done(err) {
    this.session++;
    this.running = false;
    this.emit("end", err);
  }
});

// node_modules/image-size/dist/types/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findBox = exports.readUInt = exports.readUInt32LE = exports.readUInt32BE = exports.readInt32LE = exports.readUInt24LE = exports.readUInt16LE = exports.readUInt16BE = exports.readInt16LE = exports.toHexString = exports.toUTF8String = undefined;
  var decoder = new TextDecoder;
  var toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));
  exports.toUTF8String = toUTF8String;
  var toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i) => memo + ("0" + i.toString(16)).slice(-2), "");
  exports.toHexString = toHexString;
  var readInt16LE = (input, offset = 0) => {
    const val = input[offset] + input[offset + 1] * 2 ** 8;
    return val | (val & 2 ** 15) * 131070;
  };
  exports.readInt16LE = readInt16LE;
  var readUInt16BE = (input, offset = 0) => input[offset] * 2 ** 8 + input[offset + 1];
  exports.readUInt16BE = readUInt16BE;
  var readUInt16LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8;
  exports.readUInt16LE = readUInt16LE;
  var readUInt24LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16;
  exports.readUInt24LE = readUInt24LE;
  var readInt32LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16 + (input[offset + 3] << 24);
  exports.readInt32LE = readInt32LE;
  var readUInt32BE = (input, offset = 0) => input[offset] * 2 ** 24 + input[offset + 1] * 2 ** 16 + input[offset + 2] * 2 ** 8 + input[offset + 3];
  exports.readUInt32BE = readUInt32BE;
  var readUInt32LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16 + input[offset + 3] * 2 ** 24;
  exports.readUInt32LE = readUInt32LE;
  var methods = {
    readUInt16BE: exports.readUInt16BE,
    readUInt16LE: exports.readUInt16LE,
    readUInt32BE: exports.readUInt32BE,
    readUInt32LE: exports.readUInt32LE
  };
  function readUInt(input, bits, offset, isBigEndian) {
    offset = offset || 0;
    const endian = isBigEndian ? "BE" : "LE";
    const methodName = "readUInt" + bits + endian;
    return methods[methodName](input, offset);
  }
  exports.readUInt = readUInt;
  function readBox(input, offset) {
    if (input.length - offset < 4)
      return;
    const boxSize = (0, exports.readUInt32BE)(input, offset);
    if (input.length - offset < boxSize)
      return;
    return {
      name: (0, exports.toUTF8String)(input, 4 + offset, 8 + offset),
      offset,
      size: boxSize
    };
  }
  function findBox(input, boxName, offset) {
    while (offset < input.length) {
      const box = readBox(input, offset);
      if (!box)
        break;
      if (box.name === boxName)
        return box;
      offset += box.size;
    }
  }
  exports.findBox = findBox;
});

// node_modules/image-size/dist/types/bmp.js
var require_bmp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BMP = undefined;
  var utils_1 = require_utils2();
  exports.BMP = {
    validate: (input) => (0, utils_1.toUTF8String)(input, 0, 2) === "BM",
    calculate: (input) => ({
      height: Math.abs((0, utils_1.readInt32LE)(input, 22)),
      width: (0, utils_1.readUInt32LE)(input, 18)
    })
  };
});

// node_modules/image-size/dist/types/ico.js
var require_ico = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ICO = undefined;
  var utils_1 = require_utils2();
  var TYPE_ICON = 1;
  var SIZE_HEADER = 2 + 2 + 2;
  var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
  function getSizeFromOffset(input, offset) {
    const value = input[offset];
    return value === 0 ? 256 : value;
  }
  function getImageSize(input, imageIndex) {
    const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
    return {
      height: getSizeFromOffset(input, offset + 1),
      width: getSizeFromOffset(input, offset)
    };
  }
  exports.ICO = {
    validate(input) {
      const reserved = (0, utils_1.readUInt16LE)(input, 0);
      const imageCount = (0, utils_1.readUInt16LE)(input, 4);
      if (reserved !== 0 || imageCount === 0)
        return false;
      const imageType2 = (0, utils_1.readUInt16LE)(input, 2);
      return imageType2 === TYPE_ICON;
    },
    calculate(input) {
      const nbImages = (0, utils_1.readUInt16LE)(input, 4);
      const imageSize = getImageSize(input, 0);
      if (nbImages === 1)
        return imageSize;
      const imgs = [imageSize];
      for (let imageIndex = 1;imageIndex < nbImages; imageIndex += 1) {
        imgs.push(getImageSize(input, imageIndex));
      }
      return {
        height: imageSize.height,
        images: imgs,
        width: imageSize.width
      };
    }
  };
});

// node_modules/image-size/dist/types/cur.js
var require_cur = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CUR = undefined;
  var ico_1 = require_ico();
  var utils_1 = require_utils2();
  var TYPE_CURSOR = 2;
  exports.CUR = {
    validate(input) {
      const reserved = (0, utils_1.readUInt16LE)(input, 0);
      const imageCount = (0, utils_1.readUInt16LE)(input, 4);
      if (reserved !== 0 || imageCount === 0)
        return false;
      const imageType2 = (0, utils_1.readUInt16LE)(input, 2);
      return imageType2 === TYPE_CURSOR;
    },
    calculate: (input) => ico_1.ICO.calculate(input)
  };
});

// node_modules/image-size/dist/types/dds.js
var require_dds = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DDS = undefined;
  var utils_1 = require_utils2();
  exports.DDS = {
    validate: (input) => (0, utils_1.readUInt32LE)(input, 0) === 542327876,
    calculate: (input) => ({
      height: (0, utils_1.readUInt32LE)(input, 12),
      width: (0, utils_1.readUInt32LE)(input, 16)
    })
  };
});

// node_modules/image-size/dist/types/gif.js
var require_gif = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GIF = undefined;
  var utils_1 = require_utils2();
  var gifRegexp = /^GIF8[79]a/;
  exports.GIF = {
    validate: (input) => gifRegexp.test((0, utils_1.toUTF8String)(input, 0, 6)),
    calculate: (input) => ({
      height: (0, utils_1.readUInt16LE)(input, 8),
      width: (0, utils_1.readUInt16LE)(input, 6)
    })
  };
});

// node_modules/image-size/dist/types/heif.js
var require_heif = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HEIF = undefined;
  var utils_1 = require_utils2();
  var brandMap = {
    avif: "avif",
    mif1: "heif",
    msf1: "heif",
    heic: "heic",
    heix: "heic",
    hevc: "heic",
    hevx: "heic"
  };
  exports.HEIF = {
    validate(input) {
      const boxType = (0, utils_1.toUTF8String)(input, 4, 8);
      if (boxType !== "ftyp")
        return false;
      const ftypBox = (0, utils_1.findBox)(input, "ftyp", 0);
      if (!ftypBox)
        return false;
      const brand = (0, utils_1.toUTF8String)(input, ftypBox.offset + 8, ftypBox.offset + 12);
      return brand in brandMap;
    },
    calculate(input) {
      const metaBox = (0, utils_1.findBox)(input, "meta", 0);
      const iprpBox = metaBox && (0, utils_1.findBox)(input, "iprp", metaBox.offset + 12);
      const ipcoBox = iprpBox && (0, utils_1.findBox)(input, "ipco", iprpBox.offset + 8);
      const ispeBox = ipcoBox && (0, utils_1.findBox)(input, "ispe", ipcoBox.offset + 8);
      if (ispeBox) {
        return {
          height: (0, utils_1.readUInt32BE)(input, ispeBox.offset + 16),
          width: (0, utils_1.readUInt32BE)(input, ispeBox.offset + 12),
          type: (0, utils_1.toUTF8String)(input, 8, 12)
        };
      }
      throw new TypeError("Invalid HEIF, no size found");
    }
  };
});

// node_modules/image-size/dist/types/icns.js
var require_icns = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ICNS = undefined;
  var utils_1 = require_utils2();
  var SIZE_HEADER = 4 + 4;
  var FILE_LENGTH_OFFSET = 4;
  var ENTRY_LENGTH_OFFSET = 4;
  var ICON_TYPE_SIZE = {
    ICON: 32,
    "ICN#": 32,
    "icm#": 16,
    icm4: 16,
    icm8: 16,
    "ics#": 16,
    ics4: 16,
    ics8: 16,
    is32: 16,
    s8mk: 16,
    icp4: 16,
    icl4: 32,
    icl8: 32,
    il32: 32,
    l8mk: 32,
    icp5: 32,
    ic11: 32,
    ich4: 48,
    ich8: 48,
    ih32: 48,
    h8mk: 48,
    icp6: 64,
    ic12: 32,
    it32: 128,
    t8mk: 128,
    ic07: 128,
    ic08: 256,
    ic13: 256,
    ic09: 512,
    ic14: 512,
    ic10: 1024
  };
  function readImageHeader(input, imageOffset) {
    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
    return [
      (0, utils_1.toUTF8String)(input, imageOffset, imageLengthOffset),
      (0, utils_1.readUInt32BE)(input, imageLengthOffset)
    ];
  }
  function getImageSize(type) {
    const size = ICON_TYPE_SIZE[type];
    return { width: size, height: size, type };
  }
  exports.ICNS = {
    validate: (input) => (0, utils_1.toUTF8String)(input, 0, 4) === "icns",
    calculate(input) {
      const inputLength = input.length;
      const fileLength = (0, utils_1.readUInt32BE)(input, FILE_LENGTH_OFFSET);
      let imageOffset = SIZE_HEADER;
      let imageHeader = readImageHeader(input, imageOffset);
      let imageSize = getImageSize(imageHeader[0]);
      imageOffset += imageHeader[1];
      if (imageOffset === fileLength)
        return imageSize;
      const result = {
        height: imageSize.height,
        images: [imageSize],
        width: imageSize.width
      };
      while (imageOffset < fileLength && imageOffset < inputLength) {
        imageHeader = readImageHeader(input, imageOffset);
        imageSize = getImageSize(imageHeader[0]);
        imageOffset += imageHeader[1];
        result.images.push(imageSize);
      }
      return result;
    }
  };
});

// node_modules/image-size/dist/types/j2c.js
var require_j2c = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.J2C = undefined;
  var utils_1 = require_utils2();
  exports.J2C = {
    validate: (input) => (0, utils_1.readUInt32BE)(input, 0) === 4283432785,
    calculate: (input) => ({
      height: (0, utils_1.readUInt32BE)(input, 12),
      width: (0, utils_1.readUInt32BE)(input, 8)
    })
  };
});

// node_modules/image-size/dist/types/jp2.js
var require_jp2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JP2 = undefined;
  var utils_1 = require_utils2();
  exports.JP2 = {
    validate(input) {
      const boxType = (0, utils_1.toUTF8String)(input, 4, 8);
      if (boxType !== "jP  ")
        return false;
      const ftypBox = (0, utils_1.findBox)(input, "ftyp", 0);
      if (!ftypBox)
        return false;
      const brand = (0, utils_1.toUTF8String)(input, ftypBox.offset + 8, ftypBox.offset + 12);
      return brand === "jp2 ";
    },
    calculate(input) {
      const jp2hBox = (0, utils_1.findBox)(input, "jp2h", 0);
      const ihdrBox = jp2hBox && (0, utils_1.findBox)(input, "ihdr", jp2hBox.offset + 8);
      if (ihdrBox) {
        return {
          height: (0, utils_1.readUInt32BE)(input, ihdrBox.offset + 8),
          width: (0, utils_1.readUInt32BE)(input, ihdrBox.offset + 12)
        };
      }
      throw new TypeError("Unsupported JPEG 2000 format");
    }
  };
});

// node_modules/image-size/dist/types/jpg.js
var require_jpg = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JPG = undefined;
  var utils_1 = require_utils2();
  var EXIF_MARKER = "45786966";
  var APP1_DATA_SIZE_BYTES = 2;
  var EXIF_HEADER_BYTES = 6;
  var TIFF_BYTE_ALIGN_BYTES = 2;
  var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
  var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
  var IDF_ENTRY_BYTES = 12;
  var NUM_DIRECTORY_ENTRIES_BYTES = 2;
  function isEXIF(input) {
    return (0, utils_1.toHexString)(input, 2, 6) === EXIF_MARKER;
  }
  function extractSize(input, index) {
    return {
      height: (0, utils_1.readUInt16BE)(input, index),
      width: (0, utils_1.readUInt16BE)(input, index + 2)
    };
  }
  function extractOrientation(exifBlock, isBigEndian) {
    const idfOffset = 8;
    const offset = EXIF_HEADER_BYTES + idfOffset;
    const idfDirectoryEntries = (0, utils_1.readUInt)(exifBlock, 16, offset, isBigEndian);
    for (let directoryEntryNumber = 0;directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
      const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
      const end = start + IDF_ENTRY_BYTES;
      if (start > exifBlock.length) {
        return;
      }
      const block = exifBlock.slice(start, end);
      const tagNumber = (0, utils_1.readUInt)(block, 16, 0, isBigEndian);
      if (tagNumber === 274) {
        const dataFormat = (0, utils_1.readUInt)(block, 16, 2, isBigEndian);
        if (dataFormat !== 3) {
          return;
        }
        const numberOfComponents = (0, utils_1.readUInt)(block, 32, 4, isBigEndian);
        if (numberOfComponents !== 1) {
          return;
        }
        return (0, utils_1.readUInt)(block, 16, 8, isBigEndian);
      }
    }
  }
  function validateExifBlock(input, index) {
    const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
    const byteAlign = (0, utils_1.toHexString)(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
    if (isBigEndian || isLittleEndian) {
      return extractOrientation(exifBlock, isBigEndian);
    }
  }
  function validateInput(input, index) {
    if (index > input.length) {
      throw new TypeError("Corrupt JPG, exceeded buffer limits");
    }
  }
  exports.JPG = {
    validate: (input) => (0, utils_1.toHexString)(input, 0, 2) === "ffd8",
    calculate(input) {
      input = input.slice(4);
      let orientation;
      let next;
      while (input.length) {
        const i = (0, utils_1.readUInt16BE)(input, 0);
        if (input[i] !== 255) {
          input = input.slice(1);
          continue;
        }
        if (isEXIF(input)) {
          orientation = validateExifBlock(input, i);
        }
        validateInput(input, i);
        next = input[i + 1];
        if (next === 192 || next === 193 || next === 194) {
          const size = extractSize(input, i + 5);
          if (!orientation) {
            return size;
          }
          return {
            height: size.height,
            orientation,
            width: size.width
          };
        }
        input = input.slice(i + 2);
      }
      throw new TypeError("Invalid JPG, no size found");
    }
  };
});

// node_modules/image-size/dist/utils/bit-reader.js
var require_bit_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BitReader = undefined;

  class BitReader {
    constructor(input, endianness) {
      this.input = input;
      this.endianness = endianness;
      this.byteOffset = 2;
      this.bitOffset = 0;
    }
    getBits(length = 1) {
      let result = 0;
      let bitsRead = 0;
      while (bitsRead < length) {
        if (this.byteOffset >= this.input.length) {
          throw new Error("Reached end of input");
        }
        const currentByte = this.input[this.byteOffset];
        const bitsLeft = 8 - this.bitOffset;
        const bitsToRead = Math.min(length - bitsRead, bitsLeft);
        if (this.endianness === "little-endian") {
          const mask = (1 << bitsToRead) - 1;
          const bits = currentByte >> this.bitOffset & mask;
          result |= bits << bitsRead;
        } else {
          const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;
          const bits = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;
          result = result << bitsToRead | bits;
        }
        bitsRead += bitsToRead;
        this.bitOffset += bitsToRead;
        if (this.bitOffset === 8) {
          this.byteOffset++;
          this.bitOffset = 0;
        }
      }
      return result;
    }
  }
  exports.BitReader = BitReader;
});

// node_modules/image-size/dist/types/jxl-stream.js
var require_jxl_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JXLStream = undefined;
  var utils_1 = require_utils2();
  var bit_reader_1 = require_bit_reader();
  function calculateImageDimension(reader, isSmallImage) {
    if (isSmallImage) {
      return 8 * (1 + reader.getBits(5));
    } else {
      const sizeClass = reader.getBits(2);
      const extraBits = [9, 13, 18, 30][sizeClass];
      return 1 + reader.getBits(extraBits);
    }
  }
  function calculateImageWidth(reader, isSmallImage, widthMode, height) {
    if (isSmallImage && widthMode === 0) {
      return 8 * (1 + reader.getBits(5));
    } else if (widthMode === 0) {
      return calculateImageDimension(reader, false);
    } else {
      const aspectRatios = [1, 1.2, 4 / 3, 1.5, 16 / 9, 5 / 4, 2];
      return Math.floor(height * aspectRatios[widthMode - 1]);
    }
  }
  exports.JXLStream = {
    validate: (input) => {
      return (0, utils_1.toHexString)(input, 0, 2) === "ff0a";
    },
    calculate(input) {
      const reader = new bit_reader_1.BitReader(input, "little-endian");
      const isSmallImage = reader.getBits(1) === 1;
      const height = calculateImageDimension(reader, isSmallImage);
      const widthMode = reader.getBits(3);
      const width = calculateImageWidth(reader, isSmallImage, widthMode, height);
      return { width, height };
    }
  };
});

// node_modules/image-size/dist/types/jxl.js
var require_jxl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JXL = undefined;
  var utils_1 = require_utils2();
  var jxl_stream_1 = require_jxl_stream();
  function extractCodestream(input) {
    const jxlcBox = (0, utils_1.findBox)(input, "jxlc", 0);
    if (jxlcBox) {
      return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);
    }
    const partialStreams = extractPartialStreams(input);
    if (partialStreams.length > 0) {
      return concatenateCodestreams(partialStreams);
    }
    return;
  }
  function extractPartialStreams(input) {
    const partialStreams = [];
    let offset = 0;
    while (offset < input.length) {
      const jxlpBox = (0, utils_1.findBox)(input, "jxlp", offset);
      if (!jxlpBox)
        break;
      partialStreams.push(input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size));
      offset = jxlpBox.offset + jxlpBox.size;
    }
    return partialStreams;
  }
  function concatenateCodestreams(partialCodestreams) {
    const totalLength = partialCodestreams.reduce((acc, curr) => acc + curr.length, 0);
    const codestream = new Uint8Array(totalLength);
    let position = 0;
    for (const partial of partialCodestreams) {
      codestream.set(partial, position);
      position += partial.length;
    }
    return codestream;
  }
  exports.JXL = {
    validate: (input) => {
      const boxType = (0, utils_1.toUTF8String)(input, 4, 8);
      if (boxType !== "JXL ")
        return false;
      const ftypBox = (0, utils_1.findBox)(input, "ftyp", 0);
      if (!ftypBox)
        return false;
      const brand = (0, utils_1.toUTF8String)(input, ftypBox.offset + 8, ftypBox.offset + 12);
      return brand === "jxl ";
    },
    calculate(input) {
      const codestream = extractCodestream(input);
      if (codestream)
        return jxl_stream_1.JXLStream.calculate(codestream);
      throw new Error("No codestream found in JXL container");
    }
  };
});

// node_modules/image-size/dist/types/ktx.js
var require_ktx = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KTX = undefined;
  var utils_1 = require_utils2();
  exports.KTX = {
    validate: (input) => {
      const signature = (0, utils_1.toUTF8String)(input, 1, 7);
      return ["KTX 11", "KTX 20"].includes(signature);
    },
    calculate: (input) => {
      const type = input[5] === 49 ? "ktx" : "ktx2";
      const offset = type === "ktx" ? 36 : 20;
      return {
        height: (0, utils_1.readUInt32LE)(input, offset + 4),
        width: (0, utils_1.readUInt32LE)(input, offset),
        type
      };
    }
  };
});

// node_modules/image-size/dist/types/png.js
var require_png = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PNG = undefined;
  var utils_1 = require_utils2();
  var pngSignature = `PNG\r
\x1A
`;
  var pngImageHeaderChunkName = "IHDR";
  var pngFriedChunkName = "CgBI";
  exports.PNG = {
    validate(input) {
      if (pngSignature === (0, utils_1.toUTF8String)(input, 1, 8)) {
        let chunkName = (0, utils_1.toUTF8String)(input, 12, 16);
        if (chunkName === pngFriedChunkName) {
          chunkName = (0, utils_1.toUTF8String)(input, 28, 32);
        }
        if (chunkName !== pngImageHeaderChunkName) {
          throw new TypeError("Invalid PNG");
        }
        return true;
      }
      return false;
    },
    calculate(input) {
      if ((0, utils_1.toUTF8String)(input, 12, 16) === pngFriedChunkName) {
        return {
          height: (0, utils_1.readUInt32BE)(input, 36),
          width: (0, utils_1.readUInt32BE)(input, 32)
        };
      }
      return {
        height: (0, utils_1.readUInt32BE)(input, 20),
        width: (0, utils_1.readUInt32BE)(input, 16)
      };
    }
  };
});

// node_modules/image-size/dist/types/pnm.js
var require_pnm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PNM = undefined;
  var utils_1 = require_utils2();
  var PNMTypes = {
    P1: "pbm/ascii",
    P2: "pgm/ascii",
    P3: "ppm/ascii",
    P4: "pbm",
    P5: "pgm",
    P6: "ppm",
    P7: "pam",
    PF: "pfm"
  };
  var handlers = {
    default: (lines) => {
      let dimensions = [];
      while (lines.length > 0) {
        const line = lines.shift();
        if (line[0] === "#") {
          continue;
        }
        dimensions = line.split(" ");
        break;
      }
      if (dimensions.length === 2) {
        return {
          height: parseInt(dimensions[1], 10),
          width: parseInt(dimensions[0], 10)
        };
      } else {
        throw new TypeError("Invalid PNM");
      }
    },
    pam: (lines) => {
      const size = {};
      while (lines.length > 0) {
        const line = lines.shift();
        if (line.length > 16 || line.charCodeAt(0) > 128) {
          continue;
        }
        const [key, value] = line.split(" ");
        if (key && value) {
          size[key.toLowerCase()] = parseInt(value, 10);
        }
        if (size.height && size.width) {
          break;
        }
      }
      if (size.height && size.width) {
        return {
          height: size.height,
          width: size.width
        };
      } else {
        throw new TypeError("Invalid PAM");
      }
    }
  };
  exports.PNM = {
    validate: (input) => ((0, utils_1.toUTF8String)(input, 0, 2) in PNMTypes),
    calculate(input) {
      const signature = (0, utils_1.toUTF8String)(input, 0, 2);
      const type = PNMTypes[signature];
      const lines = (0, utils_1.toUTF8String)(input, 3).split(/[\r\n]+/);
      const handler = handlers[type] || handlers.default;
      return handler(lines);
    }
  };
});

// node_modules/image-size/dist/types/psd.js
var require_psd = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PSD = undefined;
  var utils_1 = require_utils2();
  exports.PSD = {
    validate: (input) => (0, utils_1.toUTF8String)(input, 0, 4) === "8BPS",
    calculate: (input) => ({
      height: (0, utils_1.readUInt32BE)(input, 14),
      width: (0, utils_1.readUInt32BE)(input, 18)
    })
  };
});

// node_modules/image-size/dist/types/svg.js
var require_svg = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SVG = undefined;
  var utils_1 = require_utils2();
  var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
  var extractorRegExps = {
    height: /\sheight=(['"])([^%]+?)\1/,
    root: svgReg,
    viewbox: /\sviewBox=(['"])(.+?)\1/i,
    width: /\swidth=(['"])([^%]+?)\1/
  };
  var INCH_CM = 2.54;
  var units = {
    in: 96,
    cm: 96 / INCH_CM,
    em: 16,
    ex: 8,
    m: 96 / INCH_CM * 100,
    mm: 96 / INCH_CM / 10,
    pc: 96 / 72 / 12,
    pt: 96 / 72,
    px: 1
  };
  var unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`);
  function parseLength(len) {
    const m = unitsReg.exec(len);
    if (!m) {
      return;
    }
    return Math.round(Number(m[1]) * (units[m[2]] || 1));
  }
  function parseViewbox(viewbox) {
    const bounds = viewbox.split(" ");
    return {
      height: parseLength(bounds[3]),
      width: parseLength(bounds[2])
    };
  }
  function parseAttributes(root) {
    const width = root.match(extractorRegExps.width);
    const height = root.match(extractorRegExps.height);
    const viewbox = root.match(extractorRegExps.viewbox);
    return {
      height: height && parseLength(height[2]),
      viewbox: viewbox && parseViewbox(viewbox[2]),
      width: width && parseLength(width[2])
    };
  }
  function calculateByDimensions(attrs) {
    return {
      height: attrs.height,
      width: attrs.width
    };
  }
  function calculateByViewbox(attrs, viewbox) {
    const ratio = viewbox.width / viewbox.height;
    if (attrs.width) {
      return {
        height: Math.floor(attrs.width / ratio),
        width: attrs.width
      };
    }
    if (attrs.height) {
      return {
        height: attrs.height,
        width: Math.floor(attrs.height * ratio)
      };
    }
    return {
      height: viewbox.height,
      width: viewbox.width
    };
  }
  exports.SVG = {
    validate: (input) => svgReg.test((0, utils_1.toUTF8String)(input, 0, 1000)),
    calculate(input) {
      const root = (0, utils_1.toUTF8String)(input).match(extractorRegExps.root);
      if (root) {
        const attrs = parseAttributes(root[0]);
        if (attrs.width && attrs.height) {
          return calculateByDimensions(attrs);
        }
        if (attrs.viewbox) {
          return calculateByViewbox(attrs, attrs.viewbox);
        }
      }
      throw new TypeError("Invalid SVG");
    }
  };
});

// node_modules/image-size/dist/types/tga.js
var require_tga = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TGA = undefined;
  var utils_1 = require_utils2();
  exports.TGA = {
    validate(input) {
      return (0, utils_1.readUInt16LE)(input, 0) === 0 && (0, utils_1.readUInt16LE)(input, 4) === 0;
    },
    calculate(input) {
      return {
        height: (0, utils_1.readUInt16LE)(input, 14),
        width: (0, utils_1.readUInt16LE)(input, 12)
      };
    }
  };
});

// node_modules/image-size/dist/types/tiff.js
var require_tiff = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TIFF = undefined;
  var fs = __require("fs");
  var utils_1 = require_utils2();
  function readIFD(input, filepath, isBigEndian) {
    const ifdOffset = (0, utils_1.readUInt)(input, 32, 4, isBigEndian);
    let bufferSize = 1024;
    const fileSize = fs.statSync(filepath).size;
    if (ifdOffset + bufferSize > fileSize) {
      bufferSize = fileSize - ifdOffset - 10;
    }
    const endBuffer = new Uint8Array(bufferSize);
    const descriptor = fs.openSync(filepath, "r");
    fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);
    fs.closeSync(descriptor);
    return endBuffer.slice(2);
  }
  function readValue(input, isBigEndian) {
    const low = (0, utils_1.readUInt)(input, 16, 8, isBigEndian);
    const high = (0, utils_1.readUInt)(input, 16, 10, isBigEndian);
    return (high << 16) + low;
  }
  function nextTag(input) {
    if (input.length > 24) {
      return input.slice(12);
    }
  }
  function extractTags(input, isBigEndian) {
    const tags = {};
    let temp = input;
    while (temp && temp.length) {
      const code = (0, utils_1.readUInt)(temp, 16, 0, isBigEndian);
      const type = (0, utils_1.readUInt)(temp, 16, 2, isBigEndian);
      const length = (0, utils_1.readUInt)(temp, 32, 4, isBigEndian);
      if (code === 0) {
        break;
      } else {
        if (length === 1 && (type === 3 || type === 4)) {
          tags[code] = readValue(temp, isBigEndian);
        }
        temp = nextTag(temp);
      }
    }
    return tags;
  }
  function determineEndianness(input) {
    const signature = (0, utils_1.toUTF8String)(input, 0, 2);
    if (signature === "II") {
      return "LE";
    } else if (signature === "MM") {
      return "BE";
    }
  }
  var signatures = [
    "49492a00",
    "4d4d002a"
  ];
  exports.TIFF = {
    validate: (input) => signatures.includes((0, utils_1.toHexString)(input, 0, 4)),
    calculate(input, filepath) {
      if (!filepath) {
        throw new TypeError("Tiff doesn't support buffer");
      }
      const isBigEndian = determineEndianness(input) === "BE";
      const ifdBuffer = readIFD(input, filepath, isBigEndian);
      const tags = extractTags(ifdBuffer, isBigEndian);
      const width = tags[256];
      const height = tags[257];
      if (!width || !height) {
        throw new TypeError("Invalid Tiff. Missing tags");
      }
      return { height, width };
    }
  };
});

// node_modules/image-size/dist/types/webp.js
var require_webp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WEBP = undefined;
  var utils_1 = require_utils2();
  function calculateExtended(input) {
    return {
      height: 1 + (0, utils_1.readUInt24LE)(input, 7),
      width: 1 + (0, utils_1.readUInt24LE)(input, 4)
    };
  }
  function calculateLossless(input) {
    return {
      height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
      width: 1 + ((input[2] & 63) << 8 | input[1])
    };
  }
  function calculateLossy(input) {
    return {
      height: (0, utils_1.readInt16LE)(input, 8) & 16383,
      width: (0, utils_1.readInt16LE)(input, 6) & 16383
    };
  }
  exports.WEBP = {
    validate(input) {
      const riffHeader = (0, utils_1.toUTF8String)(input, 0, 4) === "RIFF";
      const webpHeader = (0, utils_1.toUTF8String)(input, 8, 12) === "WEBP";
      const vp8Header = (0, utils_1.toUTF8String)(input, 12, 15) === "VP8";
      return riffHeader && webpHeader && vp8Header;
    },
    calculate(input) {
      const chunkHeader = (0, utils_1.toUTF8String)(input, 12, 16);
      input = input.slice(20, 30);
      if (chunkHeader === "VP8X") {
        const extendedHeader = input[0];
        const validStart = (extendedHeader & 192) === 0;
        const validEnd = (extendedHeader & 1) === 0;
        if (validStart && validEnd) {
          return calculateExtended(input);
        } else {
          throw new TypeError("Invalid WebP");
        }
      }
      if (chunkHeader === "VP8 " && input[0] !== 47) {
        return calculateLossy(input);
      }
      const signature = (0, utils_1.toHexString)(input, 3, 6);
      if (chunkHeader === "VP8L" && signature !== "9d012a") {
        return calculateLossless(input);
      }
      throw new TypeError("Invalid WebP");
    }
  };
});

// node_modules/image-size/dist/types/index.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.typeHandlers = undefined;
  var bmp_1 = require_bmp();
  var cur_1 = require_cur();
  var dds_1 = require_dds();
  var gif_1 = require_gif();
  var heif_1 = require_heif();
  var icns_1 = require_icns();
  var ico_1 = require_ico();
  var j2c_1 = require_j2c();
  var jp2_1 = require_jp2();
  var jpg_1 = require_jpg();
  var jxl_1 = require_jxl();
  var jxl_stream_1 = require_jxl_stream();
  var ktx_1 = require_ktx();
  var png_1 = require_png();
  var pnm_1 = require_pnm();
  var psd_1 = require_psd();
  var svg_1 = require_svg();
  var tga_1 = require_tga();
  var tiff_1 = require_tiff();
  var webp_1 = require_webp();
  exports.typeHandlers = {
    bmp: bmp_1.BMP,
    cur: cur_1.CUR,
    dds: dds_1.DDS,
    gif: gif_1.GIF,
    heif: heif_1.HEIF,
    icns: icns_1.ICNS,
    ico: ico_1.ICO,
    j2c: j2c_1.J2C,
    jp2: jp2_1.JP2,
    jpg: jpg_1.JPG,
    jxl: jxl_1.JXL,
    "jxl-stream": jxl_stream_1.JXLStream,
    ktx: ktx_1.KTX,
    png: png_1.PNG,
    pnm: pnm_1.PNM,
    psd: psd_1.PSD,
    svg: svg_1.SVG,
    tga: tga_1.TGA,
    tiff: tiff_1.TIFF,
    webp: webp_1.WEBP
  };
});

// node_modules/image-size/dist/detector.js
var require_detector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.detector = undefined;
  var index_1 = require_types();
  var keys = Object.keys(index_1.typeHandlers);
  var firstBytes = {
    56: "psd",
    66: "bmp",
    68: "dds",
    71: "gif",
    73: "tiff",
    77: "tiff",
    82: "webp",
    105: "icns",
    137: "png",
    255: "jpg"
  };
  function detector(input) {
    const byte = input[0];
    if (byte in firstBytes) {
      const type = firstBytes[byte];
      if (type && index_1.typeHandlers[type].validate(input)) {
        return type;
      }
    }
    const finder = (key) => index_1.typeHandlers[key].validate(input);
    return keys.find(finder);
  }
  exports.detector = detector;
});

// node_modules/image-size/dist/index.js
var require_dist = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = undefined;
  var fs = __require("fs");
  var path = __require("path");
  var queue_1 = require_queue();
  var index_1 = require_types();
  var detector_1 = require_detector();
  var MaxInputSize = 512 * 1024;
  var queue = new queue_1.default({ concurrency: 100, autostart: true });
  var globalOptions = {
    disabledFS: false,
    disabledTypes: []
  };
  function lookup(input, filepath) {
    const type = (0, detector_1.detector)(input);
    if (typeof type !== "undefined") {
      if (globalOptions.disabledTypes.indexOf(type) > -1) {
        throw new TypeError("disabled file type: " + type);
      }
      if (type in index_1.typeHandlers) {
        const size = index_1.typeHandlers[type].calculate(input, filepath);
        if (size !== undefined) {
          size.type = size.type ?? type;
          return size;
        }
      }
    }
    throw new TypeError("unsupported file type: " + type + " (file: " + filepath + ")");
  }
  async function readFileAsync(filepath) {
    const handle = await fs.promises.open(filepath, "r");
    try {
      const { size } = await handle.stat();
      if (size <= 0) {
        throw new Error("Empty file");
      }
      const inputSize = Math.min(size, MaxInputSize);
      const input = new Uint8Array(inputSize);
      await handle.read(input, 0, inputSize, 0);
      return input;
    } finally {
      await handle.close();
    }
  }
  function readFileSync(filepath) {
    const descriptor = fs.openSync(filepath, "r");
    try {
      const { size } = fs.fstatSync(descriptor);
      if (size <= 0) {
        throw new Error("Empty file");
      }
      const inputSize = Math.min(size, MaxInputSize);
      const input = new Uint8Array(inputSize);
      fs.readSync(descriptor, input, 0, inputSize, 0);
      return input;
    } finally {
      fs.closeSync(descriptor);
    }
  }
  module.exports = exports = imageSize;
  exports.default = imageSize;
  function imageSize(input, callback) {
    if (input instanceof Uint8Array) {
      return lookup(input);
    }
    if (typeof input !== "string" || globalOptions.disabledFS) {
      throw new TypeError("invalid invocation. input should be a Uint8Array");
    }
    const filepath = path.resolve(input);
    if (typeof callback === "function") {
      queue.push(() => readFileAsync(filepath).then((input2) => process.nextTick(callback, null, lookup(input2, filepath))).catch(callback));
    } else {
      const input2 = readFileSync(filepath);
      return lookup(input2, filepath);
    }
  }
  exports.imageSize = imageSize;
  var disableFS = (v) => {
    globalOptions.disabledFS = v;
  };
  exports.disableFS = disableFS;
  var disableTypes = (types) => {
    globalOptions.disabledTypes = types;
  };
  exports.disableTypes = disableTypes;
  var setConcurrency = (c) => {
    queue.concurrency = c;
  };
  exports.setConcurrency = setConcurrency;
  exports.types = Object.keys(index_1.typeHandlers);
});

// node_modules/virtual-dom/vnode/is-vtext.js
var require_is_vtext = __commonJS((exports, module) => {
  var version = require_version();
  module.exports = isVirtualText;
  function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version;
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/peek-readable/lib/Errors.js
var defaultMessages = "End-Of-Stream", EndOfStreamError, AbortError;
var init_Errors = __esm(() => {
  EndOfStreamError = class EndOfStreamError extends Error {
    constructor() {
      super(defaultMessages);
      this.name = "EndOfStreamError";
    }
  };
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted") {
      super(message);
      this.name = "AbortError";
    }
  };
});

// node_modules/peek-readable/lib/Deferred.js
class Deferred {
  constructor() {
    this.resolve = () => null;
    this.reject = () => null;
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
}

// node_modules/peek-readable/lib/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.maxStreamReadSize = 1 * 1024 * 1024;
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, offset, length) {
    const bytesRead = await this.read(uint8Array, offset, length);
    this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
    return bytesRead;
  }
  async read(buffer, offset, length) {
    if (length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer, offset, length);
    bytesRead += await this.readRemainderFromStream(buffer, offset + bytesRead, length - bytesRead);
    if (bytesRead === 0) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer, offset, length) {
    let remaining = length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, offset, initialRemaining) {
    let remaining = initialRemaining;
    let bytesRead = 0;
    while (remaining > 0 && !this.endOfStream) {
      const reqLen = Math.min(remaining, this.maxStreamReadSize);
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
      remaining -= chunkLen;
    }
    return bytesRead;
  }
}
var init_AbstractStreamReader = __esm(() => {
  init_Errors();
});

// node_modules/peek-readable/lib/StreamReader.js
var StreamReader;
var init_StreamReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  StreamReader = class StreamReader extends AbstractStreamReader {
    constructor(s) {
      super();
      this.s = s;
      this.deferred = null;
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.resolve(0);
        }
      });
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.abort());
    }
    async readFromStream(buffer, offset, length) {
      const readBuffer = this.s.read(length);
      if (readBuffer) {
        buffer.set(readBuffer, offset);
        return readBuffer.length;
      }
      const request = {
        buffer,
        offset,
        length,
        deferred: new Deferred
      };
      this.deferred = request.deferred;
      this.s.once("readable", () => {
        this.readDeferred(request);
      });
      return request.deferred.promise;
    }
    readDeferred(request) {
      const readBuffer = this.s.read(request.length);
      if (readBuffer) {
        request.buffer.set(readBuffer, request.offset);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.interrupted = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
    async abort() {
      this.reject(new AbortError);
    }
    async close() {
      return this.abort();
    }
  };
});

// node_modules/peek-readable/lib/WebStreamReader.js
var WebStreamReader;
var init_WebStreamReader = __esm(() => {
  init_AbstractStreamReader();
  WebStreamReader = class WebStreamReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };
});

// node_modules/peek-readable/lib/WebStreamByobReader.js
var WebStreamByobReader;
var init_WebStreamByobReader = __esm(() => {
  init_WebStreamReader();
  WebStreamByobReader = class WebStreamByobReader extends WebStreamReader {
    async readFromStream(buffer, offset, length) {
      const result = await this.reader.read(new Uint8Array(length));
      if (result.done) {
        this.endOfStream = result.done;
      }
      if (result.value) {
        buffer.set(result.value, offset);
        return result.value.byteLength;
      }
      return 0;
    }
  };
});

// node_modules/peek-readable/lib/WebStreamDefaultReader.js
var WebStreamDefaultReader;
var init_WebStreamDefaultReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  WebStreamDefaultReader = class WebStreamDefaultReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
      this.buffer = null;
      this.bufferOffset = 0;
    }
    async readFromStream(buffer, offset, length) {
      let totalBytesRead = 0;
      if (this.buffer) {
        const remainingInBuffer = this.buffer.byteLength - this.bufferOffset;
        const toCopy = Math.min(remainingInBuffer, length);
        buffer.set(this.buffer.subarray(this.bufferOffset, this.bufferOffset + toCopy), offset);
        this.bufferOffset += toCopy;
        totalBytesRead += toCopy;
        length -= toCopy;
        offset += toCopy;
        if (this.bufferOffset >= this.buffer.byteLength) {
          this.buffer = null;
          this.bufferOffset = 0;
        }
      }
      while (length > 0 && !this.endOfStream) {
        const result = await this.reader.read();
        if (result.done) {
          this.endOfStream = true;
          break;
        }
        if (result.value) {
          const chunk = result.value;
          if (chunk.byteLength > length) {
            buffer.set(chunk.subarray(0, length), offset);
            this.buffer = chunk;
            this.bufferOffset = length;
            totalBytesRead += length;
            return totalBytesRead;
          }
          buffer.set(chunk, offset);
          totalBytesRead += chunk.byteLength;
          length -= chunk.byteLength;
          offset += chunk.byteLength;
        }
      }
      if (totalBytesRead === 0 && this.endOfStream) {
        throw new EndOfStreamError;
      }
      return totalBytesRead;
    }
    abort() {
      this.interrupted = true;
      return this.reader.cancel();
    }
    async close() {
      await this.abort();
      this.reader.releaseLock();
    }
  };
});

// node_modules/peek-readable/lib/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error) {
    if (error instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error;
  }
}
var init_WebStreamReaderFactory = __esm(() => {
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
});

// node_modules/peek-readable/lib/index.js
var init_lib = __esm(() => {
  init_Errors();
  init_StreamReader();
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
  init_WebStreamReaderFactory();
});

// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}
var init_AbstractTokenizer = __esm(() => {
  init_lib();
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000, ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_lib();
  ReadStreamTokenizer = class ReadStreamTokenizer extends AbstractTokenizer {
    constructor(streamReader, options) {
      super(options);
      this.streamReader = streamReader;
      this.fileInfo = options?.fileInfo ?? {};
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      }
      if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array, 0, normOptions.length);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes));
          return bytesRead - skipBytes;
        }
        if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array, 0, normOptions.length);
        } catch (err) {
          if (options?.mayBeLess && err instanceof EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };
});

// node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm(() => {
  init_lib();
  init_AbstractTokenizer();
  BufferTokenizer = class BufferTokenizer extends AbstractTokenizer {
    constructor(uint8Array, options) {
      super(options);
      this.uint8Array = uint8Array;
      this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    async readBuffer(uint8Array, options) {
      if (options?.position) {
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new EndOfStreamError;
      }
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
      return bytes2read;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(position) {
      this.position = position;
    }
  };
});

// node_modules/strtok3/lib/core.js
function fromStream(stream, options) {
  const streamReader = new StreamReader(stream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await streamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(streamReader, _options);
}
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
var init_core = __esm(() => {
  init_lib();
  init_ReadStreamTokenizer();
  init_BufferTokenizer();
  init_lib();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/FileTokenizer.js
import { open as fsOpen } from "node:fs/promises";
var FileTokenizer;
var init_FileTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_lib();
  FileTokenizer = class FileTokenizer extends AbstractTokenizer {
    static async fromFile(sourceFilePath) {
      const fileHandle = await fsOpen(sourceFilePath, "r");
      const stat = await fileHandle.stat();
      return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
    }
    constructor(fileHandle, options) {
      super(options);
      this.fileHandle = fileHandle;
      this.fileInfo = options.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      this.position = normOptions.position;
      if (normOptions.length === 0)
        return 0;
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      this.position += res.bytesRead;
      if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async close() {
      await this.fileHandle.close();
      return super.close();
    }
    setPosition(position) {
      this.position = position;
    }
    supportsRandomAccess() {
      return true;
    }
  };
});

// node_modules/strtok3/lib/index.js
import { stat as fsStat } from "node:fs/promises";
async function fromStream2(stream, options) {
  const rst = fromStream(stream, options);
  if (stream.path) {
    const stat = await fsStat(stream.path);
    rst.fileInfo.path = stream.path;
    rst.fileInfo.size = stat.size;
  }
  return rst;
}
var fromFile;
var init_lib2 = __esm(() => {
  init_core();
  init_FileTokenizer();
  init_FileTokenizer();
  init_core();
  fromFile = FileTokenizer.fromFile;
});

// node_modules/ieee754/index.js
var init_ieee754 = __esm(() => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/token-types/lib/index.js
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}

class StringType {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
    this.textDecoder = new TextDecoder(encoding);
  }
  get(uint8Array, offset) {
    return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
  }
}
var UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE;
var init_lib3 = __esm(() => {
  init_ieee754();
  UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
});

// node_modules/fflate/esm/index.mjs
import { createRequire as createRequire2 } from "module";
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var require2, Worker, u8, u16, i32, fleb, fdeb, clim, freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
}, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (;i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1;i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0;i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0;i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
}, flt, i, i, i, i, fdt, i, flrm, fdrm, max = function(a) {
  var m = a[0];
  for (var i = 1;i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
}, bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}, bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}, shft = function(p) {
  return (p + 7) / 8 | 0;
}, slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
}, ec, err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
}, inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0;i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0;i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
}, et, gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
}, gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
}, zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
}, td, tds = 0;
var init_esm = __esm(() => {
  require2 = createRequire2("/");
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {
  }
  u8 = Uint8Array;
  u16 = Uint16Array;
  i32 = Int32Array;
  fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  _a = freb(fleb, 2);
  fl = _a.b;
  revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  _b = freb(fdeb, 0);
  fd = _b.b;
  revfd = _b.r;
  rev = new u16(32768);
  for (i = 0;i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  flt = new u8(288);
  for (i = 0;i < 144; ++i)
    flt[i] = 8;
  for (i = 144;i < 256; ++i)
    flt[i] = 9;
  for (i = 256;i < 280; ++i)
    flt[i] = 7;
  for (i = 280;i < 288; ++i)
    flt[i] = 8;
  fdt = new u8(32);
  for (i = 0;i < 32; ++i)
    fdt[i] = 5;
  flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ];
  et = /* @__PURE__ */ new u8(0);
  td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces2) {
      createDebug.save(namespaces2);
      createDebug.namespaces = namespaces2;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces2 === "string" ? namespaces2 : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces2 = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces2;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces2) {
    try {
      if (namespaces2) {
        exports.storage.setItem("debug", namespaces2);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces2) {
    if (namespaces2) {
      process.env.DEBUG = namespaces2;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node3();
  }
});

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature, DataDescriptor, LocalFileHeaderToken, EndOfCentralDirectoryRecordToken, FileHeader;
var init_ZipToken = __esm(() => {
  init_lib3();
  Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  DataDescriptor = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        compressedSize: UINT32_LE.get(array, 8),
        uncompressedSize: UINT32_LE.get(array, 12)
      };
    },
    len: 16
  };
  LocalFileHeaderToken = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 8),
        compressedSize: UINT32_LE.get(array, 18),
        uncompressedSize: UINT32_LE.get(array, 22),
        filenameLength: UINT16_LE.get(array, 26),
        extraFieldLength: UINT16_LE.get(array, 28),
        filename: null
      };
    },
    len: 30
  };
  EndOfCentralDirectoryRecordToken = {
    get(array) {
      return {
        signature: UINT32_LE.get(array, 0),
        nrOfThisDisk: UINT16_LE.get(array, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array, 10),
        sizeOfCd: UINT32_LE.get(array, 12),
        offsetOfStartOfCd: UINT32_LE.get(array, 16),
        zipFileCommentLength: UINT16_LE.get(array, 20)
      };
    },
    len: 22
  };
  FileHeader = {
    get(array) {
      const flags = UINT16_LE.get(array, 8);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 10),
        compressedSize: UINT32_LE.get(array, 20),
        uncompressedSize: UINT32_LE.get(array, 24),
        filenameLength: UINT16_LE.get(array, 28),
        extraFieldLength: UINT16_LE.get(array, 30),
        fileCommentLength: UINT16_LE.get(array, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
        filename: null
      };
    },
    len: 46
  };
});

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i = buffer.length - 4;i >= 0; i--) {
      if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i = 0;i <= bufferLength - portionLength; i++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer[i + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i;
    }
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}
var import_debug, debug, syncBufferSize, ddSignatureArray, eocdSignatureBytes;
var init_lib4 = __esm(() => {
  init_lib3();
  init_esm();
  import_debug = __toESM(require_src(), 1);
  init_ZipToken();
  debug = import_debug.default("tokenizer:inflate");
  syncBufferSize = 256 * 1024;
  ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
});

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
function indexOf2(array, value) {
  const arrayLength = array.length;
  const valueLength = value.length;
  if (valueLength === 0) {
    return -1;
  }
  if (valueLength > arrayLength) {
    return -1;
  }
  const validOffsetLength = arrayLength - valueLength;
  for (let index = 0;index <= validOffsetLength; index++) {
    let isMatch = true;
    for (let index2 = 0;index2 < valueLength; index2++) {
      if (array[index + index2] !== value[index2]) {
        isMatch = false;
        break;
      }
    }
    if (isMatch) {
      return index;
    }
  }
  return -1;
}
function includes(array, value) {
  return indexOf2(array, value) !== -1;
}
var cachedDecoders, cachedEncoder, byteToHexLookupTable;
var init_uint8array_extras = __esm(() => {
  cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  cachedEncoder = new globalThis.TextEncoder;
  byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
});

// node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken;
var init_util = __esm(() => {
  init_lib3();
  uint32SyncSafeToken = {
    get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
  };
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm(() => {
  extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "ai",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar"
  ];
  mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/x-apache-arrow",
    "video/mp4",
    "audio/midi",
    "video/x-matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/x-flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/x-parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    "application/x-lz4",
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroEnabled.12",
    "application/vnd.ms-word.document.macroEnabled.12",
    "application/vnd.ms-word.template.macroEnabled.12",
    "application/vnd.ms-powerpoint.template.macroEnabled.12",
    "application/vnd.ms-powerpoint.presentation.macroEnabled.12",
    "application/java-archive"
  ];
});

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input) {
  return new FileTypeParser().fromBuffer(input);
}
async function fileTypeFromBlob(blob) {
  return new FileTypeParser().fromBlob(blob);
}
function getFileTypeFromMimeType(mimeType) {
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: "application/epub+zip"
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: "application/vnd.oasis.opendocument.text"
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: "application/vnd.oasis.opendocument.text-template"
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: "application/vnd.oasis.opendocument.spreadsheet"
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: "application/vnd.oasis.opendocument.spreadsheet-template"
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: "application/vnd.oasis.opendocument.presentation"
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: "application/vnd.oasis.opendocument.presentation-template"
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: "application/vnd.oasis.opendocument.graphics"
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: "application/vnd.oasis.opendocument.graphics-template"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
      };
    case "application/vnd.ms-excel.sheet.macroEnabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroEnabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.template"
      };
    case "application/vnd.ms-excel.template.macroEnabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
      };
    case "application/vnd.ms-word.document.macroEnabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroEnabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.template"
      };
    case "application/vnd.ms-word.template.macroEnabledTemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroEnabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: "application/vnd.openxmlformats-officedocument.presentationml.template"
      };
    case "application/vnd.ms-powerpoint.template.macroEnabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroEnabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
      };
    case "application/vnd.ms-powerpoint.presentation.macroEnabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroEnabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fileTypeFromTokenizer(tokenizer) {
  return new FileTypeParser().fromTokenizer(tokenizer);
}

class FileTypeParser {
  constructor(options) {
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.slice(0, sampleSize));
        } catch (error) {
          if (!(error instanceof EndOfStreamError)) {
            throw error;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = new Uint8Array(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/x-flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      try {
        const skipBytes = 1350;
        if (skipBytes === await tokenizer.ignore(skipBytes)) {
          const maxBufferSize2 = 10 * 1024 * 1024;
          const buffer = new Uint8Array(Math.min(maxBufferSize2, tokenizer.fileInfo.size - skipBytes));
          await tokenizer.readBuffer(buffer, { mayBeLess: true });
          if (includes(buffer, new TextEncoder().encode("AIPrivateData"))) {
            return {
              ext: "ai",
              mime: "application/postscript"
            };
          }
        }
      } catch (error) {
        if (!(error instanceof EndOfStreamError)) {
          throw error;
        }
      }
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/x-matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1")) {
      return {
        ext: "parquet",
        mime: "application/x-parquet"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string = await tokenizer.readToken(new StringType(13, "ascii"));
      if (string === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && [`
`, "\r", "\t", " ", "\x00"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/x-apache-arrow"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\x00", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new StringType(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.slice(16, jsonSize + 16));
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {
        }
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \x00")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    if (this.buffer.length >= 2 && this.check([255, 224], { offset: 0, mask: [255, 224] })) {
      if (this.check([16], { offset: 1, mask: [22] })) {
        if (this.check([8], { offset: 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
}
var reasonableDetectionSizeInBytes = 4100, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm(() => {
  init_lib3();
  init_core();
  init_lib4();
  init_uint8array_extras();
  init_util();
  init_supported();
  supportedExtensions = new Set(extensions);
  supportedMimeTypes = new Set(mimeTypes);
});

// node_modules/file-type/index.js
var exports_file_type = {};
__export(exports_file_type, {
  supportedMimeTypes: () => supportedMimeTypes,
  supportedExtensions: () => supportedExtensions,
  fileTypeStream: () => fileTypeStream,
  fileTypeFromTokenizer: () => fileTypeFromTokenizer,
  fileTypeFromStream: () => fileTypeFromStream,
  fileTypeFromFile: () => fileTypeFromFile,
  fileTypeFromBuffer: () => fileTypeFromBuffer,
  fileTypeFromBlob: () => fileTypeFromBlob,
  FileTypeParser: () => FileTypeParser2
});
import { ReadableStream as WebReadableStream } from "node:stream/web";
import { pipeline, PassThrough, Readable } from "node:stream";
async function fileTypeFromFile(path, fileTypeOptions) {
  return new FileTypeParser2(fileTypeOptions).fromFile(path, fileTypeOptions);
}
async function fileTypeFromStream(stream, fileTypeOptions) {
  return new FileTypeParser2(fileTypeOptions).fromStream(stream);
}
async function fileTypeStream(readableStream, options = {}) {
  return new FileTypeParser2(options).toDetectionStream(readableStream, options);
}
var FileTypeParser2;
var init_file_type = __esm(() => {
  init_lib2();
  init_core2();
  init_core2();
  FileTypeParser2 = class FileTypeParser2 extends FileTypeParser {
    async fromStream(stream) {
      const tokenizer = await (stream instanceof WebReadableStream ? fromWebStream(stream, this.tokenizerOptions) : fromStream2(stream, this.tokenizerOptions));
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async fromFile(path) {
      const tokenizer = await fromFile(path);
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async toDetectionStream(readableStream, options = {}) {
      if (!(readableStream instanceof Readable)) {
        return super.toDetectionStream(readableStream, options);
      }
      const { sampleSize = reasonableDetectionSizeInBytes } = options;
      return new Promise((resolve, reject) => {
        readableStream.on("error", reject);
        readableStream.once("readable", () => {
          (async () => {
            try {
              const pass = new PassThrough;
              const outputStream = pipeline ? pipeline(readableStream, pass, () => {
              }) : readableStream.pipe(pass);
              const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
              try {
                pass.fileType = await this.fromBuffer(chunk);
              } catch (error) {
                if (error instanceof EndOfStreamError) {
                  pass.fileType = undefined;
                } else {
                  reject(error);
                }
              }
              resolve(outputStream);
            } catch (error) {
              reject(error);
            }
          })();
        });
      });
    }
  };
});

// index.ts
var import_jszip = __toESM(require_lib3(), 1);

// src/html-to-docx.ts
var import_html_entities = __toESM(require_lib4(), 1);
var import_html_to_vdom2 = __toESM(require_html_to_vdom2(), 1);
var import_vnode4 = __toESM(require_vnode(), 1);
var import_vtext2 = __toESM(require_vtext(), 1);
var import_xmlbuilder24 = __toESM(require_lib12(), 1);

// src/constants.ts
var import_lodash = __toESM(require_lodash(), 1);
var applicationName = "html-to-docx";
var defaultOrientation = "portrait";
var landscapeWidth = 15840;
var landscapeHeight = 12240;
var landscapeMargins = {
  top: 1800,
  right: 1440,
  bottom: 1800,
  left: 1440,
  header: 720,
  footer: 720,
  gutter: 0
};
var portraitMargins = {
  top: 1440,
  right: 1800,
  bottom: 1440,
  left: 1800,
  header: 720,
  footer: 720,
  gutter: 0
};
var defaultFont = "Times New Roman";
var defaultFontSize = 22;
var defaultLang = "en-US";
var defaultDocumentOptions = {
  orientation: defaultOrientation,
  margins: import_lodash.default.cloneDeep(portraitMargins),
  creator: applicationName,
  keywords: [applicationName],
  lastModifiedBy: applicationName,
  font: defaultFont,
  fontSize: defaultFontSize,
  complexScriptFontSize: defaultFontSize,
  pageSize: {
    width: landscapeHeight,
    height: landscapeWidth
  },
  defaultLang
};
var defaultHTMLString = "<p></p>";
var relsFolderName = "_rels";
var headerFileName = "header1";
var footerFileName = "footer1";
var themeFileName = "theme1";
var documentFileName = "document";
var headerType = "header";
var footerType = "footer";
var themeType = "theme";
var hyperlinkType = "hyperlink";
var imageType = "image";
var internalRelationship = "Internal";
var wordFolder = "word";
var themeFolder = "theme";
var paragraphBordersObject = {
  top: {
    size: 0,
    spacing: 3,
    color: "FFFFFF"
  },
  left: {
    size: 0,
    spacing: 3,
    color: "FFFFFF"
  },
  bottom: {
    size: 0,
    spacing: 3,
    color: "FFFFFF"
  },
  right: {
    size: 0,
    spacing: 3,
    color: "FFFFFF"
  }
};
var colorlessColors = ["transparent", "auto"];
var verticalAlignValues = ["top", "middle", "bottom"];

// node_modules/nanoid/index.js
import { webcrypto as crypto } from "node:crypto";

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function nanoid(size = 21) {
  fillPool(size |= 0);
  let id = "";
  for (let i = poolOffset - size;i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
}

// src/docx-document.ts
var import_xmlbuilder23 = __toESM(require_lib12(), 1);

// src/helpers/render-document-file.ts
var import_html_to_vdom = __toESM(require_html_to_vdom2(), 1);
var import_image_size2 = __toESM(require_dist(), 1);
var import_is_vnode2 = __toESM(require_is_vnode(), 1);
var import_is_vtext2 = __toESM(require_is_vtext(), 1);
var import_vnode2 = __toESM(require_vnode(), 1);
var import_vtext = __toESM(require_vtext(), 1);
var import_xmlbuilder22 = __toESM(require_lib12(), 1);

// src/namespaces.ts
var namespaces = {
  a: "http://schemas.openxmlformats.org/drawingml/2006/main",
  b: "http://schemas.openxmlformats.org/officeDocument/2006/bibliography",
  cdr: "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing",
  dc: "http://purl.org/dc/elements/1.1/",
  dcmitype: "http://purl.org/dc/dcmitype/",
  dcterms: "http://purl.org/dc/terms/",
  o: "urn:schemas-microsoft-com:office:office",
  pic: "http://schemas.openxmlformats.org/drawingml/2006/picture",
  r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  v: "urn:schemas-microsoft-com:vml",
  ve: "http://schemas.openxmlformats.org/markup-compatibility/2006",
  vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
  w10: "urn:schemas-microsoft-com:office:word",
  wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
  wne: "http://schemas.microsoft.com/office/word/2006/wordml",
  xsd: "http://www.w3.org/2001/XMLSchema",
  xsi: "http://www.w3.org/2001/XMLSchema-instance",
  numbering: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
  fontTable: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
  hyperlinks: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  images: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  headers: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
  footers: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
  themes: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  coreProperties: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  officeDocumentRelation: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  corePropertiesRelation: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  settingsRelation: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
  webSettingsRelation: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
  sl: "http://schemas.openxmlformats.org/schemaLibrary/2006/main",
  contentTypes: "http://schemas.openxmlformats.org/package/2006/content-types",
  relationship: "http://schemas.openxmlformats.org/package/2006/relationships"
};
var namespaces_default = namespaces;

// src/utils/base64.ts
var import_mime_types = __toESM(require_mime_types(), 1);
async function fetchImageToDataUrl(imageUrlStr) {
  try {
    const imageUrl = new URL(imageUrlStr);
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      console.warn(`WARNING: Skip download of "${imageUrl}" ` + `due to HTTP error ${imageResponse.status}`);
      return emptyPngDataURL;
    }
    const imgArrayBuff = await imageResponse.arrayBuffer();
    const base64String = Buffer.from(imgArrayBuff).toString("base64");
    if (!base64String) {
      console.warn("WARNING: Image response could not be converted to base64");
      return emptyPngDataURL;
    } else {
      let mimeType = import_mime_types.default.lookup(imageUrl.pathname);
      if (!mimeType) {
        const { fileTypeFromBuffer: fileTypeFromBuffer2 } = await Promise.resolve().then(() => (init_file_type(), exports_file_type));
        const fileType = await fileTypeFromBuffer2(imgArrayBuff);
        mimeType = fileType?.mime || false;
      }
      return `data:${mimeType || "png"};base64,${base64String}`;
    }
  } catch (error) {
    console.warn(`WARNING: Image download failed for "${imageUrlStr}" with following error:`, error);
    return emptyPngDataURL;
  }
}
function extractBase64Data(src) {
  if (!src) {
    console.error("ERROR: Empty base64 data URL");
    return null;
  }
  const idxComma = src.indexOf(",");
  const idxSlash = src.indexOf("/");
  if (idxComma === -1 || idxSlash === -1 || !src.startsWith("data:")) {
    console.error(`ERROR: Invalid base64 data URL:
`, src);
    return null;
  }
  const idxSemi = src.indexOf(";");
  const extEnd = idxSemi === -1 ? idxComma : Math.min(idxSemi, idxComma);
  return {
    type: src.substring("data:".length, idxSlash),
    extension: src.substring(idxSlash + 1, extEnd),
    base64Content: src.substring(idxComma + 1).trim()
  };
}
var emptyPngBase64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=";
var emptyPngDataURL = "data:image/png;base64," + emptyPngBase64;

// src/utils/url.ts
function isValidUrl(urlString) {
  const urlRegex = /http(s)?:\/\/(\w+:?\w*@)?(\S+)(:\d+)?((?<=\.)\w+)+(\/([\w#!:.?+=&%@!\-/])*)?/gi;
  return Boolean(urlRegex.test(urlString));
}

// src/utils/vnode.ts
function vNodeHasChildren(vNode) {
  return vNode && vNode.children && Array.isArray(vNode.children) && vNode.children.length;
}

// node_modules/color-name/index.js
var color_name_default = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

// src/helpers/xml-builder.ts
var import_image_size = __toESM(require_dist(), 1);
var import_lodash2 = __toESM(require_lodash(), 1);
var import_is_vnode = __toESM(require_is_vnode(), 1);
var import_is_vtext = __toESM(require_is_vtext(), 1);
var import_xmlbuilder2 = __toESM(require_lib12(), 1);

// src/utils/color-conversion.ts
var rgbRegex = /rgb\((\d+),\s*([\d.]+),\s*([\d.]+)\)/i;
var hslRegex = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/i;
var hexRegex = /#([0-9A-F]{6})/i;
var hex3Regex = /#([0-9A-F])([0-9A-F])([0-9A-F])/i;
function rgbToHex(red, green, blue) {
  const hexColorCode = [red, green, blue].map((x) => {
    x = (typeof x === "string" ? parseInt(x) : x || 0).toString(16);
    return x.length === 1 ? `0${x}` : x;
  }).join("");
  return hexColorCode;
}
function hslToHex(hue, saturation, luminosity) {
  hue = (hue || 0) / 360;
  saturation = (saturation || 0) / 100;
  luminosity = (luminosity || 0) / 100;
  let red;
  let green;
  let blue;
  if (saturation === 0) {
    red = green = blue = luminosity;
  } else {
    let hue2rgb = function(p2, q2, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2)
        return q2;
      if (t < 2 / 3)
        return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = luminosity < 0.5 ? luminosity * (1 + saturation) : luminosity + saturation - luminosity * saturation;
    const p = 2 * luminosity - q;
    red = hue2rgb(p, q, hue + 1 / 3);
    green = hue2rgb(p, q, hue);
    blue = hue2rgb(p, q, hue - 1 / 3);
  }
  return [red, green, blue].map((x) => {
    const hex = Math.round(x * 255).toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }).join("");
}
function hex3ToHex(red, green, blue) {
  const hexColorCode = [red, green, blue].map((color) => `${color}${color}`).join("");
  return hexColorCode;
}

// src/utils/unit-conversion.ts
var pixelRegex = /([\d.]+)px/i;
var percentageRegex = /([\d.]+)%/i;
var pointRegex = /([\d.]+)pt/i;
var cmRegex = /([\d.]+)cm/i;
var inchRegex = /([\d.]+)in/i;
function pixelToEMU(pixelValue) {
  return Math.round(pixelValue * 9525);
}
function TWIPToEMU(TWIPValue) {
  return Math.round(TWIPValue * 635);
}
function EMUToTWIP(EMUValue) {
  return Math.round(EMUValue / 635);
}
function pointToTWIP(pointValue) {
  return Math.round(pointValue * 20);
}
function pointToHIP(pointValue) {
  return Math.round(pointValue * 2);
}
function HIPToPoint(HIPValue) {
  return Math.round(HIPValue / 2);
}
function HIPToTWIP(HIPValue) {
  return Math.round(HIPValue * 10);
}
function TWIPToHIP(TWIPValue) {
  return Math.round(TWIPValue / 10);
}
function pixelToTWIP(pixelValue) {
  return EMUToTWIP(pixelToEMU(pixelValue));
}
function pixelToHIP(pixelValue) {
  return TWIPToHIP(EMUToTWIP(pixelToEMU(pixelValue)));
}
function inchToPoint(inchValue) {
  return Math.round(inchValue * 72);
}
function inchToTWIP(inchValue) {
  return pointToTWIP(inchToPoint(inchValue));
}
function cmToInch(cmValue) {
  return cmValue * 0.3937008;
}
function cmToTWIP(cmValue) {
  return inchToTWIP(cmToInch(cmValue));
}
function pixelToPoint(pixelValue) {
  return HIPToPoint(pixelToHIP(pixelValue));
}
function pointToEIP(PointValue) {
  return Math.round(PointValue * 8);
}
function pixelToEIP(pixelValue) {
  return pointToEIP(pixelToPoint(pixelValue));
}

// src/helpers/xml-builder.ts
function fixupColorCode(colorCodeString) {
  if (Object.prototype.hasOwnProperty.call(color_name_default, colorCodeString.toLowerCase())) {
    const [red, green, blue] = Object.prototype.hasOwnProperty.call(color_name_default, colorCodeString.toLowerCase()) ? color_name_default[colorCodeString.toLowerCase()] : [0, 0, 0];
    return rgbToHex(red, green, blue);
  } else if (rgbRegex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(rgbRegex);
    const red = matchedParts?.[1];
    const green = matchedParts?.[2];
    const blue = matchedParts?.[3];
    return rgbToHex(red, green, blue);
  } else if (hslRegex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(hslRegex);
    const hue = Number(matchedParts?.[1]);
    const saturation = Number(matchedParts?.[2]);
    const luminosity = Number(matchedParts?.[3]);
    return hslToHex(hue, saturation, luminosity);
  } else if (hexRegex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(hexRegex);
    return matchedParts?.[1] || "";
  } else if (hex3Regex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(hex3Regex);
    const red = Number(matchedParts?.[1]);
    const green = Number(matchedParts?.[2]);
    const blue = Number(matchedParts?.[3]);
    return hex3ToHex(red, green, blue);
  } else {
    return "000000";
  }
}
function buildRunFontFragment(fontName = defaultFont) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "rFonts").att("@w", "ascii", fontName).att("@w", "hAnsi", fontName).up();
}
function buildRunStyleFragment(type = "Hyperlink") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "rStyle").att("@w", "val", type).up();
}
function buildTableRowHeight(tableRowHeight) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "trHeight").att("@w", "val", String(tableRowHeight)).att("@w", "hRule", "atLeast").up();
}
function buildVerticalAlignment(verticalAlignment) {
  const vertAlign = verticalAlignment.toLowerCase() === "middle" ? "center" : verticalAlignment;
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "vAlign").att("@w", "val", vertAlign).up();
}
function buildVerticalMerge(verticalMerge = "continue") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "vMerge").att("@w", "val", verticalMerge).up();
}
function buildColor(colorCode) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "color").att("@w", "val", colorCode).up();
}
function buildFontSize(fontSize) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "sz").att("@w", "val", String(fontSize)).up();
}
function buildShading(colorCode) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "shd").att("@w", "val", "clear").att("@w", "fill", colorCode).up();
}
function buildHighlight(color = "yellow") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "highlight").att("@w", "val", color).up();
}
function buildVertAlign(type = "baseline") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "vertAlign").att("@w", "val", type).up();
}
function buildStrike() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "strike").att("@w", "val", "true").up();
}
function buildBold() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "b").up();
}
function buildItalics() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "i").up();
}
function buildUnderline(type = "single") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "u").att("@w", "val", type).up();
}
function buildLineBreak(type = "textWrapping") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "br").att("@w", "type", type).up();
}
function buildBorder(borderSide = "top", borderSize = 0, borderSpacing = 0, borderColor = fixupColorCode("black"), borderStroke = "single") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", borderSide).att("@w", "val", borderStroke).att("@w", "sz", String(borderSize)).att("@w", "space", String(borderSpacing)).att("@w", "color", borderColor).up();
}
function buildTextElement(text) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "t").att("@xml", "space", "preserve").txt(text).up();
}
function fixupLineHeight(lineHeight, fontSize) {
  if (Number.isFinite(lineHeight)) {
    if (Number.isFinite(fontSize)) {
      const actualLineHeight = Number(lineHeight) * Number(fontSize);
      return HIPToTWIP(actualLineHeight);
    } else {
      return Number(lineHeight) * 240;
    }
  } else {
    return 240;
  }
}
function fixupFontSize(fontSizeString) {
  if (pointRegex.test(fontSizeString)) {
    const matchedParts = fontSizeString.match(pointRegex);
    return pointToHIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(fontSizeString)) {
    const matchedParts = fontSizeString.match(pixelRegex);
    return pixelToHIP(Number(matchedParts?.[1]));
  } else {
    return 24;
  }
}
function fixupRowHeight(rowHeightString) {
  if (pointRegex.test(rowHeightString)) {
    const matchedParts = rowHeightString.match(pointRegex);
    return pointToTWIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(rowHeightString)) {
    const matchedParts = rowHeightString.match(pixelRegex);
    return pixelToTWIP(Number(matchedParts?.[1]));
  } else if (cmRegex.test(rowHeightString)) {
    const matchedParts = rowHeightString.match(cmRegex);
    return cmToTWIP(Number(matchedParts?.[1]));
  } else if (inchRegex.test(rowHeightString)) {
    const matchedParts = rowHeightString.match(inchRegex);
    return inchToTWIP(Number(matchedParts?.[1]));
  }
}
function fixupColumnWidth(columnWidth) {
  if (typeof columnWidth === "number") {
    return columnWidth;
  }
  if (pointRegex.test(columnWidth)) {
    const matchedParts = columnWidth.match(pointRegex);
    return pointToTWIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(columnWidth)) {
    const matchedParts = columnWidth.match(pixelRegex);
    return pixelToTWIP(Number(matchedParts?.[1]));
  } else if (cmRegex.test(columnWidth)) {
    const matchedParts = columnWidth.match(cmRegex);
    return cmToTWIP(Number(matchedParts?.[1]));
  } else if (inchRegex.test(columnWidth)) {
    const matchedParts = columnWidth.match(inchRegex);
    return inchToTWIP(Number(matchedParts?.[1]));
  } else {
    return columnWidth;
  }
}
function fixupMargin(marginString) {
  if (pointRegex.test(marginString)) {
    const matchedParts = marginString.match(pointRegex);
    return pointToTWIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(marginString)) {
    const matchedParts = marginString.match(pixelRegex);
    return pixelToTWIP(Number(matchedParts?.[1]));
  }
}
function modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes, options = { isParagraph: false }) {
  const modifiedAttributes = { ...attributes };
  if (vNode && import_is_vnode.default(vNode)) {
    const properties = vNode.properties;
    if (properties && properties.style) {
      if (properties.style.color && !colorlessColors.includes(properties.style.color)) {
        modifiedAttributes.color = fixupColorCode(properties.style.color);
      }
      if (properties.style["background-color"] && !colorlessColors.includes(properties.style["background-color"])) {
        modifiedAttributes.backgroundColor = fixupColorCode(properties.style["background-color"]);
      }
      if (properties.style["vertical-align"] && verticalAlignValues.includes(properties.style["vertical-align"])) {
        modifiedAttributes.verticalAlign = properties.style["vertical-align"];
      }
      if (properties.style["text-align"] && ["left", "right", "center", "justify"].includes(properties.style["text-align"])) {
        modifiedAttributes.textAlign = properties.style["text-align"];
      }
      if (properties.style["font-weight"] && properties.style["font-weight"] === "bold") {
        modifiedAttributes.strong = properties.style["font-weight"];
      }
      if (properties.style["font-family"]) {
        modifiedAttributes.font = docxDocumentInstance.createFont(properties.style["font-family"]);
      }
      if (properties.style["font-size"]) {
        modifiedAttributes.fontSize = fixupFontSize(properties.style["font-size"]);
      }
      if (properties.style["line-height"]) {
        modifiedAttributes.lineHeight = fixupLineHeight(properties.style["line-height"], properties.style["font-size"] ? fixupFontSize(properties.style["font-size"]) : undefined);
      }
      if (properties.style["margin-left"] || properties.style["margin-right"]) {
        const leftMargin = fixupMargin(properties.style["margin-left"]);
        const rightMargin = fixupMargin(properties.style["margin-right"]);
        if (leftMargin || rightMargin) {
          modifiedAttributes.indentation = {
            left: leftMargin,
            right: rightMargin
          };
        }
      }
      if (properties.style.display) {
        modifiedAttributes.display = properties.style.display;
      }
      if (properties.style.width) {
        modifiedAttributes.width = properties.style.width;
      }
    }
  }
  if (options?.isParagraph) {
    if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "blockquote") {
      modifiedAttributes.indentation = { left: 284, right: 0 };
      modifiedAttributes.textAlign = "justify";
    } else if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "code") {
      modifiedAttributes.highlightColor = "lightGray";
    } else if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "pre") {
      modifiedAttributes.font = "Courier";
    }
  }
  return modifiedAttributes;
}
function buildFormatting(htmlTag, options) {
  switch (htmlTag) {
    case "strong":
    case "b":
      return buildBold();
    case "em":
    case "i":
      return buildItalics();
    case "ins":
    case "u":
      return buildUnderline();
    case "strike":
    case "del":
    case "s":
      return buildStrike();
    case "sub":
      return buildVertAlign("subscript");
    case "sup":
      return buildVertAlign("superscript");
    case "mark":
      return buildHighlight();
    case "code":
      return buildHighlight("lightGray");
    case "highlightColor":
      if (options.color) {
        return buildHighlight(options.color);
      }
      break;
    case "font":
      if (options.font) {
        return buildRunFontFragment(options.font);
      }
      break;
    case "pre":
      return buildRunFontFragment("Courier");
    case "color":
      if (options.color) {
        return buildColor(options.color);
      }
      break;
    case "backgroundColor":
      if (options.color) {
        return buildShading(options.color);
      }
      break;
    case "fontSize":
      return buildFontSize(options.fontSize ? options.fontSize : 10);
    case "hyperlink":
      return buildRunStyleFragment("Hyperlink");
    default:
      break;
  }
  return null;
}
function buildRunProperties(attributes) {
  const runPropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "rPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach((key) => {
      const options = {
        color: key === "color" || key === "backgroundColor" || key === "highlightColor" ? attributes[key] || undefined : undefined,
        fontSize: key === "fontSize" ? attributes.fontSize : undefined,
        font: key === "font" ? attributes.font : undefined
      };
      const formattingFragment = buildFormatting(key, options);
      if (formattingFragment) {
        runPropertiesFragment.import(formattingFragment);
      }
    });
  }
  runPropertiesFragment.up();
  return runPropertiesFragment;
}
async function buildRun(vNode, attributes, docxDocumentInstance) {
  const runFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
  const runPropertiesFragment = buildRunProperties(import_lodash2.default.cloneDeep(attributes));
  if (import_is_vnode.default(vNode) && vNode.tagName === "span") {
    return buildRunOrRuns(vNode, attributes, docxDocumentInstance);
  }
  if (vNode && import_is_vnode.default(vNode) && [
    "strong",
    "b",
    "em",
    "i",
    "u",
    "ins",
    "strike",
    "del",
    "s",
    "sub",
    "sup",
    "mark",
    "blockquote",
    "code",
    "pre"
  ].includes(vNode.tagName)) {
    const runFragmentsArray = [];
    let vNodes = [vNode];
    let tempAttributes = import_lodash2.default.cloneDeep(attributes);
    let tempRunFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
    while (vNodes.length) {
      const tempVNode = vNodes.shift();
      if (import_is_vtext.default(tempVNode)) {
        const textFragment = buildTextElement(tempVNode.text);
        const tempRunPropertiesFragment = buildRunProperties({
          ...attributes,
          ...tempAttributes
        });
        tempRunFragment.import(tempRunPropertiesFragment);
        tempRunFragment.import(textFragment);
        runFragmentsArray.push(tempRunFragment);
        tempAttributes = import_lodash2.default.cloneDeep(attributes);
        tempRunFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "r");
      } else if (import_is_vnode.default(tempVNode)) {
        if ([
          "strong",
          "b",
          "em",
          "i",
          "u",
          "ins",
          "strike",
          "del",
          "s",
          "sub",
          "sup",
          "mark",
          "code",
          "pre"
        ].includes(tempVNode.tagName)) {
          switch (tempVNode.tagName) {
            case "strong":
            case "b":
              tempAttributes.strong = true;
              break;
            case "i":
              tempAttributes.i = true;
              break;
            case "u":
              tempAttributes.u = true;
              break;
            case "sub":
              tempAttributes.sub = true;
              break;
            case "sup":
              tempAttributes.sup = true;
              break;
            default:
              break;
          }
          const formattingFragment = buildFormatting(tempVNode.tagName, {});
          if (formattingFragment) {
            runPropertiesFragment.import(formattingFragment);
          }
        } else if (tempVNode.tagName === "span") {
          const spanFragment = await buildRunOrRuns(tempVNode, { ...attributes, ...tempAttributes }, docxDocumentInstance);
          if (Array.isArray(spanFragment)) {
            spanFragment.flat(Infinity);
            runFragmentsArray.push(...spanFragment);
          } else {
            runFragmentsArray.push(spanFragment);
          }
          continue;
        }
      }
      if (tempVNode.children?.length) {
        if (tempVNode.children.length > 1) {
          attributes = { ...attributes, ...tempAttributes };
        }
        vNodes = tempVNode.children.slice().concat(vNodes);
      }
    }
    if (runFragmentsArray.length) {
      return runFragmentsArray;
    }
  }
  runFragment.import(runPropertiesFragment);
  if (import_is_vtext.default(vNode)) {
    const textFragment = buildTextElement(vNode.text);
    runFragment.import(textFragment);
  } else if (attributes && attributes.type === "picture") {
    let response = null;
    const base64Uri = decodeURIComponent(vNode.properties.src);
    if (base64Uri) {
      response = docxDocumentInstance.createMediaFile(base64Uri);
    }
    if (response) {
      docxDocumentInstance.zip.folder("word")?.folder("media")?.file(response.fileNameWithExtension, Buffer.from(response.fileContent, "base64"), {
        createFolders: false
      });
      const documentRelsId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, imageType, `media/${response.fileNameWithExtension}`, internalRelationship);
      attributes.inlineOrAnchored = true;
      attributes.relationshipId = documentRelsId;
      attributes.id = response.id;
      attributes.fileContent = response.fileContent;
      attributes.fileNameWithExtension = response.fileNameWithExtension;
    }
    const imageFragment = buildDrawing(attributes);
    runFragment.import(imageFragment);
  } else if (import_is_vnode.default(vNode) && vNode.tagName === "br") {
    const lineBreakFragment = buildLineBreak();
    runFragment.import(lineBreakFragment);
  }
  runFragment.up();
  return runFragment;
}
async function buildRunOrRuns(vNode, attributes, docxDocumentInstance) {
  if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "span") {
    let runFragments = [];
    for (let index = 0;index < vNode.children.length; index++) {
      const childVNode = vNode.children[index];
      const modifiedAttributes = modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes);
      const tempRunFragments = await buildRun(childVNode, modifiedAttributes, docxDocumentInstance);
      runFragments = runFragments.concat(Array.isArray(tempRunFragments) ? tempRunFragments : [tempRunFragments]);
    }
    return runFragments;
  } else {
    const tempRunFragments = await buildRun(vNode, attributes, docxDocumentInstance);
    return tempRunFragments;
  }
}
async function buildRunOrHyperLink(vNode, attributes, docxDocumentInstance) {
  if (import_is_vnode.default(vNode) && vNode.tagName === "a") {
    const relationshipId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, hyperlinkType, vNode.properties && vNode.properties.href ? vNode.properties.href : "");
    const hyperlinkFragment = import_xmlbuilder2.fragment({
      namespaceAlias: { w: namespaces_default.w, r: namespaces_default.r }
    }).ele("@w", "hyperlink").att("@r", "id", `rId${relationshipId}`);
    const modifiedAttributes = { ...attributes };
    modifiedAttributes.hyperlink = true;
    const runFragments2 = await buildRunOrRuns(vNode.children[0], modifiedAttributes, docxDocumentInstance);
    if (Array.isArray(runFragments2)) {
      for (let index = 0;index < runFragments2.length; index++) {
        const runFragment = runFragments2[index];
        hyperlinkFragment.import(runFragment);
      }
    } else {
      hyperlinkFragment.import(runFragments2);
    }
    hyperlinkFragment.up();
    return hyperlinkFragment;
  }
  const runFragments = await buildRunOrRuns(vNode, attributes, docxDocumentInstance);
  return runFragments;
}
function buildNumberingProperties(levelId, numberingId) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "numPr").ele("@w", "ilvl").att("@w", "val", String(levelId)).up().ele("@w", "numId").att("@w", "val", String(numberingId)).up();
}
function buildSpacing(lineSpacing, beforeSpacing, afterSpacing) {
  const spacingFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "spacing");
  if (lineSpacing) {
    spacingFragment.att("@w", "line", String(lineSpacing));
  }
  if (beforeSpacing) {
    spacingFragment.att("@w", "before", String(beforeSpacing));
  }
  if (afterSpacing) {
    spacingFragment.att("@w", "after", String(afterSpacing));
  }
  spacingFragment.att("@w", "lineRule", "auto").up();
  return spacingFragment;
}
function buildIndentation({ left, right }) {
  if (!left && !right) {
    return;
  }
  const indentationFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "ind");
  if (left) {
    indentationFragment.att("@w", "left", String(left));
  }
  if (right) {
    indentationFragment.att("@w", "right", String(right));
  }
  indentationFragment.up();
  return indentationFragment;
}
function buildPStyle(style = "Normal") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "pStyle").att("@w", "val", style).up();
}
function buildHorizontalAlignment(horizontalAlignment) {
  const horAlign = horizontalAlignment === "justify" ? "both" : horizontalAlignment;
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "jc").att("@w", "val", horAlign).up();
}
function buildParagraphBorder() {
  const paragraphBorderFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "pBdr");
  const bordersObject = import_lodash2.default.cloneDeep(paragraphBordersObject);
  Object.keys(bordersObject).forEach((borderName) => {
    const bName = borderName;
    if (bordersObject[bName]) {
      const { size, spacing, color } = bordersObject[bName];
      const borderFragment = buildBorder(bName, size, spacing, color);
      paragraphBorderFragment.import(borderFragment);
    }
  });
  paragraphBorderFragment.up();
  return paragraphBorderFragment;
}
function buildParagraphProperties(attributes) {
  const paragraphPropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "pPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach((key) => {
      switch (key) {
        case "numbering": {
          if (attributes.numbering?.levelId && attributes.numbering?.numberingId) {
            const numberingPropertiesFragment = buildNumberingProperties(attributes.numbering.levelId, attributes.numbering.numberingId);
            paragraphPropertiesFragment.import(numberingPropertiesFragment);
            delete attributes.numbering;
          }
          break;
        }
        case "textAlign": {
          if (attributes.textAlign) {
            const horizontalAlignmentFragment = buildHorizontalAlignment(attributes.textAlign);
            paragraphPropertiesFragment.import(horizontalAlignmentFragment);
            delete attributes.textAlign;
          }
          break;
        }
        case "backgroundColor":
          if (attributes.backgroundColor && attributes.display === "block") {
            const shadingFragment = buildShading(attributes.backgroundColor);
            paragraphPropertiesFragment.import(shadingFragment);
            const paragraphBorderFragment = buildParagraphBorder();
            paragraphPropertiesFragment.import(paragraphBorderFragment);
            delete attributes.backgroundColor;
          }
          break;
        case "paragraphStyle": {
          const pStyleFragment = buildPStyle(attributes.paragraphStyle);
          paragraphPropertiesFragment.import(pStyleFragment);
          delete attributes.paragraphStyle;
          break;
        }
        case "indentation": {
          if (attributes.indentation) {
            const indentationFragment = buildIndentation(attributes.indentation);
            if (indentationFragment) {
              paragraphPropertiesFragment.import(indentationFragment);
            }
            delete attributes.indentation;
          }
          break;
        }
        default:
          break;
      }
    });
    const spacingFragment = buildSpacing(attributes.lineHeight, attributes.beforeSpacing, attributes.afterSpacing);
    delete attributes.lineHeight;
    delete attributes.beforeSpacing;
    delete attributes.afterSpacing;
    if (spacingFragment) {
      paragraphPropertiesFragment.import(spacingFragment);
    }
  }
  paragraphPropertiesFragment.up();
  return paragraphPropertiesFragment;
}
function computeImageDimensions(vNode, attributes) {
  const { maximumWidth, originalWidth, originalHeight } = attributes;
  const aspectRatio = (originalWidth || 0) / (originalHeight || 1);
  const maximumWidthInEMU = TWIPToEMU(maximumWidth || 0);
  let originalWidthInEMU = pixelToEMU(originalWidth || 0);
  let originalHeightInEMU = pixelToEMU(originalHeight || 0);
  if (originalWidthInEMU > maximumWidthInEMU) {
    originalWidthInEMU = maximumWidthInEMU;
    originalHeightInEMU = Math.round(originalWidthInEMU / aspectRatio);
  }
  let modifiedHeight;
  let modifiedWidth;
  if (vNode.properties && vNode.properties.style) {
    if (vNode.properties.style.width) {
      if (vNode.properties.style.width !== "auto") {
        if (pixelRegex.test(vNode.properties.style.width)) {
          modifiedWidth = pixelToEMU(vNode.properties.style.width.match(pixelRegex)[1]);
        } else if (percentageRegex.test(vNode.properties.style.width)) {
          const percentageValue = vNode.properties.style.width.match(percentageRegex)[1];
          modifiedWidth = Math.round(percentageValue / 100 * originalWidthInEMU);
        }
      } else {
        if (vNode.properties.style.height && vNode.properties.style.height === "auto") {
          modifiedWidth = originalWidthInEMU;
          modifiedHeight = originalHeightInEMU;
        }
      }
    }
    if (vNode.properties.style.height) {
      if (vNode.properties.style.height !== "auto") {
        if (pixelRegex.test(vNode.properties.style.height)) {
          modifiedHeight = pixelToEMU(vNode.properties.style.height.match(pixelRegex)[1]);
        } else if (percentageRegex.test(vNode.properties.style.height)) {
          const percentageValue = vNode.properties.style.width.match(percentageRegex)[1];
          modifiedHeight = Math.round(percentageValue / 100 * originalHeightInEMU);
          if (!modifiedWidth) {
            modifiedWidth = Math.round(modifiedHeight * aspectRatio);
          }
        }
      } else {
        if (modifiedWidth) {
          if (!modifiedHeight) {
            modifiedHeight = Math.round(modifiedWidth / aspectRatio);
          }
        } else {
          modifiedHeight = originalHeightInEMU;
          modifiedWidth = originalWidthInEMU;
        }
      }
    }
    if (modifiedWidth && !modifiedHeight) {
      modifiedHeight = Math.round(modifiedWidth / aspectRatio);
    } else if (modifiedHeight && !modifiedWidth) {
      modifiedWidth = Math.round(modifiedHeight * aspectRatio);
    }
  } else {
    modifiedWidth = originalWidthInEMU;
    modifiedHeight = originalHeightInEMU;
  }
  attributes.width = modifiedWidth;
  attributes.height = modifiedHeight || 0;
}
async function buildParagraph(vNode, attributes, docxDocumentInstance) {
  const paragraphFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "p");
  const modifiedAttributes = modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes, {
    isParagraph: true
  });
  const paragraphPropertiesFragment = buildParagraphProperties(modifiedAttributes);
  paragraphFragment.import(paragraphPropertiesFragment);
  if (vNode && import_is_vnode.default(vNode) && vNodeHasChildren(vNode)) {
    if ([
      "span",
      "strong",
      "b",
      "em",
      "i",
      "u",
      "ins",
      "strike",
      "del",
      "s",
      "sub",
      "sup",
      "mark",
      "a",
      "code",
      "pre"
    ].includes(vNode.tagName)) {
      const runOrHyperlinkFragments = await buildRunOrHyperLink(vNode, modifiedAttributes, docxDocumentInstance);
      if (Array.isArray(runOrHyperlinkFragments)) {
        for (let iteratorIndex = 0;iteratorIndex < runOrHyperlinkFragments.length; iteratorIndex++) {
          const runOrHyperlinkFragment = runOrHyperlinkFragments[iteratorIndex];
          paragraphFragment.import(runOrHyperlinkFragment);
        }
      } else {
        paragraphFragment.import(runOrHyperlinkFragments);
      }
    } else if (vNode.tagName === "blockquote") {
      const runFragmentOrFragments = await buildRun(vNode, attributes, docxDocumentInstance);
      if (Array.isArray(runFragmentOrFragments)) {
        for (let index = 0;index < runFragmentOrFragments.length; index++) {
          paragraphFragment.import(runFragmentOrFragments[index]);
        }
      } else {
        paragraphFragment.import(runFragmentOrFragments);
      }
    } else {
      for (let index = 0;index < vNode.children.length; index++) {
        const childVNode = vNode.children[index];
        if (import_is_vnode.default(childVNode) && childVNode.tagName === "img") {
          if (isValidUrl(childVNode.properties.src)) {
            childVNode.properties.src = await fetchImageToDataUrl(childVNode.properties.src);
          }
          const base64String = extractBase64Data(childVNode.properties.src)?.base64Content;
          const imageBuffer = Buffer.from(decodeURIComponent(base64String || ""), "base64");
          const imageProperties = import_image_size.imageSize(imageBuffer);
          modifiedAttributes.maximumWidth = modifiedAttributes.maximumWidth || docxDocumentInstance.availableDocumentSpace;
          modifiedAttributes.originalWidth = imageProperties.width;
          modifiedAttributes.originalHeight = imageProperties.height;
          computeImageDimensions(childVNode, modifiedAttributes);
        }
        const runOrHyperlinkFragments = await buildRunOrHyperLink(childVNode, import_is_vnode.default(childVNode) && childVNode.tagName === "img" ? {
          ...modifiedAttributes,
          type: "picture",
          description: childVNode.properties.alt
        } : modifiedAttributes, docxDocumentInstance);
        if (Array.isArray(runOrHyperlinkFragments)) {
          for (let iteratorIndex = 0;iteratorIndex < runOrHyperlinkFragments.length; iteratorIndex++) {
            const runOrHyperlinkFragment = runOrHyperlinkFragments[iteratorIndex];
            paragraphFragment.import(runOrHyperlinkFragment);
          }
        } else {
          paragraphFragment.import(runOrHyperlinkFragments);
        }
      }
    }
  } else {
    if (vNode && import_is_vnode.default(vNode) && vNode.tagName === "img") {
      const imageSource = vNode.properties.src;
      if (isValidUrl(vNode.properties.src)) {
        vNode.properties.src = await fetchImageToDataUrl(vNode.properties.src);
      }
      const base64String = extractBase64Data(imageSource)?.base64Content;
      const imageBuffer = Buffer.from(decodeURIComponent(base64String || ""), "base64");
      const imageProperties = import_image_size.imageSize(imageBuffer);
      modifiedAttributes.maximumWidth = modifiedAttributes.maximumWidth || docxDocumentInstance.availableDocumentSpace;
      modifiedAttributes.originalWidth = imageProperties.width;
      modifiedAttributes.originalHeight = imageProperties.height;
      computeImageDimensions(vNode, modifiedAttributes);
    }
    const runFragments = await buildRunOrRuns(vNode, modifiedAttributes, docxDocumentInstance);
    if (Array.isArray(runFragments)) {
      for (let index = 0;index < runFragments.length; index++) {
        const runFragment = runFragments[index];
        paragraphFragment.import(runFragment);
      }
    } else {
      paragraphFragment.import(runFragments);
    }
  }
  paragraphFragment.up();
  return paragraphFragment;
}
function buildGridSpanFragment(spanValue) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "gridSpan").att("@w", "val", String(spanValue)).up();
}
function buildTableCellSpacing(cellSpacing = 0) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblCellSpacing").att("@w", "w", String(cellSpacing)).att("@w", "type", "dxa").up();
}
function buildTableCellBorders(tableCellBorder) {
  const tableCellBordersFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "tcBorders");
  const { color, stroke, ...borders } = tableCellBorder;
  Object.keys(borders).forEach((border) => {
    const borderVal = tableCellBorder[border];
    if (borderVal) {
      const borderFragment = buildBorder(border, borderVal, 0, color, stroke);
      tableCellBordersFragment.import(borderFragment);
    }
  });
  tableCellBordersFragment.up();
  return tableCellBordersFragment;
}
function buildTableCellWidth(tableCellWidth) {
  const colWidth = fixupColumnWidth(tableCellWidth);
  const frag = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tcW");
  if (typeof colWidth === "string" && colWidth.endsWith("%")) {
    return frag.att("@w", "w", colWidth).att("@w", "type", "pct").up();
  } else {
    return frag.att("@w", "w", String(colWidth)).att("@w", "type", "dxa").up();
  }
}
function buildTableCellProperties(attributes) {
  const tableCellPropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "tcPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach((key) => {
      switch (key) {
        case "backgroundColor": {
          if (attributes.backgroundColor) {
            const shadingFragment = buildShading(attributes.backgroundColor);
            tableCellPropertiesFragment.import(shadingFragment);
            delete attributes.backgroundColor;
          }
          break;
        }
        case "verticalAlign": {
          if (attributes.verticalAlign) {
            const verticalAlignmentFragment = buildVerticalAlignment(attributes.verticalAlign);
            tableCellPropertiesFragment.import(verticalAlignmentFragment);
            delete attributes.verticalAlign;
          }
          break;
        }
        case "colSpan": {
          if (attributes.colSpan) {
            const gridSpanFragment = buildGridSpanFragment(attributes.colSpan);
            tableCellPropertiesFragment.import(gridSpanFragment);
            delete attributes.colSpan;
          }
          break;
        }
        case "tableCellBorder": {
          if (attributes.tableCellBorder) {
            const tableCellBorderFragment = buildTableCellBorders(attributes.tableCellBorder);
            tableCellPropertiesFragment.import(tableCellBorderFragment);
            delete attributes.tableCellBorder;
          }
          break;
        }
        case "rowSpan": {
          if (attributes.rowSpan) {
            const verticalMergeFragment = buildVerticalMerge(attributes[key]);
            tableCellPropertiesFragment.import(verticalMergeFragment);
            delete attributes.rowSpan;
          }
          break;
        }
        case "width": {
          const widthFragment = buildTableCellWidth(attributes.width || 0);
          tableCellPropertiesFragment.import(widthFragment);
          delete attributes.width;
          break;
        }
        default:
          break;
      }
    });
  }
  tableCellPropertiesFragment.up();
  return tableCellPropertiesFragment;
}
function fixupTableCellBorder(vNode, attributes) {
  const defaultTableCellBorder = {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    color: "000000",
    stroke: "single"
  };
  if (Object.prototype.hasOwnProperty.call(vNode.properties.style, "border")) {
    if (vNode.properties.style.border === "none" || vNode.properties.style.border === 0) {
      attributes.tableCellBorder = defaultTableCellBorder;
    } else {
      const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style.border);
      attributes.tableCellBorder = {
        top: borderSize,
        left: borderSize,
        bottom: borderSize,
        right: borderSize,
        color: borderColor,
        stroke: borderStroke
      };
    }
  }
  if (vNode.properties.style["border-top"] && vNode.properties.style["border-top"] === "0") {
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      top: 0
    };
  } else if (vNode.properties.style["border-top"] && vNode.properties.style["border-top"] !== "0") {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-top"]);
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      top: borderSize,
      color: borderColor,
      stroke: borderStroke
    };
  }
  if (vNode.properties.style["border-left"] && vNode.properties.style["border-left"] === "0") {
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      left: 0
    };
  } else if (vNode.properties.style["border-left"] && vNode.properties.style["border-left"] !== "0") {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-left"]);
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      left: borderSize,
      color: borderColor,
      stroke: borderStroke
    };
  }
  if (vNode.properties.style["border-bottom"] && vNode.properties.style["border-bottom"] === "0") {
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      bottom: 0
    };
  } else if (vNode.properties.style["border-bottom"] && vNode.properties.style["border-bottom"] !== "0") {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-bottom"]);
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      bottom: borderSize,
      color: borderColor,
      stroke: borderStroke
    };
  }
  if (vNode.properties.style["border-right"] && vNode.properties.style["border-right"] === "0") {
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      right: 0
    };
  } else if (vNode.properties.style["border-right"] && vNode.properties.style["border-right"] !== "0") {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-right"]);
    attributes.tableCellBorder = {
      ...attributes.tableCellBorder || defaultTableCellBorder,
      right: borderSize,
      color: borderColor,
      stroke: borderStroke
    };
  }
}
async function buildTableCell(vNode, attributes, rowSpanMap, columnIndex, docxDocumentInstance) {
  const tableCellFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tc");
  let modifiedAttributes = { ...attributes };
  if (import_is_vnode.default(vNode) && vNode.properties) {
    if (vNode.properties.rowSpan) {
      rowSpanMap.set(columnIndex.index, {
        rowSpan: vNode.properties.rowSpan - 1,
        colSpan: 0
      });
      modifiedAttributes.rowSpan = "restart";
    } else {
      const previousSpanObject = rowSpanMap.get(columnIndex.index);
      rowSpanMap.set(columnIndex.index, Object.assign({}, previousSpanObject, {
        rowSpan: 0,
        colSpan: previousSpanObject && previousSpanObject.colSpan || 0
      }));
    }
    if (vNode.properties.colSpan || vNode.properties.style && vNode.properties.style["column-span"]) {
      modifiedAttributes.colSpan = vNode.properties.colSpan || vNode.properties.style && vNode.properties.style["column-span"];
      const previousSpanObject = rowSpanMap.get(columnIndex.index);
      rowSpanMap.set(columnIndex.index, Object.assign({}, previousSpanObject, {
        colSpan: Number(modifiedAttributes.colSpan) || 0
      }));
      columnIndex.index += Number(modifiedAttributes.colSpan) - 1;
    }
    if (vNode.properties.style) {
      modifiedAttributes = {
        ...modifiedAttributes,
        ...modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes)
      };
      fixupTableCellBorder(vNode, modifiedAttributes);
    }
  }
  const tableCellPropertiesFragment = buildTableCellProperties(modifiedAttributes);
  tableCellFragment.import(tableCellPropertiesFragment);
  if (vNodeHasChildren(vNode)) {
    for (let index = 0;index < vNode.children.length; index++) {
      const childVNode = vNode.children[index];
      if (import_is_vnode.default(childVNode) && childVNode.tagName === "img") {
        if (modifiedAttributes.maximumWidth) {
          const imageFragment = await buildImage(docxDocumentInstance, childVNode, modifiedAttributes.maximumWidth);
          if (imageFragment) {
            tableCellFragment.import(imageFragment);
          }
        }
      } else if (import_is_vnode.default(childVNode) && childVNode.tagName === "figure") {
        if (vNodeHasChildren(childVNode)) {
          for (let iteratorIndex = 0;iteratorIndex < childVNode.children.length; iteratorIndex++) {
            const grandChildVNode = childVNode.children[iteratorIndex];
            if (import_is_vnode.default(grandChildVNode) && grandChildVNode.tagName === "img") {
              const imageFragment = await buildImage(docxDocumentInstance, grandChildVNode, modifiedAttributes.maximumWidth || 0);
              if (imageFragment) {
                tableCellFragment.import(imageFragment);
              }
            }
          }
        }
      } else if (import_is_vnode.default(childVNode) && ["ul", "ol"].includes(childVNode.tagName)) {
        if (vNodeHasChildren(childVNode)) {
          await buildList(childVNode, docxDocumentInstance, tableCellFragment);
        }
      } else {
        const paragraphFragment = await buildParagraph(childVNode, modifiedAttributes, docxDocumentInstance);
        tableCellFragment.import(paragraphFragment);
      }
    }
  } else {
    const paragraphFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "p").up();
    tableCellFragment.import(paragraphFragment);
  }
  tableCellFragment.up();
  return tableCellFragment;
}
function buildRowSpanCell(rowSpanMap, columnIndex, attributes) {
  const rowSpanCellFragments = [];
  let spanObject = rowSpanMap.get(columnIndex.index);
  while (spanObject && spanObject.rowSpan) {
    const rowSpanCellFragment = import_xmlbuilder2.fragment({
      namespaceAlias: { w: namespaces_default.w }
    }).ele("@w", "tc");
    const tableCellPropertiesFragment = buildTableCellProperties({
      ...attributes,
      rowSpan: "continue",
      colSpan: spanObject.colSpan ? spanObject.colSpan : 0
    });
    rowSpanCellFragment.import(tableCellPropertiesFragment);
    const paragraphFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "p").up();
    rowSpanCellFragment.import(paragraphFragment);
    rowSpanCellFragment.up();
    rowSpanCellFragments.push(rowSpanCellFragment);
    if (spanObject.rowSpan - 1 === 0) {
      rowSpanMap.delete(columnIndex.index);
    } else {
      rowSpanMap.set(columnIndex.index, {
        rowSpan: spanObject.rowSpan - 1,
        colSpan: spanObject.colSpan || 0
      });
    }
    columnIndex.index += spanObject.colSpan || 1;
    spanObject = rowSpanMap.get(columnIndex.index);
  }
  return rowSpanCellFragments;
}
function buildTableRowProperties(attributes) {
  const tableRowPropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "trPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach((key) => {
      switch (key) {
        case "tableRowHeight": {
          if (attributes.tableRowHeight) {
            const tableRowHeightFragment = buildTableRowHeight(attributes.tableRowHeight);
            tableRowPropertiesFragment.import(tableRowHeightFragment);
            delete attributes.tableRowHeight;
          }
          break;
        }
        case "rowCantSplit":
          if (attributes.rowCantSplit) {
            const cantSplitFragment = import_xmlbuilder2.fragment({
              namespaceAlias: { w: namespaces_default.w }
            }).ele("@w", "cantSplit").up();
            tableRowPropertiesFragment.import(cantSplitFragment);
            delete attributes.rowCantSplit;
          }
          break;
        default:
          break;
      }
    });
  }
  tableRowPropertiesFragment.up();
  return tableRowPropertiesFragment;
}
async function buildTableRow(vNode, attributes, rowSpanMap, docxDocumentInstance) {
  const tableRowFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tr");
  const modifiedAttributes = { ...attributes };
  if (import_is_vnode.default(vNode) && vNode.properties) {
    const firstChild = vNode.children[0];
    if (vNode.properties.style && vNode.properties.style.height || firstChild && import_is_vnode.default(firstChild) && firstChild.properties.style && firstChild.properties.style.height) {
      modifiedAttributes.tableRowHeight = fixupRowHeight(vNode.properties.style && vNode.properties.style.height || (firstChild && import_is_vnode.default(firstChild) && firstChild.properties.style && firstChild.properties.style.height ? firstChild.properties.style.height : undefined));
    }
    if (vNode.properties.style) {
      fixupTableCellBorder(vNode, modifiedAttributes);
    }
  }
  const tableRowPropertiesFragment = buildTableRowProperties(modifiedAttributes);
  tableRowFragment.import(tableRowPropertiesFragment);
  const columnIndex = { index: 0 };
  if (vNodeHasChildren(vNode)) {
    const tableColumns = vNode.children.filter((childVNode) => import_is_vnode.default(childVNode) && ["td", "th"].includes(childVNode.tagName));
    const maximumColumnWidth = docxDocumentInstance.availableDocumentSpace / tableColumns.length;
    for (const column of tableColumns) {
      const rowSpanCellFragments = buildRowSpanCell(rowSpanMap, columnIndex, modifiedAttributes);
      if (Array.isArray(rowSpanCellFragments)) {
        for (let iteratorIndex = 0;iteratorIndex < rowSpanCellFragments.length; iteratorIndex++) {
          const rowSpanCellFragment = rowSpanCellFragments[iteratorIndex];
          tableRowFragment.import(rowSpanCellFragment);
        }
      }
      const tableCellFragment = await buildTableCell(column, { ...modifiedAttributes, maximumWidth: maximumColumnWidth }, rowSpanMap, columnIndex, docxDocumentInstance);
      columnIndex.index++;
      tableRowFragment.import(tableCellFragment);
    }
  }
  if (columnIndex.index < rowSpanMap.size) {
    const rowSpanCellFragments = buildRowSpanCell(rowSpanMap, columnIndex, modifiedAttributes);
    if (Array.isArray(rowSpanCellFragments)) {
      for (let iteratorIndex = 0;iteratorIndex < rowSpanCellFragments.length; iteratorIndex++) {
        const rowSpanCellFragment = rowSpanCellFragments[iteratorIndex];
        tableRowFragment.import(rowSpanCellFragment);
      }
    }
  }
  tableRowFragment.up();
  return tableRowFragment;
}
function buildTableGridCol(gridWidth) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "gridCol").att("@w", "w", String(Math.round(gridWidth)));
}
function buildTableGrid(vNode, attributes) {
  const tableGridFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblGrid");
  if (vNodeHasChildren(vNode)) {
    const gridColumns = vNode.children.filter((childVNode) => import_is_vnode.default(childVNode) && childVNode.tagName === "col");
    const gridWidth = (attributes.maximumWidth || 0) / gridColumns.length;
    for (let index = 0;index < gridColumns.length; index++) {
      const tableGridColFragment = buildTableGridCol(gridWidth);
      tableGridFragment.import(tableGridColFragment);
    }
  }
  tableGridFragment.up();
  return tableGridFragment;
}
function buildTableGridFromTableRow(vNode, attributes) {
  const tableGridFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblGrid");
  if (vNodeHasChildren(vNode)) {
    const numberOfGridColumns = vNode.children.reduce((accumulator, childVNode) => {
      let colSpan;
      if (import_is_vnode.default(childVNode)) {
        const props = childVNode.properties;
        colSpan = props.colSpan || props.style && props.style["column-span"];
      }
      return accumulator + (colSpan ? parseInt(colSpan) : 1);
    }, 0);
    const gridWidth = (attributes.maximumWidth || 0) / numberOfGridColumns;
    for (let index = 0;index < numberOfGridColumns; index++) {
      const tableGridColFragment = buildTableGridCol(gridWidth);
      tableGridFragment.import(tableGridColFragment);
    }
  }
  tableGridFragment.up();
  return tableGridFragment;
}
function buildTableBorders(tableBorder) {
  const tableBordersFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblBorders");
  const { color, stroke, ...borders } = tableBorder;
  Object.keys(borders).forEach((border) => {
    const borderVal = tableBorder[border];
    if (borderVal) {
      const borderFragment = buildBorder(border, borderVal, 0, color, stroke);
      tableBordersFragment.import(borderFragment);
    }
  });
  tableBordersFragment.up();
  return tableBordersFragment;
}
function buildTableWidth(tableWidth) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblW").att("@w", "type", "dxa").att("@w", "w", String(tableWidth)).up();
}
function buildCellMargin(side, margin) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", side).att("@w", "type", "dxa").att("@w", "w", String(margin)).up();
}
function buildTableCellMargins(margin) {
  const tableCellMarFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tblCellMar");
  ["top", "bottom"].forEach((side) => {
    const marginFragment = buildCellMargin(side, margin / 2);
    tableCellMarFragment.import(marginFragment);
  });
  ["left", "right"].forEach((side) => {
    const marginFragment = buildCellMargin(side, margin);
    tableCellMarFragment.import(marginFragment);
  });
  return tableCellMarFragment;
}
function buildTableProperties(attributes) {
  const tablePropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { w: namespaces_default.w }
  }).ele("@w", "tblPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach((key) => {
      switch (key) {
        case "tableBorder": {
          if (attributes.tableBorder) {
            const tableBordersFragment = buildTableBorders(attributes.tableBorder);
            tablePropertiesFragment.import(tableBordersFragment);
            delete attributes.tableBorder;
          }
          break;
        }
        case "tableCellSpacing": {
          const tableCellSpacingFragment = buildTableCellSpacing(attributes[key]);
          tablePropertiesFragment.import(tableCellSpacingFragment);
          delete attributes.tableCellSpacing;
          break;
        }
        case "width": {
          if (attributes[key]) {
            const tableWidthFragment = buildTableWidth(attributes[key]);
            tablePropertiesFragment.import(tableWidthFragment);
          }
          delete attributes.width;
          break;
        }
        default:
          break;
      }
    });
  }
  const tableCellMarginFragment = buildTableCellMargins(160);
  tablePropertiesFragment.import(tableCellMarginFragment);
  const alignmentFragment = buildHorizontalAlignment("center");
  tablePropertiesFragment.import(alignmentFragment);
  tablePropertiesFragment.up();
  return tablePropertiesFragment;
}
function cssBorderParser(borderString) {
  const [size, stroke, color] = borderString.split(" ");
  let sizeNum = parseInt(size);
  if (pointRegex.test(size)) {
    const matchedParts = size.match(pointRegex);
    sizeNum = pointToEIP(Number(matchedParts?.[1]));
  } else if (pixelRegex.test(size)) {
    const matchedParts = size.match(pixelRegex);
    sizeNum = pixelToEIP(Number(matchedParts?.[1]));
  }
  return [
    sizeNum,
    stroke && ["dashed", "dotted", "double"].includes(stroke) ? stroke : "single",
    color && fixupColorCode(color).toUpperCase()
  ];
}
async function buildTable(vNode, attributes, docxDocumentInstance) {
  const tableFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "tbl");
  const modifiedAttributes = { ...attributes };
  if (import_is_vnode.default(vNode) && vNode.properties) {
    const tableAttributes = vNode.properties.attributes || {};
    const tableStyles = vNode.properties.style || {};
    let [borderSize, borderStrike, borderColor] = [2, "single", "000000"];
    if (!isNaN(Number(tableAttributes.border))) {
      borderSize = parseInt(tableAttributes.border, 10);
    }
    if (tableStyles.border) {
      const [cssSize, cssStroke, cssColor] = cssBorderParser(tableStyles.border);
      borderSize = Number(cssSize) || borderSize;
      borderColor = String(cssColor) || borderColor;
      borderStrike = String(cssStroke) || borderStrike;
    }
    const tableBorders = {
      top: borderSize,
      bottom: borderSize,
      left: borderSize,
      right: borderSize,
      stroke: borderStrike,
      color: borderColor,
      insideV: 0,
      insideH: 0
    };
    if (tableStyles["border-collapse"] === "collapse") {
      tableBorders.insideV = borderSize;
      tableBorders.insideH = borderSize;
    } else {
      modifiedAttributes.tableCellBorder = {
        top: 1,
        bottom: 1,
        left: 1,
        right: 1,
        color: "000000",
        stroke: "single"
      };
    }
    modifiedAttributes.tableBorder = tableBorders;
    modifiedAttributes.tableCellSpacing = 0;
    let minimumWidth;
    let maximumWidth;
    let width;
    if (pixelRegex.test(tableStyles["min-width"])) {
      minimumWidth = pixelToTWIP(tableStyles["min-width"].match(pixelRegex)[1]);
    } else if (percentageRegex.test(tableStyles["min-width"])) {
      const percentageValue = tableStyles["min-width"].match(percentageRegex)[1];
      minimumWidth = Math.round(percentageValue / 100 * (attributes.maximumWidth || 0));
    }
    if (pixelRegex.test(tableStyles["max-width"])) {
      pixelRegex.lastIndex = 0;
      maximumWidth = pixelToTWIP(tableStyles["max-width"].match(pixelRegex)[1]);
    } else if (percentageRegex.test(tableStyles["max-width"])) {
      percentageRegex.lastIndex = 0;
      const percentageValue = tableStyles["max-width"].match(percentageRegex)[1];
      maximumWidth = Math.round(percentageValue / 100 * (attributes.maximumWidth || 0));
    }
    if (pixelRegex.test(tableStyles.width)) {
      pixelRegex.lastIndex = 0;
      width = pixelToTWIP(tableStyles.width.match(pixelRegex)[1]);
    } else if (percentageRegex.test(tableStyles.width)) {
      percentageRegex.lastIndex = 0;
      const percentageValue = tableStyles.width.match(percentageRegex)[1];
      width = Math.round(percentageValue / 100 * (attributes.maximumWidth || 0));
    }
    if (width) {
      modifiedAttributes.width = width;
      if (maximumWidth) {
        modifiedAttributes.width = Math.min(modifiedAttributes.width, maximumWidth);
      }
      if (minimumWidth) {
        modifiedAttributes.width = Math.max(modifiedAttributes.width, minimumWidth);
      }
    } else if (minimumWidth) {
      modifiedAttributes.width = minimumWidth;
    }
    if (modifiedAttributes.width) {
      modifiedAttributes.width = Math.min(modifiedAttributes.width, attributes.maximumWidth || 0);
    }
  }
  const tablePropertiesFragment = buildTableProperties(modifiedAttributes);
  tableFragment.import(tablePropertiesFragment);
  const rowSpanMap = new Map;
  if (vNodeHasChildren(vNode)) {
    for (let index = 0;index < vNode.children.length; index++) {
      if (import_is_vnode.default(vNode.children[index])) {
        const childVNode = vNode.children[index];
        if (childVNode.tagName === "colgroup") {
          const tableGridFragment = buildTableGrid(childVNode, modifiedAttributes);
          tableFragment.import(tableGridFragment);
        } else if (childVNode.tagName === "thead") {
          for (let iteratorIndex = 0;iteratorIndex < childVNode.children.length; iteratorIndex++) {
            if (import_is_vnode.default(childVNode.children[iteratorIndex])) {
              const grandChildVNode = childVNode.children[iteratorIndex];
              if (grandChildVNode.tagName === "tr") {
                if (iteratorIndex === 0) {
                  const tableGridFragment = buildTableGridFromTableRow(grandChildVNode, modifiedAttributes);
                  tableFragment.import(tableGridFragment);
                }
                const tableRowFragment = await buildTableRow(grandChildVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
                tableFragment.import(tableRowFragment);
              }
            }
          }
        } else if (childVNode.tagName === "tbody") {
          for (let iteratorIndex = 0;iteratorIndex < childVNode.children.length; iteratorIndex++) {
            if (import_is_vnode.default(childVNode.children[iteratorIndex])) {
              const grandChildVNode = childVNode.children[iteratorIndex];
              if (grandChildVNode.tagName === "tr") {
                if (iteratorIndex === 0) {
                  const tableGridFragment = buildTableGridFromTableRow(grandChildVNode, modifiedAttributes);
                  tableFragment.import(tableGridFragment);
                }
                const tableRowFragment = await buildTableRow(grandChildVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
                tableFragment.import(tableRowFragment);
              }
            }
          }
        } else if (childVNode.tagName === "tr") {
          if (index === 0) {
            const tableGridFragment = buildTableGridFromTableRow(childVNode, modifiedAttributes);
            tableFragment.import(tableGridFragment);
          }
          const tableRowFragment = await buildTableRow(childVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
          tableFragment.import(tableRowFragment);
        }
      }
    }
  }
  tableFragment.up();
  return tableFragment;
}
function buildPresetGeometry() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "prstGeom").att("prst", "rect").up();
}
function buildExtents({ width = 0, height = 0 }) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "ext").att("cx", String(width)).att("cy", String(height)).up();
}
function buildOffset() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "off").att("x", "0").att("y", "0").up();
}
function buildGraphicFrameTransform(attributes) {
  const graphicFrameTransformFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { a: namespaces_default.a }
  }).ele("@a", "xfrm");
  const offsetFragment = buildOffset();
  graphicFrameTransformFragment.import(offsetFragment);
  const extentsFragment = buildExtents(attributes);
  graphicFrameTransformFragment.import(extentsFragment);
  graphicFrameTransformFragment.up();
  return graphicFrameTransformFragment;
}
function buildShapeProperties(attributes) {
  const shapeProperties = import_xmlbuilder2.fragment({ namespaceAlias: { pic: namespaces_default.pic } }).ele("@pic", "spPr");
  const graphicFrameTransformFragment = buildGraphicFrameTransform(attributes);
  shapeProperties.import(graphicFrameTransformFragment);
  const presetGeometryFragment = buildPresetGeometry();
  shapeProperties.import(presetGeometryFragment);
  shapeProperties.up();
  return shapeProperties;
}
function buildFillRect() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "fillRect").up();
}
function buildStretch() {
  const stretchFragment = import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "stretch");
  const fillRectFragment = buildFillRect();
  stretchFragment.import(fillRectFragment);
  stretchFragment.up();
  return stretchFragment;
}
function buildSrcRectFragment() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "srcRect").att("b", "0").att("l", "0").att("r", "0").att("t", "0").up();
}
function buildBinaryLargeImageOrPicture(relationshipId) {
  return import_xmlbuilder2.fragment({
    namespaceAlias: { a: namespaces_default.a, r: namespaces_default.r }
  }).ele("@a", "blip").att("@r", "embed", `rId${relationshipId}`).att("cstate", "print").up();
}
function buildBinaryLargeImageOrPictureFill(relationshipId) {
  const binaryLargeImageOrPictureFillFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { pic: namespaces_default.pic }
  }).ele("@pic", "blipFill");
  const binaryLargeImageOrPictureFragment = buildBinaryLargeImageOrPicture(relationshipId);
  binaryLargeImageOrPictureFillFragment.import(binaryLargeImageOrPictureFragment);
  const srcRectFragment = buildSrcRectFragment();
  binaryLargeImageOrPictureFillFragment.import(srcRectFragment);
  const stretchFragment = buildStretch();
  binaryLargeImageOrPictureFillFragment.import(stretchFragment);
  binaryLargeImageOrPictureFillFragment.up();
  return binaryLargeImageOrPictureFillFragment;
}
function buildNonVisualPictureDrawingProperties() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { pic: namespaces_default.pic } }).ele("@pic", "cNvPicPr").up();
}
function buildNonVisualDrawingProperties(pictureId, pictureNameWithExtension, pictureDescription = "") {
  return import_xmlbuilder2.fragment({ namespaceAlias: { pic: namespaces_default.pic } }).ele("@pic", "cNvPr").att("id", String(pictureId)).att("name", pictureNameWithExtension).att("descr", pictureDescription).up();
}
function buildNonVisualPictureProperties(pictureId, pictureNameWithExtension, pictureDescription) {
  const nonVisualPicturePropertiesFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { pic: namespaces_default.pic }
  }).ele("@pic", "nvPicPr");
  const nonVisualDrawingPropertiesFragment = buildNonVisualDrawingProperties(pictureId, pictureNameWithExtension, pictureDescription);
  nonVisualPicturePropertiesFragment.import(nonVisualDrawingPropertiesFragment);
  const nonVisualPictureDrawingPropertiesFragment = buildNonVisualPictureDrawingProperties();
  nonVisualPicturePropertiesFragment.import(nonVisualPictureDrawingPropertiesFragment);
  nonVisualPicturePropertiesFragment.up();
  return nonVisualPicturePropertiesFragment;
}
function buildPicture({
  id,
  fileNameWithExtension,
  description,
  relationshipId,
  width = 0,
  height = 0
}) {
  const pictureFragment = import_xmlbuilder2.fragment({ namespaceAlias: { pic: namespaces_default.pic } }).ele("@pic", "pic");
  const nonVisualPicturePropertiesFragment = buildNonVisualPictureProperties(id || 0, fileNameWithExtension || "", description || "");
  pictureFragment.import(nonVisualPicturePropertiesFragment);
  const binaryLargeImageOrPictureFill = buildBinaryLargeImageOrPictureFill(relationshipId || 0);
  pictureFragment.import(binaryLargeImageOrPictureFill);
  const shapeProperties = buildShapeProperties({ width, height });
  pictureFragment.import(shapeProperties);
  pictureFragment.up();
  return pictureFragment;
}
function buildGraphicData(graphicType, attributes) {
  const graphicDataFragment = import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "graphicData").att("uri", "http://schemas.openxmlformats.org/drawingml/2006/picture");
  if (graphicType === "picture") {
    const pictureFragment = buildPicture(attributes);
    graphicDataFragment.import(pictureFragment);
  }
  graphicDataFragment.up();
  return graphicDataFragment;
}
function buildGraphic(graphicType, attributes) {
  const graphicFragment = import_xmlbuilder2.fragment({ namespaceAlias: { a: namespaces_default.a } }).ele("@a", "graphic");
  const graphicDataFragment = buildGraphicData(graphicType, attributes);
  graphicFragment.import(graphicDataFragment);
  graphicFragment.up();
  return graphicFragment;
}
function buildDrawingObjectNonVisualProperties(pictureId, pictureName) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "docPr").att("id", String(pictureId)).att("name", pictureName).up();
}
function buildWrapSquare() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "wrapSquare").att("wrapText", "bothSides").att("distB", "228600").att("distT", "228600").att("distL", "228600").att("distR", "228600").up();
}
function buildEffectExtentFragment() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "effectExtent").att("b", "0").att("l", "0").att("r", "0").att("t", "0").up();
}
function buildExtent({ width = 0, height = 0 }) {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "extent").att("cx", String(width)).att("cy", String(height)).up();
}
function buildPositionV() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "positionV").att("relativeFrom", "paragraph").ele("@wp", "posOffset").txt("19050").up();
}
function buildPositionH() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "positionH").att("relativeFrom", "column").ele("@wp", "posOffset").txt("19050").up();
}
function buildSimplePos() {
  return import_xmlbuilder2.fragment({ namespaceAlias: { wp: namespaces_default.wp } }).ele("@wp", "simplePos").att("x", "0").att("y", "0").up();
}
function buildAnchoredDrawing(graphicType, attributes) {
  const anchoredDrawingFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { wp: namespaces_default.wp }
  }).ele("@wp", "anchor").att("distB", "0").att("distL", "0").att("distR", "0").att("distT", "0").att("relativeHeight", "0").att("behindDoc", "false").att("locked", "true").att("layoutInCell", "true").att("allowOverlap", "false").att("simplePos", "false");
  const simplePosFragment = buildSimplePos();
  anchoredDrawingFragment.import(simplePosFragment);
  const positionHFragment = buildPositionH();
  anchoredDrawingFragment.import(positionHFragment);
  const positionVFragment = buildPositionV();
  anchoredDrawingFragment.import(positionVFragment);
  const extentFragment = buildExtent({
    width: attributes.width,
    height: attributes.height
  });
  anchoredDrawingFragment.import(extentFragment);
  const effectExtentFragment = buildEffectExtentFragment();
  anchoredDrawingFragment.import(effectExtentFragment);
  const wrapSquareFragment = buildWrapSquare();
  anchoredDrawingFragment.import(wrapSquareFragment);
  const drawingObjectNonVisualPropertiesFragment = buildDrawingObjectNonVisualProperties(attributes.id || 0, attributes.fileNameWithExtension || "");
  anchoredDrawingFragment.import(drawingObjectNonVisualPropertiesFragment);
  const graphicFragment = buildGraphic(graphicType, attributes);
  anchoredDrawingFragment.import(graphicFragment);
  anchoredDrawingFragment.up();
  return anchoredDrawingFragment;
}
function buildInlineDrawing(graphicType, attributes) {
  const inlineDrawingFragment = import_xmlbuilder2.fragment({
    namespaceAlias: { wp: namespaces_default.wp }
  }).ele("@wp", "inline").att("distB", "0").att("distL", "0").att("distR", "0").att("distT", "0");
  const extentFragment = buildExtent({
    width: attributes.width,
    height: attributes.height
  });
  inlineDrawingFragment.import(extentFragment);
  const effectExtentFragment = buildEffectExtentFragment();
  inlineDrawingFragment.import(effectExtentFragment);
  const drawingObjectNonVisualPropertiesFragment = buildDrawingObjectNonVisualProperties(attributes.id || 0, attributes.fileNameWithExtension || "");
  inlineDrawingFragment.import(drawingObjectNonVisualPropertiesFragment);
  const graphicFragment = buildGraphic(graphicType, attributes);
  inlineDrawingFragment.import(graphicFragment);
  inlineDrawingFragment.up();
  return inlineDrawingFragment;
}
function buildDrawing(attributes) {
  const inlineOrAnchored = attributes.inlineOrAnchored || false;
  const graphicType = attributes.graphicType || "picture";
  const drawingFragment = import_xmlbuilder2.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "drawing");
  const inlineOrAnchoredDrawingFragment = inlineOrAnchored ? buildInlineDrawing(graphicType, attributes) : buildAnchoredDrawing(graphicType, attributes);
  drawingFragment.import(inlineOrAnchoredDrawingFragment);
  drawingFragment.up();
  return drawingFragment;
}

// src/helpers/render-document-file.ts
var convertHTML = import_html_to_vdom.default({
  VNode: import_vnode2.default,
  VText: import_vtext.default
});
async function buildImage(docxDocumentInstance, vNode, maximumWidth) {
  let response = null;
  try {
    if (isValidUrl(vNode.properties.src)) {
      vNode.properties.src = await fetchImageToDataUrl(vNode.properties.src);
    }
    const base64Uri = decodeURIComponent(vNode.properties.src);
    if (base64Uri) {
      response = docxDocumentInstance.createMediaFile(base64Uri);
    }
  } catch (error) {
    console.error(error);
  }
  if (response) {
    docxDocumentInstance.zip.folder("word")?.folder("media")?.file(response.fileNameWithExtension, Buffer.from(response.fileContent, "base64"), {
      createFolders: false
    });
    const documentRelsId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, imageType, `media/${response.fileNameWithExtension}`, internalRelationship);
    const imageBuffer = Buffer.from(response.fileContent, "base64");
    const imageProperties = import_image_size2.imageSize(imageBuffer);
    const imageFragment = await buildParagraph(vNode, {
      type: "picture",
      inlineOrAnchored: true,
      relationshipId: documentRelsId,
      ...response,
      description: vNode.properties.alt,
      maximumWidth: maximumWidth || docxDocumentInstance.availableDocumentSpace,
      originalWidth: imageProperties.width,
      originalHeight: imageProperties.height
    }, docxDocumentInstance);
    return imageFragment;
  }
}
async function buildList(vNode, docxDocumentInstance, xmlFragment) {
  const listElements = [];
  let vNodeObjects = [
    {
      node: vNode,
      level: 0,
      type: vNode.tagName,
      numberingId: docxDocumentInstance.createNumbering(vNode.tagName, vNode.properties)
    }
  ];
  while (vNodeObjects.length) {
    const tempVNodeObject = vNodeObjects.shift();
    if (tempVNodeObject) {
      if (import_is_vtext2.default(tempVNodeObject.node) || import_is_vnode2.default(tempVNodeObject.node) && !["ul", "ol", "li"].includes(tempVNodeObject.node.tagName)) {
        const paragraphFragment = await buildParagraph(tempVNodeObject.node, {
          numbering: {
            levelId: tempVNodeObject.level,
            numberingId: tempVNodeObject.numberingId
          }
        }, docxDocumentInstance);
        xmlFragment.import(paragraphFragment);
      }
    }
    if (tempVNodeObject?.node.children && tempVNodeObject?.node.children.length && ["ul", "ol", "li"].includes(tempVNodeObject?.node.tagName)) {
      const tempVNodeObjects = tempVNodeObject.node.children.reduce((accumulator, childVNode) => {
        if (["ul", "ol"].includes(childVNode.tagName)) {
          accumulator.push({
            node: childVNode,
            level: tempVNodeObject.level + 1,
            type: childVNode.tagName,
            numberingId: docxDocumentInstance.createNumbering(childVNode.tagName, childVNode.properties)
          });
        } else {
          if (accumulator.length > 0 && import_is_vnode2.default(accumulator[accumulator.length - 1].node) && accumulator[accumulator.length - 1].node.tagName.toLowerCase() === "p") {
            accumulator[accumulator.length - 1].node.children.push(childVNode);
          } else {
            const paragraphVNode = new import_vnode2.default("p", null, import_is_vtext2.default(childVNode) ? [childVNode] : import_is_vnode2.default(childVNode) ? childVNode.tagName.toLowerCase() === "li" ? [...childVNode.children] : [childVNode] : []);
            accumulator.push({
              node: import_is_vnode2.default(childVNode) ? childVNode.tagName.toLowerCase() === "li" ? childVNode : childVNode.tagName.toLowerCase() !== "p" ? paragraphVNode : childVNode : paragraphVNode,
              level: tempVNodeObject.level,
              type: tempVNodeObject.type,
              numberingId: tempVNodeObject.numberingId
            });
          }
        }
        return accumulator;
      }, []);
      vNodeObjects = tempVNodeObjects.concat(vNodeObjects);
    }
  }
  return listElements;
}
async function findXMLEquivalent(docxDocumentInstance, vNode, xmlFragment) {
  if (vNode.tagName === "div" && (vNode.properties.attributes.class === "page-break" || vNode.properties.style && vNode.properties.style["page-break-after"])) {
    const paragraphFragment = import_xmlbuilder22.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "p").ele("@w", "r").ele("@w", "br").att("@w", "type", "page").up().up().up();
    xmlFragment.import(paragraphFragment);
    return;
  }
  switch (vNode.tagName) {
    case "h1":
    case "h2":
    case "h3":
    case "h4":
    case "h5":
    case "h6":
      const headingFragment = await buildParagraph(vNode, {
        paragraphStyle: `Heading${vNode.tagName[1]}`
      }, docxDocumentInstance);
      xmlFragment.import(headingFragment);
      return;
    case "span":
    case "strong":
    case "b":
    case "em":
    case "i":
    case "u":
    case "ins":
    case "strike":
    case "del":
    case "s":
    case "sub":
    case "sup":
    case "mark":
    case "p":
    case "a":
    case "blockquote":
    case "code":
    case "pre":
      const paragraphFragment = await buildParagraph(vNode, {}, docxDocumentInstance);
      xmlFragment.import(paragraphFragment);
      return;
    case "figure":
      if (vNodeHasChildren(vNode)) {
        for (let index = 0;index < vNode.children.length; index++) {
          const childVNode = vNode.children[index];
          if (childVNode.tagName === "table") {
            const tableFragment2 = await buildTable(childVNode, {
              maximumWidth: docxDocumentInstance.availableDocumentSpace,
              rowCantSplit: docxDocumentInstance.tableRowCantSplit
            }, docxDocumentInstance);
            xmlFragment.import(tableFragment2);
            const emptyParagraphFragment2 = await buildParagraph(null, {}, docxDocumentInstance);
            xmlFragment.import(emptyParagraphFragment2);
          } else if (childVNode.tagName === "img") {
            const imageFragment2 = await buildImage(docxDocumentInstance, childVNode, docxDocumentInstance.availableDocumentSpace);
            if (imageFragment2) {
              xmlFragment.import(imageFragment2);
            }
          }
        }
      }
      return;
    case "table":
      const tableFragment = await buildTable(vNode, {
        maximumWidth: docxDocumentInstance.availableDocumentSpace,
        rowCantSplit: docxDocumentInstance.tableRowCantSplit
      }, docxDocumentInstance);
      xmlFragment.import(tableFragment);
      const emptyParagraphFragment = await buildParagraph(null, {}, docxDocumentInstance);
      xmlFragment.import(emptyParagraphFragment);
      return;
    case "ol":
    case "ul":
      await buildList(vNode, docxDocumentInstance, xmlFragment);
      return;
    case "img":
      const imageFragment = await buildImage(docxDocumentInstance, vNode, docxDocumentInstance.availableDocumentSpace);
      if (imageFragment) {
        xmlFragment.import(imageFragment);
      }
      return;
    case "br":
      const linebreakFragment = await buildParagraph(null, {}, docxDocumentInstance);
      xmlFragment.import(linebreakFragment);
      return;
    case "head":
      return;
    default:
      break;
  }
  if (vNodeHasChildren(vNode)) {
    for (let index = 0;index < vNode.children.length; index++) {
      const childVNode = vNode.children[index];
      await convertVTreeToXML(docxDocumentInstance, childVNode, xmlFragment);
    }
  }
}
async function convertVTreeToXML(docxDocumentInstance, vTree, xmlFragment) {
  if (!vTree) {
    return xmlFragment;
  }
  if (Array.isArray(vTree) && vTree.length) {
    for (let index = 0;index < vTree.length; index++) {
      const vNode = vTree[index];
      await convertVTreeToXML(docxDocumentInstance, vNode, xmlFragment);
    }
  } else if (import_is_vnode2.default(vTree)) {
    await findXMLEquivalent(docxDocumentInstance, vTree, xmlFragment);
  } else if (import_is_vtext2.default(vTree)) {
    const paragraphFragment = await buildParagraph(vTree, {}, docxDocumentInstance);
    xmlFragment.import(paragraphFragment);
  }
  return xmlFragment;
}
async function renderDocumentFile(docxDocumentInstance) {
  if (!docxDocumentInstance.htmlString) {
    throw new Error("HTML string is required");
  }
  const vTree = convertHTML(docxDocumentInstance.htmlString);
  const xmlFragment = import_xmlbuilder22.fragment({ namespaceAlias: { w: namespaces_default.w } });
  const populatedXmlFragment = await convertVTreeToXML(docxDocumentInstance, vTree, xmlFragment);
  return populatedXmlFragment;
}
// src/schemas/content-types.ts
var contentTypesXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels"
    ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="jpeg"
    ContentType="image/jpeg"/>
  <Default Extension="png"
    ContentType="image/png"/>
  <Default Extension="xml"
    ContentType="application/xml"/>
  <Override PartName="/_rels/.rels"
    ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Override PartName="/word/_rels/document.xml.rels"
    ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Override PartName="/word/document.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
  <Override PartName="/word/numbering.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml"/>
  <Override PartName="/word/theme/theme1.xml"
    ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>
  <Override PartName="/word/fontTable.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"/>
  <Override PartName="/docProps/core.xml"
    ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
  <Override PartName="/word/settings.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>
  <Override PartName="/word/webSettings.xml"
    ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"/>
</Types>
`;
var content_types_default = contentTypesXML;
// src/schemas/core.ts
function generateCoreXML(title = "", subject = "", creator = applicationName, keywords = [applicationName], description = "", lastModifiedBy = applicationName, revision = 1, createdAt = new Date, modifiedAt = new Date) {
  const keyws = keywords && Array.isArray(keywords) ? `<cp:keywords>${keywords.join(", ")}</cp:keywords>` : "";
  const crAt = createdAt instanceof Date ? createdAt.toISOString() : new Date().toISOString();
  const modAt = modifiedAt instanceof Date ? modifiedAt.toISOString() : new Date().toISOString();
  return `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <cp:coreProperties
      xmlns:cp="${namespaces_default.coreProperties}"
      xmlns:dc="${namespaces_default.dc}"
      xmlns:dcterms="${namespaces_default.dcterms}"
      xmlns:dcmitype="${namespaces_default.dcmitype}"
      xmlns:xsi="${namespaces_default.xsi}"
    >
      <dc:title>${title}</dc:title>
      <dc:subject>${subject}</dc:subject>
      <dc:creator>${creator}</dc:creator>
      ${keyws}
      <dc:description>${description}</dc:description>
      <cp:lastModifiedBy>${lastModifiedBy}</cp:lastModifiedBy>
      <cp:revision>${revision}</cp:revision>
      <dcterms:created xsi:type="dcterms:W3CDTF">${crAt}</dcterms:created>
      <dcterms:modified xsi:type="dcterms:W3CDTF">${modAt}</dcterms:modified>
    </cp:coreProperties>
  `;
}
// src/schemas/document-rels.ts
var documentRelsXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<Relationships
  xmlns="http://schemas.openxmlformats.org/package/2006/relationships"
>
  <Relationship
    Id="rId1"
    Type="${namespaces_default.numbering}"
    Target="numbering.xml"
  />
  <Relationship
    Id="rId2"
    Type="${namespaces_default.styles}"
    Target="styles.xml"
  />
  <Relationship
    Id="rId3"
    Type="${namespaces_default.settingsRelation}"
    Target="settings.xml"
  />
  <Relationship
    Id="rId4"
    Type="${namespaces_default.webSettingsRelation}"
    Target="webSettings.xml"
  />
  <Relationship
    Id="rId5"
    Type="${namespaces_default.fontTable}"
    Target="fontTable.xml"
  />
</Relationships>
`;
var document_rels_default = documentRelsXML;
// src/schemas/document.template.ts
function generateDocumentTemplate() {
  return `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:document
      xmlns:a="${namespaces_default.a}"
      xmlns:cdr="${namespaces_default.cdr}"
      xmlns:o="${namespaces_default.o}"
      xmlns:pic="${namespaces_default.pic}"
      xmlns:r="${namespaces_default.r}"
      xmlns:v="${namespaces_default.v}"
      xmlns:ve="${namespaces_default.ve}"
      xmlns:vt="${namespaces_default.vt}"
      xmlns:w="${namespaces_default.w}"
      xmlns:w10="${namespaces_default.w10}"
      xmlns:wp="${namespaces_default.wp}"
      xmlns:wne="${namespaces_default.wne}"
      >
      <w:body>
      </w:body>
    </w:document>
  `;
}
// src/schemas/font-table.ts
var fontTableXML = `
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

  <w:fonts
    xmlns:r="${namespaces_default.r}"
    xmlns:w="${namespaces_default.w}"
  >
    <w:font w:name="Arial">
      <w:panose1 w:val="020B0604020202020204"/>
      <w:charset w:val="00"/>
      <w:family w:val="auto"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="00000003" w:usb1="00000000" w:usb2="00000000"
        w:usb3="00000000" w:csb0="00000001" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Calibri">
      <w:panose1 w:val="020F0502020204030204"/>
      <w:charset w:val="00"/>
      <w:family w:val="swiss"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="E4002EFF" w:usb1="C000247B" w:usb2="00000009"
        w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Calibri Light">
      <w:panose1 w:val="020F0302020204030204"/>
      <w:charset w:val="00"/>
      <w:family w:val="swiss"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="E4002EFF" w:usb1="C000247B" w:usb2="00000009"
        w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Courier New">
      <w:panose1 w:val="02070309020205020404"/>
      <w:charset w:val="00"/>
      <w:family w:val="auto"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="00000003" w:usb1="00000000" w:usb2="00000000"
        w:usb3="00000000" w:csb0="00000001" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Symbol">
      <w:panose1 w:val="05050102010706020507"/>
      <w:charset w:val="02"/>
      <w:family w:val="decorative"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="00000000" w:usb1="10000000" w:usb2="00000000"
        w:usb3="00000000" w:csb0="80000000" w:csb1="00000000"/>
    </w:font>
    <w:font w:name="Times New Roman">
      <w:panose1 w:val="02020603050405020304"/>
      <w:charset w:val="00"/>
      <w:family w:val="roman"/>
      <w:pitch w:val="variable"/>
      <w:sig w:usb0="E0002EFF" w:usb1="C000785B" w:usb2="00000009"
        w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
    </w:font>
  </w:fonts>
`;
var font_table_default = fontTableXML;
// src/schemas/generic-rels.ts
var genericRelsXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<Relationships
  xmlns="http://schemas.openxmlformats.org/package/2006/relationships"
>
</Relationships>
`;
var generic_rels_default = genericRelsXML;
// src/schemas/numbering.ts
function generateNumberingXMLTemplate() {
  return `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:numbering
      xmlns:w="${namespaces_default.w}"
      xmlns:ve="${namespaces_default.ve}"
      xmlns:o="${namespaces_default.o}"
      xmlns:r="${namespaces_default.r}"
      xmlns:v="${namespaces_default.v}"
      xmlns:wp="${namespaces_default.wp}"
      xmlns:w10="${namespaces_default.w10}"
      xmlns:wne="${namespaces_default.wne}"
    >
    </w:numbering>
  `;
}
// src/schemas/rels.ts
var relsXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<Relationships
  xmlns="http://schemas.openxmlformats.org/package/2006/relationships"
>
  <Relationship
    Id="rId1"
    Type="${namespaces_default.officeDocumentRelation}"
    Target="word/document.xml"
  />
  <Relationship
    Id="rId2"
    Type="${namespaces_default.corePropertiesRelation}"
    Target="docProps/core.xml"
  />
</Relationships>
`;
var rels_default = relsXML;
// src/schemas/settings.ts
var settingsXML = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<w:settings
  xmlns:w="${namespaces_default.w}"
  xmlns:o="${namespaces_default.o}"
  xmlns:r="${namespaces_default.r}"
  xmlns:v="${namespaces_default.v}"
  xmlns:w10="${namespaces_default.w10}"
  xmlns:sl="${namespaces_default.sl}"
>
  <w:zoom w:percent="100"/>
  <w:defaultTabStop w:val="720"/>
  <w:decimalSymbol w:val="."/>
  <w:listSeparator w:val=","/>
</w:settings>
`;
var settings_default = settingsXML;
// src/schemas/styles.ts
function generateStylesXML(font = defaultFont, fontSize = defaultFontSize, complexScriptFontSize = defaultFontSize, lang = defaultLang) {
  return `
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

  <w:styles xmlns:w="${namespaces_default.w}" xmlns:r="${namespaces_default.r}">
  <w:docDefaults>
    <w:rPrDefault>
    <w:rPr>
      <w:rFonts
        w:ascii="${font}"
        w:eastAsiaTheme="minorHAnsi"
        w:hAnsiTheme="minorHAnsi"
        w:cstheme="minorBidi"
      />
      <w:sz w:val="${fontSize}" />
      <w:szCs w:val="${complexScriptFontSize}" />
      <w:lang w:val="${lang}" w:eastAsia="${lang}" w:bidi="ar-SA" />
    </w:rPr>
    </w:rPrDefault>
    <w:pPrDefault>
    <w:pPr>
      <w:spacing w:after="120" w:line="240" w:lineRule="atLeast" />
    </w:pPr>
    </w:pPrDefault>
  </w:docDefaults>
  <w:style w:type="character" w:styleId="Hyperlink">
    <w:name w:val="Hyperlink" />
    <w:rPr>
    <w:color w:val="0000FF" />
    <w:u w:val="single" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading1">
    <w:name w:val="heading 1" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="480" />
    <w:outlineLvl w:val="0" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="48" />
    <w:szCs w:val="48" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading2">
    <w:name w:val="heading 2" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="360" w:after="80" />
    <w:outlineLvl w:val="1" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="36" />
    <w:szCs w:val="36" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading3">
    <w:name w:val="heading 3" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:semiHidden />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="280" w:after="80" />
    <w:outlineLvl w:val="2" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="28" />
    <w:szCs w:val="28" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading4">
    <w:name w:val="heading 4" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:semiHidden />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="240" w:after="40" />
    <w:outlineLvl w:val="3" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="24" />
    <w:szCs w:val="24" />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading5">
    <w:name w:val="heading 5" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:semiHidden />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="220" w:after="40" />
    <w:outlineLvl w:val="4" />
    </w:pPr>
    <w:rPr>
    <w:b />
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading6">
    <w:name w:val="heading 6" />
    <w:basedOn w:val="Normal" />
    <w:next w:val="Normal" />
    <w:uiPriority w:val="9" />
    <w:semiHidden />
    <w:unhideWhenUsed />
    <w:qFormat />
    <w:pPr>
    <w:keepNext />
    <w:keepLines />
    <w:spacing w:before="200" w:after="40" />
    <w:outlineLvl w:val="5" />
    </w:pPr>
    <w:rPr>
    <w:b />
    <w:sz w:val="20" />
    <w:szCs w:val="20" />
    </w:rPr>
  </w:style>
  </w:styles>
  `;
}
// src/schemas/theme.ts
function generateThemeXML(font = defaultFont) {
  return `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <a:theme
      xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
      name="Office Theme"
    >
    <a:themeElements>
      <a:clrScheme name="Office">
        <a:dk1>
          <a:sysClr val="windowText" lastClr="000000"/>
        </a:dk1>
        <a:lt1>
          <a:sysClr val="window" lastClr="FFFFFF"/>
        </a:lt1>
        <a:dk2>
          <a:srgbClr val="44546A"/>
        </a:dk2>
        <a:lt2>
          <a:srgbClr val="E7E6E6"/>
        </a:lt2>
        <a:accent1>
          <a:srgbClr val="4472C4"/>
        </a:accent1>
        <a:accent2>
          <a:srgbClr val="ED7D31"/>
        </a:accent2>
        <a:accent3>
          <a:srgbClr val="A5A5A5"/>
        </a:accent3>
        <a:accent4>
          <a:srgbClr val="FFC000"/>
        </a:accent4>
        <a:accent5>
          <a:srgbClr val="5B9BD5"/>
        </a:accent5>
        <a:accent6>
          <a:srgbClr val="70AD47"/>
        </a:accent6>
        <a:hlink>
          <a:srgbClr val="0563C1"/>
        </a:hlink>
        <a:folHlink>
          <a:srgbClr val="954F72"/>
        </a:folHlink>
      </a:clrScheme>
      <a:fontScheme name="Office">
        <a:majorFont>
          <a:latin typeface="${font}"/>
          <a:ea typeface="${font}"/>
          <a:cs typeface=""/>
        </a:majorFont>
        <a:minorFont>
          <a:latin typeface="${font}"/>
          <a:ea typeface="${font}"/>
          <a:cs typeface=""/>
        </a:minorFont>
      </a:fontScheme>
      <a:fmtScheme name="Office">
        <a:fillStyleLst>
          <a:solidFill>
            <a:schemeClr val="phClr"/>
          </a:solidFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:lumMod val="110000"/>
                  <a:satMod val="105000"/>
                  <a:tint val="67000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="105000"/>
                  <a:satMod val="103000"/>
                  <a:tint val="73000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="105000"/>
                  <a:satMod val="109000"/>
                  <a:tint val="81000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:satMod val="103000"/>
                  <a:lumMod val="102000"/>
                  <a:tint val="94000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:satMod val="110000"/>
                  <a:lumMod val="100000"/>
                  <a:shade val="100000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="99000"/>
                  <a:satMod val="120000"/>
                  <a:shade val="78000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
        </a:fillStyleLst>
        <a:lnStyleLst>
          <a:ln w="6350" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
          <a:ln w="12700" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
          <a:ln w="19050" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
        </a:lnStyleLst>
        <a:effectStyleLst>
          <a:effectStyle>
            <a:effectLst/>
          </a:effectStyle>
          <a:effectStyle>
            <a:effectLst/>
          </a:effectStyle>
          <a:effectStyle>
            <a:effectLst>
              <a:outerShdw
                blurRad="57150"
                dist="19050"
                dir="5400000"
                algn="ctr"
                rotWithShape="0"
              >
                <a:srgbClr val="000000">
                  <a:alpha val="63000"/>
                </a:srgbClr>
              </a:outerShdw>
            </a:effectLst>
          </a:effectStyle>
        </a:effectStyleLst>
        <a:bgFillStyleLst>
          <a:solidFill>
            <a:schemeClr val="phClr"/>
          </a:solidFill>
          <a:solidFill>
            <a:schemeClr val="phClr">
              <a:tint val="95000"/>
              <a:satMod val="170000"/>
            </a:schemeClr>
          </a:solidFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:tint val="93000"/>
                  <a:satMod val="150000"/>
                  <a:shade val="98000"/>
                  <a:lumMod val="102000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:tint val="98000"/>
                  <a:satMod val="130000"/>
                  <a:shade val="90000"/>
                  <a:lumMod val="103000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:shade val="63000"/>
                  <a:satMod val="120000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
        </a:bgFillStyleLst>
      </a:fmtScheme>
    </a:themeElements>
  </a:theme>
`;
}
// src/schemas/web-settings.ts
var webSettingsXML = `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:webSettings xmlns:w="${namespaces_default.w}" xmlns:r="${namespaces_default.r}">
    </w:webSettings>
`;
var web_settings_default = webSettingsXML;
// src/utils/font-family-conversion.ts
var removeSimpleOrDoubleQuotes = /(["'])(.*?)\1/;
function fontFamilyToTableObject(fontFamilyString, fallbackFont) {
  const fontFamilyElements = fontFamilyString ? fontFamilyString.split(",").map((fontName) => {
    const trimmedFontName = fontName.trim();
    if (removeSimpleOrDoubleQuotes.test(trimmedFontName)) {
      return trimmedFontName.match(removeSimpleOrDoubleQuotes)?.[2];
    }
    return trimmedFontName;
  }) : [fallbackFont];
  return {
    fontName: fontFamilyElements[0] || fallbackFont,
    genericFontName: fontFamilyElements[fontFamilyElements.length - 1] || fallbackFont
  };
}

// src/utils/list.ts
class ListStyleBuilder {
  defaults;
  constructor(defaults) {
    this.defaults = defaults || { defaultOrderedListStyleType: "decimal" };
  }
  getListStyleType(listType) {
    switch (listType) {
      case "upper-roman":
        return "upperRoman";
      case "lower-roman":
        return "lowerRoman";
      case "upper-alpha":
      case "upper-alpha-bracket-end":
        return "upperLetter";
      case "lower-alpha":
      case "lower-alpha-bracket-end":
        return "lowerLetter";
      case "decimal":
      case "decimal-bracket":
        return "decimal";
      default:
        return this.defaults.defaultOrderedListStyleType;
    }
  }
  getListPrefixSuffix(style, lvl) {
    let listType = this.defaults.defaultOrderedListStyleType;
    if (style && style["list-style-type"]) {
      listType = style["list-style-type"];
    }
    switch (listType) {
      case "upper-roman":
      case "lower-roman":
      case "upper-alpha":
      case "lower-alpha":
        return `%${lvl + 1}.`;
      case "upper-alpha-bracket-end":
      case "lower-alpha-bracket-end":
      case "decimal-bracket-end":
        return `%${lvl + 1})`;
      case "decimal-bracket":
        return `(%${lvl + 1})`;
      case "decimal":
      default:
        return `%${lvl + 1}.`;
    }
  }
}

// src/docx-document.ts
function generateContentTypesFragments(contentTypesXML2, type, objects) {
  if (objects && Array.isArray(objects)) {
    objects.forEach((object) => {
      const contentTypesFragment = import_xmlbuilder23.fragment({
        defaultNamespace: { ele: namespaces_default.contentTypes }
      }).ele("Override").att("PartName", `/word/${type}${object[`${type}Id`]}.xml`).att("ContentType", "application/vnd.openxmlformats-officedocument" + `.wordprocessingml.${type}+xml`).up();
      contentTypesXML2.root().import(contentTypesFragment);
    });
  }
}
function generateSectionReferenceXML(documentXML, documentSectionType, objects, isEnabled) {
  if (isEnabled && objects && Array.isArray(objects) && objects.length) {
    const xmlFragment = import_xmlbuilder23.fragment();
    objects.forEach(({ relationshipId, type }) => {
      const objectFragment = import_xmlbuilder23.fragment({
        namespaceAlias: { w: namespaces_default.w, r: namespaces_default.r }
      }).ele("@w", `${documentSectionType}Reference`).att("@r", "id", `rId${relationshipId}`).att("@w", "type", type).up();
      xmlFragment.import(objectFragment);
    });
    const sectPr = documentXML.root().first().last();
    sectPr.import(xmlFragment);
  }
}
function generateXMLString(xmlString) {
  const xmlDocumentString = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, xmlString);
  return xmlDocumentString.toString({ prettyPrint: true });
}
async function generateSectionXML(vTree, type) {
  const sectionXML = import_xmlbuilder23.create({
    encoding: "UTF-8",
    standalone: true,
    namespaceAlias: {
      w: namespaces_default.w,
      ve: namespaces_default.ve,
      o: namespaces_default.o,
      r: namespaces_default.r,
      v: namespaces_default.v,
      wp: namespaces_default.wp,
      w10: namespaces_default.w10
    }
  }).ele("@w", type === "header" ? "hdr" : "ftr");
  const XMLFragment = import_xmlbuilder23.fragment();
  await convertVTreeToXML(this, vTree, XMLFragment);
  if (type === "footer" && XMLFragment.first().node.tagName === "p" && this.pageNumber) {
    XMLFragment.first().import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "fldSimple").att("@w", "instr", "PAGE").ele("@w", "r").up().up());
  }
  sectionXML.root().import(XMLFragment);
  if (type === "header") {
    this.lastHeaderId += 1;
    return {
      headerId: this.lastHeaderId,
      headerXML: sectionXML
    };
  } else {
    this.lastFooterId += 1;
    return {
      footerId: this.lastFooterId,
      footerXML: sectionXML
    };
  }
}

class DocxDocument {
  zip;
  htmlString;
  orientation;
  pageSize;
  width;
  height;
  margins;
  availableDocumentSpace;
  title;
  subject;
  creator;
  keywords;
  description;
  lastModifiedBy;
  revision;
  createdAt;
  modifiedAt;
  headerType;
  header;
  footerType;
  footer;
  font;
  fontSize;
  complexScriptFontSize;
  lang;
  tableRowCantSplit;
  pageNumber;
  skipFirstHeaderFooter;
  lineNumberOptions;
  lastNumberingId;
  lastMediaId;
  lastHeaderId;
  lastFooterId;
  stylesObjects;
  numberingObjects;
  fontTableObjects;
  relationshipFilename;
  relationships;
  mediaFiles;
  headerObjects;
  footerObjects;
  documentXML;
  generateSectionXML;
  ListStyleBuilder;
  constructor(properties) {
    this.zip = properties.zip;
    this.htmlString = properties.htmlString;
    this.orientation = properties.orientation;
    this.pageSize = properties.pageSize || defaultDocumentOptions.pageSize;
    const isPortraitOrientation = this.orientation === defaultOrientation;
    const height = this.pageSize?.height ? this.pageSize.height : landscapeHeight;
    const width = this.pageSize?.width ? this.pageSize.width : landscapeWidth;
    this.width = isPortraitOrientation ? width : height;
    this.height = isPortraitOrientation ? height : width;
    const marginsObject = properties.margins;
    this.margins = marginsObject && Object.keys(marginsObject).length ? marginsObject : isPortraitOrientation ? portraitMargins : landscapeMargins;
    this.availableDocumentSpace = this.width - this.margins.left - this.margins.right;
    this.title = properties.title || "";
    this.subject = properties.subject || "";
    this.creator = properties.creator || applicationName;
    this.keywords = properties.keywords || [applicationName];
    this.description = properties.description || "";
    this.lastModifiedBy = properties.lastModifiedBy || applicationName;
    this.revision = properties.revision || 1;
    this.createdAt = properties.createdAt || new Date;
    this.modifiedAt = properties.modifiedAt || new Date;
    this.headerType = properties.headerType || "default";
    this.header = properties.header || false;
    this.footerType = properties.footerType || "default";
    this.footer = properties.footer || false;
    this.font = properties.font || defaultFont;
    this.fontSize = properties.fontSize || defaultFontSize;
    this.complexScriptFontSize = properties.complexScriptFontSize || defaultFontSize;
    this.lang = properties.lang || defaultLang;
    this.tableRowCantSplit = properties.table && properties.table.row && properties.table.row.cantSplit || false;
    this.pageNumber = properties.pageNumber || false;
    this.skipFirstHeaderFooter = properties.skipFirstHeaderFooter || false;
    this.lineNumberOptions = properties.lineNumber ? properties.lineNumberOptions : undefined;
    this.lastNumberingId = 0;
    this.lastMediaId = 0;
    this.lastHeaderId = 0;
    this.lastFooterId = 0;
    this.stylesObjects = [];
    this.numberingObjects = [];
    this.fontTableObjects = [];
    this.relationshipFilename = documentFileName;
    this.relationships = [{
      fileName: documentFileName,
      lastRelsId: 5,
      rels: []
    }];
    this.mediaFiles = [];
    this.headerObjects = [];
    this.footerObjects = [];
    this.documentXML = null;
    this.generateContentTypesXML = this.generateContentTypesXML.bind(this);
    this.generateDocumentXML = this.generateDocumentXML.bind(this);
    this.generateCoreXML = this.generateCoreXML.bind(this);
    this.generateSettingsXML = this.generateSettingsXML.bind(this);
    this.generateWebSettingsXML = this.generateWebSettingsXML.bind(this);
    this.generateStylesXML = this.generateStylesXML.bind(this);
    this.generateFontTableXML = this.generateFontTableXML.bind(this);
    this.generateThemeXML = this.generateThemeXML.bind(this);
    this.generateNumberingXML = this.generateNumberingXML.bind(this);
    this.generateRelsXML = this.generateRelsXML.bind(this);
    this.createMediaFile = this.createMediaFile.bind(this);
    this.createDocumentRelationships = this.createDocumentRelationships.bind(this);
    this.generateHeaderXML = this.generateHeaderXML.bind(this);
    this.generateFooterXML = this.generateFooterXML.bind(this);
    this.generateSectionXML = generateSectionXML.bind(this);
    this.ListStyleBuilder = new ListStyleBuilder(properties.numbering);
  }
  generateContentTypesXML() {
    const contentTypesXML2 = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, content_types_default);
    generateContentTypesFragments(contentTypesXML2, "header", this.headerObjects);
    generateContentTypesFragments(contentTypesXML2, "footer", this.footerObjects);
    return contentTypesXML2.toString({ prettyPrint: true });
  }
  generateDocumentXML() {
    const documentXML = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, generateDocumentTemplate());
    const body = documentXML.root().first();
    if (this.documentXML) {
      body.import(this.documentXML);
    } else {
      throw new Error("Document XML must be created before importing");
    }
    const sectPr = import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "sectPr").ele("@w", "pgSz").att("@w", "w", String(this.width)).att("@w", "h", String(this.height)).att("@w", "orient", this.orientation).up().ele("@w", "pgMar").att("@w", "top", String(this.margins?.top || 0)).att("@w", "right", String(this.margins?.right || 0)).att("@w", "bottom", String(this.margins?.bottom || 0)).att("@w", "left", String(this.margins?.left || 0)).att("@w", "header", String(this.margins?.header || 0)).att("@w", "footer", String(this.margins?.footer || 0)).att("@w", "gutter", String(this.margins?.gutter || 0)).up().up();
    body.import(sectPr);
    generateSectionReferenceXML(documentXML, "header", this.headerObjects, this.header);
    generateSectionReferenceXML(documentXML, "footer", this.footerObjects, this.footer);
    if ((this.header || this.footer) && this.skipFirstHeaderFooter) {
      documentXML.root().first().first().import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "titlePg"));
    }
    if (this.lineNumberOptions) {
      const { countBy, start, restart } = this.lineNumberOptions;
      documentXML.root().first().first().import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "lnNumType").att("@w", "countBy", String(countBy)).att("@w", "start", String(start)).att("@w", "restart", String(restart)));
    }
    return documentXML.toString({ prettyPrint: true });
  }
  generateCoreXML() {
    return generateXMLString(generateCoreXML(this.title, this.subject, this.creator, this.keywords, this.description, this.lastModifiedBy, this.revision, this.createdAt, this.modifiedAt));
  }
  generateSettingsXML() {
    return generateXMLString(settings_default);
  }
  generateWebSettingsXML() {
    return generateXMLString(web_settings_default);
  }
  generateStylesXML() {
    return generateXMLString(generateStylesXML(this.font, this.fontSize, this.complexScriptFontSize, this.lang));
  }
  generateFontTableXML() {
    const fontTableXML2 = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, font_table_default);
    const fontNames = [
      "Arial",
      "Calibri",
      "Calibri Light",
      "Courier New",
      "Symbol",
      "Times New Roman"
    ];
    this.fontTableObjects.forEach(({ fontName, genericFontName }) => {
      if (!fontNames.includes(fontName)) {
        fontNames.push(fontName);
        const fontFragment = import_xmlbuilder23.fragment({
          namespaceAlias: { w: namespaces_default.w }
        }).ele("@w", "font").att("@w", "name", fontName);
        switch (genericFontName) {
          case "serif":
            fontFragment.ele("@w", "altName").att("@w", "val", "Times New Roman");
            fontFragment.ele("@w", "family").att("@w", "val", "roman");
            fontFragment.ele("@w", "pitch").att("@w", "val", "variable");
            break;
          case "sans-serif":
            fontFragment.ele("@w", "altName").att("@w", "val", "Arial");
            fontFragment.ele("@w", "family").att("@w", "val", "swiss");
            fontFragment.ele("@w", "pitch").att("@w", "val", "variable");
            break;
          case "monospace":
            fontFragment.ele("@w", "altName").att("@w", "val", "Courier New");
            fontFragment.ele("@w", "family").att("@w", "val", "modern");
            fontFragment.ele("@w", "pitch").att("@w", "val", "fixed");
            break;
          default:
            break;
        }
        fontTableXML2.root().import(fontFragment);
      }
    });
    return fontTableXML2.toString({ prettyPrint: true });
  }
  generateThemeXML() {
    return generateXMLString(generateThemeXML(this.font));
  }
  generateNumberingXML() {
    const numberingXML = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, generateNumberingXMLTemplate());
    const abstractNumberingFragments = import_xmlbuilder23.fragment();
    const numberingFragments = import_xmlbuilder23.fragment();
    this.numberingObjects.forEach(({ numberingId, type, properties }) => {
      const abstractNumberingFragment = import_xmlbuilder23.fragment({
        namespaceAlias: { w: namespaces_default.w }
      }).ele("@w", "abstractNum").att("@w", "abstractNumId", String(numberingId));
      [
        ...Array(8).keys()
      ].forEach((level) => {
        const levelFragment = import_xmlbuilder23.fragment({
          namespaceAlias: { w: namespaces_default.w }
        }).ele("@w", "lvl").att("@w", "ilvl", String(level)).ele("@w", "start").att("@w", "val", type === "ol" ? String(properties?.attributes?.["data-start"] || 1) : "1").up().ele("@w", "numFmt").att("@w", "val", type === "ol" ? this.ListStyleBuilder.getListStyleType(properties?.style?.["list-style-type"] || "decimal") : "bullet").up().ele("@w", "lvlText").att("@w", "val", type === "ol" ? this.ListStyleBuilder.getListPrefixSuffix(properties.style || { "list-style-type": "decimal" }, level) : "").up().ele("@w", "lvlJc").att("@w", "val", "left").up().ele("@w", "pPr").ele("@w", "tabs").ele("@w", "tab").att("@w", "val", "num").att("@w", "pos", String((level + 1) * 720)).up().up().ele("@w", "ind").att("@w", "left", String((level + 1) * 720)).att("@w", "hanging", "360").up().up().up();
        if (type === "ul") {
          levelFragment.last().import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "rPr").ele("@w", "rFonts").att("@w", "ascii", "Symbol").att("@w", "hAnsi", "Symbol").att("@w", "hint", "default").up().up());
        }
        abstractNumberingFragment.import(levelFragment);
      });
      abstractNumberingFragment.up();
      abstractNumberingFragments.import(abstractNumberingFragment);
      numberingFragments.import(import_xmlbuilder23.fragment({ namespaceAlias: { w: namespaces_default.w } }).ele("@w", "num").att("@w", "numId", String(numberingId)).ele("@w", "abstractNumId").att("@w", "val", String(numberingId)).up().up());
    });
    numberingXML.root().import(abstractNumberingFragments);
    numberingXML.root().import(numberingFragments);
    return numberingXML.toString({ prettyPrint: true });
  }
  appendRelationships(xmlFragment, relationships) {
    relationships.forEach(({ relationshipId, type, target, targetMode }) => {
      xmlFragment.import(import_xmlbuilder23.fragment({ defaultNamespace: { ele: namespaces_default.relationship } }).ele("Relationship").att("Id", `rId${relationshipId}`).att("Type", type).att("Target", target).att("TargetMode", targetMode).up());
    });
  }
  generateRelsXML() {
    const relationshipXMLStrings = this.relationships.map(({ fileName, rels }) => {
      const xmlFragment = import_xmlbuilder23.create({ encoding: "UTF-8", standalone: true }, fileName === documentFileName ? document_rels_default : generic_rels_default);
      this.appendRelationships(xmlFragment.root(), rels);
      return {
        fileName,
        xmlString: xmlFragment.toString({ prettyPrint: true })
      };
    });
    return relationshipXMLStrings;
  }
  createNumbering(type, properties) {
    this.lastNumberingId += 1;
    this.numberingObjects.push({ numberingId: this.lastNumberingId, type, properties });
    return this.lastNumberingId;
  }
  createFont(fontFamily) {
    const fontTableObject = fontFamilyToTableObject(fontFamily, this.font);
    this.fontTableObjects.push(fontTableObject);
    return fontTableObject.fontName || "";
  }
  createMediaFile(srcString) {
    const fileData = extractBase64Data(srcString);
    if (!fileData) {
      throw new Error("Invalid data URL");
    }
    const fileExtension = fileData.extension === "octet-stream" ? "png" : fileData.extension;
    const fileNameWithExtension = `image-${nanoid()}.${fileExtension}`;
    this.lastMediaId += 1;
    return {
      id: this.lastMediaId,
      fileContent: fileData.base64Content,
      fileNameWithExtension
    };
  }
  createDocumentRelationships(fileName = "document", type, target, targetMode = "External") {
    let relationshipObject = this.relationships.find((relationship) => relationship.fileName === fileName);
    let lastRelsId = 1;
    if (relationshipObject) {
      lastRelsId = relationshipObject.lastRelsId + 1;
      relationshipObject.lastRelsId = lastRelsId;
    } else {
      relationshipObject = { fileName, lastRelsId, rels: [] };
      this.relationships.push(relationshipObject);
    }
    let relationshipType;
    switch (type) {
      case hyperlinkType:
        relationshipType = namespaces_default.hyperlinks;
        break;
      case imageType:
        relationshipType = namespaces_default.images;
        break;
      case headerType:
        relationshipType = namespaces_default.headers;
        break;
      case footerType:
        relationshipType = namespaces_default.footers;
        break;
      case themeType:
        relationshipType = namespaces_default.themes;
        break;
      default:
        break;
    }
    relationshipObject.rels.push({
      relationshipId: lastRelsId,
      type: relationshipType || "",
      target,
      targetMode
    });
    return lastRelsId;
  }
  generateHeaderXML(vTree) {
    return this.generateSectionXML(vTree, "header");
  }
  generateFooterXML(vTree) {
    return this.generateSectionXML(vTree, "footer");
  }
}

// src/html-to-docx.ts
var convertHTML2 = import_html_to_vdom2.default({
  VNode: import_vnode4.default,
  VText: import_vtext2.default
});
function mergeOptions(options, patch) {
  return { ...options, ...patch };
}
function fixupFontSize2(fontSize) {
  let normalizedFontSize;
  if (pointRegex.test(fontSize)) {
    const matchedParts = fontSize.match(pointRegex);
    normalizedFontSize = pointToHIP(Number(matchedParts?.[1]));
  } else if (fontSize) {
    normalizedFontSize = Number(fontSize);
  } else {
    normalizedFontSize = undefined;
  }
  return normalizedFontSize;
}
function normalizeUnits(dimensioningObject, defaultDimensionsProperty) {
  const normalizedUnitResult = {};
  if (typeof dimensioningObject === "object" && dimensioningObject !== null) {
    Object.keys(dimensioningObject).forEach((key) => {
      if (pixelRegex.test(String(dimensioningObject[key]))) {
        const matchedParts = String(dimensioningObject[key]).match(pixelRegex);
        normalizedUnitResult[key] = pixelToTWIP(Number(matchedParts?.[1]));
      } else if (cmRegex.test(String(dimensioningObject[key]))) {
        const matchedParts = String(dimensioningObject[key]).match(cmRegex);
        normalizedUnitResult[key] = cmToTWIP(Number(matchedParts?.[1]));
      } else if (inchRegex.test(String(dimensioningObject[key]))) {
        const matchedParts = String(dimensioningObject[key]).match(inchRegex);
        normalizedUnitResult[key] = inchToTWIP(Number(matchedParts?.[1]));
      } else if (dimensioningObject[key]) {
        normalizedUnitResult[key] = dimensioningObject[key];
      } else {
        normalizedUnitResult[key] = defaultDimensionsProperty[key];
      }
    });
    return normalizedUnitResult;
  } else {
    return null;
  }
}
function normalizeDocumentOptions(documentOptions) {
  const normalizedDocumentOptions = {
    ...documentOptions
  };
  Object.keys(documentOptions).forEach((key) => {
    switch (key) {
      case "pageSize":
      case "margins":
        normalizedDocumentOptions.margins = normalizeUnits(documentOptions.margins, defaultDocumentOptions.margins);
        break;
      case "fontSize":
      case "complexScriptFontSize":
        normalizedDocumentOptions.complexScriptFontSize = fixupFontSize2(String(documentOptions.complexScriptFontSize));
        break;
      default:
        break;
    }
  });
  return normalizedDocumentOptions;
}
async function addFilesToContainer(zip, htmlString, suppliedDocumentOptions, headerHTMLString, footerHTMLString) {
  const normalizedDocumentOptions = normalizeDocumentOptions(suppliedDocumentOptions);
  const documentOptions = mergeOptions(defaultDocumentOptions, normalizedDocumentOptions);
  if (documentOptions.header && !headerHTMLString) {
    headerHTMLString = defaultHTMLString;
  }
  if (documentOptions.footer && !footerHTMLString) {
    footerHTMLString = defaultHTMLString;
  }
  if (documentOptions.decodeUnicode) {
    headerHTMLString = import_html_entities.decode(headerHTMLString);
    htmlString = import_html_entities.decode(htmlString);
    footerHTMLString = import_html_entities.decode(footerHTMLString);
  }
  const docxDocument = new DocxDocument({
    ...documentOptions,
    zip,
    htmlString,
    orientation: documentOptions.orientation || "portrait",
    table: documentOptions.table || { row: { cantSplit: false } },
    numbering: documentOptions.numbering || { defaultOrderedListStyleType: "decimal" }
  });
  docxDocument.documentXML = await renderDocumentFile(docxDocument);
  zip.folder(relsFolderName)?.file(".rels", import_xmlbuilder24.create({ encoding: "UTF-8", standalone: true }, rels_default).toString({ prettyPrint: true }), { createFolders: false });
  zip.folder("docProps")?.file("core.xml", docxDocument.generateCoreXML(), {
    createFolders: false
  });
  if (docxDocument.header && headerHTMLString) {
    const vTree = convertHTML2(headerHTMLString);
    docxDocument.relationshipFilename = headerFileName;
    const { headerId, headerXML } = await docxDocument.generateHeaderXML(vTree);
    docxDocument.relationshipFilename = documentFileName;
    const fileNameWithExt = `${headerType}${headerId}.xml`;
    const relationshipId = docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, headerType, fileNameWithExt, internalRelationship);
    zip.folder(wordFolder)?.file(fileNameWithExt, headerXML.toString({ prettyPrint: true }), {
      createFolders: false
    });
    docxDocument.headerObjects.push({
      headerId,
      relationshipId,
      type: docxDocument.headerType
    });
  }
  if (docxDocument.footer && footerHTMLString) {
    const vTree = convertHTML2(footerHTMLString);
    docxDocument.relationshipFilename = footerFileName;
    const { footerId, footerXML } = await docxDocument.generateFooterXML(vTree);
    docxDocument.relationshipFilename = documentFileName;
    const fileNameWithExt = `${footerType}${footerId}.xml`;
    const relationshipId = docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, footerType, fileNameWithExt, internalRelationship);
    zip.folder(wordFolder)?.file(fileNameWithExt, footerXML.toString({ prettyPrint: true }), {
      createFolders: false
    });
    docxDocument.footerObjects.push({
      footerId,
      relationshipId,
      type: docxDocument.footerType
    });
  }
  const themeFileNameWithExt = `${themeFileName}.xml`;
  docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, themeType, `${themeFolder}/${themeFileNameWithExt}`, internalRelationship);
  zip.folder(wordFolder)?.folder(themeFolder)?.file(themeFileNameWithExt, docxDocument.generateThemeXML(), {
    createFolders: false
  });
  zip.folder(wordFolder)?.file("document.xml", docxDocument.generateDocumentXML(), {
    createFolders: false
  })?.file("fontTable.xml", docxDocument.generateFontTableXML(), {
    createFolders: false
  })?.file("styles.xml", docxDocument.generateStylesXML(), {
    createFolders: false
  })?.file("numbering.xml", docxDocument.generateNumberingXML(), {
    createFolders: false
  })?.file("settings.xml", docxDocument.generateSettingsXML(), {
    createFolders: false
  })?.file("webSettings.xml", docxDocument.generateWebSettingsXML(), {
    createFolders: false
  });
  const relationshipXMLs = docxDocument.generateRelsXML();
  if (relationshipXMLs && Array.isArray(relationshipXMLs)) {
    relationshipXMLs.forEach(({ fileName, xmlString }) => {
      zip.folder(wordFolder)?.folder(relsFolderName)?.file(`${fileName}.xml.rels`, xmlString, {
        createFolders: false
      });
    });
  }
  zip.file("[Content_Types].xml", docxDocument.generateContentTypesXML(), {
    createFolders: false
  });
  return zip;
}

// index.ts
function minifyHTMLString(htmlString) {
  const minifiedHTMLString = htmlString.replace(/\n/g, " ").replace(/\r/g, " ").replace(/\r\n/g, " ").replace(/[\t]+</g, "<").replace(/>[\t ]+</g, "><").replace(/>[\t ]+$/g, ">");
  return minifiedHTMLString;
}
async function generateContainer(htmlString, headerHTMLString, documentOptions, footerHTMLString) {
  const zip = new import_jszip.default;
  await addFilesToContainer(zip, htmlString ? minifyHTMLString(htmlString) : "", documentOptions, headerHTMLString ? minifyHTMLString(headerHTMLString) : "", footerHTMLString ? minifyHTMLString(footerHTMLString) : "");
  const buffer = await zip.generateAsync({ type: "arraybuffer" });
  if (Object.prototype.hasOwnProperty.call(global, "Buffer")) {
    return Buffer.from(new Uint8Array(buffer));
  }
  if (Object.prototype.hasOwnProperty.call(global, "Blob")) {
    return new Blob([buffer], {
      type: "application/" + "vnd.openxmlformats-officedocument.wordprocessingml.document"
    });
  }
  throw new Error("Add blob support using a polyfill. " + "E.g. https://github.com/bjornstar/blob-polyfill");
}
export {
  generateContainer as default
};
